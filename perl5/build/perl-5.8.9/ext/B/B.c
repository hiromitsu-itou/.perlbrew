/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.19 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION >= 9
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION <= 8
    "B::BM",
#endif
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
#if PERL_VERSION >= 9
    "B::GV",
#endif
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
#if PERL_VERSION <= 8
    "B::GV",
#endif
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ const OP *o)
{
    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 PL_op_name[o->op_type]);
    return OPc_BASEOP;
}

static char *
cc_opclassname(pTHX_ const OP *o)
{
    return (char *)opclassnames[cc_opclass(aTHX_ o)];
}

static SV *
make_sv_object(pTHX_ SV *arg, SV *sv)
{
    const char *type = 0;
    IV iv;
    dMY_CXT;
    
    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

#if PERL_VERSION >= 9
static SV *
make_temp_object(pTHX_ SV *arg, SV *temp)
{
    SV *target;
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ SV *arg, STRLEN *warnings)
{
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ arg,
				newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ SV *arg, COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_temp_object(aTHX_ arg, newSVsv(value));
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ arg, NULL);
    }
}
#endif

static SV *
make_mg_object(pTHX_ SV *arg, MAGIC *mg)
{
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr = newSVpvn("", 0);

    if (!SvOK(sv))
	sv_setpvn(sstr, "0", 1);
    else if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpvn(sstr,"\"",1);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvn(sstr, "\\\"", 2);
	    else if (*s == '$')
		sv_catpvn(sstr, "\\$", 2);
	    else if (*s == '@')
		sv_catpvn(sstr, "\\@", 2);
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvn(sstr, "\\\\", 2);
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
	sv_catpv(sstr, "\"");
	return sstr;
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	sv_catpv(sstr, "\"");
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpv(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpv(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
                sprintf(escbuff, "\\%03o", '?');
                sv_catpv(sstr, escbuff);
            }
	    else if (perlstyle && *s == '$')
		sv_catpv(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpv(sstr, "\\@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpv(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpv(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpv(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpv(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpv(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpv(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpv(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
		const unsigned char c = (unsigned char) *s;
		sprintf(escbuff, "\\%03o", c);
		sv_catpv(sstr, escbuff);
	    }
	    /* XXX Add line breaks if string is long */
	}
	sv_catpv(sstr, "\"");
    }
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvn("'", 1);
    const char *s = SvPV_nolen(sv);

    if (*s == '\'')
	sv_catpvn(sstr, "\\'", 2);
    else if (*s == '\\')
	sv_catpvn(sstr, "\\\\", 2);
#ifdef EBCDIC
    else if (isPRINT(*s))
#else
    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
	sv_catpvn(sstr, s, 1);
    else if (*s == '\n')
	sv_catpvn(sstr, "\\n", 2);
    else if (*s == '\r')
	sv_catpvn(sstr, "\\r", 2);
    else if (*s == '\t')
	sv_catpvn(sstr, "\\t", 2);
    else if (*s == '\a')
	sv_catpvn(sstr, "\\a", 2);
    else if (*s == '\b')
	sv_catpvn(sstr, "\\b", 2);
    else if (*s == '\f')
	sv_catpvn(sstr, "\\f", 2);
    else if (*s == '\v')
	sv_catpvn(sstr, "\\v", 2);
    else
    {
	/* no trigraph support */
	char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
	/* Don't want promotion of a signed -1 char in sprintf args */
	unsigned char c = (unsigned char) *s;
	sprintf(escbuff, "\\%03o", c);
	sv_catpv(sstr, escbuff);
    }
    sv_catpvn(sstr, "'", 1);
    return sstr;
}

static void
walkoptree(pTHX_ SV *opsv, const char *method)
{
    dSP;
    OP *o, *kid;
    dMY_CXT;

    if (!SvROK(opsv))
	croak("opsv is not a reference");
    opsv = sv_mortalcopy(opsv);
    o = INT2PTR(OP*,SvIV((SV*)SvRV(opsv)));
    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(opsv);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(opsv);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    /* Use the same opsv. Rely on methods not to mess it up. */
	    sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	    walkoptree(aTHX_ opsv, method);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
#if PERL_VERSION >= 9
	    && (kid = cPMOPo->op_pmreplrootu.op_pmreplroot)
#else
	    && (kid = cPMOPo->op_pmreplroot)
#endif
	)
    {
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	walkoptree(aTHX_ opsv, method);
    }
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	SV *opsv;
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
	    break;
	o->op_seq = 0;
#endif
	opsv = sv_newmortal();
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));
	XPUSHs(opsv);
        switch (o->op_type) {
	case OP_SUBST:
#if PERL_VERSION >= 9
            SP = oplist(aTHX_ cPMOPo->op_pmstashstartu.op_pmreplstart, SP);
#else
            SP = oplist(aTHX_ cPMOPo->op_pmreplstart, SP);
#endif
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
#if PERL_VERSION >= 9
typedef struct refcounted_he	*B__RHE;
#endif

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 605 "B.c"
#define B_main_cv()	PL_main_cv
#define B_init_av()	PL_initav
#define B_inc_gv()	PL_incgv
#define B_check_av()	PL_checkav_save
#if PERL_VERSION > 8
#  define B_unitcheck_av()	PL_unitcheckav_save
#else
#  define B_unitcheck_av()	NULL
#endif
#define B_begin_av()	PL_beginav_save
#define B_end_av()	PL_endav
#define B_main_root()	PL_main_root
#define B_main_start()	PL_main_start
#define B_amagic_generation()	PL_amagic_generation
#define B_sub_generation()	PL_sub_generation
#define B_defstash()	PL_defstash
#define B_curstash()	PL_curstash
#define B_dowarn()	PL_dowarn
#define B_comppadlist()	(PL_main_cv ? CvPADLIST(PL_main_cv) : CvPADLIST(PL_compcv))
#define B_sv_undef()	&PL_sv_undef
#define B_sv_yes()	&PL_sv_yes
#define B_sv_no()	&PL_sv_no
#define B_formfeed()	PL_formfeed
#ifdef USE_ITHREADS
#define B_regex_padav()	PL_regex_padav
#endif

XS(XS_B_init_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_init_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::init_av", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_init_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_check_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_check_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::check_av", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_check_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAA 1


XS(XS_B_unitcheck_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_unitcheck_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::unitcheck_av", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_unitcheck_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_begin_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_begin_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::begin_av", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_begin_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_end_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_end_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::end_av", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_end_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_inc_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_inc_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::inc_gv", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	RETVAL;

	RETVAL = B_inc_gv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAB 1


XS(XS_B_regex_padav); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_regex_padav)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::regex_padav", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_regex_padav();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_main_cv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_cv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::main_cv", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	RETVAL;

	RETVAL = B_main_cv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_root)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::main_root", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	RETVAL;

	RETVAL = B_main_root();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_main_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_start)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::main_start", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	RETVAL;

	RETVAL = B_main_start();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_amagic_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::amagic_generation", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_amagic_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sub_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::sub_generation", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_sub_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_comppadlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::comppadlist", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	RETVAL;

	RETVAL = B_comppadlist();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_undef)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::sv_undef", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	RETVAL;

	RETVAL = B_sv_undef();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_yes); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_yes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::sv_yes", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	RETVAL;

	RETVAL = B_sv_yes();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_no); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_no)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::sv_no", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	RETVAL;

	RETVAL = B_sv_no();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_curstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_curstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::curstash", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	RETVAL;

	RETVAL = B_curstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_defstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_defstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::defstash", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	RETVAL;

	RETVAL = B_defstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_dowarn); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_dowarn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::dowarn", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	U8	RETVAL;
	dXSTARG;

	RETVAL = B_dowarn();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_formfeed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::formfeed", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	RETVAL;

	RETVAL = B_formfeed();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_warnhook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_warnhook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::warnhook", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 711 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_warnhook);
#line 1127 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_diehook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_diehook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::diehook", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 716 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_diehook);
#line 1147 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::walkoptree", "opsv, method");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	opsv = ST(0);
	const char *	method = (const char *)SvPV_nolen(ST(1));
#line 725 "B.xs"
	walkoptree(aTHX_ opsv, method);
#line 1169 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 730 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 1192 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_address)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::address", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_svref_2object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::svref_2object", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
	B__SV	RETVAL;
#line 747 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	RETVAL = (SV*)SvRV(sv);
#line 1241 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_opnumber)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::opnumber", "name");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));
#line 757 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1281 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_ppname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::ppname", "opnum");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	opnum = (int)SvIV(ST(0));
#line 778 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo) {
	    sv_setpvn(ST(0), "pp_", 3);
	    sv_catpv(ST(0), PL_op_name[opnum]);
	}
#line 1306 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::hash", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
#line 788 "B.xs"
	STRLEN len;
	U32 hash = 0;
	char hexhash[19]; /* must fit "0xffffffffffffffff" plus trailing \0 */
	const char *s = SvPV(sv, len);
	PERL_HASH(hash, s, len);
	sprintf(hexhash, "0x%"UVxf, (UV)hash);
	ST(0) = sv_2mortal(newSVpv(hexhash, 0));
#line 1333 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cast_I32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::cast_I32", "i");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	IV	i = (IV)SvIV(ST(0));
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_minus_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::minus_c", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 804 "B.xs"
	PL_minus_c = TRUE;
#line 1377 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_save_BEGINs); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_save_BEGINs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::save_BEGINs", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 809 "B.xs"
	PL_savebegin = TRUE;
#line 1397 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::cstring", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 815 "B.xs"
	RETVAL = cstring(aTHX_ sv, 0);
#line 1419 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_perlstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_perlstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::perlstring", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 823 "B.xs"
	RETVAL = cstring(aTHX_ sv, 1);
#line 1443 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_cchar); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cchar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::cchar", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 831 "B.xs"
	RETVAL = cchar(aTHX_ sv);
#line 1467 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_threadsv_names)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::threadsv_names", "");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 838 "B.xs"
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
	int i;
	const STRLEN len = strlen(PL_threadsv_names);

	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(sv_2mortal(newSVpvn(&PL_threadsv_names[i], 1)));
# endif
#endif
#line 1500 "B.c"
	PUTBACK;
	return;
    }
}

#define OP_next(o)	o->op_next
#define OP_sibling(o)	o->op_sibling
#define OP_desc(o)	(char *)PL_op_desc[o->op_type]
#define OP_targ(o)	o->op_targ
#define OP_type(o)	o->op_type
#if PERL_VERSION >= 9
#  define OP_opt(o)	o->op_opt
#else
#  define OP_seq(o)	o->op_seq
#endif
#define OP_flags(o)	o->op_flags
#define OP_private(o)	o->op_private
#define OP_spare(o)	o->op_spare

XS(XS_B__OP_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::size", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	size_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 869 "B.xs"
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
#line 1544 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::next", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_next(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_sibling); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_sibling)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::sibling", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_sibling(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::name", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 885 "B.xs"
	RETVAL = (char *)PL_op_name[o->op_type];
#line 1637 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_ppaddr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::ppaddr", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
#line 894 "B.xs"
	int i;
	SV *sv = sv_newmortal();
#line 1660 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 897 "B.xs"
	sv_setpvn(sv, "PL_ppaddr[OP_", 13);
	sv_catpv(sv, PL_op_name[o->op_type]);
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	sv_catpv(sv, "]");
	ST(0) = sv;
#line 1675 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__OP_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_desc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::desc", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_desc(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_targ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_targ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::targ", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_targ(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::type", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_type(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAC 1


XS(XS_B__OP_opt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_opt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::opt", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_opt(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1


XS(XS_B__OP_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::seq", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::flags", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_flags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_private); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_private)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::private", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_private(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAE 1


XS(XS_B__OP_spare); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_spare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::spare", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_spare(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_oplist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::OP::oplist", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 950 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1956 "B.c"
	PUTBACK;
	return;
    }
}

#define UNOP_first(o)	o->op_first

XS(XS_B__UNOP_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_first)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::UNOP::first", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__UNOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__UNOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = UNOP_first(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define BINOP_last(o)	o->op_last

XS(XS_B__BINOP_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_last)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::BINOP::last", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__BINOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = BINOP_last(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define LOGOP_other(o)	o->op_other

XS(XS_B__LOGOP_other); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_other)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::LOGOP::other", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__LOGOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOGOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOGOP_other(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LISTOP_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LISTOP_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::LISTOP::children", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__LISTOP	o;
	OP *	kid;
	int	i;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LISTOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 984 "B.xs"
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
#line 2088 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif
#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	PM_GETRE(o)
#ifdef USE_ITHREADS
#define PMOP_pmoffset(o)	o->op_pmoffset
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
#else
#define PMOP_pmstash(o)		PmopSTASH(o);
#endif
#define PMOP_pmflags(o)		o->op_pmflags
#if PERL_VERSION <= 8
#define XSubPPtmpAAAF 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmreplroot", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1017 "B.xs"
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#  else
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
#  endif
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
	}
#line 2151 "B.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAG 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmreplroot", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1039 "B.xs"
	ST(0) = sv_newmortal();
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), o->op_pmreplrootu.op_pmtargetoff);
#  else
	    GV *const target = o->op_pmreplrootu.op_pmtargetgv;
	    sv_setiv(newSVrv(ST(0), target ?
			     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
		     PTR2IV(target));
#  endif
	}
	else {
	    OP *const root = o->op_pmreplrootu.op_pmreplroot; 
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)),
		     PTR2IV(root));
	}
#line 2197 "B.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmreplstart); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplstart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmreplstart", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmreplstart(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAH 1


XS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmnext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmnext", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmnext(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif
#ifdef USE_ITHREADS
#define XSubPPtmpAAAI 1


XS(XS_B__PMOP_pmoffset); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmoffset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmoffset", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmoffset(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmstashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmstashpv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAJ 1


XS(XS_B__PMOP_pmstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmstash", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmflags", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAK 1


XS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmpermflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmpermflags", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmdynflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmdynflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::pmdynflags", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmdynflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::precomp", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1109 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setpvn(ST(0), rx->precomp, rx->prelen);
#line 2489 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAL 1


XS(XS_B__PMOP_reflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_reflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PMOP::reflags", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1121 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setuv(ST(0), rx->extflags);
#line 2524 "B.c"
    }
    XSRETURN(1);
}

#endif
#define SVOP_sv(o)     cSVOPo->op_sv
#define SVOP_gv(o)     ((GV*)cSVOPo->op_sv)

XS(XS_B__SVOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SVOP::sv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SVOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__SVOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SVOP::gv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SVOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PAD_SVl(o->op_padix) : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PAD_SVl(o->op_padix)) == SVt_PVGV) \
			 ? (GV*)PAD_SVl(o->op_padix) : (GV *)NULL)

XS(XS_B__PADOP_padix); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_padix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PADOP::padix", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PADOP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_padix(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PADOP::sv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PADOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PADOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PADOP::gv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PADOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVOP_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVOP::pv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1167 "B.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	if (o->op_type == OP_TRANS &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    const short* const tbl = (short*)o->op_pv;
	    const short entries = 257 + tbl[256];
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, entries * sizeof(short)));
	}
	else if (o->op_type == OP_TRANS) {
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 256 * sizeof(short)));
	}
	else
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 0));
#line 2734 "B.c"
    }
    XSRETURN(1);
}

#define LOOP_redoop(o)	o->op_redoop
#define LOOP_nextop(o)	o->op_nextop
#define LOOP_lastop(o)	o->op_lastop

XS(XS_B__LOOP_redoop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_redoop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::LOOP::redoop", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_redoop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_nextop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_nextop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::LOOP::nextop", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_nextop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_lastop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_lastop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::LOOP::lastop", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_lastop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define COP_label(o)	o->cop_label
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
#define COP_filegv(o)	CopFILEGV(o)
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	CopARYBASE_get(o)
#define COP_line(o)	CopLINE(o)
#define COP_hints(o)	CopHINTS_get(o)
#if PERL_VERSION < 9
#  define COP_warnings(o)  o->cop_warnings
#  define COP_io(o)	o->cop_io
#endif

XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::label", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::stashpv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::stash", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::file", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_file(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_filegv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_filegv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::filegv", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_filegv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_cop_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_cop_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::cop_seq", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_cop_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_arybase)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::arybase", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_arybase(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_line); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_line)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::line", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_line(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAM 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::warnings", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1259 "B.xs"
	ST(0) = make_warnings_object(aTHX_ sv_newmortal(), o->cop_warnings);
	XSRETURN(1);
#line 3121 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::io", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1266 "B.xs"
	ST(0) = make_cop_io_object(aTHX_ sv_newmortal(), o);
	XSRETURN(1);
#line 3153 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_hints_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::hints_hash", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	B__RHE	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1273 "B.xs"
	RETVAL = o->cop_hints_hash;
#line 3183 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::RHE"), PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAN 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::warnings", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_warnings(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::io", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_io(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__COP_hints); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::COP::hints", "o");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_hints(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_SvTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_SvTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::SvTYPE", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvTYPE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define object_2svref(sv)	sv
#define SVREF SV *

XS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_object_2svref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::object_2svref", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	SVREF	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = object_2svref(sv);
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_REFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::REFCNT", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvREFCNT(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::FLAGS", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvFLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_POK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_POK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::POK", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPOK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_ROK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_ROK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::ROK", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvROK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_MAGICAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_MAGICAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::SV::MAGICAL", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvMAGICAL(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::IV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::IVX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIVX(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_UVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_UVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::UVX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvUVX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define needs64bits(sv) ((I32)SvIVX(sv) != SvIVX(sv))

XS(XS_B__IV_needs64bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_needs64bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::needs64bits", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = needs64bits(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_packiv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::packiv", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1355 "B.xs"
	if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = sv_2mortal(newSVpvn((char *)wp, 8));
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = sv_2mortal(newSVpvn((char *)&w, 4));
	}
#line 3664 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAO 1


XS(XS_B__IV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IV::RV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1384 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3701 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::NV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_NVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::NVX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNVX(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_LOW); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_LOW)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::COP_SEQ_RANGE_LOW", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_LOW(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_HIGH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_HIGH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::COP_SEQ_RANGE_HIGH", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_HIGH(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_PAD_INDEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_PAD_INDEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::PARENT_PAD_INDEX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_PAD_INDEX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_FAKELEX_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_FAKELEX_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::NV::PARENT_FAKELEX_FLAGS", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_FAKELEX_FLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAP 1


XS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::RV::RV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__RV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvRV(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PV_PVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::PVX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPVX(sv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::RV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1441 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3986 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::PV", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1454 "B.xs"
        ST(0) = sv_newmortal();
        if( SvPOK(sv) ) {
	    /* FIXME - we need a better way for B to identify PVs that are
	       in the pads as variable names.  */
	    if((SvLEN(sv) && SvCUR(sv) >= SvLEN(sv))) {
		/* It claims to be longer than the space allocated for it -
		   presuambly it's a variable name in the pad  */
		sv_setpv(ST(0), SvPV_nolen_const(sv));
	    } else {
		sv_setpvn(ST(0), SvPVX_const(sv), SvCUR(sv));
	    }
            SvFLAGS(ST(0)) |= SvUTF8(sv);
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
            sv_setpvn(ST(0), NULL, 0);
        }
#line 4035 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_PVBM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVBM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::PVBM", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1480 "B.xs"
        ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX_const(sv),
	    SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0));
#line 4065 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::LEN", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PV_CUR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_CUR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PV::CUR", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvCUR(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_MAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVMG::MAGIC", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1500 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ sv_newmortal(), mg));
#line 4157 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__PVMG_SvSTASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_SvSTASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVMG::SvSTASH", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVMG	sv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvSTASH(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAQ 1


XS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::REGEXP::REGEX", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVMG	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1517 "B.xs"
	RETVAL = PTR2IV(((struct xregexp *)SvANY(sv))->xrx_regexp);
#line 4223 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__REGEXP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::REGEXP::precomp", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVMG	sv;
	REGEXP*	rx;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1526 "B.xs"
	rx = ((struct xregexp *)SvANY(sv))->xrx_regexp;
	/* FIXME - UTF-8? And the equivalent precomp methods? */
	RETVAL = newSVpvn( rx->precomp, rx->prelen );
#line 4256 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#define MgMOREMAGIC(mg) mg->mg_moremagic
#define MgPRIVATE(mg) mg->mg_private
#define MgTYPE(mg) mg->mg_type
#define MgFLAGS(mg) mg->mg_flags
#define MgOBJ(mg) mg->mg_obj
#define MgLENGTH(mg) mg->mg_len
#define MgREGEX(mg) PTR2IV(mg->mg_obj)

XS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_MOREMAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::MOREMAGIC", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	B__MAGIC	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1548 "B.xs"
	if( MgMOREMAGIC(mg) ) {
	    RETVAL = MgMOREMAGIC(mg);
	}
	else {
	    XSRETURN_UNDEF;
	}
#line 4300 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::MAGIC"), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PRIVATE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PRIVATE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::PRIVATE", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgPRIVATE(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::TYPE", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgTYPE(mg);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::FLAGS", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgFLAGS(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_OBJ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::OBJ", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgOBJ(mg);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::REGEX", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1577 "B.xs"
        if(mg->mg_type == PERL_MAGIC_qr) {
            RETVAL = MgREGEX(mg);
        }
        else {
            croak( "REGEX is only meaningful on r-magic" );
        }
#line 4460 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::precomp", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1590 "B.xs"
        if (mg->mg_type == PERL_MAGIC_qr) {
            REGEXP* rx = (REGEXP*)mg->mg_obj;
            RETVAL = Nullsv;
            if( rx )
                RETVAL = newSVpvn( rx->precomp, rx->prelen );
        }
        else {
            croak( "precomp is only meaningful on r-magic" );
        }
#line 4498 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_LENGTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_LENGTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::LENGTH", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgLENGTH(mg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PTR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::MAGIC::PTR", "mg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1610 "B.xs"
	ST(0) = sv_newmortal();
 	if (mg->mg_ptr){
		if (mg->mg_len >= 0){
	    		sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
		} else if (mg->mg_len == HEf_SVKEY) {
			ST(0) = make_sv_object(aTHX_
				    sv_newmortal(), (SV*)mg->mg_ptr);
		}
	}
#line 4566 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGOFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGOFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVLV::TARGOFF", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGOFF(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGLEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGLEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVLV::TARGLEN", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVLV::TYPE", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVLV	sv;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTYPE(sv);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARG); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARG)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::PVLV::TARG", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__PVLV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARG(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__BM_USEFUL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_USEFUL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::BM::USEFUL", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__BM	sv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmUSEFUL(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_PREVIOUS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::BM::PREVIOUS", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__BM	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmPREVIOUS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_RARE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::BM::RARE", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmRARE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_TABLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_TABLE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::BM::TABLE", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__BM	sv;
	STRLEN	len;
	char *	str;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1658 "B.xs"
	str = SvPV(sv, len);
	/* Boyer-Moore table is just after string and its safety-margin \0 */
	ST(0) = sv_2mortal(newSVpvn(str + len + PERL_FBM_TABLE_OFFSET, 256));
#line 4810 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::NAME", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1668 "B.xs"
	ST(0) = sv_2mortal(newSVpvn(GvNAME(gv), GvNAMELEN(gv)));
#line 4838 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_is_empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::is_empty", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1674 "B.xs"
        RETVAL = GvGP(gv) == Null(GP*);
#line 4867 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_isGV_with_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_isGV_with_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::isGV_with_GP", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1682 "B.xs"
#if PERL_VERSION >= 9
	RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
#else
	RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
#endif
#line 4902 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::GP", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_B__GV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::STASH", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSTASH(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_SV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::SV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_IO); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_IO)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::IO", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__IO	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvIO(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_FORM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FORM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::FORM", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__FM	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1710 "B.xs"
	RETVAL = (SV*)GvFORM(gv);
#line 5059 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_AV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_AV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::AV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvAV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_HV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_HV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::HV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvHV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_EGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_EGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::EGV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::CV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CVGEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CVGEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::CVGEN", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCVGEN(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_LINE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_LINE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::LINE", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvLINE(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::FILE", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILE(gv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILEGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::FILEGV", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_GvREFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvREFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::GvREFCNT", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvREFCNT(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_GvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::GV::GvFLAGS", "gv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__GV	gv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFLAGS(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::LINES", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::PAGE", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::PAGE_LEN", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE_LEN(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES_LEFT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES_LEFT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::LINES_LEFT", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES_LEFT(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::TOP_NAME", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::TOP_GV", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::FMT_NAME", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::FMT_GV", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::BOTTOM_NAME", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::BOTTOM_GV", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION <= 8
#define XSubPPtmpAAAR 1


XS(XS_B__IO_SUBPROCESS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_SUBPROCESS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::SUBPROCESS", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	short	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoSUBPROCESS(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IsSTD)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::IsSTD", "io, name");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1));
#line 1811 "B.xs"
	PerlIO* handle = 0;
#line 5735 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");
#line 1813 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 5758 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::IoTYPE", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTYPE(io);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::IO::IoFLAGS", "io");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__IO	io;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFLAGS(io);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::FILL", "av");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::MAX", "av");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvMAX(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off
#define XSubPPtmpAAAS 1


XS(XS_B__AV_OFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_OFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::OFF", "av");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	av;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvOFF(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::ARRAY", "av");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1864 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ sv_newmortal(), svp[i]));
	}
#line 5950 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAYelt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::ARRAYelt", "av, idx");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1));

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1876 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), NULL));
#line 5985 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAT 1


XS(XS_B__AV_AvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_AvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::AV::AvFLAGS", "av");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__AV	av;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFLAGS(av);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__FM_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::FM::LINES", "form");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__FM	form;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    form = INT2PTR(B__FM,tmp);
	}
	else
	    croak("form is not a reference");

	RETVAL = FmLINES(form);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CONST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::CONST", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::STASH", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvSTASH(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_START)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::START", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1911 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvSTART(cv);
#line 6141 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_ROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_ROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::ROOT", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1919 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvROOT(cv);
#line 6173 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::GV", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvGV(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::FILE", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFILE(cv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_DEPTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::DEPTH", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_PADLIST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::PADLIST", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvPADLIST(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::OUTSIDE", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE_SEQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE_SEQ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::OUTSIDE_SEQ", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE_SEQ(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUB)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::XSUB", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1951 "B.xs"
	ST(0) = sv_2mortal(newSViv(CvISXSUB(cv) ? PTR2IV(CvXSUB(cv)) : 0));
#line 6390 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUBANY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUBANY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::XSUBANY", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1958 "B.xs"
	ST(0) = CvCONST(cv) ?
	    make_sv_object(aTHX_ sv_newmortal(),(SV *)CvXSUBANY(cv).any_ptr) :
	    sv_2mortal(newSViv(CvISXSUB(cv) ? CvXSUBANY(cv).any_iv : 0));
#line 6420 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_CvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::CvFLAGS", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFLAGS(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_const_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::CV::const_sv", "cv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__CV	cv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = cv_const_sv(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::FILL", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::MAX", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvMAX(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_KEYS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_KEYS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::KEYS", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvKEYS(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_RITER)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::RITER", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::NAME", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvNAME(hv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAU 1


XS(XS_B__HV_PMROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_PMROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::PMROOT", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HV	hv;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvPMROOT(hv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif

XS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HV::ARRAY", "hv");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");
#line 2009 "B.xs"
	if (HvKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvKEYS(hv) * 2);
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
		mPUSHp(key, len);
		PUSHs(make_sv_object(aTHX_ sv_newmortal(), sv));
	    }
	}
#line 6707 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_VAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HE::VAL", "he");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeVAL(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HE::HASH", "he");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HE_SVKEY_force); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_SVKEY_force)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::HE::SVKEY_force", "he");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeSVKEY_force(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAV 1


XS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RHE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "B::RHE::HASH", "h");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference");
#line 2043 "B.xs"
	RETVAL = newRV( (SV*)Perl_refcounted_he_chain_2hv(aTHX_ h) );
#line 6834 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS(boot_B); /* prototype to pass -Wmissing-prototypes */
XS(boot_B)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("B::init_av", XS_B_init_av, file);
        newXS("B::check_av", XS_B_check_av, file);
#if XSubPPtmpAAAA
        newXS("B::unitcheck_av", XS_B_unitcheck_av, file);
#endif
        newXS("B::begin_av", XS_B_begin_av, file);
        newXS("B::end_av", XS_B_end_av, file);
        newXS("B::inc_gv", XS_B_inc_gv, file);
#if XSubPPtmpAAAB
        newXS("B::regex_padav", XS_B_regex_padav, file);
#endif
        newXS("B::main_cv", XS_B_main_cv, file);
        newXS("B::main_root", XS_B_main_root, file);
        newXS("B::main_start", XS_B_main_start, file);
        newXS("B::amagic_generation", XS_B_amagic_generation, file);
        newXS("B::sub_generation", XS_B_sub_generation, file);
        newXS("B::comppadlist", XS_B_comppadlist, file);
        newXS("B::sv_undef", XS_B_sv_undef, file);
        newXS("B::sv_yes", XS_B_sv_yes, file);
        newXS("B::sv_no", XS_B_sv_no, file);
        newXS("B::curstash", XS_B_curstash, file);
        newXS("B::defstash", XS_B_defstash, file);
        newXS("B::dowarn", XS_B_dowarn, file);
        newXS("B::formfeed", XS_B_formfeed, file);
        newXS("B::warnhook", XS_B_warnhook, file);
        newXS("B::diehook", XS_B_diehook, file);
        newXS("B::walkoptree", XS_B_walkoptree, file);
        newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        newXS("B::address", XS_B_address, file);
        newXS("B::svref_2object", XS_B_svref_2object, file);
        newXS("B::opnumber", XS_B_opnumber, file);
        newXS("B::ppname", XS_B_ppname, file);
        newXS("B::hash", XS_B_hash, file);
        newXS("B::cast_I32", XS_B_cast_I32, file);
        newXS("B::minus_c", XS_B_minus_c, file);
        newXS("B::save_BEGINs", XS_B_save_BEGINs, file);
        newXS("B::cstring", XS_B_cstring, file);
        newXS("B::perlstring", XS_B_perlstring, file);
        newXS("B::cchar", XS_B_cchar, file);
        newXS("B::threadsv_names", XS_B_threadsv_names, file);
        newXS("B::OP::size", XS_B__OP_size, file);
        newXS("B::OP::next", XS_B__OP_next, file);
        newXS("B::OP::sibling", XS_B__OP_sibling, file);
        newXS("B::OP::name", XS_B__OP_name, file);
        newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
        newXS("B::OP::desc", XS_B__OP_desc, file);
        newXS("B::OP::targ", XS_B__OP_targ, file);
        newXS("B::OP::type", XS_B__OP_type, file);
#if XSubPPtmpAAAC
        newXS("B::OP::opt", XS_B__OP_opt, file);
#endif
#if XSubPPtmpAAAD
        newXS("B::OP::seq", XS_B__OP_seq, file);
#endif
        newXS("B::OP::flags", XS_B__OP_flags, file);
        newXS("B::OP::private", XS_B__OP_private, file);
#if XSubPPtmpAAAE
        newXS("B::OP::spare", XS_B__OP_spare, file);
#endif
        newXS("B::OP::oplist", XS_B__OP_oplist, file);
        newXS("B::UNOP::first", XS_B__UNOP_first, file);
        newXS("B::BINOP::last", XS_B__BINOP_last, file);
        newXS("B::LOGOP::other", XS_B__LOGOP_other, file);
        newXS("B::LISTOP::children", XS_B__LISTOP_children, file);
#if XSubPPtmpAAAF
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
#if XSubPPtmpAAAG
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
        newXS("B::PMOP::pmreplstart", XS_B__PMOP_pmreplstart, file);
#if XSubPPtmpAAAH
        newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
#endif
#if XSubPPtmpAAAI
        newXS("B::PMOP::pmoffset", XS_B__PMOP_pmoffset, file);
        newXS("B::PMOP::pmstashpv", XS_B__PMOP_pmstashpv, file);
#endif
#if XSubPPtmpAAAJ
        newXS("B::PMOP::pmstash", XS_B__PMOP_pmstash, file);
#endif
        newXS("B::PMOP::pmflags", XS_B__PMOP_pmflags, file);
#if XSubPPtmpAAAK
        newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        newXS("B::PMOP::pmdynflags", XS_B__PMOP_pmdynflags, file);
#endif
        newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
#if XSubPPtmpAAAL
        newXS("B::PMOP::reflags", XS_B__PMOP_reflags, file);
#endif
        newXS("B::SVOP::sv", XS_B__SVOP_sv, file);
        newXS("B::SVOP::gv", XS_B__SVOP_gv, file);
        newXS("B::PADOP::padix", XS_B__PADOP_padix, file);
        newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        newXS("B::PADOP::gv", XS_B__PADOP_gv, file);
        newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        newXS("B::LOOP::redoop", XS_B__LOOP_redoop, file);
        newXS("B::LOOP::nextop", XS_B__LOOP_nextop, file);
        newXS("B::LOOP::lastop", XS_B__LOOP_lastop, file);
        newXS("B::COP::label", XS_B__COP_label, file);
        newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        newXS("B::COP::stash", XS_B__COP_stash, file);
        newXS("B::COP::file", XS_B__COP_file, file);
        newXS("B::COP::filegv", XS_B__COP_filegv, file);
        newXS("B::COP::cop_seq", XS_B__COP_cop_seq, file);
        newXS("B::COP::arybase", XS_B__COP_arybase, file);
        newXS("B::COP::line", XS_B__COP_line, file);
#if XSubPPtmpAAAM
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::io", XS_B__COP_io, file);
        newXS("B::COP::hints_hash", XS_B__COP_hints_hash, file);
#endif
#if XSubPPtmpAAAN
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::io", XS_B__COP_io, file);
#endif
        newXS("B::COP::hints", XS_B__COP_hints, file);
        newXS("B::SV::SvTYPE", XS_B__SV_SvTYPE, file);
        newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        newXS("B::SV::FLAGS", XS_B__SV_FLAGS, file);
        newXS("B::SV::POK", XS_B__SV_POK, file);
        newXS("B::SV::ROK", XS_B__SV_ROK, file);
        newXS("B::SV::MAGICAL", XS_B__SV_MAGICAL, file);
        newXS("B::IV::IV", XS_B__IV_IV, file);
        newXS("B::IV::IVX", XS_B__IV_IVX, file);
        newXS("B::IV::UVX", XS_B__IV_UVX, file);
        newXS("B::IV::needs64bits", XS_B__IV_needs64bits, file);
        newXS("B::IV::packiv", XS_B__IV_packiv, file);
#if XSubPPtmpAAAO
        newXS("B::IV::RV", XS_B__IV_RV, file);
#endif
        newXS("B::NV::NV", XS_B__NV_NV, file);
        newXS("B::NV::NVX", XS_B__NV_NVX, file);
        newXS("B::NV::COP_SEQ_RANGE_LOW", XS_B__NV_COP_SEQ_RANGE_LOW, file);
        newXS("B::NV::COP_SEQ_RANGE_HIGH", XS_B__NV_COP_SEQ_RANGE_HIGH, file);
        newXS("B::NV::PARENT_PAD_INDEX", XS_B__NV_PARENT_PAD_INDEX, file);
        newXS("B::NV::PARENT_FAKELEX_FLAGS", XS_B__NV_PARENT_FAKELEX_FLAGS, file);
#if XSubPPtmpAAAP
        newXS("B::RV::RV", XS_B__RV_RV, file);
#endif
        newXS("B::PV::PVX", XS_B__PV_PVX, file);
        newXS("B::PV::RV", XS_B__PV_RV, file);
        newXS("B::PV::PV", XS_B__PV_PV, file);
        newXS("B::PV::PVBM", XS_B__PV_PVBM, file);
        newXS("B::PV::LEN", XS_B__PV_LEN, file);
        newXS("B::PV::CUR", XS_B__PV_CUR, file);
        newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        newXS("B::PVMG::SvSTASH", XS_B__PVMG_SvSTASH, file);
#if XSubPPtmpAAAQ
        newXS("B::REGEXP::REGEX", XS_B__REGEXP_REGEX, file);
        newXS("B::REGEXP::precomp", XS_B__REGEXP_precomp, file);
#endif
        newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_PRIVATE, file);
        newXS("B::MAGIC::TYPE", XS_B__MAGIC_TYPE, file);
        newXS("B::MAGIC::FLAGS", XS_B__MAGIC_FLAGS, file);
        newXS("B::MAGIC::OBJ", XS_B__MAGIC_OBJ, file);
        newXS("B::MAGIC::REGEX", XS_B__MAGIC_REGEX, file);
        newXS("B::MAGIC::precomp", XS_B__MAGIC_precomp, file);
        newXS("B::MAGIC::LENGTH", XS_B__MAGIC_LENGTH, file);
        newXS("B::MAGIC::PTR", XS_B__MAGIC_PTR, file);
        newXS("B::PVLV::TARGOFF", XS_B__PVLV_TARGOFF, file);
        newXS("B::PVLV::TARGLEN", XS_B__PVLV_TARGLEN, file);
        newXS("B::PVLV::TYPE", XS_B__PVLV_TYPE, file);
        newXS("B::PVLV::TARG", XS_B__PVLV_TARG, file);
        newXS("B::BM::USEFUL", XS_B__BM_USEFUL, file);
        newXS("B::BM::PREVIOUS", XS_B__BM_PREVIOUS, file);
        newXS("B::BM::RARE", XS_B__BM_RARE, file);
        newXS("B::BM::TABLE", XS_B__BM_TABLE, file);
        newXS("B::GV::NAME", XS_B__GV_NAME, file);
        newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        newXS("B::GV::isGV_with_GP", XS_B__GV_isGV_with_GP, file);
        newXS("B::GV::GP", XS_B__GV_GP, file);
        newXS("B::GV::STASH", XS_B__GV_STASH, file);
        newXS("B::GV::SV", XS_B__GV_SV, file);
        newXS("B::GV::IO", XS_B__GV_IO, file);
        newXS("B::GV::FORM", XS_B__GV_FORM, file);
        newXS("B::GV::AV", XS_B__GV_AV, file);
        newXS("B::GV::HV", XS_B__GV_HV, file);
        newXS("B::GV::EGV", XS_B__GV_EGV, file);
        newXS("B::GV::CV", XS_B__GV_CV, file);
        newXS("B::GV::CVGEN", XS_B__GV_CVGEN, file);
        newXS("B::GV::LINE", XS_B__GV_LINE, file);
        newXS("B::GV::FILE", XS_B__GV_FILE, file);
        newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
        newXS("B::GV::GvREFCNT", XS_B__GV_GvREFCNT, file);
        newXS("B::GV::GvFLAGS", XS_B__GV_GvFLAGS, file);
        newXS("B::IO::LINES", XS_B__IO_LINES, file);
        newXS("B::IO::PAGE", XS_B__IO_PAGE, file);
        newXS("B::IO::PAGE_LEN", XS_B__IO_PAGE_LEN, file);
        newXS("B::IO::LINES_LEFT", XS_B__IO_LINES_LEFT, file);
        newXS("B::IO::TOP_NAME", XS_B__IO_TOP_NAME, file);
        newXS("B::IO::TOP_GV", XS_B__IO_TOP_GV, file);
        newXS("B::IO::FMT_NAME", XS_B__IO_FMT_NAME, file);
        newXS("B::IO::FMT_GV", XS_B__IO_FMT_GV, file);
        newXS("B::IO::BOTTOM_NAME", XS_B__IO_BOTTOM_NAME, file);
        newXS("B::IO::BOTTOM_GV", XS_B__IO_BOTTOM_GV, file);
#if XSubPPtmpAAAR
        newXS("B::IO::SUBPROCESS", XS_B__IO_SUBPROCESS, file);
#endif
        newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        newXS("B::IO::IoTYPE", XS_B__IO_IoTYPE, file);
        newXS("B::IO::IoFLAGS", XS_B__IO_IoFLAGS, file);
        newXS("B::AV::FILL", XS_B__AV_FILL, file);
        newXS("B::AV::MAX", XS_B__AV_MAX, file);
#if XSubPPtmpAAAS
        newXS("B::AV::OFF", XS_B__AV_OFF, file);
#endif
        newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
#if XSubPPtmpAAAT
        newXS("B::AV::AvFLAGS", XS_B__AV_AvFLAGS, file);
#endif
        newXS("B::FM::LINES", XS_B__FM_LINES, file);
        newXS("B::CV::CONST", XS_B__CV_CONST, file);
        newXS("B::CV::STASH", XS_B__CV_STASH, file);
        newXS("B::CV::START", XS_B__CV_START, file);
        newXS("B::CV::ROOT", XS_B__CV_ROOT, file);
        newXS("B::CV::GV", XS_B__CV_GV, file);
        newXS("B::CV::FILE", XS_B__CV_FILE, file);
        newXS("B::CV::DEPTH", XS_B__CV_DEPTH, file);
        newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
        newXS("B::CV::OUTSIDE", XS_B__CV_OUTSIDE, file);
        newXS("B::CV::OUTSIDE_SEQ", XS_B__CV_OUTSIDE_SEQ, file);
        newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        newXS("B::CV::XSUBANY", XS_B__CV_XSUBANY, file);
        newXS("B::CV::CvFLAGS", XS_B__CV_CvFLAGS, file);
        newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        newXS("B::HV::FILL", XS_B__HV_FILL, file);
        newXS("B::HV::MAX", XS_B__HV_MAX, file);
        newXS("B::HV::KEYS", XS_B__HV_KEYS, file);
        newXS("B::HV::RITER", XS_B__HV_RITER, file);
        newXS("B::HV::NAME", XS_B__HV_NAME, file);
#if XSubPPtmpAAAU
        newXS("B::HV::PMROOT", XS_B__HV_PMROOT, file);
#endif
        newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);
        newXS("B::HE::VAL", XS_B__HE_VAL, file);
        newXS("B::HE::HASH", XS_B__HE_HASH, file);
        newXS("B::HE::SVKEY_force", XS_B__HE_SVKEY_force, file);
#if XSubPPtmpAAAV
        newXS("B::RHE::HASH", XS_B__RHE_HASH, file);
#endif

    /* Initialisation Section */

#line 596 "B.xs"
{
    HV *stash = gv_stashpvn("B", 1, GV_ADD);
    AV *export_ok = perl_get_av("B::EXPORT_OK",TRUE);
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;
#if PERL_VERSION <= 8
#  define OPpPAD_STATE 0
#endif
#include "defsubs.h"
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#if XSubPPtmpAAAR
#endif
#if XSubPPtmpAAAS
#endif
#if XSubPPtmpAAAT
#endif
#if XSubPPtmpAAAU
#endif
#if XSubPPtmpAAAV
#endif
#line 7168 "B.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

