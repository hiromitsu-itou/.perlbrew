/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.21 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION >= 9
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION <= 8
    "B::BM",
#endif
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
#if PERL_VERSION >= 9
    "B::GV",
#endif
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
#if PERL_VERSION <= 8
    "B::GV",
#endif
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ const OP *o)
{
    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 PL_op_name[o->op_type]);
    return OPc_BASEOP;
}

static char *
cc_opclassname(pTHX_ const OP *o)
{
    return (char *)opclassnames[cc_opclass(aTHX_ o)];
}

static SV *
make_sv_object(pTHX_ SV *arg, SV *sv)
{
    const char *type = 0;
    IV iv;
    dMY_CXT;
    
    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

#if PERL_VERSION >= 9
static SV *
make_temp_object(pTHX_ SV *arg, SV *temp)
{
    SV *target;
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ SV *arg, STRLEN *warnings)
{
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ arg,
				newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ SV *arg, COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_temp_object(aTHX_ arg, newSVsv(value));
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ arg, NULL);
    }
}
#endif

static SV *
make_mg_object(pTHX_ SV *arg, MAGIC *mg)
{
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr = newSVpvs("");

    if (!SvOK(sv))
	sv_setpvs(sstr, "0");
    else if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpvs(sstr,"\"");
	while (*s)
	{
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (*s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvs(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
	sv_catpvs(sstr, "\"");
	return sstr;
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	sv_catpvs(sstr, "\"");
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpvs(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
		const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", '?');
                sv_catpvn(sstr, escbuff, oct_len);
            }
	    else if (perlstyle && *s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpvs(sstr, "\\@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpvs(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpvs(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpvs(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpvs(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpvs(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpvs(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpvs(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
		const unsigned char c = (unsigned char) *s;
		const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", c);
		sv_catpvn(sstr, escbuff, oct_len);
	    }
	    /* XXX Add line breaks if string is long */
	}
	sv_catpvs(sstr, "\"");
    }
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvs("'");
    const char *s = SvPV_nolen(sv);

    if (*s == '\'')
	sv_catpvs(sstr, "\\'");
    else if (*s == '\\')
	sv_catpvs(sstr, "\\\\");
#ifdef EBCDIC
    else if (isPRINT(*s))
#else
    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
	sv_catpvn(sstr, s, 1);
    else if (*s == '\n')
	sv_catpvs(sstr, "\\n");
    else if (*s == '\r')
	sv_catpvs(sstr, "\\r");
    else if (*s == '\t')
	sv_catpvs(sstr, "\\t");
    else if (*s == '\a')
	sv_catpvs(sstr, "\\a");
    else if (*s == '\b')
	sv_catpvs(sstr, "\\b");
    else if (*s == '\f')
	sv_catpvs(sstr, "\\f");
    else if (*s == '\v')
	sv_catpvs(sstr, "\\v");
    else
    {
	/* no trigraph support */
	char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
	/* Don't want promotion of a signed -1 char in sprintf args */
	unsigned char c = (unsigned char) *s;
	const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", c);
	sv_catpvn(sstr, escbuff, oct_len);
    }
    sv_catpvs(sstr, "'");
    return sstr;
}

#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplroot
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif

static void
walkoptree(pTHX_ SV *opsv, const char *method)
{
    dSP;
    OP *o, *kid;
    dMY_CXT;

    if (!SvROK(opsv))
	croak("opsv is not a reference");
    opsv = sv_mortalcopy(opsv);
    o = INT2PTR(OP*,SvIV((SV*)SvRV(opsv)));
    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(opsv);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(opsv);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    /* Use the same opsv. Rely on methods not to mess it up. */
	    sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	    walkoptree(aTHX_ opsv, method);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	walkoptree(aTHX_ opsv, method);
    }
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	SV *opsv;
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
	    break;
	o->op_seq = 0;
#endif
	opsv = sv_newmortal();
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));
	XPUSHs(opsv);
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
#if PERL_VERSION >= 9
typedef struct refcounted_he	*B__RHE;
#endif

#line 602 "B.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 654 "B.c"
#define B_main_cv()	PL_main_cv
#define B_init_av()	PL_initav
#define B_inc_gv()	PL_incgv
#define B_check_av()	PL_checkav_save
#if PERL_VERSION > 8
#  define B_unitcheck_av()	PL_unitcheckav_save
#else
#  define B_unitcheck_av()	NULL
#endif
#define B_begin_av()	PL_beginav_save
#define B_end_av()	PL_endav
#define B_main_root()	PL_main_root
#define B_main_start()	PL_main_start
#define B_amagic_generation()	PL_amagic_generation
#define B_sub_generation()	PL_sub_generation
#define B_defstash()	PL_defstash
#define B_curstash()	PL_curstash
#define B_dowarn()	PL_dowarn
#define B_comppadlist()	(PL_main_cv ? CvPADLIST(PL_main_cv) : CvPADLIST(PL_compcv))
#define B_sv_undef()	&PL_sv_undef
#define B_sv_yes()	&PL_sv_yes
#define B_sv_no()	&PL_sv_no
#define B_formfeed()	PL_formfeed
#ifdef USE_ITHREADS
#define B_regex_padav()	PL_regex_padav
#endif

XS(XS_B_init_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_init_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_init_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_check_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_check_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_check_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAA 1


XS(XS_B_unitcheck_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_unitcheck_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_unitcheck_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_begin_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_begin_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_begin_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_end_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_end_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_end_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_inc_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_inc_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__GV	RETVAL;

	RETVAL = B_inc_gv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAB 1


XS(XS_B_regex_padav); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_regex_padav)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_regex_padav();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_main_cv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_cv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__CV	RETVAL;

	RETVAL = B_main_cv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_root)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__OP	RETVAL;

	RETVAL = B_main_root();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_main_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_start)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__OP	RETVAL;

	RETVAL = B_main_start();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_amagic_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_amagic_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sub_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_sub_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_comppadlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_comppadlist();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_undef)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_undef();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_yes); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_yes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_yes();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_no); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_no)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_no();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_curstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_curstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__HV	RETVAL;

	RETVAL = B_curstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_defstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_defstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__HV	RETVAL;

	RETVAL = B_defstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_dowarn); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_dowarn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	U8	RETVAL;
	dXSTARG;

	RETVAL = B_dowarn();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_formfeed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_formfeed();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_warnhook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_warnhook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 712 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_warnhook);
#line 1155 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_diehook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_diehook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 717 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_diehook);
#line 1174 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "opsv, method");
    {
	SV *	opsv = ST(0);
	const char *	method = (const char *)SvPV_nolen(ST(1));
#line 726 "B.xs"
	walkoptree(aTHX_ opsv, method);
#line 1195 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 731 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 1218 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_address)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_svref_2object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	B__SV	RETVAL;
#line 748 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	RETVAL = (SV*)SvRV(sv);
#line 1265 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_opnumber)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));
#line 758 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1304 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_ppname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "opnum");
    {
	int	opnum = (int)SvIV(ST(0));
#line 779 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo) {
	    sv_setpvs(ST(0), "pp_");
	    sv_catpv(ST(0), PL_op_name[opnum]);
	}
#line 1328 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
#line 789 "B.xs"
	STRLEN len;
	U32 hash = 0;
	char hexhash[19]; /* must fit "0xffffffffffffffff" plus trailing \0 */
	const char *s = SvPV(sv, len);
	PERL_HASH(hash, s, len);
	len = my_sprintf(hexhash, "0x%"UVxf, (UV)hash);
	ST(0) = newSVpvn_flags(hexhash, len, SVs_TEMP);
#line 1354 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cast_I32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	IV	i = (IV)SvIV(ST(0));
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_minus_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 805 "B.xs"
	PL_minus_c = TRUE;
#line 1396 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_save_BEGINs); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_save_BEGINs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 810 "B.xs"
	PL_savebegin = TRUE;
#line 1415 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 816 "B.xs"
	RETVAL = cstring(aTHX_ sv, 0);
#line 1436 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_perlstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_perlstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 824 "B.xs"
	RETVAL = cstring(aTHX_ sv, 1);
#line 1459 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_cchar); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cchar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 832 "B.xs"
	RETVAL = cchar(aTHX_ sv);
#line 1482 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_threadsv_names)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 839 "B.xs"
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
	int i;
	const STRLEN len = strlen(PL_threadsv_names);

	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(newSVpvn_flags(&PL_threadsv_names[i], 1, SVs_TEMP));
# endif
#endif
#line 1514 "B.c"
	PUTBACK;
	return;
    }
}

#define OP_next(o)	o->op_next
#define OP_sibling(o)	o->op_sibling
#define OP_desc(o)	(char *)PL_op_desc[o->op_type]
#define OP_targ(o)	o->op_targ
#define OP_type(o)	o->op_type
#if PERL_VERSION >= 9
#  define OP_opt(o)	o->op_opt
#else
#  define OP_seq(o)	o->op_seq
#endif
#define OP_flags(o)	o->op_flags
#define OP_private(o)	o->op_private
#define OP_spare(o)	o->op_spare

XS(XS_B__OP_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	size_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 870 "B.xs"
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
#line 1557 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_next(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_sibling); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_sibling)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_sibling(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 886 "B.xs"
	RETVAL = (char *)PL_op_name[o->op_type];
#line 1647 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_ppaddr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
#line 895 "B.xs"
	int i;
	SV *sv = sv_newmortal();
#line 1669 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 898 "B.xs"
	sv_setpvs(sv, "PL_ppaddr[OP_");
	sv_catpv(sv, PL_op_name[o->op_type]);
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	sv_catpvs(sv, "]");
	ST(0) = sv;
#line 1684 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__OP_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_desc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_desc(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_targ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_targ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_targ(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_type(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAC 1


XS(XS_B__OP_opt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_opt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_opt(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1


XS(XS_B__OP_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_flags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_private); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_private)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_private(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAE 1


XS(XS_B__OP_spare); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_spare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_spare(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_oplist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 951 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1956 "B.c"
	PUTBACK;
	return;
    }
}

#define UNOP_first(o)	o->op_first

XS(XS_B__UNOP_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_first)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__UNOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__UNOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = UNOP_first(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define BINOP_last(o)	o->op_last

XS(XS_B__BINOP_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_last)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__BINOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = BINOP_last(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define LOGOP_other(o)	o->op_other

XS(XS_B__LOGOP_other); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_other)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOGOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOGOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOGOP_other(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LISTOP_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LISTOP_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LISTOP	o;
	OP *	kid;
	int	i;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LISTOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 985 "B.xs"
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
#line 2084 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	PM_GETRE(o)
#ifdef USE_ITHREADS
#define PMOP_pmoffset(o)	o->op_pmoffset
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
#else
#define PMOP_pmstash(o)		PmopSTASH(o);
#endif
#define PMOP_pmflags(o)		o->op_pmflags
#if PERL_VERSION <= 8
#define XSubPPtmpAAAF 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1011 "B.xs"
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#  else
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
#  endif
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
	}
#line 2139 "B.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAG 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1033 "B.xs"
	ST(0) = sv_newmortal();
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), o->op_pmreplrootu.op_pmtargetoff);
#  else
	    GV *const target = o->op_pmreplrootu.op_pmtargetgv;
	    sv_setiv(newSVrv(ST(0), target ?
			     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
		     PTR2IV(target));
#  endif
	}
	else {
	    OP *const root = o->op_pmreplrootu.op_pmreplroot; 
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)),
		     PTR2IV(root));
	}
#line 2184 "B.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmreplstart); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplstart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmreplstart(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAH 1


XS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmnext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmnext(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif
#ifdef USE_ITHREADS
#define XSubPPtmpAAAI 1


XS(XS_B__PMOP_pmoffset); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmoffset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmoffset(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmstashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAJ 1


XS(XS_B__PMOP_pmstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAK 1


XS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmpermflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmdynflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmdynflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmdynflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1103 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setpvn(ST(0), RX_PRECOMP(rx), RX_PRELEN(rx));
#line 2467 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAL 1


XS(XS_B__PMOP_reflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_reflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1115 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setuv(ST(0), RX_EXTFLAGS(rx));
#line 2501 "B.c"
    }
    XSRETURN(1);
}

#endif
#define SVOP_sv(o)     cSVOPo->op_sv
#define SVOP_gv(o)     ((GV*)cSVOPo->op_sv)

XS(XS_B__SVOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__SVOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__SVOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__SVOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PAD_SVl(o->op_padix) : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PAD_SVl(o->op_padix)) == SVt_PVGV) \
			 ? (GV*)PAD_SVl(o->op_padix) : (GV *)NULL)

XS(XS_B__PADOP_padix); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_padix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_padix(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PADOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVOP_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1161 "B.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	if (o->op_type == OP_TRANS &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    const short* const tbl = (short*)o->op_pv;
	    const short entries = 257 + tbl[256];
	    ST(0) = newSVpvn_flags(o->op_pv, entries * sizeof(short), SVs_TEMP);
	}
	else if (o->op_type == OP_TRANS) {
	    ST(0) = newSVpvn_flags(o->op_pv, 256 * sizeof(short), SVs_TEMP);
	}
	else
	    ST(0) = newSVpvn_flags(o->op_pv, strlen(o->op_pv), SVs_TEMP);
#line 2705 "B.c"
    }
    XSRETURN(1);
}

#define LOOP_redoop(o)	o->op_redoop
#define LOOP_nextop(o)	o->op_nextop
#define LOOP_lastop(o)	o->op_lastop

XS(XS_B__LOOP_redoop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_redoop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_redoop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_nextop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_nextop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_nextop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_lastop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_lastop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_lastop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define COP_label(o)	CopLABEL(o)
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
#define COP_filegv(o)	CopFILEGV(o)
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	CopARYBASE_get(o)
#define COP_line(o)	CopLINE(o)
#define COP_hints(o)	CopHINTS_get(o)
#if PERL_VERSION < 9
#  define COP_warnings(o)  o->cop_warnings
#  define COP_io(o)	o->cop_io
#endif
#if PERL_VERSION >= 11
#define XSubPPtmpAAAM 1


XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAN 1


XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#endif

XS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_file(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_filegv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_filegv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_filegv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_cop_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_cop_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_cop_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_arybase)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_arybase(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_line); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_line)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_line(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAO 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1263 "B.xs"
	ST(0) = make_warnings_object(aTHX_ sv_newmortal(), o->cop_warnings);
	XSRETURN(1);
#line 3116 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1270 "B.xs"
	ST(0) = make_cop_io_object(aTHX_ sv_newmortal(), o);
	XSRETURN(1);
#line 3147 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_hints_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__RHE	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1277 "B.xs"
	RETVAL = o->cop_hints_hash;
#line 3176 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::RHE"), PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAP 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_warnings(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_io(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__COP_hints); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_hints(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_SvTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_SvTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvTYPE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define object_2svref(sv)	sv
#define SVREF SV *

XS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_object_2svref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	SVREF	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = object_2svref(sv);
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_REFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvREFCNT(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvFLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_POK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_POK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPOK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_ROK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_ROK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvROK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_MAGICAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_MAGICAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvMAGICAL(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIVX(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_UVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_UVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvUVX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define needs64bits(sv) ((I32)SvIVX(sv) != SvIVX(sv))

XS(XS_B__IV_needs64bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_needs64bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = needs64bits(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_packiv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1359 "B.xs"
	if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
	}
#line 3642 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAQ 1


XS(XS_B__IV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1388 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3678 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_NVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNVX(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_LOW); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_LOW)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_LOW(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_HIGH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_HIGH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_HIGH(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_PAD_INDEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_PAD_INDEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_PAD_INDEX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_FAKELEX_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_FAKELEX_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_FAKELEX_FLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAR 1


XS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__RV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvRV(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PV_PVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPVX(sv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1445 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3954 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1458 "B.xs"
        ST(0) = sv_newmortal();
        if( SvPOK(sv) ) {
	    /* FIXME - we need a better way for B to identify PVs that are
	       in the pads as variable names.  */
	    if((SvLEN(sv) && SvCUR(sv) >= SvLEN(sv))) {
		/* It claims to be longer than the space allocated for it -
		   presuambly it's a variable name in the pad  */
		sv_setpv(ST(0), SvPV_nolen_const(sv));
	    } else {
		sv_setpvn(ST(0), SvPVX_const(sv), SvCUR(sv));
	    }
            SvFLAGS(ST(0)) |= SvUTF8(sv);
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
            sv_setpvn(ST(0), NULL, 0);
        }
#line 4002 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_PVBM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVBM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1484 "B.xs"
        ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX_const(sv),
	    SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0));
#line 4031 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PV_CUR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_CUR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvCUR(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_MAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1504 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ sv_newmortal(), mg));
#line 4120 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__PVMG_SvSTASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_SvSTASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVMG	sv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvSTASH(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAS 1


XS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__REGEXP	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1521 "B.xs"
	/* FIXME - can we code this method more efficiently?  */
	RETVAL = PTR2IV(sv);
#line 4185 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__REGEXP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__REGEXP	sv;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1530 "B.xs"
	RETVAL = newSVpvn( RX_PRECOMP(sv), RX_PRELEN(sv) );
#line 4214 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#define MgMOREMAGIC(mg) mg->mg_moremagic
#define MgPRIVATE(mg) mg->mg_private
#define MgTYPE(mg) mg->mg_type
#define MgFLAGS(mg) mg->mg_flags
#define MgOBJ(mg) mg->mg_obj
#define MgLENGTH(mg) mg->mg_len
#define MgREGEX(mg) PTR2IV(mg->mg_obj)

XS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_MOREMAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	B__MAGIC	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1550 "B.xs"
	if( MgMOREMAGIC(mg) ) {
	    RETVAL = MgMOREMAGIC(mg);
	}
	else {
	    XSRETURN_UNDEF;
	}
#line 4257 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::MAGIC"), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PRIVATE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PRIVATE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgPRIVATE(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgTYPE(mg);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgFLAGS(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_OBJ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgOBJ(mg);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1579 "B.xs"
        if(mg->mg_type == PERL_MAGIC_qr) {
            RETVAL = MgREGEX(mg);
        }
        else {
            croak( "REGEX is only meaningful on r-magic" );
        }
#line 4412 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1592 "B.xs"
        if (mg->mg_type == PERL_MAGIC_qr) {
            REGEXP* rx = (REGEXP*)mg->mg_obj;
            RETVAL = Nullsv;
            if( rx )
                RETVAL = newSVpvn( RX_PRECOMP(rx), RX_PRELEN(rx) );
        }
        else {
            croak( "precomp is only meaningful on r-magic" );
        }
#line 4449 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_LENGTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_LENGTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgLENGTH(mg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PTR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1612 "B.xs"
	ST(0) = sv_newmortal();
 	if (mg->mg_ptr){
		if (mg->mg_len >= 0){
	    		sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
		} else if (mg->mg_len == HEf_SVKEY) {
			ST(0) = make_sv_object(aTHX_
				    sv_newmortal(), (SV*)mg->mg_ptr);
		}
	}
#line 4515 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGOFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGOFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGOFF(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGLEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGLEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTYPE(sv);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARG); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARG)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARG(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__BM_USEFUL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_USEFUL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmUSEFUL(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_PREVIOUS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmPREVIOUS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_RARE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmRARE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_TABLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_TABLE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	STRLEN	len;
	char *	str;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1660 "B.xs"
	str = SvPV(sv, len);
	/* Boyer-Moore table is just after string and its safety-margin \0 */
	ST(0) = newSVpvn_flags(str + len + PERL_FBM_TABLE_OFFSET, 256, SVs_TEMP);
#line 4751 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1670 "B.xs"
#if PERL_VERSION >= 10
	ST(0) = sv_2mortal(newSVhek(GvNAME_HEK(gv)));
#else
	ST(0) = newSVpvn_flags(GvNAME(gv), GvNAMELEN(gv), SVs_TEMP);
#endif
#line 4782 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_is_empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1680 "B.xs"
        RETVAL = GvGP(gv) == Null(GP*);
#line 4810 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_isGV_with_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_isGV_with_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1688 "B.xs"
#if PERL_VERSION >= 9
	RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
#else
	RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
#endif
#line 4844 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_B__GV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSTASH(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_SV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_IO); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_IO)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__IO	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvIO(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_FORM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FORM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__FM	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1716 "B.xs"
	RETVAL = (SV*)GvFORM(gv);
#line 4996 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_AV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_AV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvAV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_HV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_HV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvHV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_EGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_EGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CVGEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CVGEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCVGEN(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_LINE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_LINE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvLINE(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILE(gv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILEGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_GvREFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvREFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvREFCNT(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_GvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFLAGS(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE_LEN(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES_LEFT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES_LEFT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES_LEFT(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION <= 8
#define XSubPPtmpAAAT 1


XS(XS_B__IO_SUBPROCESS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_SUBPROCESS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	short	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoSUBPROCESS(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IsSTD)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "io, name");
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1));
#line 1817 "B.xs"
	PerlIO* handle = 0;
#line 5650 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");
#line 1819 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 5673 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTYPE(io);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFLAGS(io);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvMAX(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off
#define XSubPPtmpAAAU 1


XS(XS_B__AV_OFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_OFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvOFF(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1870 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ sv_newmortal(), svp[i]));
	}
#line 5859 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAYelt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "av, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1));

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1882 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), NULL));
#line 5893 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAV 1


XS(XS_B__AV_AvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_AvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFLAGS(av);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__FM_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "form");
    {
	B__FM	form;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    form = INT2PTR(B__FM,tmp);
	}
	else
	    croak("form is not a reference");

	RETVAL = FmLINES(form);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CONST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvSTASH(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_START)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1917 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvSTART(cv);
#line 6044 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_ROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_ROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1925 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvROOT(cv);
#line 6075 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvGV(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFILE(cv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_DEPTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_PADLIST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvPADLIST(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE_SEQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE_SEQ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE_SEQ(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUB)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1957 "B.xs"
	ST(0) = sv_2mortal(newSViv(CvISXSUB(cv) ? PTR2IV(CvXSUB(cv)) : 0));
#line 6285 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUBANY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUBANY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1964 "B.xs"
	ST(0) = CvCONST(cv) ?
	    make_sv_object(aTHX_ sv_newmortal(),(SV *)CvXSUBANY(cv).any_ptr) :
	    sv_2mortal(newSViv(CvISXSUB(cv) ? CvXSUBANY(cv).any_iv : 0));
#line 6314 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_CvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFLAGS(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_const_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = cv_const_sv(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvMAX(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_KEYS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_KEYS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvKEYS(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_RITER)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvNAME(hv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAW 1


XS(XS_B__HV_PMROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_PMROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvPMROOT(hv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif

XS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");
#line 2015 "B.xs"
	if (HvKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvKEYS(hv) * 2);
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
		mPUSHp(key, len);
		PUSHs(make_sv_object(aTHX_ sv_newmortal(), sv));
	    }
	}
#line 6592 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_VAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeVAL(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HE_SVKEY_force); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_SVKEY_force)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeSVKEY_force(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAX 1


XS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RHE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference");
#line 2049 "B.xs"
	RETVAL = newRV( (SV*)Perl_refcounted_he_chain_2hv(aTHX_ h) );
#line 6715 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS(boot_B); /* prototype to pass -Wmissing-prototypes */
XS(boot_B)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXS("B::init_av", XS_B_init_av, file);
        (void)newXS("B::check_av", XS_B_check_av, file);
#if XSubPPtmpAAAA
        (void)newXS("B::unitcheck_av", XS_B_unitcheck_av, file);
#endif
        (void)newXS("B::begin_av", XS_B_begin_av, file);
        (void)newXS("B::end_av", XS_B_end_av, file);
        (void)newXS("B::inc_gv", XS_B_inc_gv, file);
#if XSubPPtmpAAAB
        (void)newXS("B::regex_padav", XS_B_regex_padav, file);
#endif
        (void)newXS("B::main_cv", XS_B_main_cv, file);
        (void)newXS("B::main_root", XS_B_main_root, file);
        (void)newXS("B::main_start", XS_B_main_start, file);
        (void)newXS("B::amagic_generation", XS_B_amagic_generation, file);
        (void)newXS("B::sub_generation", XS_B_sub_generation, file);
        (void)newXS("B::comppadlist", XS_B_comppadlist, file);
        (void)newXS("B::sv_undef", XS_B_sv_undef, file);
        (void)newXS("B::sv_yes", XS_B_sv_yes, file);
        (void)newXS("B::sv_no", XS_B_sv_no, file);
        (void)newXS("B::curstash", XS_B_curstash, file);
        (void)newXS("B::defstash", XS_B_defstash, file);
        (void)newXS("B::dowarn", XS_B_dowarn, file);
        (void)newXS("B::formfeed", XS_B_formfeed, file);
        (void)newXS("B::warnhook", XS_B_warnhook, file);
        (void)newXS("B::diehook", XS_B_diehook, file);
        (void)newXS("B::walkoptree", XS_B_walkoptree, file);
        (void)newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        (void)newXS("B::address", XS_B_address, file);
        (void)newXS("B::svref_2object", XS_B_svref_2object, file);
        (void)newXS("B::opnumber", XS_B_opnumber, file);
        (void)newXS("B::ppname", XS_B_ppname, file);
        (void)newXS("B::hash", XS_B_hash, file);
        (void)newXS("B::cast_I32", XS_B_cast_I32, file);
        (void)newXS("B::minus_c", XS_B_minus_c, file);
        (void)newXS("B::save_BEGINs", XS_B_save_BEGINs, file);
        (void)newXS("B::cstring", XS_B_cstring, file);
        (void)newXS("B::perlstring", XS_B_perlstring, file);
        (void)newXS("B::cchar", XS_B_cchar, file);
        (void)newXS("B::threadsv_names", XS_B_threadsv_names, file);
        (void)newXS("B::OP::size", XS_B__OP_size, file);
        (void)newXS("B::OP::next", XS_B__OP_next, file);
        (void)newXS("B::OP::sibling", XS_B__OP_sibling, file);
        (void)newXS("B::OP::name", XS_B__OP_name, file);
        (void)newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
        (void)newXS("B::OP::desc", XS_B__OP_desc, file);
        (void)newXS("B::OP::targ", XS_B__OP_targ, file);
        (void)newXS("B::OP::type", XS_B__OP_type, file);
#if XSubPPtmpAAAC
        (void)newXS("B::OP::opt", XS_B__OP_opt, file);
#endif
#if XSubPPtmpAAAD
        (void)newXS("B::OP::seq", XS_B__OP_seq, file);
#endif
        (void)newXS("B::OP::flags", XS_B__OP_flags, file);
        (void)newXS("B::OP::private", XS_B__OP_private, file);
#if XSubPPtmpAAAE
        (void)newXS("B::OP::spare", XS_B__OP_spare, file);
#endif
        (void)newXS("B::OP::oplist", XS_B__OP_oplist, file);
        (void)newXS("B::UNOP::first", XS_B__UNOP_first, file);
        (void)newXS("B::BINOP::last", XS_B__BINOP_last, file);
        (void)newXS("B::LOGOP::other", XS_B__LOGOP_other, file);
        (void)newXS("B::LISTOP::children", XS_B__LISTOP_children, file);
#if XSubPPtmpAAAF
        (void)newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
#if XSubPPtmpAAAG
        (void)newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
        (void)newXS("B::PMOP::pmreplstart", XS_B__PMOP_pmreplstart, file);
#if XSubPPtmpAAAH
        (void)newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
#endif
#if XSubPPtmpAAAI
        (void)newXS("B::PMOP::pmoffset", XS_B__PMOP_pmoffset, file);
        (void)newXS("B::PMOP::pmstashpv", XS_B__PMOP_pmstashpv, file);
#endif
#if XSubPPtmpAAAJ
        (void)newXS("B::PMOP::pmstash", XS_B__PMOP_pmstash, file);
#endif
        (void)newXS("B::PMOP::pmflags", XS_B__PMOP_pmflags, file);
#if XSubPPtmpAAAK
        (void)newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        (void)newXS("B::PMOP::pmdynflags", XS_B__PMOP_pmdynflags, file);
#endif
        (void)newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
#if XSubPPtmpAAAL
        (void)newXS("B::PMOP::reflags", XS_B__PMOP_reflags, file);
#endif
        (void)newXS("B::SVOP::sv", XS_B__SVOP_sv, file);
        (void)newXS("B::SVOP::gv", XS_B__SVOP_gv, file);
        (void)newXS("B::PADOP::padix", XS_B__PADOP_padix, file);
        (void)newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        (void)newXS("B::PADOP::gv", XS_B__PADOP_gv, file);
        (void)newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        (void)newXS("B::LOOP::redoop", XS_B__LOOP_redoop, file);
        (void)newXS("B::LOOP::nextop", XS_B__LOOP_nextop, file);
        (void)newXS("B::LOOP::lastop", XS_B__LOOP_lastop, file);
#if XSubPPtmpAAAM
        (void)newXS("B::COP::label", XS_B__COP_label, file);
#endif
#if XSubPPtmpAAAN
        (void)newXS("B::COP::label", XS_B__COP_label, file);
#endif
        (void)newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        (void)newXS("B::COP::stash", XS_B__COP_stash, file);
        (void)newXS("B::COP::file", XS_B__COP_file, file);
        (void)newXS("B::COP::filegv", XS_B__COP_filegv, file);
        (void)newXS("B::COP::cop_seq", XS_B__COP_cop_seq, file);
        (void)newXS("B::COP::arybase", XS_B__COP_arybase, file);
        (void)newXS("B::COP::line", XS_B__COP_line, file);
#if XSubPPtmpAAAO
        (void)newXS("B::COP::warnings", XS_B__COP_warnings, file);
        (void)newXS("B::COP::io", XS_B__COP_io, file);
        (void)newXS("B::COP::hints_hash", XS_B__COP_hints_hash, file);
#endif
#if XSubPPtmpAAAP
        (void)newXS("B::COP::warnings", XS_B__COP_warnings, file);
        (void)newXS("B::COP::io", XS_B__COP_io, file);
#endif
        (void)newXS("B::COP::hints", XS_B__COP_hints, file);
        (void)newXS("B::SV::SvTYPE", XS_B__SV_SvTYPE, file);
        (void)newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        (void)newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        (void)newXS("B::SV::FLAGS", XS_B__SV_FLAGS, file);
        (void)newXS("B::SV::POK", XS_B__SV_POK, file);
        (void)newXS("B::SV::ROK", XS_B__SV_ROK, file);
        (void)newXS("B::SV::MAGICAL", XS_B__SV_MAGICAL, file);
        (void)newXS("B::IV::IV", XS_B__IV_IV, file);
        (void)newXS("B::IV::IVX", XS_B__IV_IVX, file);
        (void)newXS("B::IV::UVX", XS_B__IV_UVX, file);
        (void)newXS("B::IV::needs64bits", XS_B__IV_needs64bits, file);
        (void)newXS("B::IV::packiv", XS_B__IV_packiv, file);
#if XSubPPtmpAAAQ
        (void)newXS("B::IV::RV", XS_B__IV_RV, file);
#endif
        (void)newXS("B::NV::NV", XS_B__NV_NV, file);
        (void)newXS("B::NV::NVX", XS_B__NV_NVX, file);
        (void)newXS("B::NV::COP_SEQ_RANGE_LOW", XS_B__NV_COP_SEQ_RANGE_LOW, file);
        (void)newXS("B::NV::COP_SEQ_RANGE_HIGH", XS_B__NV_COP_SEQ_RANGE_HIGH, file);
        (void)newXS("B::NV::PARENT_PAD_INDEX", XS_B__NV_PARENT_PAD_INDEX, file);
        (void)newXS("B::NV::PARENT_FAKELEX_FLAGS", XS_B__NV_PARENT_FAKELEX_FLAGS, file);
#if XSubPPtmpAAAR
        (void)newXS("B::RV::RV", XS_B__RV_RV, file);
#endif
        (void)newXS("B::PV::PVX", XS_B__PV_PVX, file);
        (void)newXS("B::PV::RV", XS_B__PV_RV, file);
        (void)newXS("B::PV::PV", XS_B__PV_PV, file);
        (void)newXS("B::PV::PVBM", XS_B__PV_PVBM, file);
        (void)newXS("B::PV::LEN", XS_B__PV_LEN, file);
        (void)newXS("B::PV::CUR", XS_B__PV_CUR, file);
        (void)newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        (void)newXS("B::PVMG::SvSTASH", XS_B__PVMG_SvSTASH, file);
#if XSubPPtmpAAAS
        (void)newXS("B::REGEXP::REGEX", XS_B__REGEXP_REGEX, file);
        (void)newXS("B::REGEXP::precomp", XS_B__REGEXP_precomp, file);
#endif
        (void)newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        (void)newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_PRIVATE, file);
        (void)newXS("B::MAGIC::TYPE", XS_B__MAGIC_TYPE, file);
        (void)newXS("B::MAGIC::FLAGS", XS_B__MAGIC_FLAGS, file);
        (void)newXS("B::MAGIC::OBJ", XS_B__MAGIC_OBJ, file);
        (void)newXS("B::MAGIC::REGEX", XS_B__MAGIC_REGEX, file);
        (void)newXS("B::MAGIC::precomp", XS_B__MAGIC_precomp, file);
        (void)newXS("B::MAGIC::LENGTH", XS_B__MAGIC_LENGTH, file);
        (void)newXS("B::MAGIC::PTR", XS_B__MAGIC_PTR, file);
        (void)newXS("B::PVLV::TARGOFF", XS_B__PVLV_TARGOFF, file);
        (void)newXS("B::PVLV::TARGLEN", XS_B__PVLV_TARGLEN, file);
        (void)newXS("B::PVLV::TYPE", XS_B__PVLV_TYPE, file);
        (void)newXS("B::PVLV::TARG", XS_B__PVLV_TARG, file);
        (void)newXS("B::BM::USEFUL", XS_B__BM_USEFUL, file);
        (void)newXS("B::BM::PREVIOUS", XS_B__BM_PREVIOUS, file);
        (void)newXS("B::BM::RARE", XS_B__BM_RARE, file);
        (void)newXS("B::BM::TABLE", XS_B__BM_TABLE, file);
        (void)newXS("B::GV::NAME", XS_B__GV_NAME, file);
        (void)newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        (void)newXS("B::GV::isGV_with_GP", XS_B__GV_isGV_with_GP, file);
        (void)newXS("B::GV::GP", XS_B__GV_GP, file);
        (void)newXS("B::GV::STASH", XS_B__GV_STASH, file);
        (void)newXS("B::GV::SV", XS_B__GV_SV, file);
        (void)newXS("B::GV::IO", XS_B__GV_IO, file);
        (void)newXS("B::GV::FORM", XS_B__GV_FORM, file);
        (void)newXS("B::GV::AV", XS_B__GV_AV, file);
        (void)newXS("B::GV::HV", XS_B__GV_HV, file);
        (void)newXS("B::GV::EGV", XS_B__GV_EGV, file);
        (void)newXS("B::GV::CV", XS_B__GV_CV, file);
        (void)newXS("B::GV::CVGEN", XS_B__GV_CVGEN, file);
        (void)newXS("B::GV::LINE", XS_B__GV_LINE, file);
        (void)newXS("B::GV::FILE", XS_B__GV_FILE, file);
        (void)newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
        (void)newXS("B::GV::GvREFCNT", XS_B__GV_GvREFCNT, file);
        (void)newXS("B::GV::GvFLAGS", XS_B__GV_GvFLAGS, file);
        (void)newXS("B::IO::LINES", XS_B__IO_LINES, file);
        (void)newXS("B::IO::PAGE", XS_B__IO_PAGE, file);
        (void)newXS("B::IO::PAGE_LEN", XS_B__IO_PAGE_LEN, file);
        (void)newXS("B::IO::LINES_LEFT", XS_B__IO_LINES_LEFT, file);
        (void)newXS("B::IO::TOP_NAME", XS_B__IO_TOP_NAME, file);
        (void)newXS("B::IO::TOP_GV", XS_B__IO_TOP_GV, file);
        (void)newXS("B::IO::FMT_NAME", XS_B__IO_FMT_NAME, file);
        (void)newXS("B::IO::FMT_GV", XS_B__IO_FMT_GV, file);
        (void)newXS("B::IO::BOTTOM_NAME", XS_B__IO_BOTTOM_NAME, file);
        (void)newXS("B::IO::BOTTOM_GV", XS_B__IO_BOTTOM_GV, file);
#if XSubPPtmpAAAT
        (void)newXS("B::IO::SUBPROCESS", XS_B__IO_SUBPROCESS, file);
#endif
        (void)newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        (void)newXS("B::IO::IoTYPE", XS_B__IO_IoTYPE, file);
        (void)newXS("B::IO::IoFLAGS", XS_B__IO_IoFLAGS, file);
        (void)newXS("B::AV::FILL", XS_B__AV_FILL, file);
        (void)newXS("B::AV::MAX", XS_B__AV_MAX, file);
#if XSubPPtmpAAAU
        (void)newXS("B::AV::OFF", XS_B__AV_OFF, file);
#endif
        (void)newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        (void)newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
#if XSubPPtmpAAAV
        (void)newXS("B::AV::AvFLAGS", XS_B__AV_AvFLAGS, file);
#endif
        (void)newXS("B::FM::LINES", XS_B__FM_LINES, file);
        (void)newXS("B::CV::CONST", XS_B__CV_CONST, file);
        (void)newXS("B::CV::STASH", XS_B__CV_STASH, file);
        (void)newXS("B::CV::START", XS_B__CV_START, file);
        (void)newXS("B::CV::ROOT", XS_B__CV_ROOT, file);
        (void)newXS("B::CV::GV", XS_B__CV_GV, file);
        (void)newXS("B::CV::FILE", XS_B__CV_FILE, file);
        (void)newXS("B::CV::DEPTH", XS_B__CV_DEPTH, file);
        (void)newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
        (void)newXS("B::CV::OUTSIDE", XS_B__CV_OUTSIDE, file);
        (void)newXS("B::CV::OUTSIDE_SEQ", XS_B__CV_OUTSIDE_SEQ, file);
        (void)newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        (void)newXS("B::CV::XSUBANY", XS_B__CV_XSUBANY, file);
        (void)newXS("B::CV::CvFLAGS", XS_B__CV_CvFLAGS, file);
        (void)newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        (void)newXS("B::HV::FILL", XS_B__HV_FILL, file);
        (void)newXS("B::HV::MAX", XS_B__HV_MAX, file);
        (void)newXS("B::HV::KEYS", XS_B__HV_KEYS, file);
        (void)newXS("B::HV::RITER", XS_B__HV_RITER, file);
        (void)newXS("B::HV::NAME", XS_B__HV_NAME, file);
#if XSubPPtmpAAAW
        (void)newXS("B::HV::PMROOT", XS_B__HV_PMROOT, file);
#endif
        (void)newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);
        (void)newXS("B::HE::VAL", XS_B__HE_VAL, file);
        (void)newXS("B::HE::HASH", XS_B__HE_HASH, file);
        (void)newXS("B::HE::SVKEY_force", XS_B__HE_SVKEY_force, file);
#if XSubPPtmpAAAX
        (void)newXS("B::RHE::HASH", XS_B__RHE_HASH, file);
#endif

    /* Initialisation Section */

#line 597 "B.xs"
{
    HV *stash = gv_stashpvs("B", GV_ADD);
    AV *export_ok = perl_get_av("B::EXPORT_OK", GV_ADD);
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;
#if PERL_VERSION <= 8
#  define OPpPAD_STATE 0
#endif
#include "defsubs.h"
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#if XSubPPtmpAAAR
#endif
#if XSubPPtmpAAAS
#endif
#if XSubPPtmpAAAT
#endif
#if XSubPPtmpAAAU
#endif
#if XSubPPtmpAAAV
#endif
#if XSubPPtmpAAAW
#endif
#if XSubPPtmpAAAX
#endif
#line 7062 "B.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

