/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.21 from the
 * contents of APItest.xs. Do not edit this file, edit APItest.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "APItest.xs"
#define PERL_IN_XS_APITEST
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"


/* for my_cxt tests */

#define MY_CXT_KEY "XS::APItest::_guts" XS_VERSION

typedef struct {
    int i;
    SV *sv;
} my_cxt_t;

START_MY_CXT

/* indirect functions to test the [pa]MY_CXT macros */

int
my_cxt_getint_p(pMY_CXT)
{
    return MY_CXT.i;
}

void
my_cxt_setint_p(pMY_CXT_ int i)
{
    MY_CXT.i = i;
}

SV*
my_cxt_getsv_interp_context(void)
{
    dTHX;
    dMY_CXT_INTERP(my_perl);
    return MY_CXT.sv;
}

SV*
my_cxt_getsv_interp(void)
{
    dMY_CXT;
    return MY_CXT.sv;
}

void
my_cxt_setsv_p(SV* sv _pMY_CXT)
{
    MY_CXT.sv = sv;
}


/* from exception.c */
int apitest_exception(int);

/* from core_or_not.inc */
bool sv_setsv_cow_hashkey_core(void);
bool sv_setsv_cow_hashkey_notcore(void);

/* A routine to test hv_delayfree_ent
   (which itself is tested by testing on hv_free_ent  */

typedef void (freeent_function)(pTHX_ HV *, register HE *);

void
test_freeent(freeent_function *f) {
    dTHX;
    dSP;
    HV *test_hash = newHV();
    HE *victim;
    SV *test_scalar;
    U32 results[4];
    int i;

#ifdef PURIFY
    victim = (HE*)safemalloc(sizeof(HE));
#else
    /* Storing then deleting something should ensure that a hash entry is
       available.  */
    hv_store(test_hash, "", 0, &PL_sv_yes, 0);
    hv_delete(test_hash, "", 0, 0);

    /* We need to "inline" new_he here as it's static, and the functions we
       test expect to be able to call del_HE on the HE  */
    if (!PL_body_roots[HE_SVSLOT])
	croak("PL_he_root is 0");
    victim = (HE*) PL_body_roots[HE_SVSLOT];
    PL_body_roots[HE_SVSLOT] = HeNEXT(victim);
#endif

    victim->hent_hek = Perl_share_hek(aTHX_ "", 0, 0);

    test_scalar = newSV(0);
    SvREFCNT_inc(test_scalar);
    HeVAL(victim) = test_scalar;

    /* Need this little game else we free the temps on the return stack.  */
    results[0] = SvREFCNT(test_scalar);
    SAVETMPS;
    results[1] = SvREFCNT(test_scalar);
    f(aTHX_ test_hash, victim);
    results[2] = SvREFCNT(test_scalar);
    FREETMPS;
    results[3] = SvREFCNT(test_scalar);

    i = 0;
    do {
	mPUSHu(results[i]);
    } while (++i < sizeof(results)/sizeof(results[0]));

    /* Goodbye to our extra reference.  */
    SvREFCNT_dec(test_scalar);
}


static I32
bitflip_key(pTHX_ IV action, SV *field) {
    MAGIC *mg = mg_find(field, PERL_MAGIC_uvar);
    SV *keysv;
    if (mg && (keysv = mg->mg_obj)) {
	STRLEN len;
	const char *p = SvPV(keysv, len);

	if (len) {
	    SV *newkey = newSV(len);
	    char *new_p = SvPVX(newkey);

	    if (SvUTF8(keysv)) {
		const char *const end = p + len;
		while (p < end) {
		    STRLEN len;
		    UV chr = utf8_to_uvuni((U8 *)p, &len);
		    new_p = (char *)uvuni_to_utf8((U8 *)new_p, chr ^ 32);
		    p += len;
		}
		SvUTF8_on(newkey);
	    } else {
		while (len--)
		    *new_p++ = *p++ ^ 32;
	    }
	    *new_p = '\0';
	    SvCUR_set(newkey, SvCUR(keysv));
	    SvPOK_on(newkey);

	    mg->mg_obj = newkey;
	}
    }
    return 0;
}

static I32
rot13_key(pTHX_ IV action, SV *field) {
    MAGIC *mg = mg_find(field, PERL_MAGIC_uvar);
    SV *keysv;
    if (mg && (keysv = mg->mg_obj)) {
	STRLEN len;
	const char *p = SvPV(keysv, len);

	if (len) {
	    SV *newkey = newSV(len);
	    char *new_p = SvPVX(newkey);

	    /* There's a deliberate fencepost error here to loop len + 1 times
	       to copy the trailing \0  */
	    do {
		char new_c = *p++;
		/* Try doing this cleanly and clearly in EBCDIC another way: */
		switch (new_c) {
		case 'A': new_c = 'N'; break;
		case 'B': new_c = 'O'; break;
		case 'C': new_c = 'P'; break;
		case 'D': new_c = 'Q'; break;
		case 'E': new_c = 'R'; break;
		case 'F': new_c = 'S'; break;
		case 'G': new_c = 'T'; break;
		case 'H': new_c = 'U'; break;
		case 'I': new_c = 'V'; break;
		case 'J': new_c = 'W'; break;
		case 'K': new_c = 'X'; break;
		case 'L': new_c = 'Y'; break;
		case 'M': new_c = 'Z'; break;
		case 'N': new_c = 'A'; break;
		case 'O': new_c = 'B'; break;
		case 'P': new_c = 'C'; break;
		case 'Q': new_c = 'D'; break;
		case 'R': new_c = 'E'; break;
		case 'S': new_c = 'F'; break;
		case 'T': new_c = 'G'; break;
		case 'U': new_c = 'H'; break;
		case 'V': new_c = 'I'; break;
		case 'W': new_c = 'J'; break;
		case 'X': new_c = 'K'; break;
		case 'Y': new_c = 'L'; break;
		case 'Z': new_c = 'M'; break;
		case 'a': new_c = 'n'; break;
		case 'b': new_c = 'o'; break;
		case 'c': new_c = 'p'; break;
		case 'd': new_c = 'q'; break;
		case 'e': new_c = 'r'; break;
		case 'f': new_c = 's'; break;
		case 'g': new_c = 't'; break;
		case 'h': new_c = 'u'; break;
		case 'i': new_c = 'v'; break;
		case 'j': new_c = 'w'; break;
		case 'k': new_c = 'x'; break;
		case 'l': new_c = 'y'; break;
		case 'm': new_c = 'z'; break;
		case 'n': new_c = 'a'; break;
		case 'o': new_c = 'b'; break;
		case 'p': new_c = 'c'; break;
		case 'q': new_c = 'd'; break;
		case 'r': new_c = 'e'; break;
		case 's': new_c = 'f'; break;
		case 't': new_c = 'g'; break;
		case 'u': new_c = 'h'; break;
		case 'v': new_c = 'i'; break;
		case 'w': new_c = 'j'; break;
		case 'x': new_c = 'k'; break;
		case 'y': new_c = 'l'; break;
		case 'z': new_c = 'm'; break;
		}
		*new_p++ = new_c;
	    } while (len--);
	    SvCUR_set(newkey, SvCUR(keysv));
	    SvPOK_on(newkey);
	    if (SvUTF8(keysv))
		SvUTF8_on(newkey);

	    mg->mg_obj = newkey;
	}
    }
    return 0;
}

STATIC I32
rmagical_a_dummy(pTHX_ IV idx, SV *sv) {
    return 0;
}

STATIC MGVTBL rmagical_b = { 0 };

#include "const-c.inc"

#line 255 "APItest.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 307 "APItest.c"

/* INCLUDE:  Including 'const-xs.inc' from 'APItest.xs' */


XS(XS_XS__APItest__Hash_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 195 "./const-xs.inc"
	STRLEN		len;
#line 327 "APItest.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 200 "./const-xs.inc"
#ifdef SYMBIAN
	sv = newSVpvf("%"SVf" is not a valid XS::APItest macro", sv);
#else
	HV *constant_missing = get_missing_hash(aTHX);
	if (hv_exists(constant_missing, s, SvUTF8(sv) ? -(I32)len : (I32)len)) {
	    sv = newSVpvf("Your vendor has not defined XS::APItest macro %" SVf
			  ", used", sv);
	} else {
	    sv = newSVpvf("%"SVf" is not a valid XS::APItest macro",
			  sv);
	}
#endif
	PUSHs(sv_2mortal(sv));
#line 344 "APItest.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'APItest.xs' from 'const-xs.inc' */


XS(XS_XS__APItest__Hash_rot13_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_rot13_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hash");
    {
	HV *	hash;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::rot13_hash",
			"hash");
#line 253 "APItest.xs"
	{
	    struct ufuncs uf;
	    uf.uf_val = rot13_key;
	    uf.uf_set = 0;
	    uf.uf_index = 0;

	    sv_magic((SV*)hash, NULL, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));
	}
#line 382 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest__Hash_bitflip_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_bitflip_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hash");
    {
	HV *	hash;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::bitflip_hash",
			"hash");
#line 266 "APItest.xs"
	{
	    struct ufuncs uf;
	    uf.uf_val = bitflip_key;
	    uf.uf_set = 0;
	    uf.uf_index = 0;

	    sv_magic((SV*)hash, NULL, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));
	}
#line 416 "APItest.c"
    }
    XSRETURN_EMPTY;
}

#define UTF8KLEN(sv, len)   (SvUTF8(sv) ? -(I32)len : (I32)len)

XS(XS_XS__APItest__Hash_exists); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_exists)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hash, key_sv");
    {
#line 280 "APItest.xs"
	STRLEN len;
	const char *key;
#line 437 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	bool	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::exists",
			"hash");
#line 286 "APItest.xs"
	key = SvPV(key_sv, len);
	RETVAL = hv_exists(hash, key, UTF8KLEN(key_sv, len));
#line 451 "APItest.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_exists_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_exists_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hash, key_sv");
    {
#line 294 "APItest.xs"
#line 471 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	bool	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::exists_ent",
			"hash");
#line 298 "APItest.xs"
	RETVAL = hv_exists_ent(hash, key_sv, 0);
#line 484 "APItest.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "hash, key_sv, flags = 0");
    {
#line 305 "APItest.xs"
	STRLEN len;
	const char *key;
#line 506 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	I32	flags;
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::delete",
			"hash");

	if (items < 3)
	    flags = 0;
	else {
	    flags = (I32)SvIV(ST(2));
	}
#line 312 "APItest.xs"
	key = SvPV(key_sv, len);
	/* It's already mortal, so need to increase reference count.  */
	RETVAL
	    = SvREFCNT_inc(hv_delete(hash, key, UTF8KLEN(key_sv, len), flags));
#line 529 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_delete_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_delete_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "hash, key_sv, flags = 0");
    {
	HV *	hash;
	SV *	key_sv = ST(1);
	I32	flags;
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::delete_ent",
			"hash");

	if (items < 3)
	    flags = 0;
	else {
	    flags = (I32)SvIV(ST(2));
	}
#line 326 "APItest.xs"
	/* It's already mortal, so need to increase reference count.  */
	RETVAL = SvREFCNT_inc(hv_delete_ent(hash, key_sv, flags, 0));
#line 568 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_store_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_store_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hash, key, value");
    {
#line 334 "APItest.xs"
	SV *copy;
	HE *result;
#line 590 "APItest.c"
	HV *	hash;
	SV *	key = ST(1);
	SV *	value = ST(2);
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::store_ent",
			"hash");
#line 341 "APItest.xs"
	copy = newSV(0);
	result = hv_store_ent(hash, key, copy, 0);
	SvSetMagicSV(copy, value);
	if (!result) {
	    SvREFCNT_dec(copy);
	    XSRETURN_EMPTY;
	}
	/* It's about to become mortal, so need to increase reference count.
	 */
	RETVAL = SvREFCNT_inc(HeVAL(result));
#line 613 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_store); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hash, key_sv, value");
    {
#line 357 "APItest.xs"
	STRLEN len;
	const char *key;
	SV *copy;
	SV **result;
#line 637 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	SV *	value = ST(2);
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::store",
			"hash");
#line 366 "APItest.xs"
	key = SvPV(key_sv, len);
	copy = newSV(0);
	result = hv_store(hash, key, UTF8KLEN(key_sv, len), copy, 0);
	SvSetMagicSV(copy, value);
	if (!result) {
	    SvREFCNT_dec(copy);
	    XSRETURN_EMPTY;
	}
	/* It's about to become mortal, so need to increase reference count.
	 */
	RETVAL = SvREFCNT_inc(*result);
#line 661 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_fetch_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_fetch_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hash, key_sv");
    {
#line 383 "APItest.xs"
	HE *result;
#line 682 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::fetch_ent",
			"hash");
#line 388 "APItest.xs"
	result = hv_fetch_ent(hash, key_sv, 0, 0);
	if (!result) {
	    XSRETURN_EMPTY;
	}
	/* Force mg_get  */
	RETVAL = newSVsv(HeVAL(result));
#line 700 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hash, key_sv");
    {
#line 400 "APItest.xs"
	STRLEN len;
	const char *key;
	SV **result;
#line 723 "APItest.c"
	HV *	hash;
	SV *	key_sv = ST(1);
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hash = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::fetch",
			"hash");
#line 407 "APItest.xs"
	key = SvPV(key_sv, len);
	result = hv_fetch(hash, key, UTF8KLEN(key_sv, len), 0);
	if (!result) {
	    XSRETURN_EMPTY;
	}
	/* Force mg_get  */
	RETVAL = newSVsv(*result);
#line 742 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#if defined (hv_common)
#define XSubPPtmpAAAA 1


XS(XS_XS__APItest__Hash_common); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_common)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "params");
    {
	HV *	params;
#line 424 "APItest.xs"
	HE *result;
	HV *hv = NULL;
	SV *keysv = NULL;
	const char *key = NULL;
	STRLEN klen = 0;
	int flags = 0;
	int action = 0;
	SV *val = NULL;
	U32 hash = 0;
	SV **svp;
#line 776 "APItest.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    params = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::APItest::Hash::common",
			"params");
#line 435 "APItest.xs"
	if ((svp = hv_fetchs(params, "hv", 0))) {
	    SV *const rv = *svp;
	    if (!SvROK(rv))
		croak("common passed a non-reference for parameter hv");
	    hv = (HV *)SvRV(rv);
	}
	if ((svp = hv_fetchs(params, "keysv", 0)))
	    keysv = *svp;
	if ((svp = hv_fetchs(params, "keypv", 0))) {
	    key = SvPV_const(*svp, klen);
	    if (SvUTF8(*svp))
		flags = HVhek_UTF8;
	}
	if ((svp = hv_fetchs(params, "action", 0)))
	    action = SvIV(*svp);
	if ((svp = hv_fetchs(params, "val", 0)))
	    val = newSVsv(*svp);
	if ((svp = hv_fetchs(params, "hash", 0)))
	    hash = SvUV(*svp);

	if ((svp = hv_fetchs(params, "hash_pv", 0))) {
	    PERL_HASH(hash, key, klen);
	}
	if ((svp = hv_fetchs(params, "hash_sv", 0))) {
	    STRLEN len;
	    const char *const p = SvPV(keysv, len);
	    PERL_HASH(hash, p, len);
	}

	result = (HE *)hv_common(hv, keysv, key, klen, flags, action, val, hash);
	if (!result) {
	    XSRETURN_EMPTY;
	}
	/* Force mg_get  */
	RETVAL = newSVsv(HeVAL(result));
#line 821 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif

XS(XS_XS__APItest__Hash_test_hv_free_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_test_hv_free_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 478 "APItest.xs"
	test_freeent(&Perl_hv_free_ent);
	XSRETURN(4);
#line 846 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest__Hash_test_hv_delayfree_ent); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_test_hv_delayfree_ent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 484 "APItest.xs"
	test_freeent(&Perl_hv_delayfree_ent);
	XSRETURN(4);
#line 869 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest__Hash_test_share_unshare_pvn); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_test_share_unshare_pvn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "input");
    {
#line 490 "APItest.xs"
	STRLEN len;
	U32 hash;
	char *pvx;
	char *p;
#line 892 "APItest.c"
	SV *	input = ST(0);
	SV *	RETVAL;
#line 497 "APItest.xs"
	pvx = SvPV(input, len);
	PERL_HASH(hash, pvx, len);
	p = sharepvn(pvx, len, hash);
	RETVAL = newSVpvn(p, len);
	unsharepvn(p, len, hash);
#line 901 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAB 1


XS(XS_XS__APItest__Hash_refcounted_he_exists); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_refcounted_he_exists)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "key, level=0");
    {
	SV *	key = ST(0);
	IV	level;
	bool	RETVAL;

	if (items < 2)
	    level = 0;
	else {
	    level = (IV)SvIV(ST(1));
	}
#line 512 "APItest.xs"
	if (level) {
	    croak("level must be zero, not %"IVdf, level);
	}
	RETVAL = (Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,
					   key, NULL, 0, 0, 0)
		  != &PL_sv_placeholder);
#line 939 "APItest.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest__Hash_refcounted_he_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest__Hash_refcounted_he_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "key, level=0");
    {
	SV *	key = ST(0);
	IV	level;
	SV *	RETVAL;

	if (items < 2)
	    level = 0;
	else {
	    level = (IV)SvIV(ST(1));
	}
#line 526 "APItest.xs"
	if (level) {
	    croak("level must be zero, not %"IVdf, level);
	}
	RETVAL = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash, key,
					  NULL, 0, 0, 0);
	SvREFCNT_inc(RETVAL);
#line 974 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif

XS(XS_XS__APItest_CLONE); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_CLONE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 564 "APItest.xs"
    MY_CXT_CLONE;
    MY_CXT.sv = newSVpv("initial_clone",0);
#line 996 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_print_double); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_double)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	double	val = (double)SvNV(ST(0));
#line 571 "APItest.xs"
        printf("%5.3f\n",val);
#line 1016 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_have_long_double); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_have_long_double)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 576 "APItest.xs"
#ifdef HAS_LONG_DOUBLE
        RETVAL = 1;
#else
        RETVAL = 0;
#endif
#line 1041 "APItest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_print_long_double); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_long_double)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 587 "APItest.xs"
#ifdef HAS_LONG_DOUBLE
#   if defined(PERL_PRIfldbl) && (LONG_DOUBLESIZE > DOUBLESIZE)
        long double val = 7.0;
        printf("%5.3" PERL_PRIfldbl "\n",val);
#   else
        double val = 7.0;
        printf("%5.3f\n",val);
#   endif
#endif
#line 1069 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_print_int); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_int)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	int	val = (int)SvIV(ST(0));
#line 601 "APItest.xs"
        printf("%d\n",val);
#line 1089 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_print_long); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_long)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	long	val = (long)SvIV(ST(0));
#line 607 "APItest.xs"
        printf("%ld\n",val);
#line 1109 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_print_float); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_float)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	float	val = (float)SvNV(ST(0));
#line 613 "APItest.xs"
        printf("%5.3f\n",val);
#line 1129 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_print_flush); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_print_flush)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 618 "APItest.xs"
	fflush(stdout);
#line 1148 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_mpushp); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mpushp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 623 "APItest.xs"
	EXTEND(SP, 3);
	mPUSHp("one", 3);
	mPUSHp("two", 3);
	mPUSHp("three", 5);
	XSRETURN(3);
#line 1173 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mpushn); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mpushn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 632 "APItest.xs"
	EXTEND(SP, 3);
	mPUSHn(0.5);
	mPUSHn(-0.25);
	mPUSHn(0.125);
	XSRETURN(3);
#line 1199 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mpushi); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mpushi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 641 "APItest.xs"
	EXTEND(SP, 3);
	mPUSHi(-1);
	mPUSHi(2);
	mPUSHi(-3);
	XSRETURN(3);
#line 1225 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mpushu); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mpushu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 650 "APItest.xs"
	EXTEND(SP, 3);
	mPUSHu(1);
	mPUSHu(2);
	mPUSHu(3);
	XSRETURN(3);
#line 1251 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mxpushp); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mxpushp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 659 "APItest.xs"
	mXPUSHp("one", 3);
	mXPUSHp("two", 3);
	mXPUSHp("three", 5);
	XSRETURN(3);
#line 1276 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mxpushn); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mxpushn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 667 "APItest.xs"
	mXPUSHn(0.5);
	mXPUSHn(-0.25);
	mXPUSHn(0.125);
	XSRETURN(3);
#line 1301 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mxpushi); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mxpushi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 675 "APItest.xs"
	mXPUSHi(-1);
	mXPUSHi(2);
	mXPUSHi(-3);
	XSRETURN(3);
#line 1326 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_mxpushu); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mxpushu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 683 "APItest.xs"
	mXPUSHu(1);
	mXPUSHu(2);
	mXPUSHu(3);
	XSRETURN(3);
#line 1351 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_call_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_call_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "sv, flags, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sv = ST(0);
	I32	flags = (I32)SvIV(ST(1));
#line 694 "APItest.xs"
	I32 i;
#line 1375 "APItest.c"
#line 696 "APItest.xs"
	for (i=0; i<items-2; i++)
	    ST(i) = ST(i+2); /* pop first two args */
	PUSHMARK(SP);
	SP += items - 2;
	PUTBACK;
	i = call_sv(sv, flags);
	SPAGAIN;
	EXTEND(SP, 1);
	PUSHs(sv_2mortal(newSViv(i)));
#line 1386 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_call_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_call_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "subname, flags, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	subname = (char *)SvPV_nolen(ST(0));
	I32	flags = (I32)SvIV(ST(1));
#line 711 "APItest.xs"
	I32 i;
#line 1410 "APItest.c"
#line 713 "APItest.xs"
	for (i=0; i<items-2; i++)
	    ST(i) = ST(i+2); /* pop first two args */
	PUSHMARK(SP);
	SP += items - 2;
	PUTBACK;
	i = call_pv(subname, flags);
	SPAGAIN;
	EXTEND(SP, 1);
	PUSHs(sv_2mortal(newSViv(i)));
#line 1421 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_call_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_call_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "methname, flags, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	methname = (char *)SvPV_nolen(ST(0));
	I32	flags = (I32)SvIV(ST(1));
#line 728 "APItest.xs"
	I32 i;
#line 1445 "APItest.c"
#line 730 "APItest.xs"
	for (i=0; i<items-2; i++)
	    ST(i) = ST(i+2); /* pop first two args */
	PUSHMARK(SP);
	SP += items - 2;
	PUTBACK;
	i = call_method(methname, flags);
	SPAGAIN;
	EXTEND(SP, 1);
	PUSHs(sv_2mortal(newSViv(i)));
#line 1456 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_eval_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_eval_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "sv, flags");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sv = ST(0);
	I32	flags = (I32)SvIV(ST(1));
#line 745 "APItest.xs"
    	I32 i;
#line 1480 "APItest.c"
#line 747 "APItest.xs"
	PUTBACK;
	i = eval_sv(sv, flags);
	SPAGAIN;
	EXTEND(SP, 1);
	PUSHs(sv_2mortal(newSViv(i)));
#line 1487 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_eval_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_eval_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "p, croak_on_error");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char*	p = (const char *)SvPV_nolen(ST(0));
	I32	croak_on_error = (I32)SvIV(ST(1));
#line 758 "APItest.xs"
	PUTBACK;
	EXTEND(SP, 1);
	PUSHs(eval_pv(p, croak_on_error));
#line 1513 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_require_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_require_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char*	pv = (const char *)SvPV_nolen(ST(0));
#line 766 "APItest.xs"
	PUTBACK;
	require_pv(pv);
#line 1537 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_apitest_exception); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_apitest_exception)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "throw_e");
    {
	int	throw_e = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = apitest_exception(throw_e);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_mycroak); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_mycroak)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV*	sv = ST(0);
#line 779 "APItest.xs"
    if (SvOK(sv)) {
        Perl_croak(aTHX_ "%s", SvPV_nolen(sv));
    }
    else {
	Perl_croak(aTHX_ NULL);
    }
#line 1585 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_strtab); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_strtab)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 789 "APItest.xs"
   RETVAL = newRV_inc((SV*)PL_strtab);
#line 1605 "APItest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_my_cxt_getint); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_my_cxt_getint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 796 "APItest.xs"
	dMY_CXT;
	RETVAL = my_cxt_getint_p(aMY_CXT);
#line 1629 "APItest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_my_cxt_setint); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_my_cxt_setint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0));
#line 805 "APItest.xs"
	dMY_CXT;
	my_cxt_setint_p(aMY_CXT_ i);
#line 1651 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_my_cxt_getsv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_my_cxt_getsv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "how");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	bool	how = (bool)SvTRUE(ST(0));
#line 812 "APItest.xs"
	EXTEND(SP, 1);
	ST(0) = how ? my_cxt_getsv_interp_context() : my_cxt_getsv_interp();
	XSRETURN(1);
#line 1675 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_my_cxt_setsv); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_my_cxt_setsv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
#line 820 "APItest.xs"
	dMY_CXT;
	SvREFCNT_dec(MY_CXT.sv);
	my_cxt_setsv_p(sv _aMY_CXT);
	SvREFCNT_inc(sv);
#line 1699 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_sv_setsv_cow_hashkey_core); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_sv_setsv_cow_hashkey_core)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	bool	RETVAL;

	RETVAL = sv_setsv_cow_hashkey_core();
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_sv_setsv_cow_hashkey_notcore); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_sv_setsv_cow_hashkey_notcore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	bool	RETVAL;

	RETVAL = sv_setsv_cow_hashkey_notcore();
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_rmagical_cast); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_rmagical_cast)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "sv, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
	SV *	type = ST(1);
#line 836 "APItest.xs"
	struct ufuncs uf;
#line 1764 "APItest.c"
#line 838 "APItest.xs"
	if (!SvOK(sv) || !SvROK(sv) || !SvOK(type)) { XSRETURN_UNDEF; }
	sv = SvRV(sv);
	if (SvTYPE(sv) != SVt_PVHV) { XSRETURN_UNDEF; }
	uf.uf_val = rmagical_a_dummy;
	uf.uf_set = NULL;
	uf.uf_index = 0;
	if (SvTRUE(type)) { /* b */
	    sv_magicext(sv, NULL, PERL_MAGIC_ext, &rmagical_b, NULL, 0);
	} else { /* a */
	    sv_magic(sv, NULL, PERL_MAGIC_uvar, (char *) &uf, sizeof(uf));
	}
	XSRETURN_YES;
#line 1778 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_rmagical_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_rmagical_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
#line 855 "APItest.xs"
	if (!SvOK(sv) || !SvROK(sv)) { XSRETURN_UNDEF; }
	sv = SvRV(sv);
        EXTEND(SP, 3); 
	mXPUSHu(SvFLAGS(sv) & SVs_GMG);
	mXPUSHu(SvFLAGS(sv) & SVs_SMG);
	mXPUSHu(SvFLAGS(sv) & SVs_RMG);
        XSRETURN(3);
#line 1807 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_DPeek); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_DPeek)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
#line 868 "APItest.xs"
    ST (0) = newSVpv (Perl_sv_peek (aTHX_ sv), 0);
    XSRETURN (1);
#line 1831 "APItest.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__APItest_BEGIN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_BEGIN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 874 "APItest.xs"
	sv_inc(get_sv("XS::APItest::BEGIN_called", GV_ADD|GV_ADDMULTI));
#line 1851 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_CHECK); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_CHECK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 879 "APItest.xs"
	sv_inc(get_sv("XS::APItest::CHECK_called", GV_ADD|GV_ADDMULTI));
#line 1870 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_UNITCHECK); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_UNITCHECK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 884 "APItest.xs"
	sv_inc(get_sv("XS::APItest::UNITCHECK_called", GV_ADD|GV_ADDMULTI));
#line 1889 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_INIT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_INIT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 889 "APItest.xs"
	sv_inc(get_sv("XS::APItest::INIT_called", GV_ADD|GV_ADDMULTI));
#line 1908 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_END); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_END)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 894 "APItest.xs"
	sv_inc(get_sv("XS::APItest::END_called", GV_ADD|GV_ADDMULTI));
#line 1927 "APItest.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XS__APItest_utf16_to_utf8); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_utf16_to_utf8)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "sv, ...");
    {
	SV*	sv = ST(0);
#line 902 "APItest.xs"
        STRLEN len;
	U8 *source;
	SV *dest;
	I32 got; /* Gah, badly thought out APIs */
#line 1951 "APItest.c"
#line 907 "APItest.xs"
	source = (U8 *)SvPVbyte(sv, len);
	/* Optionally only convert part of the buffer.  */ 	
	if (items > 1) {
	    len = SvUV(ST(1));
 	}
	/* Mortalise this right now, as we'll be testing croak()s  */
	dest = sv_2mortal(newSV(len * 3 / 2 + 1));
	if (ix) {
	    utf16_to_utf8_reversed(source, (U8 *)SvPVX(dest), len, &got);
	} else {
	    utf16_to_utf8(source, (U8 *)SvPVX(dest), len, &got);
	}
	SvCUR_set(dest, got);
	SvPVX(dest)[got] = '\0';
	SvPOK_on(dest);
 	ST(0) = dest;
	XSRETURN(1);
#line 1970 "APItest.c"
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_pmflag); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_pmflag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "flag, before = 0");
    {
	int	flag = (int)SvIV(ST(0));
	U32	before;
	U32	RETVAL;
	dXSTARG;

	if (items < 2)
	    before = 0;
	else {
	    before = (unsigned long)SvUV(ST(1));
	}
#line 930 "APItest.xs"
	pmflag(&before, flag);
	RETVAL = before;
#line 2000 "APItest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__APItest_my_exit); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__APItest_my_exit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "exitcode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	exitcode = (int)SvIV(ST(0));
#line 938 "APItest.xs"
        my_exit(exitcode);
#line 2023 "APItest.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XS__APItest); /* prototype to pass -Wmissing-prototypes */
XS(boot_XS__APItest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        (void)newXS("XS::APItest::Hash::constant", XS_XS__APItest__Hash_constant, file);
        (void)newXS("XS::APItest::Hash::rot13_hash", XS_XS__APItest__Hash_rot13_hash, file);
        (void)newXS("XS::APItest::Hash::bitflip_hash", XS_XS__APItest__Hash_bitflip_hash, file);
        (void)newXS("XS::APItest::Hash::exists", XS_XS__APItest__Hash_exists, file);
        (void)newXS("XS::APItest::Hash::exists_ent", XS_XS__APItest__Hash_exists_ent, file);
        (void)newXS("XS::APItest::Hash::delete", XS_XS__APItest__Hash_delete, file);
        (void)newXS("XS::APItest::Hash::delete_ent", XS_XS__APItest__Hash_delete_ent, file);
        (void)newXS("XS::APItest::Hash::store_ent", XS_XS__APItest__Hash_store_ent, file);
        (void)newXS("XS::APItest::Hash::store", XS_XS__APItest__Hash_store, file);
        (void)newXS("XS::APItest::Hash::fetch_ent", XS_XS__APItest__Hash_fetch_ent, file);
        (void)newXS("XS::APItest::Hash::fetch", XS_XS__APItest__Hash_fetch, file);
#if XSubPPtmpAAAA
        (void)newXS("XS::APItest::Hash::common", XS_XS__APItest__Hash_common, file);
#endif
        (void)newXS("XS::APItest::Hash::test_hv_free_ent", XS_XS__APItest__Hash_test_hv_free_ent, file);
        (void)newXS("XS::APItest::Hash::test_hv_delayfree_ent", XS_XS__APItest__Hash_test_hv_delayfree_ent, file);
        (void)newXS("XS::APItest::Hash::test_share_unshare_pvn", XS_XS__APItest__Hash_test_share_unshare_pvn, file);
#if XSubPPtmpAAAB
        (void)newXS("XS::APItest::Hash::refcounted_he_exists", XS_XS__APItest__Hash_refcounted_he_exists, file);
        (void)newXS("XS::APItest::Hash::refcounted_he_fetch", XS_XS__APItest__Hash_refcounted_he_fetch, file);
#endif
        (void)newXS("XS::APItest::CLONE", XS_XS__APItest_CLONE, file);
        (void)newXS("XS::APItest::print_double", XS_XS__APItest_print_double, file);
        (void)newXS("XS::APItest::have_long_double", XS_XS__APItest_have_long_double, file);
        (void)newXS("XS::APItest::print_long_double", XS_XS__APItest_print_long_double, file);
        (void)newXS("XS::APItest::print_int", XS_XS__APItest_print_int, file);
        (void)newXS("XS::APItest::print_long", XS_XS__APItest_print_long, file);
        (void)newXS("XS::APItest::print_float", XS_XS__APItest_print_float, file);
        (void)newXS("XS::APItest::print_flush", XS_XS__APItest_print_flush, file);
        (void)newXS("XS::APItest::mpushp", XS_XS__APItest_mpushp, file);
        (void)newXS("XS::APItest::mpushn", XS_XS__APItest_mpushn, file);
        (void)newXS("XS::APItest::mpushi", XS_XS__APItest_mpushi, file);
        (void)newXS("XS::APItest::mpushu", XS_XS__APItest_mpushu, file);
        (void)newXS("XS::APItest::mxpushp", XS_XS__APItest_mxpushp, file);
        (void)newXS("XS::APItest::mxpushn", XS_XS__APItest_mxpushn, file);
        (void)newXS("XS::APItest::mxpushi", XS_XS__APItest_mxpushi, file);
        (void)newXS("XS::APItest::mxpushu", XS_XS__APItest_mxpushu, file);
        (void)newXS("XS::APItest::call_sv", XS_XS__APItest_call_sv, file);
        (void)newXS("XS::APItest::call_pv", XS_XS__APItest_call_pv, file);
        (void)newXS("XS::APItest::call_method", XS_XS__APItest_call_method, file);
        (void)newXS("XS::APItest::eval_sv", XS_XS__APItest_eval_sv, file);
        (void)newXS("XS::APItest::eval_pv", XS_XS__APItest_eval_pv, file);
        (void)newXS("XS::APItest::require_pv", XS_XS__APItest_require_pv, file);
        (void)newXS("XS::APItest::apitest_exception", XS_XS__APItest_apitest_exception, file);
        (void)newXS("XS::APItest::mycroak", XS_XS__APItest_mycroak, file);
        (void)newXS("XS::APItest::strtab", XS_XS__APItest_strtab, file);
        (void)newXS("XS::APItest::my_cxt_getint", XS_XS__APItest_my_cxt_getint, file);
        (void)newXS("XS::APItest::my_cxt_setint", XS_XS__APItest_my_cxt_setint, file);
        (void)newXS("XS::APItest::my_cxt_getsv", XS_XS__APItest_my_cxt_getsv, file);
        (void)newXS("XS::APItest::my_cxt_setsv", XS_XS__APItest_my_cxt_setsv, file);
        (void)newXS("XS::APItest::sv_setsv_cow_hashkey_core", XS_XS__APItest_sv_setsv_cow_hashkey_core, file);
        (void)newXS("XS::APItest::sv_setsv_cow_hashkey_notcore", XS_XS__APItest_sv_setsv_cow_hashkey_notcore, file);
        (void)newXS("XS::APItest::rmagical_cast", XS_XS__APItest_rmagical_cast, file);
        (void)newXS("XS::APItest::rmagical_flags", XS_XS__APItest_rmagical_flags, file);
        (void)newXS("XS::APItest::DPeek", XS_XS__APItest_DPeek, file);
        (void)newXS("XS::APItest::BEGIN", XS_XS__APItest_BEGIN, file);
        (void)newXS("XS::APItest::CHECK", XS_XS__APItest_CHECK, file);
        (void)newXS("XS::APItest::UNITCHECK", XS_XS__APItest_UNITCHECK, file);
        (void)newXS("XS::APItest::INIT", XS_XS__APItest_INIT, file);
        (void)newXS("XS::APItest::END", XS_XS__APItest_END, file);
        cv = newXS("XS::APItest::utf16_to_utf8", XS_XS__APItest_utf16_to_utf8, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("XS::APItest::utf16_to_utf8_reversed", XS_XS__APItest_utf16_to_utf8, file);
        XSANY.any_i32 = 1 ;
        (void)newXS("XS::APItest::pmflag", XS_XS__APItest_pmflag, file);
        (void)newXS("XS::APItest::my_exit", XS_XS__APItest_my_exit, file);
    }

    /* Initialisation Section */

#line 2 "./const-xs.inc"
  {
#ifdef dTHX
    dTHX;
#endif
    HV *symbol_table = get_hv("XS::APItest::", GV_ADD);
#ifndef SYMBIAN
    HV *constant_missing;
#endif

    static const struct notfound_s values_for_notfound[] =
      {
#ifdef HV_DELETE
#else
        { "HV_DELETE", 9 },
#endif
#ifdef HV_DISABLE_UVAR_XKEY
#else
        { "HV_DISABLE_UVAR_XKEY", 20 },
#endif
#ifdef HV_FETCH_ISSTORE
#else
        { "HV_FETCH_ISSTORE", 16 },
#endif
#ifdef HV_FETCH_ISEXISTS
#else
        { "HV_FETCH_ISEXISTS", 17 },
#endif
#ifdef HV_FETCH_LVALUE
#else
        { "HV_FETCH_LVALUE", 15 },
#endif
#ifdef HV_FETCH_JUST_SV
#else
        { "HV_FETCH_JUST_SV", 16 },
#endif
#ifdef G_SCALAR
#else
        { "G_SCALAR", 8 },
#endif
#ifdef G_ARRAY
#else
        { "G_ARRAY", 7 },
#endif
#ifdef G_VOID
#else
        { "G_VOID", 6 },
#endif
#ifdef G_DISCARD
#else
        { "G_DISCARD", 9 },
#endif
#ifdef G_EVAL
#else
        { "G_EVAL", 6 },
#endif
#ifdef G_NOARGS
#else
        { "G_NOARGS", 8 },
#endif
#ifdef G_KEEPERR
#else
        { "G_KEEPERR", 9 },
#endif
#ifdef G_NODEBUG
#else
        { "G_NODEBUG", 9 },
#endif
#ifdef G_METHOD
#else
        { "G_METHOD", 8 },
#endif
#ifdef G_FAKINGEVAL
#else
        { "G_FAKINGEVAL", 12 },
#endif
        { NULL, 0 } };
	const struct notfound_s *value_for_notfound = values_for_notfound;

    static const struct iv_s values_for_iv[] =
      {
#ifdef HV_DELETE
        { "HV_DELETE", 9, HV_DELETE },
#endif
#ifdef HV_DISABLE_UVAR_XKEY
        { "HV_DISABLE_UVAR_XKEY", 20, HV_DISABLE_UVAR_XKEY },
#endif
#ifdef HV_FETCH_ISSTORE
        { "HV_FETCH_ISSTORE", 16, HV_FETCH_ISSTORE },
#endif
#ifdef HV_FETCH_ISEXISTS
        { "HV_FETCH_ISEXISTS", 17, HV_FETCH_ISEXISTS },
#endif
#ifdef HV_FETCH_LVALUE
        { "HV_FETCH_LVALUE", 15, HV_FETCH_LVALUE },
#endif
#ifdef HV_FETCH_JUST_SV
        { "HV_FETCH_JUST_SV", 16, HV_FETCH_JUST_SV },
#endif
#ifdef G_SCALAR
        { "G_SCALAR", 8, G_SCALAR },
#endif
#ifdef G_ARRAY
        { "G_ARRAY", 7, G_ARRAY },
#endif
#ifdef G_VOID
        { "G_VOID", 6, G_VOID },
#endif
#ifdef G_DISCARD
        { "G_DISCARD", 9, G_DISCARD },
#endif
#ifdef G_EVAL
        { "G_EVAL", 6, G_EVAL },
#endif
#ifdef G_NOARGS
        { "G_NOARGS", 8, G_NOARGS },
#endif
#ifdef G_KEEPERR
        { "G_KEEPERR", 9, G_KEEPERR },
#endif
#ifdef G_NODEBUG
        { "G_NODEBUG", 9, G_NODEBUG },
#endif
#ifdef G_METHOD
        { "G_METHOD", 8, G_METHOD },
#endif
#ifdef G_FAKINGEVAL
        { "G_FAKINGEVAL", 12, G_FAKINGEVAL },
#endif
#ifdef G_WANT
        { "G_WANT", 6, G_WANT },
#endif
#ifdef G_WANT
        /* This is the default value: */
#else
        { "G_WANT", 6, G_ARRAY|G_VOID },
#endif
        { NULL, 0, 0 } };
	const struct iv_s *value_for_iv = values_for_iv;
#ifndef SYMBIAN
	constant_missing = get_missing_hash(aTHX);
#endif
        while (value_for_iv->name) {
	    constant_add_symbol(aTHX_  symbol_table, value_for_iv->name,
				value_for_iv->namelen, newSViv(value_for_iv->value));
	    ++value_for_iv;
	}
	while (value_for_notfound->name) {

	    /* Need to add prototypes, else parsing will vary by platform.  */
	    SV **sv = hv_fetch(symbol_table, value_for_notfound->name,
			       value_for_notfound->namelen, TRUE);
	    if (!sv) {
		Perl_croak(aTHX_ 
			   "Couldn't add key '%s' to %%XS::APItest::",
			   value_for_notfound->name);
	    }
	    if (!SvOK(*sv) && SvTYPE(*sv) != SVt_PVGV) {
		/* Nothing was here before, so mark a prototype of ""  */
		sv_setpvn(*sv, "", 0);
	    } else if (SvPOK(*sv) && SvCUR(*sv) == 0) {
		/* There is already a prototype of "" - do nothing  */
	    } else {
		/* Someone has been here before us - have to make a real
		   typeglob.  */
		/* It turns out to be incredibly hard to deal with all the
		   corner cases of sub foo (); and reporting errors correctly,
		   so lets cheat a bit.  Start with a constant subroutine  */
		CV *cv = newCONSTSUB(symbol_table,
				     value_for_notfound->name,
				     &PL_sv_yes);
		/* and then turn it into a non constant declaration only.  */
		SvREFCNT_dec(CvXSUBANY(cv).any_ptr);
		CvCONST_off(cv);
		CvXSUB(cv) = NULL;
		CvXSUBANY(cv).any_ptr = NULL;
	    }
#ifndef SYMBIAN
	    if (!hv_store(constant_missing, value_for_notfound->name,
			  value_for_notfound->namelen, &PL_sv_yes, 0))
		Perl_croak(aTHX_  "Couldn't add key '%s' to missing_hash",
			   value_for_notfound->name);
#endif

	    ++value_for_notfound;
	}
    /* As we've been creating subroutines, we better invalidate any cached
       methods  */
    ++PL_sub_generation;
  }

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#line 555 "APItest.xs"
{
    MY_CXT_INIT;
    MY_CXT.i  = 99;
    MY_CXT.sv = newSVpv("initial",0);
}                              

#line 2325 "APItest.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

