.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods 3"
.TH MakeMethods 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods \- Generate common types of methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # Generates methods for your object when you "use" it.
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Hash (
\&    \*(Aqnew\*(Aq       => \*(Aqnew\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqfoo\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqbar\*(Aq,
\&  );
\&  
\&  # The generated methods can be called just like normal ones
\&  my $obj = MyObject\->new( foo => "Foozle", bar => "Bozzle" );
\&  print $obj\->foo();
\&  $obj\->bar("Barbados");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Class::MakeMethods framework allows Perl class developers to
quickly define common types of methods. When a module \f(CW\*(C`use\*(C'\fRs
Class::MakeMethods or one of its subclasses, it can select from a
variety of supported method types, and specify a name for each
method desired. The methods are dynamically generated and installed
in the calling package.
.PP
Construction of the individual methods is handled by subclasses.
This delegation approach allows for a wide variety of method-generation
techniques to be supported, each by a different subclass. Subclasses
can also be added to provide support for new types of methods.
.PP
Over a dozen subclasses are available, including implementations of
a variety of different method-generation techniques. Each subclass
generates several types of methods, with some supporting their own
open-eneded extension syntax, for hundreds of possible combinations
of method types.
.SH "GETTING STARTED"
.IX Header "GETTING STARTED"
.SS "Motivation"
.IX Subsection "Motivation"
.Vb 1
\&  "Make easy things easier."
.Ve
.PP
This module addresses a problem encountered in object-oriented
development wherein numerous methods are defined which differ only
slightly from each other.
.PP
A common example is accessor methods for hash-based object attributes,
which allow you to get and set the value \f(CW$self\fR\->{'foo'} by
calling a method \f(CW$self\fR\->\fIfoo()\fR.
.PP
These methods are generally quite simple, requiring only a couple
of lines of Perl, but in sufficient bulk, they can cut down on the
maintainability of large classes.
.PP
Class::MakeMethods allows you to simply declare those methods to
be of a predefined type, and it generates and installs the necessary
methods in your package at compile-time.
.SS "A Contrived Example"
.IX Subsection "A Contrived Example"
Object-oriented Perl code is widespread \*(-- you've probably seen code like the below a million times:
.PP
.Vb 5
\&  my $obj = MyStruct\->new( foo=>"Foozle", bar=>"Bozzle" );
\&  if ( $obj\->foo() =~ /foo/i ) {
\&    $obj\->bar("Barbados!");
\&  }
\&  print $obj\->summary();
.Ve
.PP
(If this doesn't look familiar, take a moment to read perlboot
and you'll soon learn more than's good for you.)
.PP
Typically, this involves creating numerous subroutines that follow
a handful of common patterns, like constructor methods and accessor
methods. The classic example is accessor methods for hash-based
object attributes, which allow you to get and set the value
\&\fIself\fR\->{\fIfoo\fR} by calling a method \fIself\fR\->\fIfoo\fR().
These methods are generally quite simple, requiring only a couple
of lines of Perl, but in sufficient bulk, they can cut down on the
maintainability of large classes.
.PP
Here's a possible implementation for the class whose interface is
shown above:
.PP
.Vb 1
\&  package MyStruct;
\&  
\&  sub new {
\&    my $callee = shift;
\&    my $self = bless { @_ }, (ref $callee || $callee);
\&    return $self;
\&  }
\&
\&  sub foo {
\&    my $self = shift;
\&    if ( scalar @_ ) {
\&      $self\->{\*(Aqfoo\*(Aq} = shift();
\&    } else {
\&      $self\->{\*(Aqfoo\*(Aq}
\&    }
\&  }
\&
\&  sub bar {
\&    my $self = shift;
\&    if ( scalar @_ ) {
\&      $self\->{\*(Aqbar\*(Aq} = shift();
\&    } else {
\&      $self\->{\*(Aqbar\*(Aq}
\&    }
\&  }
\&
\&  sub summary {
\&    my $self = shift;
\&    join(\*(Aq, \*(Aq, map { "\eu$_: " . $self\->$_() } qw( foo bar ) )
\&  }
.Ve
.PP
Note in particular that the foo and bar methods are almost identical,
and that the new method could be used for almost any class; this
is precisely the type of redundancy Class::MakeMethods addresses.
.PP
Class::MakeMethods allows you to simply declare those methods to
be of a predefined type, and it generates and installs the necessary
methods in your package at compile-time.
.PP
Here's the equivalent declaration for that same basic class:
.PP
.Vb 6
\&  package MyStruct;
\&  use Class::MakeMethods::Standard::Hash (
\&    \*(Aqnew\*(Aq       => \*(Aqnew\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqfoo\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqbar\*(Aq,
\&  );
\&  
\&  sub summary {
\&    my $self = shift;
\&    join(\*(Aq, \*(Aq, map { "\eu$_: " . $self\->$_() } qw( foo bar ) )
\&  }
.Ve
.PP
This is the basic purpose of Class::MakeMethods: The \*(L"boring\*(R" pieces
of code have been replaced by succinct declarations, placing the
focus on the \*(L"unique\*(R" or \*(L"custom\*(R" pieces.
.SS "Finding the Method Types You Need"
.IX Subsection "Finding the Method Types You Need"
Once you've grasped the basic idea \*(-- simplifying repetitive code
by generating and installing methods on demand \*(-- the remaining
complexity basically boils down to figuring out which arguments to
pass to generate the specific methods you want.
.PP
Unfortunately, this is not a trivial task, as there are dozens of
different types of methods that can be generated, each with a
variety of options, and several alternative ways to write each
method declaration. You may prefer to start by just finding a few
examples that you can modify to accomplish your immediate needs,
and defer investigating all of the extras until you're ready to
take a closer look.
.SS "Other Documentation"
.IX Subsection "Other Documentation"
The remainder of this document focuses on points of usage that are
common across all subclasses, and describes how to create your own
subclasses.
.PP
If this is your first exposure to Class::MakeMethods, you may want
to skim over the rest of this document, then take a look at the
examples and one or two of the method-generating subclasses to get
a more concrete sense of typical usage, before returning to the
details presented below.
.IP "\(bu" 4
A collection of sample uses is available in
Class::MakeMethods::Docs::Examples.
.IP "\(bu" 4
Some of the most common object and class methods are available from 
Class::MakeMethods::Standard::Hash,
Class::MakeMethods::Standard::Global and
Class::MakeMethods::Standard::Universal.
.IP "\(bu" 4
If you need a bit more flexibility, see Class::MakeMethods::Composite
for method generators which offer more customization options,
including pre\- and post-method callback hooks.
.IP "\(bu" 4
For the largest collection of methods and options, see
Class::MakeMethods::Template, which uses a system of dynamic
code generation to allow endless variation.
.IP "\(bu" 4
A listing of available method types from each of the different
subclasses is provided in Class::MakeMethods::Docs::Catalog.
.SH "CLASS ARCHITECTURE"
.IX Header "CLASS ARCHITECTURE"
Because there are so many common types of methods one might wish
to generate, the Class::MakeMethods framework provides an extensible
system based on subclasses.
.PP
When your code requests a method, the MakeMethods base class performs
some standard argument parsing, delegates the construction of the
actual method to the appropriate subclass, and then installs whatever
method the subclass returns.
.SS "The MakeMethods Base Class"
.IX Subsection "The MakeMethods Base Class"
The Class::MakeMethods package defines a superclass for method-generating
modules, and provides a calling convention, on-the-fly subclass
loading, and subroutine installation that will be shared by all
subclasses.
.PP
The superclass also lets you generate several different types of
methods in a single call, and will automatically load named subclasses
the first time they're used.
.SS "The Method Generator Subclasses"
.IX Subsection "The Method Generator Subclasses"
The type of method that gets created is controlled by the specific
subclass and generator function you request. For example,
\&\f(CW\*(C`Class::MakeMethods::Standard::Hash\*(C'\fR has a generator function
\&\f(CW\*(C`scalar()\*(C'\fR, which is responsible for generating simple scalar-accessor
methods for blessed-hash objects.
.PP
Each generator function specified is passed the arguments specifying
the method the caller wants, and produces a closure or eval-able
sequence of Perl statements representing the ready-to-install
function.
.SS "Included Subclasses"
.IX Subsection "Included Subclasses"
Because each subclass defines its own set of method types and
customization options, a key step is to find your way to the
appropriate subclasses.
.IP "Standard (See Class::MakeMethods::Standard.)" 4
.IX Item "Standard (See Class::MakeMethods::Standard.)"
Generally you will want to begin with the Standard::Hash subclass,
to create constructor and accessor methods for working with
blessed-hash objects (or you might choose the Standard::Array
subclass instead).  The Standard::Global subclass provides methods
for class data shared by all objects in a class.
.Sp
Each Standard method declaration can optionally include a hash of
associated parameters, which allows you to tweak some of the
characteristics of the methods. Subroutines are bound as closures
to a hash of each method's name and parameters. Standard::Hash and
Standard::Array provide object constructor and accessors. The
Standard::Global provides for static data shared by all instances
and subclasses, while the data for Standard::Inheritable methods
trace the inheritance tree to find values, and can be overriden
for any subclass or instance.
.IP "Composite (See Class::MakeMethods::Composite.)" 4
.IX Item "Composite (See Class::MakeMethods::Composite.)"
For additional customization options, check out the Composite
subclasses, which allow you to select from a more varied set of
implementations and which allow you to adjust any specific method
by adding your own code-refs to be run before or after it.
.Sp
Subroutines are bound as closures to a hash of each method's name
and optional additional data, and to one or more subroutine references
which make up the composite behavior of the method. Composite::Hash
and Composite::Array provide object constructor and accessors. The
Composite::Global provides for static data shared by all instances
and subclasses, while the data for Composite::Inheritable methods
can be overriden for any subclass or instance.
.IP "Template (See Class::MakeMethods::Template.)" 4
.IX Item "Template (See Class::MakeMethods::Template.)"
The Template subclasses provide an open-ended structure for objects
that assemble Perl code on the fly into cachable closure-generating
subroutines; if the method you need isn't included, you can extend
existing methods by re-defining just the snippet of code that's
different.
.Sp
Class::MakeMethods::Template extends MakeMethods with a text
templating system that can assemble Perl code fragments into a
desired subroutine. The code for generated methods is eval'd once
for each type, and then repeatedly bound as closures to method-specific
data for better performance.
.Sp
Templates for dozens of types of constructor, accessor, and mutator
methods are included, ranging from from the mundane (constructors
and value accessors for hash and array slots) to the esoteric
(inheritable class data and \*(L"inside-out\*(R" accessors with external
indexes).
.IP "Basic (See Class::MakeMethods::Basic.)" 4
.IX Item "Basic (See Class::MakeMethods::Basic.)"
The Basic subclasses provide stripped down method generators with
no configurable options, for minimal functionality (and minimum
overhead).
.Sp
Subroutines are bound as closures to the name of each method.
Basic::Hash and Basic::Array provide simple object constructors
and accessors. Basic::Global provides basic global-data accessors.
.IP "Emulators (See Class::MakeMethods::Emulator.)" 4
.IX Item "Emulators (See Class::MakeMethods::Emulator.)"
In several cases, Class::MakeMethods provides functionality closely
equivalent to that of an existing module, and it is simple to map
the existing module's interface to that of Class::MakeMethods.
.Sp
Emulators are included for Class::MethodMaker, Class::Accessor::Fast,
Class::Data::Inheritable, Class::Singleton, and Class::Struct, each
of which passes the original module's test suite, usually requiring
only that the name of the module be changed.
.IP "Extending" 4
.IX Item "Extending"
Class::MakeMethods can be extended by creating subclasses that
define additional method-generation functions. Callers can then
specify the name of your subclass and generator function in their
\&\f(CW\*(C`use Call::MakeMethods ...\*(C'\fR statements and your function will be
invoked to produce the required closures. See \*(L"\s-1EXTENDING\s0\*(R" for
more information.
.SS "Naming Convention for Generated Method Types"
.IX Subsection "Naming Convention for Generated Method Types"
Method generation functions in this document are often referred to using the '\fIMakerClass\fR:\fIMethodType\fR' or '\fIMakerGroup\fR::\fIMakerSubclass\fR:\fIMethodType\fR' naming conventions. As you will see, these are simply the names of Perl packages and the names of functions that are contained in those packages.
.PP
The included subclasses are grouped into several major groups, so the names used by the included subclasses and method types reflect three axes of variation, "\fIGroup\fR::\fISubclass\fR:\fIType\fR":
.IP "Maker Group" 4
.IX Item "Maker Group"
Each group shares a similar style of technical implementation and level of complexity. For example, the \f(CW\*(C`Standard::*\*(C'\fR packages are all simple, while the \f(CW\*(C`Composite::*\*(C'\fR packages all support pre\- and post-conditions.
.Sp
(For a listing of the four main groups of included subclasses, see \*(L"Included Subclasses\*(R"\*(L" in \*(R".)
.IP "Maker Subclass" 4
.IX Item "Maker Subclass"
Each subclass generates methods for a similar level of scoping or underlying object type. For example, the \f(CW*::Hash\fR packages all make methods for objects based on blessed hashes, while the \f(CW*::Global\fR packages make methods that access class-wide data that will be shared between all objects in a class.
.IP "Method Type" 4
.IX Item "Method Type"
Each method type produces a similar type of constructor or accessor. For examples, the \f(CW*:new\fR methods are all constructors, while the \f(CW\*(C`::scalar\*(C'\fR methods are all accessors that allow you to get and set a single scalar value.
.PP
Bearing that in mind, you should be able to guess the intent of many of the method types based on their names alone; when you see \*(L"Standard::Hash:scalar\*(R" you can read it as "a type of method to access a \fIscalar\fR value stored in a \fIhash\fR\-based object, with a \fIstandard\fR implementation style" and know that it's going to call the \fIscalar()\fR function in the Class::MakeMethods::Standard::Hash package to generate the requested method.
.SH "USAGE"
.IX Header "USAGE"
The supported method types, and the kinds of arguments they expect, vary from subclass to subclass; see the documentation of each subclass for details.
.PP
However, the features described below are applicable to all subclasses.
.SS "Invocation"
.IX Subsection "Invocation"
Methods are dynamically generated and installed into the calling
package when you \f(CW\*(C`use Class::MakeMethods (...)\*(C'\fR or one of its
subclasses, or if you later call \f(CW\*(C`Class::MakeMethods\->make(...)\*(C'\fR.
.PP
The arguments to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR should be pairs of a generator
type name and an associated array of method-name arguments to pass to
the generator.
.IP "\(bu" 4
use Class::MakeMethods::\fIMakerClass\fR ( 
    '\fIMethodType\fR' => [ \fIArguments\fR ], \fI...\fR
  );
.IP "\(bu" 4
Class::MakeMethods::\fIMakerClass\fR\->make ( 
    '\fIMethodType\fR' => [ \fIArguments\fR ], \fI...\fR
  );
.PP
You may select a specific subclass of Class::MakeMethods for
a single generator\-type/argument pair by prefixing the type name
with a subclass name and a colon.
.IP "\(bu" 4
use Class::MakeMethods ( 
    '\fIMakerClass\fR:\fIMethodType\fR' => [ \fIArguments\fR ], \fI...\fR
  );
.IP "\(bu" 4
Class::MakeMethods\->make ( 
    '\fIMakerClass\fR:\fIMethodType\fR' => [ \fIArguments\fR ], \fI...\fR
  );
.PP
The difference between \f(CW\*(C`use\*(C'\fR and \f(CW\*(C`make\*(C'\fR is primarily one of precedence; the \f(CW\*(C`use\*(C'\fR keyword acts as a \s-1BEGIN\s0 block, and is thus evaluated before \f(CW\*(C`make\*(C'\fR would be. (See \*(L"About Precedence\*(R" for additional discussion of this issue.)
.SS "Alternative Invocation"
.IX Subsection "Alternative Invocation"
If you want methods to be declared at run-time when a previously-unknown
method is invoked, see Class::MakeMethods::Autoload.
.IP "\(bu" 4
use Class::MakeMethods::Autoload '\fIMakerClass\fR:\fIMethodType\fR';
.PP
If you are using Perl version 5.6 or later, see
Class::MakeMethods::Attribute for an additional declaration
syntax for generated methods.
.IP "\(bu" 4
use Class::MakeMethods::Attribute '\fIMakerClass\fR';
.Sp
sub \fIname\fR :MakeMethod('\fIMethodType\fR' => \fIArguments\fR);
.SS "About Precedence"
.IX Subsection "About Precedence"
Rather than passing the method declaration arguments when you \f(CW\*(C`use\*(C'\fR one of these packages, you may instead pass them to a subsequent call to the class method \f(CW\*(C`make\*(C'\fR.
.PP
The difference between \f(CW\*(C`use\*(C'\fR and \f(CW\*(C`make\*(C'\fR is primarily one of precedence; the \f(CW\*(C`use\*(C'\fR keyword acts as a \s-1BEGIN\s0 block, and is thus evaluated before \f(CW\*(C`make\*(C'\fR would be. In particular, a \f(CW\*(C`use\*(C'\fR at the top of a file will be executed before any subroutine declarations later in the file have been seen, whereas a \f(CW\*(C`make\*(C'\fR at the same point in the file will not.
.PP
By default, Class::MakeMethods will not install generated methods over any pre-existing methods in the target class. To override this you can pass \f(CW\*(C`\-ForceInstall => 1\*(C'\fR as initial arguments to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR.
.PP
If the same method is declared multiple times, earlier calls to
\&\f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make()\*(C'\fR win over later ones, but within each call,
later declarations superceed earlier ones.
.PP
Here are some examples of the results of these precedence rules:
.PP
.Vb 5
\&  # 1 \- use, before
\&  use Class::MakeMethods::Standard::Hash (
\&    \*(Aqscalar\*(Aq=>[\*(Aqbaz\*(Aq] # baz() not seen yet, so we generate, install
\&  );
\&  sub baz { 1 } # Subsequent declaration overwrites it, with warning
\&  
\&  # 2 \- use, after
\&  sub foo { 1 }
\&  use Class::MakeMethods::Standard::Hash (
\&    \*(Aqscalar\*(Aq=>[\*(Aqfoo\*(Aq] # foo() is already declared, so has no effect
\&  );
\&  
\&  # 3 \- use, after, Force
\&  sub bar { 1 }
\&  use Class::MakeMethods::Standard::Hash ( 
\&      \-ForceInstall => 1, # Set flag for following methods...
\&    \*(Aqscalar\*(Aq => [\*(Aqbar\*(Aq]   # ... now overwrites pre\-existing bar()
\&  );
\&  
\&  # 4 \- make, before
\&  Class::MakeMethods::Standard::Hash\->make(
\&    \*(Aqscalar\*(Aq=>[\*(Aqblip\*(Aq] # blip() is already declared, so has no effect
\&  );
\&  sub blip { 1 } # Although lower than make(), this "happens" first
\&  
\&  # 5 \- make, after, Force
\&  sub ping { 1 } 
\&  Class::MakeMethods::Standard::Hash\->make(
\&      \-ForceInstall => 1, # Set flag for following methods...
\&    \*(Aqscalar\*(Aq => [\*(Aqping\*(Aq]  # ... now overwrites pre\-existing ping()
\&  );
.Ve
.SS "Global Options"
.IX Subsection "Global Options"
Global options may be specified as an argument pair with a leading hyphen. (This distinguishes them from type names, which must be valid Perl subroutine names, and thus will never begin with a hyphen.)
.PP
use Class::MakeMethods::\fIMakerClass\fR ( 
    '\-\fIParam\fR' => \fIParamValue\fR,
    '\fIMethodType\fR' => [ \fIArguments\fR ], \fI...\fR
  );
.PP
Option settings apply to all subsequent method declarations within a single \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR call.
.PP
The below options allow you to control generation and installation of the requested methods. (Some subclasses may support additional options; see their documentation for details.)
.IP "\-TargetClass" 4
.IX Item "-TargetClass"
By default, the methods are installed in the first package in the \fIcaller()\fR stack that is not a Class::MakeMethods subclass; this is generally the package in which your use or make statement was issued. To override this you can pass \f(CW\*(C`\-TargetClass => \f(CIpackage\f(CW\*(C'\fR as initial arguments to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR.
.Sp
This allows you to construct or modify classes \*(L"from the outside\*(R":
.Sp
.Vb 1
\&  package main;
\&  
\&  use Class::MakeMethods::Basic::Hash( 
\&    \-TargetClass => \*(AqMyWidget\*(Aq,
\&    \*(Aqnew\*(Aq => [\*(Aqcreate\*(Aq],
\&    \*(Aqscalar\*(Aq => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq],
\&  );
\&  
\&  $o = MyWidget\->new( foo => \*(AqFoozle\*(Aq );
\&  print $o\->foo();
.Ve
.IP "\-MakerClass" 4
.IX Item "-MakerClass"
By default, meta-methods are looked up in the package you called
use or make on.
.Sp
You can override this by passing the \f(CW\*(C`\-MakerClass\*(C'\fR flag, which
allows you to switch packages for the remainder of the meta-method
types and arguments.
.Sp
use Class::MakeMethods ( 
    '\-MakerClass'=>'\fIMakerClass\fR', 
    '\fIMethodType\fR' => [ \fIArguments\fR ] 
  );
.Sp
When specifying the MakerClass, you may provide either the trailing
part name of a subclass inside of the \f(CW\*(C`Class::MakeMethods::\*(C'\fR
namespace, or a full package name prefixed by \f(CW\*(C`::\*(C'\fR.
.Sp
For example, the following four statements are equivalent ways of
declaring a Basic::Hash scalar method named 'foo':
.Sp
.Vb 3
\&  use Class::MakeMethods::Basic::Hash ( 
\&    \*(Aqscalar\*(Aq => [ \*(Aqfoo\*(Aq ] 
\&  );
\&  
\&  use Class::MakeMethods ( 
\&    \*(AqBasic::Hash:scalar\*(Aq => [ \*(Aqfoo\*(Aq ] 
\&  );
\&  
\&  use Class::MakeMethods ( 
\&    \*(Aq\-MakerClass\*(Aq=>\*(AqBasic::Hash\*(Aq, 
\&    \*(Aqscalar\*(Aq =>  [ \*(Aqfoo\*(Aq ] 
\&  );
\&  
\&  use Class::MakeMethods ( 
\&    \*(Aq\-MakerClass\*(Aq=>\*(Aq::Class::MakeMethods::Basic::Hash\*(Aq, 
\&    \*(Aqscalar\*(Aq =>  [ \*(Aqfoo\*(Aq ] 
\&  );
.Ve
.IP "\-ForceInstall" 4
.IX Item "-ForceInstall"
By default, Class::MakeMethods will not install generated methods over any pre-existing methods in the target class. To override this you can pass \f(CW\*(C`\-ForceInstall => 1\*(C'\fR as initial arguments to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR.
.Sp
Note that the \f(CW\*(C`use\*(C'\fR keyword acts as a \s-1BEGIN\s0 block, so a \f(CW\*(C`use\*(C'\fR at the top of a file will be executed before any subroutine declarations later in the file have been seen. (See \*(L"About Precedence\*(R" for additional discussion of this issue.)
.SS "Mixing Method Types"
.IX Subsection "Mixing Method Types"
A single calling class can combine generated methods from different MakeMethods subclasses. In general, the only mixing that's problematic is combinations of methods which depend on different underlying object types, like using *::Hash and *::Array methods together \*(-- the methods will be generated, but some of them  are guaranteed to fail when called, depending on whether your object happens to be a blessed hashref or arrayref.
.PP
For example, it's common to mix and match various *::Hash methods, with a scattering of Global or Inheritable methods:
.PP
.Vb 5
\&  use Class::MakeMethods (
\&    \*(AqBasic::Hash:scalar\*(Aq      => \*(Aqfoo\*(Aq,
\&    \*(AqComposite::Hash:scalar\*(Aq  => [ \*(Aqbar\*(Aq => { post_rules => [] } ],
\&    \*(AqStandard::Global:scalar\*(Aq => \*(Aqour_shared_baz\*(Aq
\&  );
.Ve
.SS "Declaration Syntax"
.IX Subsection "Declaration Syntax"
The following types of Simple declarations are supported:
.IP "\(bu" 4
\&\fIgenerator_type\fR => '\fImethod_name\fR'
.IP "\(bu" 4
\&\fIgenerator_type\fR => '\fImethod_1\fR \fImethod_2\fR...'
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ '\fImethod_1\fR', '\fImethod_2\fR', ...]
.PP
For a list of the supported values of \fIgenerator_type\fR, see
\&\*(L"\s-1STANDARD\s0 \s-1CLASSES\s0\*(R" in Class::MakeMethods::Docs::Catalog, or the documentation
for each subclass.
.PP
For each method name you provide, a subroutine of the indicated
type will be generated and installed under that name in your module.
.PP
Method names should start with a letter, followed by zero or more
letters, numbers, or underscores.
.SS "Argument Normalization"
.IX Subsection "Argument Normalization"
The following expansion rules are applied to argument pairs to
enable the use of simple strings instead of arrays of arguments.
.IP "\(bu" 4
Each type can be followed by a single meta-method definition, or by a
reference to an array of them.
.IP "\(bu" 4
If the argument is provided as a string containing spaces, it is
split and each word is treated as a separate argument.
.IP "\(bu" 4
It the meta-method type string contains spaces, it is split and
only the first word is used as the type, while the remaining words
are placed at the front of the argument list.
.PP
For example, the following statements are equivalent ways of
declaring a pair of Basic::Hash scalar methods named 'foo' and 'bar':
.PP
.Vb 3
\&  use Class::MakeMethods::Basic::Hash ( 
\&    \*(Aqscalar\*(Aq => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ], 
\&  );
\&  
\&  use Class::MakeMethods::Basic::Hash ( 
\&    \*(Aqscalar\*(Aq => \*(Aqfoo\*(Aq, 
\&    \*(Aqscalar\*(Aq => \*(Aqbar\*(Aq, 
\&  );
\&  
\&  use Class::MakeMethods::Basic::Hash ( 
\&    \*(Aqscalar\*(Aq => \*(Aqfoo bar\*(Aq, 
\&  );
\&  
\&  use Class::MakeMethods::Basic::Hash ( 
\&    \*(Aqscalar foo\*(Aq => \*(Aqbar\*(Aq, 
\&  );
.Ve
.PP
(The last of these is clearly a bit peculiar and potentially misleading if used as shown, but it enables advanced subclasses to provide convenient formatting for declarations with  defaults or modifiers, such as \f(CW\*(AqTemplate::Hash:scalar \-\-private\*(Aq => \*(Aqfoo\*(Aq\fR, discussed elsewhere.)
.SS "Parameter Syntax"
.IX Subsection "Parameter Syntax"
The Standard syntax also provides several ways to optionally
associate a hash of additional parameters with a given method
name.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    '\fImethod_1\fR' => { \fIparam\fR=>\fIvalue\fR... }, \fI...\fR
  ]
.Sp
A hash of parameters to use just for this method name.
.Sp
(Note: to prevent confusion with self-contained definition hashes,
described below, parameter hashes following a method name must not
contain the key \f(CW\*(Aqname\*(Aq\fR.)
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    [ '\fImethod_1\fR', '\fImethod_2\fR', ... ] => { \fIparam\fR=>\fIvalue\fR... }
  ]
.Sp
Each of these method names gets a copy of the same set of parameters.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    { 'name'=>'\fImethod_1\fR', \fIparam\fR=>\fIvalue\fR... }, \fI...\fR
  ]
.Sp
By including the reserved parameter \f(CW\*(Aqname\*(Aq\fR, you create a self-contained declaration with that name and any associated hash values.
.PP
Simple declarations, as shown in the prior section, are treated as if they had an empty parameter hash.
.SS "Default Parameters"
.IX Subsection "Default Parameters"
A set of default parameters to be used for several declarations
may be specified using any of the following types of arguments to
a method generator call:
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    '\-\fIparam\fR' => '\fIvalue\fR', '\fImethod_1\fR', '\fImethod_2\fR', \fI...\fR
  ]
.Sp
Set a default value for the specified parameter to be passed to all subsequent declarations.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    '\-\-' => { '\fIparam\fR' => '\fIvalue\fR', ... }, '\fImethod_1\fR', '\fImethod_2\fR', \fI...\fR
  ]
.Sp
Set default values for one or more parameters to be passed to all subsequent declarations. Equivalent to a series of '\-\fIparam\fR' => '\fIvalue\fR' pairs for each pair in the referenced hash.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ 
    '\-\-\fIspecial_param\fR', '\fImethod_1\fR', '\fImethod_2\fR', \fI...\fR
  ]
.Sp
Appends to the default value for a special parameter named \*(L"\-\-\*(R". This parameter is currently only used by some subclasses; for details see Class::MakeMethods::Template
.PP
Parameters set in these ways are passed to each declaration that
follows it until the end of the method-generator argument array,
or until overridden by another declaration. Parameters specified
in a hash for a specific method name, as discussed above, will
override the defaults of the same name for that particular method.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
The following warnings and errors may be produced when using
Class::MakeMethods to generate methods. (Note that this list does not
include run-time messages produced by calling the generated methods.)
.PP
These messages are classified as follows (listed in increasing order of
desperation):
.PP
.Vb 5
\&    (Q) A debugging message, only shown if $CONTEXT{Debug} is true
\&    (W) A warning.
\&    (D) A deprecation.
\&    (F) A fatal error in caller\*(Aqs use of the module.
\&    (I) An internal problem with the module or subclasses.
.Ve
.PP
Portions of the message which may vary are denoted with a \f(CW%s\fR.
.IP "Can't interpret meta-method template: argument is empty or undefined" 4
.IX Item "Can't interpret meta-method template: argument is empty or undefined"
(F)
.IP "Can't interpret meta-method template: unknown template name '%s'" 4
.IX Item "Can't interpret meta-method template: unknown template name '%s'"
(F)
.IP "Can't interpret meta-method template: unsupported template type '%s'" 4
.IX Item "Can't interpret meta-method template: unsupported template type '%s'"
(F)
.IP "Can't make method %s(): template specifies unknown behavior '%s'" 4
.IX Item "Can't make method %s(): template specifies unknown behavior '%s'"
(F)
.IP "Can't parse meta-method declaration: argument is empty or undefined" 4
.IX Item "Can't parse meta-method declaration: argument is empty or undefined"
(F) You passed an undefined value or an empty string in the list
of meta-method declarations to use or make.
.IP "Can't parse meta-method declaration: missing name attribute." 4
.IX Item "Can't parse meta-method declaration: missing name attribute."
(F) You included an hash-ref-style meta-method declaration that
did not include the required name attribute. You may have meant
this to be an attributes hash for a previously specified name, but
if so we were unable to locate it.
.IP "Can't parse meta-method declaration: unknown template name '%s'" 4
.IX Item "Can't parse meta-method declaration: unknown template name '%s'"
(F) You included a template specifier of the form \f(CW\*(Aq\-\f(CItemplate_name\f(CW\*(Aq\fR
in a the list of meta-method declaration, but that template is not
available.
.IP "Can't parse meta-method declaration: unsupported declaration type '%s'" 4
.IX Item "Can't parse meta-method declaration: unsupported declaration type '%s'"
(F) You included an unsupported type of value in a list of meta-method
declarations.
.ie n .IP "Compilation error: %s" 4
.el .IP "Compilation error: \f(CW%s\fR" 4
.IX Item "Compilation error: %s"
(I)
.IP "Not an interpretable meta-method: '%s'" 4
.IX Item "Not an interpretable meta-method: '%s'"
(I)
.ie n .IP "Odd number of arguments passed to %s make" 4
.el .IP "Odd number of arguments passed to \f(CW%s\fR make" 4
.IX Item "Odd number of arguments passed to %s make"
(F) You specified an odd number of arguments in a call to use or
make.  The arguments should be key => value pairs.
.ie n .IP "Unable to compile generated method %s(): %s" 4
.el .IP "Unable to compile generated method %s(): \f(CW%s\fR" 4
.IX Item "Unable to compile generated method %s(): %s"
(I) The install_methods subroutine attempted to compile a subroutine
by calling eval on a provided string, which failed for the indicated
reason, usually some type of Perl syntax error.
.ie n .IP "Unable to dynamically load $package: $%s" 4
.el .IP "Unable to dynamically load \f(CW$package:\fR $%s" 4
.IX Item "Unable to dynamically load $package: $%s"
(F)
.IP "Unable to install code for %s() method: '%s'" 4
.IX Item "Unable to install code for %s() method: '%s'"
(I) The install_methods subroutine was passed an unsupported value
as the code to install for the named method.
.IP "Unexpected return value from compilation of %s(): '%s'" 4
.IX Item "Unexpected return value from compilation of %s(): '%s'"
(I) The install_methods subroutine attempted to compile a subroutine
by calling eval on a provided string, but the eval returned something
other than than the code ref we expect.
.ie n .IP "Unexpected return value from meta-method constructor %s: %s" 4
.el .IP "Unexpected return value from meta-method constructor \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Unexpected return value from meta-method constructor %s: %s"
(I) The requested method-generator was invoked, but it returned an unacceptable value.
.SH "EXTENDING"
.IX Header "EXTENDING"
Class::MakeMethods can be extended by creating subclasses that
define additional meta-method types. Callers then select your
subclass using any of the several techniques described above.
.SS "Creating A Subclass"
.IX Subsection "Creating A Subclass"
The begining of a typical extension might look like the below:
.PP
.Vb 3
\&  package My::UpperCaseMethods;
\&  use strict;
\&  use Class::MakeMethods \*(Aq\-isasubclass\*(Aq;
\&  
\&  sub my_method_type { ... }
.Ve
.PP
You can name your subclass anything you want; it does not need to
begin with Class::MakeMethods.
.PP
The '\-isasubclass' flag is a shortcut that automatically puts
Class::MakeMethods into your package's \f(CW@ISA\fR array so that it will
inherit the \fIimport()\fR and \fImake()\fR class methods. If you omit this
flag, you will need to place the superclass in your \f(CW@ISA\fR explicitly.
.PP
Typically, the subclass should \fBnot\fR inherit from Exporter; both
Class::MakeMethods and Exporter are based on inheriting an import
class method, and getting a subclass to support both would require
additional effort.
.SS "Naming Method Types"
.IX Subsection "Naming Method Types"
Each type of method that can be generated is defined in a subroutine
of the same name. You can give your meta-method type any name that
is a legal subroutine identifier.
.PP
(Names begining with an underscore, and the names \f(CW\*(C`import\*(C'\fR and
\&\f(CW\*(C`make\*(C'\fR, are reserved for internal use by Class::MakeMethods.)
.PP
If you plan on distributing your extension, you may wish to follow
the \*(L"Naming Convention for Generated Method Types\*(R" described above
to facilitate reuse by others.
.SS "Implementation Options"
.IX Subsection "Implementation Options"
Each method generation subroutine can be implemented in any one of
the following ways:
.IP "\(bu" 4
Subroutine Generation
.Sp
Returns a list of subroutine name/code pairs.
.Sp
The code returned may either be a coderef, or a string containing
Perl code that can be evaled and will return a coderef. If the eval
fails, or anything other than a coderef is returned, then
Class::MakeMethods croaks.
.Sp
For example a simple sub-class with a method type upper_case_get_set
that generates an accessor method for each argument provided might
look like this:
.Sp
.Vb 2
\&  package My::UpperCaseMethods;
\&  use Class::MakeMethods \*(Aq\-isasubclass\*(Aq;
\&  
\&  sub uc_scalar {
\&    my $class = shift;
\&    map { 
\&      my $name = $_;
\&      $name => sub {
\&        my $self = shift;
\&        if ( scalar @_ ) { 
\&          $self\->{ $name } = uc( shift ) 
\&        } else {
\&          $self\->{ $name };
\&        }
\&      }
\&    } @_;
\&  }
.Ve
.Sp
Callers could then generate these methods as follows:
.Sp
.Vb 1
\&  use My::UpperCaseMethods ( \*(Aquc_scalar\*(Aq => \*(Aqfoo\*(Aq );
.Ve
.IP "\(bu" 4
Aliasing
.Sp
Returns a string containing a different meta-method type to use
for those same arguments.
.Sp
For example a simple sub-class that defines a method type stored_value
might look like this:
.Sp
.Vb 2
\&  package My::UpperCaseMethods;
\&  use Class::MakeMethods \*(Aq\-isasubclass\*(Aq;
\&
\&  sub regular_scalar { return \*(AqBasic::Hash:scalar\*(Aq }
.Ve
.Sp
And here's an example usage:
.Sp
.Vb 1
\&  use My::UpperCaseMethods ( \*(Aqregular_scalar\*(Aq => [ \*(Aqfoo\*(Aq ] );
.Ve
.IP "\(bu" 4
Rewriting
.Sp
Returns one or more array references with different meta-method
types and arguments to use.
.Sp
For example, the below meta-method definition reviews the name of
each method it's passed and creates different types of meta-methods
based on whether the declared name is in all upper case:
.Sp
.Vb 2
\&  package My::UpperCaseMethods;
\&  use Class::MakeMethods \*(Aq\-isasubclass\*(Aq;
\&
\&  sub auto_detect { 
\&    my $class = shift;
\&    my @rewrite = ( [ \*(AqBasic::Hash:scalar\*(Aq ], 
\&                    [ \*(Aq::My::UpperCaseMethods:uc_scalar\*(Aq ] );
\&    foreach ( @_ ) {
\&      my $name_is_uppercase = ( $_ eq uc($_) ) ? 1 : 0;
\&      push @{ $rewrite[ $name_is_uppercase ] }, $_
\&    }
\&    return @rewrite;
\&  }
.Ve
.Sp
The following invocation would then generate a regular scalar accessor method foo, and a uc_scalar method \s-1BAR:\s0
.Sp
.Vb 1
\&  use My::UpperCaseMethods ( \*(Aqauto_detect\*(Aq => [ \*(Aqfoo\*(Aq, \*(AqBAR\*(Aq ] );
.Ve
.IP "\(bu" 4
Generator Object
.Sp
Returns an object with a method named make_methods which will be responsible for returning subroutine name/code pairs.
.Sp
See Class::MakeMethods::Template for an example.
.IP "\(bu" 4
Self-Contained
.Sp
Your code may do whatever it wishes, and return an empty list.
.SS "Access to Options"
.IX Subsection "Access to Options"
Global option values are available through the \fI_context()\fR class method at the time that method generation is being performed.
.PP
.Vb 6
\&  package My::Maker;
\&  sub my_methodtype {
\&    my $class = shift;
\&    warn "Installing in " . $class\->_context(\*(AqTargetClass\*(Aq);
\&    ...
\&  }
.Ve
.IP "\(bu" 4
TargetClass
.Sp
Class into which code should be installed.
.IP "\(bu" 4
MakerClass
.Sp
Which subclass of Class::MakeMethods will generate the methods?
.IP "\(bu" 4
ForceInstall
.Sp
Controls whether generated methods will be installed over pre-existing methods in the target package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "License and Support"
.IX Subsection "License and Support"
For distribution, installation, support, copyright and license 
information, see Class::MakeMethods::Docs::ReadMe.
.SS "Package Documentation"
.IX Subsection "Package Documentation"
A collection of sample uses is available in
Class::MakeMethods::Docs::Examples.
.PP
See the documentation for each family of subclasses:
.IP "\(bu" 4
Class::MakeMethods::Basic
.IP "\(bu" 4
Class::MakeMethods::Standard
.IP "\(bu" 4
Class::MakeMethods::Composite
.IP "\(bu" 4
Class::MakeMethods::Template
.PP
A listing of available method types from each of the different subclasses
is provided in Class::MakeMethods::Docs::Catalog.
.SS "Related Modules"
.IX Subsection "Related Modules"
For a brief survey of the numerous modules on \s-1CPAN\s0 which offer some type
of method generation, see Class::MakeMethods::Docs::RelatedModules.
.PP
In several cases, Class::MakeMethods provides functionality closely
equivalent to that of an existing module, and emulator modules are provided
to map the existing module's interface to that of Class::MakeMethods.
See Class::MakeMethods::Emulator for more information.
.PP
If you have used Class::MethodMaker, you will note numerous similarities
between the two.  Class::MakeMethods is based on Class::MethodMaker, but
has been substantially revised in order to provide a range of new features.
Backward compatibility and conversion documentation is provded in
Class::MakeMethods::Emulator::MethodMaker.
.SS "Perl Docs"
.IX Subsection "Perl Docs"
See perlboot for a quick introduction to objects for beginners.  For
an extensive discussion of various approaches to class construction, see
perltoot and perltootc (called perltootc in the most recent
versions of Perl).
.PP
See \*(L"Making References\*(R" in perlref, point 4 for more information on
closures. (\s-1FWIW\s0, I think there's a big opportunity for a \*(L"perlfunt\*(R" podfile
bundled with Perl in the tradition of \*(L"perlboot\*(R" and \*(L"perltoot\*(R", exploring
the utility of function references, callbacks, closures, and
continuations... There are a bunch of useful references available, but
not a good overview of how they all interact in a Perlish way.)
