.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Manual::Rendering 3"
.TH HTML::FormHandler::Manual::Rendering 3 "2012-02-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Manual::Rendering \- how to render with FormHandler
.SH "VERSION"
.IX Header "VERSION"
version 0.36002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
You can easily build any kind of renderer for FormHandler. A custom
renderer could be a separate object or class that takes a form object,
or a role that is applied to your form. Since the primary use of
FormHandler is for \s-1HTML\s0 forms, the built-in rendering methods create
\&\s-1HTML\s0 (though in addition all forms can return a hashref of the values
and a hashref of the values to use to fill in an \s-1HTML\s0 form).
.PP
If you are interested in creating your own renderer,
HTML::FormHandler::Render::Simple can be used as an example of
rendering directly from forms/fields. Depending on what kind of
rendering you want to do, it may be simpler to take the 'value'
hashref and use that.
.PP
\&\s-1HFH\s0 has a number of different rendering methods:
.PP
.Vb 5
\&   1. Handcoded html with no assist from HFH at all
\&   2. Use templates and the field \*(Aqwidget\*(Aq to determine the template snippet
\&   3. Use a rendering role in your form class, like Render::Simple
\&   4. Automatically installed rendering widgets using a combination of
\&      rendering roles, which can easily be customized by the user.
.Ve
.PP
With all of the rendering roles, it is impossible to make improvements
and additions to rendering without changes to the output, so you should
consider either using your own versions of the rendering objects, or
carefully inspecting the output when installing new versions of FormHandler.
.SS "Handcoded \s-1HTML\s0"
.IX Subsection "Handcoded HTML"
The names of your fields must match the names of your FormHandler fields.
If you use compound fields, you must use the FormHandler naming convention.
If you want your fields automatically filled, you probably need to
use HTML::FillInForm in some manner. If you use Select fields, you
must take care that the select lists in your \s-1HTML\s0 do not get out of
sync with the Select lists in FormHandler. A totally hand-built solution
would be difficult for Compound and Repeatable fields.
.PP
The best alternative may be to render some of the \s-1HTML\s0 by hand, but use
FormHandler to display the field elements:
.PP
.Vb 1
\&   [% form.field(\*(Aqtitle\*(Aq).render %]
.Ve
.PP
If you wish to loop through the fields yourself, use the 'sorted_fields'
method, since it skips inactive fields and handles the 'order' attribute.
.PP
FormHandler is not a template system, so unless your form is very simple,
rendering the entire form page only with FormHandler may not be the best solution.
It's great for scaffolding, or simple admin forms, but user facing forms
may need some degree of hand-building.
.PP
It is *possible* to do fairly complex form rendering in FormHandler.
Whether it makes sense for your application is something you have to decide.
The rendering roles make it easy to integrate other types of templating.
.SS "Use Render::Simple/Table or rendering widgets?"
.IX Subsection "Use Render::Simple/Table or rendering widgets?"
The form and fields rendering widgets will be automatically applied unless
a 'render' method already exists, so if your form class applies a role like:
.PP
.Vb 1
\&   with \*(AqHTML::FormHandler::Render::Simple\*(Aq;
.Ve
.PP
then HTML::FormHandler::Widget::Form::Simple' will not be applied.
.PP
The advantage of an all-in-one type role is that you can include all of
your rendering code for a particular form in one file. You could even
have one renderer for each form. The widgets are more atomic, so may
make widget reuse easier.
.PP
Note: if you're using a rendering role, and not using the field widgets
(it's possible to use both) there is a flag in the form 'no_widgets' which
will skip applying the widget roles to individual fields.
.SS "Rendering with Widgets"
.IX Subsection "Rendering with Widgets"
All FormHandler widgets are Moose roles.  Default widget roles are found in the
HTML::FormHandler::Widget directory. They include widgets for the fields in the
distribution. Field and wrapper widgets are automatically applied to fields,
Each field can render itself with \f(CW\*(C`$field\->render\*(C'\fR.
.PP
The name space used to look for the widget roles can be specified on a form or
field basis by setting 'widget_name_space' to an arrayref of name spaces:
.PP
.Vb 2
\&   has \*(Aq+widget_name_space\*(Aq => ( default => sub { [\*(AqMyApp::Form::Submit\*(Aq,
\&       \*(AqMyApp::Form::Widget\*(Aq ]);
.Ve
.PP
The HTML::FormHandler::Widget name space is always searched as the last name space.
This means that you can set up an application or form specific set of widgets.
.PP
Widgets in a widget directory (specified in widget_name_space) are located in either
a 'Field', 'Wrapper', or 'Form' subdirectory.
.PP
The form's rendering role is looked for in the widget name space plus 'Form'. The
default form rendering roles are in HTML::FormHandler::Widget::Form (Simple
and Table).  The form widget is specified in the form with 'widget_form'.
.PP
.Vb 4
\&   package MyApp::Form;
\&   ....
\&   has \*(Aq+widget_form\*(Aq => ( default => \*(AqSimple\*(Aq );
\&   ...
.Ve
.PP
The 'wrapper' for field rendering can also be specified with 'widget_wrapper'.
The widget specified will be looked for in the widget directories' 'Wrapper'
subdirectory. It contains a 'wrap_field' method which is called from the Field
widgets.  The wrap_field method takes the basic rendered field (passed from the
field widget) and wraps it with \s-1HTML\s0. The defaults provided are 'Div' and 'Table'.
You can specify a wrapper class for all the fields in the form by setting
\&'widget_wrapper' in the form class, or you can set them individually by setting
\&'widget_wrapper' on individual fields.
.PP
.Vb 1
\&   has_field \*(Aqsome_field\*(Aq => ( widget_wrapper => \*(AqMyWrapper\*(Aq );
.Ve
.PP
The 'widget' attribute is set to a default in FormHandler fields, or you can
set it to a different widget in your field declarations.
.PP
.Vb 4
\&   has_field \*(Aqanother_field\*(Aq => (
\&     widget => \*(AqMyWidget\*(Aq,
\&     widget_wrapper => \*(AqMyWrapper\*(Aq
\&   );
.Ve
.PP
Can be set in the form:
.PP
.Vb 3
\&   widget_name_space
\&   widget_wrapper
\&   widget_form
.Ve
.PP
Can be set in the field:
.PP
.Vb 3
\&   widget_name_space
\&   widget_wrapper
\&   widget
.Ve
.PP
The widget_name_space and widget_wrapper will be copied into the fields from the
form if they are not already defined.
.PP
By default, a form will use the Form::Simple and Wrapper::Simple widgets. If you
want to use the table format you can change the 'widget_form' and 'widget_wrapper'
attributes in the form, or do it on new:
.PP
.Vb 4
\&   my $form = MyApp::Form\->new(
\&     widget_form => \*(AqTable\*(Aq,
\&     widget_wrapper => \*(AqTable\*(Aq
\&   );
.Ve
.SS "\s-1HTML\s0 attributes"
.IX Subsection "HTML attributes"
Arbitrary \s-1HTML\s0 attributes on form elements (such as 'input' elements) can be specified
with 'html_attr' on the field. You can also set html attributes for the label with
\&'label_attr' and html attributes for the wrapper with 'wrapper_attr'. See the
documentation in HTML::FormHandler::Field#Attributes_for_creating_HTML.
.SS "Rendering bare html with no fieldset and no divs"
.IX Subsection "Rendering bare html with no fieldset and no divs"
Use a widget_wrapper of 'None', and set widget_tag 'no_auto_fieldset' to 1:
.PP
.Vb 3
\&    package Test::Form;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has \*(Aq+name\*(Aq => ( default => \*(Aqtestform\*(Aq );
\&    has \*(Aq+widget_wrapper\*(Aq => ( default => \*(AqNone\*(Aq );
\&    has \*(Aq+widget_tags\*(Aq => ( default => sub { { no_auto_fieldset => 1 } } );
\&    has_field \*(Aqfoo\*(Aq;
\&    has_field \*(Aqbar\*(Aq;
.Ve
.PP
Renders:
.PP
.Vb 4
\&    <form id="testform" method="post" >
\&    <input type="text" name="foo" id="foo" value="" />
\&    <input type="text" name="bar" id="bar" value="" />
\&    </form>
.Ve
.PP
Or you can use individual field rendering and produce your own html
to wrap around it:
.PP
.Vb 6
\&    <div class="my_class">
\&    [% form.field(\*(Aqfoo\*(Aq).render %]
\&    </div>
\&    <div class="another_class">
\&    [% form.field(\*(Aqbar\*(Aq).render %]
\&    </div>
.Ve
.SS "Rendering filter for fill-in-form values"
.IX Subsection "Rendering filter for fill-in-form values"
The base field class has a 'render_filter' attribute which is a coderef used to
clean the values used to fill in the form for Render::Simple and the Widgets.
The default filter changes quote, ampersand, <, and > to the equivalent html
entities. If you wish to use some other sort of filtering, you can set use
\&'render_filter' method in your form, or set a coderef on individual field
objects. A 'render_filter' function in your form will be used by all fields.
Setting it for a field will just be for that field.
.PP
.Vb 7
\&    sub render_filter {
\&        my $string = shift;
\&        $string =~ s/my/MY/g; # perform some kind of transformation
\&        return $string;
\&    }
\&    \-\- or \-\-
\&    has_field \*(Aqfoo\*(Aq => ( render_filter => sub { ... } );
.Ve
.PP
The filter is called in Render::Simple in the widgets with as
\&\f(CW\*(C`$self\->html_filter( $fif ) or $field\->html_filter( $fif )\*(C'\fR.
.SS "Customized Widgets"
.IX Subsection "Customized Widgets"
You can create custom widgets for your complete application or on a per-form basis.
One possible layout for your widgets;
.PP
.Vb 4
\&   lib/MyApp/Form
\&   lib/MyApp/Form/Widget/Form
\&   lib/MyApp/Form/Widget/Field (contains MyWidget.pm)
\&   lib/MyApp/Form/Widget/Wrapper
.Ve
.PP
Create custom widgets and put them in the respective directories, and then specify your
widget name space:
.PP
.Vb 5
\&   MyApp::Form::User:
\&   ...
\&   has \*(Aq+widget_name_space\*(Aq => ( default => sub { [\*(AqMyApp::Form::Widget\*(Aq] } );
\&   ..
\&   has \*(Aqsome_field\*(Aq => ( widget => \*(AqMyWidget\*(Aq );
.Ve
.PP
Your rendering widgets will be applied into your field classes.
.SS "widget_tags"
.IX Subsection "widget_tags"
The 'widget_tags' hashref attribute has been provided to allow customizing
rendering behavior on a per-field basis. FormHandler has a number of flags/settings
that it uses; you can add your own for your custom rendering code.
.PP
.Vb 6
\&    wrapper_tag    \-\- the tag to use in the wrapper, default \*(Aqdiv\*(Aq
\&    wrapper_start  \-\- replaces the entire wrapper start html code
\&    wrapper_end    \-\- replaces the entire wrapper end html code
\&    label_no_colon \-\- don\*(Aqt put a \*(Aq: \*(Aq following the label
\&    no_auto_fieldset \-\- don\*(Aqt put a fieldset around main form
\&    no_compound_wrapper \-\- don\*(Aqt put a fieldset wrapper around compound fields
.Ve
.PP
They can be used to switch the Simple
wrapper from divs to using paragraphs instead, or to suppress the colon in
label formatting:
.PP
.Vb 2
\&   has_field \*(Aqmy_field\*(Aq => (
\&       widget_tags => {wrapper_tag => \*(Aqp\*(Aq, label_no_colon => 1  } );
.Ve
.PP
If you want just the plain html (including the label) with no wrapping div or
other element, you can set the wrapper_start and wrapper_end to ''.
.PP
.Vb 3
\&   has_field \*(Aqbaz\*(Aq => ( widget_tags => { wrapper_start => \*(Aq\*(Aq,
\&        wrapper_end => \*(Aq\*(Aq } );
\&   <label class="label" for="baz">Baz: </label><input type="text" name="baz" id="baz" value="" />
.Ve
.PP
Widget tags set for the form will be copied into the fields if the same key
does not exist in the field 'wrapper_tags' hashref, so you can set the
widget_tags in a form to apply them to all the fields:
.PP
.Vb 4
\&   package MyApp::Form;
\&   ....
\&   has \*(Aq+widget_tags\*(Aq => ( default => sub { {wrapper_start => \*(Aq<p>\*(Aq,
\&      wrapper_end => \*(Aq</p>\*(Aq } } );
.Ve
.SS "Creating Widgets"
.IX Subsection "Creating Widgets"
The new widgets are designed to be used with either the FormHandler
form/field objects or the HTML::FormHandler::Result objects. For that reason,
you should use \f(CW\*(C`$field\->result\*(C'\fR to access the current value, errors and
\&'fif' (fill-in-form) in field widgets, so that they will work
for both form and result rendering.
.PP
The basic structure for a field widget:
.PP
.Vb 2
\&   package MyApp::Form::Widget::Field::MyWidget;
\&   use Moose::Role;
\&
\&   sub render {
\&      my ( $self, $result ) = @_;
\&
\&      $result ||= $self\->result;
\&      my $output;
\&      < create rendered field >
\&      my $fif = $result\->fif;
\&      my $value = $result\->value;
\&      my $errors = $result\->errors;
\&      < done creating rendered field )
\&      return $self\->wrap_field($result, $output);
\&   }
\&   use namespace::autoclean;
\&   1;
.Ve
.PP
Although the shipped widgets use a wrapper method, it is not necessary for
you to do that in your widgets.
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
