.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DateTime::Format::Builder 3"
.TH DateTime::Format::Builder 3 "2012-02-19" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DateTime::Format::Builder \- Create DateTime parser classes and objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    package DateTime::Format::Brief;
\&    our $VERSION = \*(Aq0.07\*(Aq;
\&    use DateTime::Format::Builder
\&    (
\&        parsers => {
\&            parse_datetime => [
\&            {
\&                regex => qr/^(\ed{4})(\ed\ed)(\ed\ed)(\ed\ed)(\ed\ed)(\ed\ed)$/,
\&                params => [qw( year month day hour minute second )],
\&            },
\&            {
\&                regex => qr/^(\ed{4})(\ed\ed)(\ed\ed)$/,
\&                params => [qw( year month day )],
\&            },
\&            ],
\&        }
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DateTime::Format::Builder creates DateTime parsers.
Many string formats of dates and times are simple and just
require a basic regular expression to extract the relevant
information. Builder provides a simple way to do this
without writing reams of structural code.
.PP
Builder provides a number of methods, most of which you'll
never need, or at least rarely need. They're provided more
for exposing of the module's innards to any subclasses, or
for when you need to do something slightly beyond what I
expected.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
See DateTime::Format::Builder::Tutorial.
.SH "ERROR HANDLING AND BAD PARSES"
.IX Header "ERROR HANDLING AND BAD PARSES"
Often, I will speak of \f(CW\*(C`undef\*(C'\fR being returned, however
that's not strictly true.
.PP
When a simple single specification is given for a method,
the method isn't given a single parser directly. It's given
a wrapper that will call \f(CW\*(C`on_fail()\*(C'\fR if the single parser
returns \f(CW\*(C`undef\*(C'\fR. The single parser must return \f(CW\*(C`undef\*(C'\fR so
that a multiple parser can work nicely and actual errors can
be thrown from any of the callbacks.
.PP
Similarly, any multiple parsers will only call \f(CW\*(C`on_fail()\*(C'\fR
right at the end when it's tried all it could.
.PP
\&\f(CW\*(C`on_fail()\*(C'\fR (see later) is defined, by default,
to throw an error.
.PP
Multiple parser specifications can also specify \f(CW\*(C`on_fail\*(C'\fR
with a coderef as an argument in the options block. This
will take precedence over the inheritable and over-ridable
method.
.PP
That said, don't throw real errors from callbacks in
multiple parser specifications unless you really want
parsing to stop right there and not try any other parsers.
.PP
In summary: calling a \fBmethod\fR will result in either a
\&\f(CW\*(C`DateTime\*(C'\fR object being returned or an error being thrown
(unless you've overridden \f(CW\*(C`on_fail()\*(C'\fR or
\&\f(CW\*(C`create_method()\*(C'\fR, or you've specified a \f(CW\*(C`on_fail\*(C'\fR key to
a multiple parser specification).
.PP
Individual \fBparsers\fR (be they multiple parsers or single
parsers) will return either the \f(CW\*(C`DateTime\*(C'\fR object or
\&\f(CW\*(C`undef\*(C'\fR.
.SH "SINGLE SPECIFICATIONS"
.IX Header "SINGLE SPECIFICATIONS"
A single specification is a hash ref of instructions
on how to create a parser.
.PP
The precise set of keys and values varies according to parser
type. There are some common ones though:
.IP "\(bu" 4
\&\fBlength\fR is an optional parameter that can be used to
specify that this particular \fIregex\fR is only applicable to
strings of a certain fixed length. This can be used to make
parsers more efficient. It's strongly recommended that any
parser that can use this parameter does.
.Sp
You may happily specify the same length twice. The parsers
will be tried in order of specification.
.Sp
You can also specify multiple lengths by giving it an
arrayref of numbers rather than just a single scalar.
If doing so, please keep the number of lengths to a minimum.
.Sp
If any specifications without \fIlength\fRs are given and the
particular \fIlength\fR parser fails, then the non\-\fIlength\fR
parsers are tried.
.Sp
This parameter is ignored unless the specification is part
of a multiple parser specification.
.IP "\(bu" 4
\&\fBlabel\fR provides a name for the specification and is passed
to some of the callbacks about to mentioned.
.IP "\(bu" 4
\&\fBon_match\fR and \fBon_fail\fR are callbacks. Both routines will
be called with parameters of:
.RS 4
.IP "\(bu" 4
\&\fBinput\fR, being the input to the parser (after any
preprocessing callbacks).
.IP "\(bu" 4
\&\fBlabel\fR, being the label of the parser, if there is one.
.IP "\(bu" 4
\&\fBself\fR, being the object on which the method has been
invoked (which may just be a class name). Naturally, you
can then invoke your own methods on it do get information
you want.
.IP "\(bu" 4
\&\fBargs\fR, being an arrayref of any passed arguments, if any.
If there were no arguments, then this parameter is not given.
.RE
.RS 4
.Sp
These routines will be called depending on whether the
\&\fBregex\fR match succeeded or failed.
.RE
.IP "\(bu" 4
\&\fBpreprocess\fR is a callback provided for cleaning up input
prior to parsing. It's given a hash as arguments with the
following keys:
.RS 4
.IP "\(bu" 4
\&\fBinput\fR being the datetime string the parser was given (if
using multiple specifications and an overall \fIpreprocess\fR
then this is the date after it's been through that
preprocessor).
.IP "\(bu" 4
\&\fBparsed\fR being the state of parsing so far. Usually empty
at this point unless an overall \fIpreprocess\fR was given.
Items may be placed in it and will be given to any
\&\fBpostprocess\fRor and \f(CW\*(C`DateTime\->new\*(C'\fR (unless the
postprocessor deletes it).
.IP "\(bu" 4
\&\fBself\fR, \fBargs\fR, \fBlabel\fR as per \fIon_match\fR and \fIon_fail\fR.
.RE
.RS 4
.Sp
The return value from the routine is what is given to the
\&\fIregex\fR. Note that this is last code stop before the match.
.Sp
\&\fBNote\fR: mixing \fIlength\fR and a \fIpreprocess\fR that modifies
the length of the input string is probably not what you
meant to do. You probably meant to use the
\&\fImultiple parser\fR variant of \fIpreprocess\fR which is done
\&\fBbefore\fR any length calculations. This \f(CW\*(C`single parser\*(C'\fR variant
of \fIpreprocess\fR is performed \fBafter\fR any length
calculations.
.RE
.IP "\(bu" 4
\&\fBpostprocess\fR is the last code stop before
\&\f(CW\*(C`DateTime\->new()\*(C'\fR is called. It's given the same
arguments as \fIpreprocess\fR. This allows it to modify the
parsed parameters after the parse and before the creation
of the object. For example, you might use:
.Sp
.Vb 5
\&    {
\&        regex  => qr/^(\ed\ed) (\ed\ed) (\ed\ed)$/,
\&        params => [qw( year  month  day   )],
\&        postprocess => \e&_fix_year,
\&    }
.Ve
.Sp
where \f(CW\*(C`_fix_year\*(C'\fR is defined as:
.Sp
.Vb 7
\&    sub _fix_year
\&    {
\&        my %args = @_;
\&        my ($date, $p) = @args{qw( input parsed )};
\&        $p\->{year} += $p\->{year} > 69 ? 1900 : 2000;
\&        return 1;
\&    }
.Ve
.Sp
This will cause the two digit years to be corrected
according to the cut off. If the year was '69' or lower,
then it is made into 2069 (or 2045, or whatever the year was
parsed as). Otherwise it is assumed to be 19xx. The
DateTime::Format::Mail module uses code similar to this
(only it allows the cut off to be configured and it doesn't
use Builder).
.Sp
\&\fBNote\fR: It is \fBvery important\fR to return an explicit value
from the \fIpostprocess\fR callback. If the return value is
false then the parse is taken to have failed. If the return
value is true, then the parse is taken to have succeeded and
\&\f(CW\*(C`DateTime\->new()\*(C'\fR is called.
.PP
See the documentation for the individual parsers for their
valid keys.
.PP
Parsers at the time of writing are:
.IP "\(bu" 4
DateTime::Format::Builder::Parser::Regex \- provides regular
expression based parsing.
.IP "\(bu" 4
DateTime::Format::Builder::Parser::Strptime \- provides strptime
based parsing.
.SS "Subroutines / coderefs as specifications."
.IX Subsection "Subroutines / coderefs as specifications."
A single parser specification can be a coderef. This was
added mostly because it could be and because I knew someone,
somewhere, would want to use it.
.PP
If the specification is a reference to a piece of code, be
it a subroutine, anonymous, or whatever, then it's passed
more or less straight through. The code should return
\&\f(CW\*(C`undef\*(C'\fR in event of failure (or any false value,
but \f(CW\*(C`undef\*(C'\fR is strongly preferred), or a true value in the
event of success (ideally a \f(CW\*(C`DateTime\*(C'\fR object or some
object that has the same interface).
.PP
This all said, I generally wouldn't recommend using this
feature unless you have to.
.SS "Callbacks"
.IX Subsection "Callbacks"
I mention a number of callbacks in this document.
.PP
Any time you see a callback being mentioned, you can,
if you like, substitute an arrayref of coderefs rather
than having the straight coderef.
.SH "MULTIPLE SPECIFICATIONS"
.IX Header "MULTIPLE SPECIFICATIONS"
These are very easily described as an array of single
specifications.
.PP
Note that if the first element of the array is an arrayref,
then you're specifying options.
.IP "\(bu" 4
\&\fBpreprocess\fR lets you specify a preprocessor that is called
before any of the parsers are tried. This lets you do things
like strip off timezones or any unnecessary data. The most
common use people have for it at present is to get the input
date to a particular length so that the \fIlength\fR is usable
(DateTime::Format::ICal would use it to strip off the
variable length timezone).
.Sp
Arguments are as for the \fIsingle parser\fR \fIpreprocess\fR
variant with the exception that \fIlabel\fR is never given.
.IP "\(bu" 4
\&\fBon_fail\fR should be a reference to a subroutine that is
called if the parser fails. If this is not provided, the
default action is to call
\&\f(CW\*(C`DateTime::Format::Builder::on_fail\*(C'\fR, or the \f(CW\*(C`on_fail\*(C'\fR
method of the subclass of \s-1DTFB\s0 that was used to create the
parser.
.SH "EXECUTION FLOW"
.IX Header "EXECUTION FLOW"
Builder allows you to plug in a fair few callbacks, which
can make following how a parse failed (or succeeded
unexpectedly) somewhat tricky.
.SS "For Single Specifications"
.IX Subsection "For Single Specifications"
A single specification will do the following:
.PP
User calls parser:
.PP
.Vb 1
\&       my $dt = $class\->parse_datetime( $string );
.Ve
.IP "1." 4
\&\fIpreprocess\fR is called. It's given \f(CW$string\fR and a
reference to the parsing workspace hash, which we'll call
\&\f(CW$p\fR. At this point, \f(CW$p\fR is empty. The return value is
used as \f(CW$date\fR for the rest of this single parser.
Anything put in \f(CW$p\fR is also used for the rest of this
single parser.
.IP "2." 4
\&\fIregex\fR is applied.
.IP "3." 4
If \fIregex\fR \fBdid not\fR match, then \fIon_fail\fR is called (and is given
\&\f(CW$date\fR and also \fIlabel\fR if it was defined). Any return
value is ignored and the next thing is for the single
parser to return \f(CW\*(C`undef\*(C'\fR.
.Sp
If \fIregex\fR \fBdid\fR match, then \fIon_match\fR is called with
the same arguments as would be given to \fIon_fail\fR. The
return value is similarly ignored, but we then move to step
4 rather than exiting the parser.
.IP "4." 4
\&\fIpostprocess\fR is called with \f(CW$date\fR and a filled out
\&\f(CW$p\fR. The return value is taken as a indication of whether
the parse was a success or not. If it wasn't a success then
the single parser will exit at this point, returning undef.
.IP "5." 4
\&\f(CW\*(C`DateTime\->new()\*(C'\fR is called and the user is given the
resultant \f(CW\*(C`DateTime\*(C'\fR object.
.PP
See the section on error handling
regarding the \f(CW\*(C`undef\*(C'\fRs mentioned above.
.SS "For Multiple Specifications"
.IX Subsection "For Multiple Specifications"
With multiple specifications:
.PP
User calls parser:
.PP
.Vb 1
\&      my $dt = $class\->complex_parse( $string );
.Ve
.IP "1." 4
The overall \fIpreprocess\fRor is called and is given \f(CW$string\fR
and the hashref \f(CW$p\fR (identically to the per parser
\&\fIpreprocess\fR mentioned in the previous flow).
.Sp
If the callback modifies \f(CW$p\fR then a \fBcopy\fR of \f(CW$p\fR is
given to each of the individual parsers.  This is so parsers
won't accidentally pollute each other's workspace.
.IP "2." 4
If an appropriate length specific parser is found, then it
is called and the single parser flow (see the previous
section) is followed, and the parser is given a copy of
\&\f(CW$p\fR and the return value of the overall \fIpreprocess\fRor as
\&\f(CW$date\fR.
.Sp
If a \f(CW\*(C`DateTime\*(C'\fR object was returned so we go straight back
to the user.
.Sp
If no appropriate parser was found, or the parser returned
\&\f(CW\*(C`undef\*(C'\fR, then we progress to step 3!
.IP "3." 4
Any non\-\fIlength\fR based parsers are tried in the order they
were specified.
.Sp
For each of those the single specification flow above is
performed, and is given a copy of the output from the
overall preprocessor.
.Sp
If a real \f(CW\*(C`DateTime\*(C'\fR object is returned then we exit back
to the user.
.Sp
If no parser could parse, then an error is thrown.
.PP
See the section on error handling
regarding the \f(CW\*(C`undef\*(C'\fRs mentioned above.
.SH "METHODS"
.IX Header "METHODS"
In the general course of things you won't need any of the
methods. Life often throws unexpected things at us so the
methods are all available for use.
.SS "import"
.IX Subsection "import"
\&\f(CW\*(C`import()\*(C'\fR is a wrapper for \f(CW\*(C`create_class()\*(C'\fR. If you
specify the \fIclass\fR option (see documentation for
\&\f(CW\*(C`create_class()\*(C'\fR) it will be ignored.
.SS "create_class"
.IX Subsection "create_class"
This method can be used as the runtime equivalent of
\&\f(CW\*(C`import()\*(C'\fR. That is, it takes the exact same parameters as
when one does:
.PP
.Vb 1
\&   use DateTime::Format::Builder ( blah blah blah )
.Ve
.PP
That can be (almost) equivalently written as:
.PP
.Vb 2
\&   use DateTime::Format::Builder;
\&   DateTime::Format::Builder\->create_class( blah blah blah );
.Ve
.PP
The difference being that the first is done at compile time
while the second is done at run time.
.PP
In the tutorial I said there were only two parameters at
present. I lied. There are actually three of them.
.IP "\(bu" 4
\&\fBparsers\fR takes a hashref of methods and their parser
specifications. See the
tutorial above for details.
.Sp
Note that if you define a subroutine of the same name as one
of the methods you define here, an error will be thrown.
.IP "\(bu" 4
\&\fBconstructor\fR determines whether and how to create a
\&\f(CW\*(C`new()\*(C'\fR function in the new class. If given a true value, a
constructor is created. If given a false value, one isn't.
.Sp
If given an anonymous sub or a reference to a sub then that
is used as \f(CW\*(C`new()\*(C'\fR.
.Sp
The default is \f(CW1\fR (that is, create a constructor using
our default code which simply creates a hashref and blesses
it).
.Sp
If your class defines its own \f(CW\*(C`new()\*(C'\fR method it will not be
overwritten. If you define your own \f(CW\*(C`new()\*(C'\fR and \fBalso\fR tell
Builder to define one an error will be thrown.
.IP "\(bu" 4
\&\fBverbose\fR takes a value. If the value is undef, then
logging is disabled. If the value is a filehandle then
that's where logging will go. If it's a true value, then
output will go to \f(CW\*(C`STDERR\*(C'\fR.
.Sp
Alternatively, call \f(CW\*(C`$DateTime::Format::Builder::verbose()\*(C'\fR
with the relevant value. Whichever value is given more
recently is adhered to.
.Sp
Be aware that verbosity is a global wide setting.
.IP "\(bu" 4
\&\fBclass\fR is optional and specifies the name of the class in
which to create the specified methods.
.Sp
If using this method in the guise of \f(CW\*(C`import()\*(C'\fR then this
field will cause an error so it is only of use when calling
as \f(CW\*(C`create_class()\*(C'\fR.
.IP "\(bu" 4
\&\fBversion\fR is also optional and specifies the value to give
\&\f(CW$VERSION\fR in the class. It's generally not recommended
unless you're combining with the \fIclass\fR option. A
\&\f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR / \f(CW\*(C`CPAN\*(C'\fR compliant version
specification is much better.
.PP
In addition to creating any of the methods it also creates a
\&\f(CW\*(C`new()\*(C'\fR method that can instantiate (or clone) objects.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
In the rest of the documentation I've often lied in order to
get some of the ideas across more easily. The thing is, this
module's very flexible. You can get markedly different
behaviour from simply subclassing it and overriding some
methods.
.SS "create_method"
.IX Subsection "create_method"
Given a parser coderef, returns a coderef that is suitable
to be a method.
.PP
The default action is to call \f(CW\*(C`on_fail()\*(C'\fR in the event of a
non-parse, but you can make it do whatever you want.
.SS "on_fail"
.IX Subsection "on_fail"
This is called in the event of a non-parse (unless you've
overridden \f(CW\*(C`create_method()\*(C'\fR to do something else.
.PP
The single argument is the input string. The default action
is to call \f(CW\*(C`croak()\*(C'\fR. Above, where I've said parsers or
methods throw errors, this is the method that is doing the
error throwing.
.PP
You could conceivably override this method to, say, return
\&\f(CW\*(C`undef\*(C'\fR.
.SH "USING BUILDER OBJECTS aka USERS USING BUILDER"
.IX Header "USING BUILDER OBJECTS aka USERS USING BUILDER"
The methods listed in the \s-1METHODS\s0 section are all you
generally need when creating your own class. Sometimes
you may not want a full blown class to parse something just
for this one program. Some methods are provided to make that
task easier.
.SS "new"
.IX Subsection "new"
The basic constructor. It takes no arguments, merely returns
a new \f(CW\*(C`DateTime::Format::Builder\*(C'\fR object.
.PP
.Vb 1
\&    my $parser = DateTime::Format::Builder\->new();
.Ve
.PP
If called as a method on an object (rather than as a class
method), then it clones the object.
.PP
.Vb 1
\&    my $clone = $parser\->new();
.Ve
.SS "clone"
.IX Subsection "clone"
Provided for those who prefer an explicit \f(CW\*(C`clone()\*(C'\fR method
rather than using \f(CW\*(C`new()\*(C'\fR as an object method.
.PP
.Vb 1
\&    my $clone_of_clone = $clone\->clone();
.Ve
.SS "parser"
.IX Subsection "parser"
Given either a single or multiple parser specification, sets
the object to have a parser based on that specification.
.PP
.Vb 4
\&    $parser\->parser(
\&        regex  => qr/^ (\ed{4}) (\ed\ed) (\ed\ed) $/x;
\&        params => [qw( year    month  day    )],
\&    );
.Ve
.PP
The arguments given to \f(CW\*(C`parser()\*(C'\fR are handed directly to
\&\f(CW\*(C`create_parser()\*(C'\fR. The resultant parser is passed to
\&\f(CW\*(C`set_parser()\*(C'\fR.
.PP
If called as an object method, it returns the object.
.PP
If called as a class method, it creates a new object, sets
its parser and returns that object.
.SS "set_parser"
.IX Subsection "set_parser"
Sets the parser of the object to the given parser.
.PP
.Vb 1
\&   $parser\->set_parser( $coderef );
.Ve
.PP
Note: this method does not take specifications. It also does
not take anything except coderefs. Luckily, coderefs are
what most of the other methods produce.
.PP
The method return value is the object itself.
.SS "get_parser"
.IX Subsection "get_parser"
Returns the parser the object is using.
.PP
.Vb 1
\&   my $code = $parser\->get_parser();
.Ve
.SS "parse_datetime"
.IX Subsection "parse_datetime"
Given a string, it calls the parser and returns the
\&\f(CW\*(C`DateTime\*(C'\fR object that results.
.PP
.Vb 1
\&   my $dt = $parser\->parse_datetime( "1979 07 16" );
.Ve
.PP
The return value, if not a \f(CW\*(C`DateTime\*(C'\fR object, is whatever
the parser wants to return. Generally this means that if the
parse failed an error will be thrown.
.SS "format_datetime"
.IX Subsection "format_datetime"
If you call this function, it will throw an errror.
.SH "LONGER EXAMPLES"
.IX Header "LONGER EXAMPLES"
Some longer examples are provided in the distribution. These
implement some of the common parsing DateTime modules using
Builder. Each of them are, or were, drop in replacements for
the modules at the time of writing them.
.SH "THANKS"
.IX Header "THANKS"
Dave Rolsky (\s-1DROLSKY\s0) for kickstarting the DateTime project,
writing DateTime::Format::ICal and
DateTime::Format::MySQL, and some much needed review.
.PP
Joshua Hoblitt (\s-1JHOBLITT\s0) for the concept, some of the \s-1API\s0,
impetus for writing the multilength code (both one length with
multiple parsers and single parser with multiple lengths),
blame for the Regex custom constructor code,
spotting a bug in Dispatch,
and more much needed review.
.PP
Kellan Elliott-McCrea (\s-1KELLAN\s0) for even more review,
suggestions, DateTime::Format::W3CDTF and the encouragement to
rewrite these docs almost 100%!
.PP
Claus Fa\*:rber (\s-1CFAERBER\s0) for having me get around to
fixing the auto-constructor writing, providing the
\&'args'/'self' patch, and suggesting the multi-callbacks.
.PP
Rick Measham (\s-1RICKM\s0) for DateTime::Format::Strptime
which Builder now supports.
.PP
Matthew McGillis for pointing out that \f(CW\*(C`on_fail\*(C'\fR overriding
should be simpler.
.PP
Simon Cozens (\s-1SIMON\s0) for saying it was cool.
.SH "SUPPORT"
.IX Header "SUPPORT"
Support for this module is provided via the datetime@perl.org email
list. See http://lists.perl.org/ for more details.
.PP
Alternatively, log them via the \s-1CPAN\s0 \s-1RT\s0 system via the web or email:
.PP
.Vb 2
\&    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DateTime%3A%3AFormat%3A%3ABuilder
\&    bug\-datetime\-format\-builder@rt.cpan.org
.Ve
.PP
This makes it much easier for me to track things and thus means
your problem is less likely to be neglected.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright X Iain Truskett, 2003. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.000 or,
at your option, any later version of Perl 5 you may have available.
.PP
The full text of the licences can be found in the \fIArtistic\fR and
\&\fI\s-1COPYING\s0\fR files included with this module, or in perlartistic and
perlgpl as supplied with Perl 5.8.1 and later.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally written by Iain Truskett <spoon@cpan.org>, who died on
December 29, 2003.
.PP
Maintained by Dave Rolsky <autarch@urth.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CW\*(C`datetime@perl.org\*(C'\fR mailing list.
.PP
http://datetime.perl.org/
.PP
perl, DateTime, DateTime::Format::Builder::Tutorial,
DateTime::Format::Builder::Parser
