.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Filters 3"
.TH Imager::Filters 3 "2011-11-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Filters \- Entire Image Filtering Operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Imager;
\&
\&  $img = ...;
\&
\&  $img\->filter(type=>\*(Aqautolevels\*(Aq);
\&  $img\->filter(type=>\*(Aqautolevels\*(Aq, lsat=>0.2);
\&  $img\->filter(type=>\*(Aqturbnoise\*(Aq)
\&
\&  # and lots of others
\&
\&  load_plugin("dynfilt/dyntest.so")
\&    or die "unable to load plugin\en";
\&
\&  $img\->filter(type=>\*(Aqlin_stretch\*(Aq, a=>35, b=>200);
\&
\&  unload_plugin("dynfilt/dyntest.so")
\&    or die "unable to load plugin\en";
\&
\&  $out = $img\->difference(other=>$other_img);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Filters are operations that have similar calling interface.
.IP "\fIfilter()\fR" 4
.IX Item "filter()"
Parameters:
.RS 4
.IP "\(bu" 4
type \- the type of filter, see \*(L"Types of Filters\*(R".
.IP "\(bu" 4
many other possible parameters, see \*(L"Types of Filters\*(R" below.
.RE
.RS 4
.Sp
Returns the invocant (\f(CW$self\fR) on success, returns a false value on
failure.  You can call \f(CW\*(C`$self\->errstr\*(C'\fR to determine the cause of
the failure.
.Sp
.Vb 2
\&  $self\->filter(type => $type, ...)
\&    or die $self\->errstr;
.Ve
.RE
.SS "Types of Filters"
.IX Subsection "Types of Filters"
Here is a list of the filters that are always available in Imager.
This list can be obtained by running the \f(CW\*(C`filterlist.perl\*(C'\fR script
that comes with the module source.
.PP
.Vb 4
\&  Filter          Arguments   Default value
\&  autolevels      lsat        0.1
\&                  usat        0.1
\&                  skew        0
\&
\&  bumpmap         bump lightx lighty
\&                  elevation   0
\&                  st          2
\&
\&  bumpmap_complex bump
\&                  channel     0
\&                  tx          0
\&                  ty          0
\&                  Lx          0.2
\&                  Ly          0.4
\&                  Lz          \-1 
\&                  cd          1.0 
\&                  cs          40.0
\&                  n           1.3
\&                  Ia          (0 0 0)
\&                  Il          (255 255 255)
\&                  Is          (255 255 255)
\&
\&  contrast        intensity
\&
\&  conv            coef
\&
\&  fountain        xa ya xb yb
\&                  ftype        linear
\&                  repeat       none
\&                  combine      none
\&                  super_sample none
\&                  ssample_param 4
\&                  segments(see below)
\&
\&  gaussian        stddev
\&
\&  gradgen         xo yo colors 
\&                  dist         0
\&
\&  hardinvert
\&
\&  hardinvertall
\&
\&  mosaic          size         20
\&
\&  noise           amount       3
\&                  subtype      0
\&
\&  postlevels      levels       10
\&
\&  radnoise        xo           100
\&                  yo           100
\&                  ascale       17.0
\&                  rscale       0.02
\&
\&  turbnoise       xo           0.0
\&                  yo           0.0
\&                  scale        10.0
\&
\&  unsharpmask     stddev       2.0
\&                  scale        1.0
\&
\&  watermark       wmark
\&                  pixdiff      10
\&                  tx           0
\&                  ty           0
.Ve
.PP
All parameters must have some value but if a parameter has a default
value it may be omitted when calling the filter function.
.PP
Every one of these filters modifies the image in place.
.PP
If none of the filters here do what you need, the
\&\*(L"\fItransform()\fR\*(R" in Imager::Engines or \*(L"\fItransform2()\fR\*(R" in Imager::Engines
function may be useful.
.PP
A reference of the filters follows:
.IP "autolevels" 4
.IX Item "autolevels"
scales the value of each channel so that the values in the image will
cover the whole possible range for the channel.  \f(CW\*(C`lsat\*(C'\fR and \f(CW\*(C`usat\*(C'\fR
truncate the range by the specified fraction at the top and bottom of
the range respectively.
.Sp
.Vb 3
\&  # increase contrast per channel, losing little detail
\&  $img\->filter(type=>"autolevels")
\&    or die $img\->errstr;
\&
\&  # increase contrast, losing 20% of highlight at top and bottom range
\&  $img\->filter(type=>"autolevels", lsat=>0.2, usat=>0.2)
\&    or die $img\->errstr;
.Ve
.IP "bumpmap" 4
.IX Item "bumpmap"
uses the channel \f(CW\*(C`elevation\*(C'\fR image \f(CW\*(C`bump\*(C'\fR as a bump map on your
image, with the light at (\f(CW\*(C`lightx\*(C'\fR, \f(CW\*(C`lightty\*(C'\fR), with a shadow length
of \f(CW\*(C`st\*(C'\fR.
.Sp
.Vb 3
\&  $img\->filter(type=>"bumpmap", bump=>$bumpmap_img,
\&               lightx=>10, lighty=>10, st=>5)
\&    or die $img\->errstr;
.Ve
.IP "bumpmap_complex" 4
.IX Item "bumpmap_complex"
uses the channel \f(CW\*(C`channel\*(C'\fR image \f(CW\*(C`bump\*(C'\fR as a bump map on your image.
If \f(CW\*(C`Lz < 0\*(C'\fR the three L parameters are considered to be the
direction of the light.  If \f(CW\*(C`Lz > 0\*(C'\fR the L parameters are
considered to be the light position.  \f(CW\*(C`Ia\*(C'\fR is the ambient color,
\&\f(CW\*(C`Il\*(C'\fR is the light color, \f(CW\*(C`Is\*(C'\fR is the color of specular highlights.
\&\f(CW\*(C`cd\*(C'\fR is the diffuse coefficient and \f(CW\*(C`cs\*(C'\fR is the specular
coefficient.  \f(CW\*(C`n\*(C'\fR is the shininess of the surface.
.Sp
.Vb 2
\&  $img\->filter(type=>"bumpmap_complex", bump=>$bumpmap_img)
\&    or die $img\->errstr;
.Ve
.IP "contrast" 4
.IX Item "contrast"
scales each channel by \f(CW\*(C`intensity\*(C'\fR.  Values of \f(CW\*(C`intensity\*(C'\fR < 1.0
will reduce the contrast.
.Sp
.Vb 3
\&  # higher contrast
\&  $img\->filter(type=>"contrast", intensity=>1.3)
\&    or die $img\->errstr;
\&
\&  # lower contrast
\&  $img\->filter(type=>"contrast", intensity=>0.8)
\&    or die $img\->errstr;
.Ve
.IP "conv" 4
.IX Item "conv"
performs 2 1\-dimensional convolutions on the image using the values
from \f(CW\*(C`coef\*(C'\fR.  \f(CW\*(C`coef\*(C'\fR should be have an odd length and the sum of the
coefficients must be non-zero.
.Sp
.Vb 3
\&  # sharper
\&  $img\->filter(type=>"conv", coef=>[\-0.5, 2, \-0.5 ])
\&    or die $img\->errstr;
\&
\&  # blur
\&  $img\->filter(type=>"conv", coef=>[ 1, 2, 1 ])
\&    or die $img\->errstr;
\&
\&  # error
\&  $img\->filter(type=>"conv", coef=>[ \-0.5, 1, \-0.5 ])
\&    or die $img\->errstr;
.Ve
.IP "fountain" 4
.IX Item "fountain"
renders a fountain fill, similar to the gradient tool in most paint
software.  The default fill is a linear fill from opaque black to
opaque white.  The points \f(CW\*(C`A(Cxa, ya)\*(C'\fR and \f(CW\*(C`B(xb, yb)\*(C'\fR control the
way the fill is performed, depending on the \f(CW\*(C`ftype\*(C'\fR parameter:
.RS 4
.ie n .IP """linear""" 4
.el .IP "\f(CWlinear\fR" 4
.IX Item "linear"
the fill ramps from A through to B.
.ie n .IP """bilinear""" 4
.el .IP "\f(CWbilinear\fR" 4
.IX Item "bilinear"
the fill ramps in both directions from A, where \s-1AB\s0 defines the length
of the gradient.
.ie n .IP """radial""" 4
.el .IP "\f(CWradial\fR" 4
.IX Item "radial"
A is the center of a circle, and B is a point on it's circumference.
The fill ramps from the center out to the circumference.
.ie n .IP """radial_square""" 4
.el .IP "\f(CWradial_square\fR" 4
.IX Item "radial_square"
A is the center of a square and B is the center of one of it's sides.
This can be used to rotate the square.  The fill ramps out to the
edges of the square.
.ie n .IP """revolution""" 4
.el .IP "\f(CWrevolution\fR" 4
.IX Item "revolution"
A is the center of a circle and B is a point on its circumference.  B
marks the 0 and 360 point on the circle, with the fill ramping
clockwise.
.ie n .IP """conical""" 4
.el .IP "\f(CWconical\fR" 4
.IX Item "conical"
A is the center of a circle and B is a point on it's circumference.  B
marks the 0 and point on the circle, with the fill ramping in both
directions to meet opposite.
.RE
.RS 4
.Sp
The \f(CW\*(C`repeat\*(C'\fR option controls how the fill is repeated for some
\&\f(CW\*(C`ftype\*(C'\fRs after it leaves the \s-1AB\s0 range:
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
no repeats, points outside of each range are treated as if they were
on the extreme end of that range.
.ie n .IP """sawtooth""" 4
.el .IP "\f(CWsawtooth\fR" 4
.IX Item "sawtooth"
the fill simply repeats in the positive direction
.ie n .IP """triangle""" 4
.el .IP "\f(CWtriangle\fR" 4
.IX Item "triangle"
the fill repeats in reverse and then forward and so on, in the
positive direction
.ie n .IP """saw_both""" 4
.el .IP "\f(CWsaw_both\fR" 4
.IX Item "saw_both"
the fill repeats in both the positive and negative directions (only
meaningful for a linear fill).
.ie n .IP """tri_both""" 4
.el .IP "\f(CWtri_both\fR" 4
.IX Item "tri_both"
as for triangle, but in the negative direction too (only meaningful
for a linear fill).
.RE
.RS 4
.Sp
By default the fill simply overwrites the whole image (unless you have
parts of the range 0 through 1 that aren't covered by a segment), if
any segments of your fill have any transparency, you can set the
\&\fIcombine\fR option to 'normal' to have the fill combined with the
existing pixels.  See the description of \fIcombine\fR in Imager::Fill.
.Sp
If your fill has sharp edges, for example between steps if you use
repeat set to 'triangle', you may see some aliased or ragged edges.
You can enable super-sampling which will take extra samples within the
pixel in an attempt anti-alias the fill.
.Sp
The possible values for the super_sample option are:
.IP "none" 4
.IX Item "none"
no super-sampling is done
.IP "grid" 4
.IX Item "grid"
a square grid of points are sampled.  The number of points sampled is
the square of ceil(0.5 + sqrt(ssample_param)).
.IP "random" 4
.IX Item "random"
a random set of points within the pixel are sampled.  This looks
pretty bad for low ssample_param values.
.IP "circle" 4
.IX Item "circle"
the points on the radius of a circle within the pixel are sampled.
This seems to produce the best results, but is fairly slow (for now).
.RE
.RS 4
.Sp
You can control the level of sampling by setting the ssample_param
option.  This is roughly the number of points sampled, but depends on
the type of sampling.
.Sp
The segments option is an arrayref of segments.  You really should use
the Imager::Fountain class to build your fountain fill.  Each
segment is an array ref containing:
.IP "start" 4
.IX Item "start"
a floating point number between 0 and 1, the start of the range of
fill parameters covered by this segment.
.IP "middle" 4
.IX Item "middle"
a floating point number between start and end which can be used to
push the color range towards one end of the segment.
.IP "end" 4
.IX Item "end"
a floating point number between 0 and 1, the end of the range of fill
parameters covered by this segment.  This should be greater than
start.
.IP "c0" 4
.IX Item "c0"
.PD 0
.IP "c1" 4
.IX Item "c1"
.PD
The colors at each end of the segment.  These can be either
Imager::Color or Imager::Color::Float objects.
.IP "segment type" 4
.IX Item "segment type"
The type of segment, this controls the way the fill parameter varies
over the segment. 0 for linear, 1 for curved (unimplemented), 2 for
sine, 3 for sphere increasing, 4 for sphere decreasing.
.IP "color type" 4
.IX Item "color type"
The way the color varies within the segment, 0 for simple \s-1RGB\s0, 1 for
hue increasing and 2 for hue decreasing.
.RE
.RS 4
.Sp
Don't forget to use Imager::Fountain instead of building your own.
Really.  It even loads \s-1GIMP\s0 gradient files.
.Sp
.Vb 10
\&  # build the gradient the hard way \- linear from black to white,
\&  # then back again
\&  my @simple =
\&   (
\&     [   0, 0.25, 0.5, \*(Aqblack\*(Aq, \*(Aqwhite\*(Aq, 0, 0 ],
\&     [ 0.5. 0.75, 1.0, \*(Aqwhite\*(Aq, \*(Aqblack\*(Aq, 0, 0 ],
\&   );
\&  # across
\&  my $linear = $img\->copy;
\&  $linear\->filter(type     => "fountain",
\&                  ftype    => \*(Aqlinear\*(Aq,
\&                  repeat   => \*(Aqsawtooth\*(Aq,
\&                  segments => \e@simple,
\&                  xa       => 0,
\&                  ya       => $linear\->getheight / 2,
\&                  xb       => $linear\->getwidth \- 1,
\&                  yb       => $linear\->getheight / 2)
\&    or die $linear\->errstr;
\&  # around
\&  my $revolution = $img\->copy;
\&  $revolution\->filter(type     => "fountain",
\&                      ftype    => \*(Aqrevolution\*(Aq,
\&                      segments => \e@simple,
\&                      xa       => $revolution\->getwidth / 2,
\&                      ya       => $revolution\->getheight / 2,
\&                      xb       => $revolution\->getwidth / 2,
\&                      yb       => 0)
\&    or die $revolution\->errstr;
\&  # out from the middle
\&  my $radial = $img\->copy;
\&  $radial\->filter(type     => "fountain",
\&                  ftype    => \*(Aqradial\*(Aq,
\&                  segments => \e@simple,
\&                  xa       => $im\->getwidth / 2,
\&                  ya       => $im\->getheight / 2,
\&                  xb       => $im\->getwidth / 2,
\&                  yb       => 0)
\&    or die $radial\->errstr;
.Ve
.RE
.IP "gaussian" 4
.IX Item "gaussian"
performs a Gaussian blur of the image, using \f(CW\*(C`stddev\*(C'\fR as the standard
deviation of the curve used to combine pixels, larger values give
bigger blurs.  For a definition of Gaussian Blur, see:
.Sp
.Vb 1
\&  http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node99.html
.Ve
.Sp
Values of \f(CW\*(C`stddev\*(C'\fR around 0.5 provide a barely noticeable blur,
values around 5 provide a very strong blur.
.Sp
.Vb 3
\&  # only slightly blurred
\&  $img\->filter(type=>"gaussian", stddev=>0.5)
\&    or die $img\->errstr;
\&
\&  # more strongly blurred
\&  $img\->filter(type=>"gaussian", stddev=>5)
\&    or die $img\->errstr;
.Ve
.IP "gradgen" 4
.IX Item "gradgen"
renders a gradient, with the given \fIcolors\fR at the corresponding
points (x,y) in \f(CW\*(C`xo\*(C'\fR and \f(CW\*(C`yo\*(C'\fR.  You can specify the way distance is
measured for color blending by setting \f(CW\*(C`dist\*(C'\fR to 0 for Euclidean, 1
for Euclidean squared, and 2 for Manhattan distance.
.Sp
.Vb 4
\&  $img\->filter(type="gradgen", 
\&               xo=>[ 10, 50, 10 ], 
\&               yo=>[ 10, 50, 50 ],
\&               colors=>[ qw(red blue green) ]);
.Ve
.IP "hardinvert" 4
.IX Xref "filters, hardinvert hardinvert"
.IX Item "hardinvert"
inverts the image, black to white, white to black.  All color channels
are inverted, excluding the alpha channel if any.
.Sp
.Vb 2
\&  $img\->filter(type=>"hardinvert")
\&    or die $img\->errstr;
.Ve
.IP "hardinvertall" 4
.IX Xref "filters, hardinvertall hardinvertall"
.IX Item "hardinvertall"
inverts the image, black to white, white to black.  All channels are
inverted, including the alpha channel if any.
.Sp
.Vb 2
\&  $img\->filter(type=>"hardinvertall")
\&    or die $img\->errstr;
.Ve
.IP "mosaic" 4
.IX Item "mosaic"
produces averaged tiles of the given \f(CW\*(C`size\*(C'\fR.
.Sp
.Vb 2
\&  $img\->filter(type=>"mosaic", size=>5)
\&    or die $img\->errstr;
.Ve
.IP "noise" 4
.IX Item "noise"
adds noise of the given \f(CW\*(C`amount\*(C'\fR to the image.  If \f(CW\*(C`subtype\*(C'\fR is
zero, the noise is even to each channel, otherwise noise is added to
each channel independently.
.Sp
.Vb 3
\&  # monochrome noise
\&  $img\->filter(type=>"noise", amount=>20, subtype=>0)
\&    or die $img\->errstr;
\&
\&  # color noise
\&  $img\->filter(type=>"noise", amount=>20, subtype=>1)
\&    or die $img\->errstr;
.Ve
.IP "radnoise" 4
.IX Item "radnoise"
renders radiant Perlin turbulent noise.  The center of the noise is at
(\f(CW\*(C`xo\*(C'\fR, \f(CW\*(C`yo\*(C'\fR), \f(CW\*(C`ascale\*(C'\fR controls the angular scale of the noise ,
and \f(CW\*(C`rscale\*(C'\fR the radial scale, higher numbers give more detail.
.Sp
.Vb 3
\&  $img\->filter(type=>"radnoise", xo=>50, yo=>50,
\&               ascale=>1, rscale=>0.02)
\&    or die $img\->errstr;
.Ve
.IP "postlevels" 4
.IX Item "postlevels"
alters the image to have only \f(CW\*(C`levels\*(C'\fR distinct level in each
channel.
.Sp
.Vb 2
\&  $img\->filter(type=>"postlevels", levels=>10)
\&    or die $img\->errstr;
.Ve
.IP "turbnoise" 4
.IX Item "turbnoise"
renders Perlin turbulent noise.  (\f(CW\*(C`xo\*(C'\fR, \f(CW\*(C`yo\*(C'\fR) controls the origin of
the noise, and \f(CW\*(C`scale\*(C'\fR the scale of the noise, with lower numbers
giving more detail.
.Sp
.Vb 2
\&  $img\->filter(type=>"turbnoise", xo=>10, yo=>10, scale=>10)
\&    or die $img\->errstr;
.Ve
.IP "unsharpmask" 4
.IX Item "unsharpmask"
performs an unsharp mask on the image.  This increases the contrast of
edges in the image.
.Sp
This is the result of subtracting a Gaussian blurred version of the
image from the original.  \f(CW\*(C`stddev\*(C'\fR controls the \f(CW\*(C`stddev\*(C'\fR parameter
of the Gaussian blur.  Each output pixel is:
.Sp
.Vb 1
\&  in + scale * (in \- blurred)
.Ve
.Sp
eg.
.Sp
.Vb 2
\&  $img\->filter(type=>"unsharpmask", stddev=>1, scale=>0.5)
\&    or die $img\->errstr;
.Ve
.Sp
\&\f(CW\*(C`unsharpmark\*(C'\fR has the following parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`stddev\*(C'\fR \- this is equivalent to the \f(CW\*(C`Radius\*(C'\fR value in the \s-1GIMP\s0's
unsharp mask filter.  This controls the size of the contrast increase
around edges, larger values will remove fine detail. You should
probably experiment on the types of images you plan to work with.
Default: 2.0.
.IP "\(bu" 4
\&\f(CW\*(C`scale\*(C'\fR \- controls the strength of the edge enhancement, equivalent
to \fIAmount\fR in the \s-1GIMP\s0's unsharp mask filter.  Default: 1.0.
.RE
.RS 4
.RE
.IP "watermark" 4
.IX Item "watermark"
applies \f(CW\*(C`wmark\*(C'\fR as a watermark on the image with strength \f(CW\*(C`pixdiff\*(C'\fR,
with an origin at (\f(CW\*(C`tx\*(C'\fR, \f(CW\*(C`ty\*(C'\fR)
.Sp
.Vb 3
\&  $img\->filter(type=>"watermark", tx=>10, ty=>50, 
\&               wmark=>$wmark_image, pixdiff=>50)
\&    or die $img\->errstr;
.Ve
.PP
A demonstration of most of the filters can be found at:
.PP
.Vb 1
\&  http://www.develop\-help.com/imager/filters.html
.Ve
.SS "External Filters"
.IX Subsection "External Filters"
As of Imager 0.48 you can create perl or \s-1XS\s0 based filters and hook
them into Imager's \fIfilter()\fR method:
.IP "\fIregister_filter()\fR" 4
.IX Item "register_filter()"
Registers a filter so it is visible via Imager's \fIfilter()\fR method.
.Sp
.Vb 5
\&  Imager\->register_filter(type => \*(Aqyour_filter\*(Aq,
\&                          defaults => { parm1 => \*(Aqdefault1\*(Aq },
\&                          callseq => [ qw/image parm1/ ],
\&                          callsub => \e&your_filter);
\&  $img\->filter(type=>\*(Aqyour_filter\*(Aq, parm1 => \*(Aqsomething\*(Aq);
.Ve
.Sp
The following parameters are needed:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- the type value that will be supplied to \fIfilter()\fR to use your
filter.
.IP "\(bu" 4
\&\f(CW\*(C`defaults\*(C'\fR \- a hash of defaults for the filter's parameters
.IP "\(bu" 4
\&\f(CW\*(C`callseq\*(C'\fR \- a reference to an array of required parameter names.
.IP "\(bu" 4
\&\f(CW\*(C`callsub\*(C'\fR \- a code reference called to execute your filter.  The
parameters passed to \fIfilter()\fR are supplied as a list of parameter
name, value ... which can be assigned to a hash.
.Sp
The special parameters \f(CW\*(C`image\*(C'\fR and \f(CW\*(C`imager\*(C'\fR are supplied as the low
level image object from \f(CW$self\fR and \f(CW$self\fR itself respectively.
.Sp
The function you supply must modify the image in place.
.Sp
To indicate an error, die with an error message followed by a
newline. \f(CW\*(C`filter()\*(C'\fR will store the error message as the \f(CW\*(C`errstr()\*(C'\fR
for the invocant and return false to indicate failure.
.Sp
.Vb 4
\&  sub my_filter {
\&    my %opts = @_;
\&    _is_valid($opts{myparam})
\&      or die "myparam invalid!\en";
\&
\&    # actually do the filtering...
\&  }
.Ve
.RE
.RS 4
.Sp
See Imager::Filter::Mandelbrot for an example.
.RE
.SS "Plug-ins"
.IX Subsection "Plug-ins"
The plug in interface is deprecated.  Please use the Imager \s-1API\s0, see
Imager::API and \*(L"External Filters\*(R" for details
.PP
It is possible to add filters to the module without recompiling Imager
itself.  This is done by using DSOs (Dynamic shared object) available
on most systems.  This way you can maintain your own filters and not
have to have it added to Imager, or worse patch every new version of
Imager.  Modules can be loaded \s-1AND\s0 \s-1UNLOADED\s0 at run time.  This means
that you can have a server/daemon thingy that can do something like:
.PP
.Vb 2
\&  load_plugin("dynfilt/dyntest.so")
\&    or die "unable to load plugin\en";
\&
\&  $img\->filter(type=>\*(Aqlin_stretch\*(Aq, a=>35, b=>200);
\&
\&  unload_plugin("dynfilt/dyntest.so")
\&    or die "unable to load plugin\en";
.Ve
.PP
Someone decides that the filter is not working as it should \-
\&\fIdyntest.c\fR can be modified and recompiled, and then reloaded:
.PP
.Vb 2
\&  load_plugin("dynfilt/dyntest.so")
\&    or die "unable to load plugin\en";
\&
\&  $img\->filter(%hsh);
.Ve
.PP
Note: This has been tested successfully on the following systems:
Linux, Solaris, \s-1HPUX\s0, OpenBSD, FreeBSD, \s-1TRU64/OSF1\s0, \s-1AIX\s0, Win32, \s-1OS\s0 X.
.IP "\fIload_plugin()\fR" 4
.IX Item "load_plugin()"
This is a function, not a method, exported by default.  You should
import this function explicitly for future compatibility if you need
it.
.Sp
Accepts a single parameter, the name of a shared library file to load.
.Sp
Returns true on success.  Check Imager\->errstr on failure.
.IP "\fIunload_plugin()\fR" 4
.IX Item "unload_plugin()"
This is a function, not a method, which is exported by default.  You
should import this function explicitly for future compatibility if you
need it.
.Sp
Accepts a single parameter, the name of a shared library to unload.
This library must have been previously loaded by \fIload_plugin()\fR.
.Sp
Returns true on success.  Check Imager\->errstr on failure.
.PP
A few example plug-ins are included and built (but not installed):
.IP "\(bu" 4
\&\fIplugins/dyntest.c\fR \- provides the \f(CW\*(C`null\*(C'\fR (no action) filter, and
\&\f(CW\*(C`lin_stretch\*(C'\fR filters.  \f(CW\*(C`lin_stretch\*(C'\fR stretches sample values
between \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`b\*(C'\fR out to the full sample range.
.IP "\(bu" 4
\&\fIplugins/dt2.c\fR \- provides the \f(CW\*(C`html_art\*(C'\fR filter that writes the
image to the \s-1HTML\s0 fragment file supplied in \f(CW\*(C`fname\*(C'\fR as a \s-1HTML\s0 table.
.IP "\(bu" 4
\&\fIplugins/flines.c\fR \- provides the \f(CW\*(C`flines\*(C'\fR filter that dims
alternate lines to emulate an old \s-1CRT\s0 display.
Imager::Filter::Flines provides the same functionality.
.IP "\(bu" 4
\&\fIplugins/mandelbrot.c\fR \- provides the \f(CW\*(C`mandelbrot\*(C'\fR filter that
renders the Mandelbrot set within the given range of x [\-2, 0.5) and y
[\-1.25, 1,25).  Imager::Filter::Mandelbrot provides a more flexible
Mandelbrot set renderer.
.SS "Image Difference"
.IX Subsection "Image Difference"
.IP "\fIdifference()\fR" 4
.IX Item "difference()"
You can create a new image that is the difference between 2 other images.
.Sp
.Vb 1
\&  my $diff = $img\->difference(other=>$other_img);
.Ve
.Sp
For each pixel in \f(CW$img\fR that is different to the pixel in \f(CW$other_img\fR,
the pixel from \f(CW$other_img\fR is given, otherwise the pixel is transparent
black.
.Sp
This can be used for debugging image differences (\*(L"Where are they
different?\*(R"), and for optimizing animated GIFs.
.Sp
Note that \f(CW$img\fR and \f(CW$other_img\fR must have the same number of channels.
The width and height of \f(CW$diff\fR will be the minimum of each of the width
and height of \f(CW$img\fR and \f(CW$other_img\fR.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`other\*(C'\fR \- the other image object to compare against
.IP "\(bu" 4
\&\f(CW\*(C`mindist\*(C'\fR \- the difference between corresponding samples must be
greater than \f(CW\*(C`mindist\*(C'\fR for the pixel to be considered different.  So
a value of zero returns all different pixels, not all pixels.  Range:
0 to 255 inclusive.  Default: 0.
.Sp
For large sample images this is scaled down to the range 0 .. 1.
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Arnar M. Hrafnkelsson, Tony Cook <tonyc@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager, Imager::Filter::Flines, Imager::Filter::Mandelbrot
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Revision\fR$
