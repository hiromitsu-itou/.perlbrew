.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Appender::DBI 3"
.TH Appender::DBI 3 "2010-07-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Log4perl::Appender::DBI \- implements appending to a DB
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    my $config = q{
\&     log4j.category = WARN, DBAppndr
\&     log4j.appender.DBAppndr             = Log::Log4perl::Appender::DBI
\&     log4j.appender.DBAppndr.datasource  = DBI:CSV:f_dir=t/tmp
\&     log4j.appender.DBAppndr.username    = bobjones
\&     log4j.appender.DBAppndr.password    = 12345
\&     log4j.appender.DBAppndr.sql         = \e
\&        insert into log4perltest           \e
\&        (loglevel, custid, category, message, ipaddr) \e
\&        values (?,?,?,?,?)
\&     log4j.appender.DBAppndr.params.1 = %p    
\&                                   #2 is custid from the log() call
\&     log4j.appender.DBAppndr.params.3 = %c
\&                                   #4 is the message from log()
\&                                   #5 is ipaddr from log()
\&         
\&     
\&     log4j.appender.DBAppndr.usePreparedStmt = 1
\&      #\-\-or\-\-
\&     log4j.appender.DBAppndr.bufferSize = 2
\&     
\&     #just pass through the array of message items in the log statement 
\&     log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
\&     log4j.appender.DBAppndr.warp_message = 0
\&    };
\&     
\&    $logger\->warn( $custid, \*(Aqbig problem!!\*(Aq, $ip_addr );
.Ve
.SH "CAVEAT"
.IX Header "CAVEAT"
This is a very young module and there are a lot of variations
in setups with different databases and connection methods,
so make sure you test thoroughly!  Any feedback is welcome!
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a specialized Log::Dispatch object customized to work with
log4perl and its abilities, originally based on Log::Dispatch::DBI 
by Tatsuhiko Miyagawa but with heavy modifications.
.PP
It is an attempted compromise between what Log::Dispatch::DBI was 
doing and what log4j's JDBCAppender does.  Note the log4j docs say
the JDBCAppender \*(L"is very likely to be completely replaced in the future.\*(R"
.PP
The simplest usage is this:
.PP
.Vb 9
\&    log4j.category = WARN, DBAppndr
\&    log4j.appender.DBAppndr            = Log::Log4perl::Appender::DBI
\&    log4j.appender.DBAppndr.datasource = DBI:CSV:f_dir=t/tmp
\&    log4j.appender.DBAppndr.username   = bobjones
\&    log4j.appender.DBAppndr.password   = 12345
\&    log4j.appender.DBAppndr.sql        = \e
\&       INSERT INTO logtbl                \e
\&          (loglevel, message)            \e
\&          VALUES (\*(Aq%c\*(Aq,\*(Aq%m\*(Aq)
\&    
\&    log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::PatternLayout
\&
\&
\&    $logger\->fatal(\*(Aqfatal message\*(Aq);
\&    $logger\->warn(\*(Aqwarning message\*(Aq);
\&
\&    ===============================
\&    |FATAL|fatal message          |
\&    |WARN |warning message        |
\&    ===============================
.Ve
.PP
But the downsides to that usage are:
.IP "\(bu" 4
You'd better be darn sure there are not quotes in your log message, or your
insert could have unforseen consequences!  This is a very insecure way to
handle database inserts, using place holders and bind values is much better, 
keep reading. (Note that the log4j docs warn \*(L"Be careful of quotes in your 
messages!\*(R") \fB*\fR.
.IP "\(bu" 4
It's not terribly high-performance, a statement is created and executed
for each log call.
.IP "\(bu" 4
The only run-time parameter you get is the \f(CW%m\fR message, in reality
you probably want to log specific data in specific table columns.
.PP
So let's try using placeholders, and tell the logger to create a
prepared statement handle at the beginning and just reuse it 
(just like Log::Dispatch::DBI does)
.PP
.Vb 4
\&    log4j.appender.DBAppndr.sql = \e
\&       INSERT INTO logtbl \e
\&          (custid, loglevel, message) \e
\&          VALUES (?,?,?)
\&
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    #now the bind values:
\&                                  #1 is the custid
\&    log4j.appender.DBAppndr.params.2 = %p    
\&                                  #3 is the message
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
\&    log4j.appender.DBAppndr.warp_message = 0
\&    
\&    log4j.appender.DBAppndr.usePreparedStmt = 1
\&    
\&    
\&    $logger\->warn( 1234, \*(Aqwarning message\*(Aq );
.Ve
.PP
Now see how we're using the '?' placeholders in our statement?  This
means we don't have to worry about messages that look like
.PP
.Vb 1
\&    invalid input: 1234\*(Aq;drop table custid;
.Ve
.PP
fubaring our database!
.PP
Normally a list of things in the logging statement gets concatenated into 
a single string, but setting \f(CW\*(C`warp_message\*(C'\fR to 0 and using the 
NoopLayout means that in
.PP
.Vb 1
\&    $logger\->warn( 1234, \*(Aqwarning message\*(Aq, \*(Aqbgates\*(Aq );
.Ve
.PP
the individual list values will still be available for the \s-1DBI\s0 appender later 
on.  (If \f(CW\*(C`warp_message\*(C'\fR is not set to 0, the default behavior is to
join the list elements into a single string.   If PatternLayout or SimpleLayout
are used, their attempt to \f(CW\*(C`render()\*(C'\fR your layout will result in something 
like \*(L"\s-1ARRAY\s0(0x841d8dc)\*(R" in your logs.  More information on \f(CW\*(C`warp_message\*(C'\fR
is in Log::Log4perl::Appender.)
.PP
In your insert \s-1SQL\s0 you can mix up '?' placeholders with conversion specifiers 
(%c, \f(CW%p\fR, etc) as you see fit\*(--the logger will match the question marks to 
params you've defined in the config file and populate the rest with values 
from your list.  If there are more '?' placeholders than there are values in 
your message, it will use undef for the rest.  For instance,
.PP
.Vb 6
\&        log4j.appender.DBAppndr.sql =                 \e
\&           insert into log4perltest                   \e
\&           (loglevel, message, datestr, subpoena_id)\e
\&           values (?,?,?,?)
\&        log4j.appender.DBAppndr.params.1 = %p
\&        log4j.appender.DBAppndr.params.3 = %d
\&
\&        log4j.appender.DBAppndr.warp_message=0
\&
\&
\&        $logger\->info(\*(Aqarrest him!\*(Aq, $subpoena_id);
.Ve
.PP
results in the first '?' placholder being bound to \f(CW%p\fR, the second to
\&\*(L"arrest him!\*(R", the third to the date from \*(L"%d\*(R", and the fourth to your
\&\f(CW$subpoenaid\fR.  If you forget the \f(CW$subpoena_id\fR and just log
.PP
.Vb 1
\&        $logger\->info(\*(Aqarrest him!\*(Aq);
.Ve
.PP
then you just get undef in the fourth column.
.PP
If the logger statement is also being handled by other non-DBI appenders,
they will just join the list into a string, joined with 
\&\f(CW$Log::Log4perl::JOIN_MSG_ARRAY_CHAR\fR (default is an empty string).
.PP
And see the \f(CW\*(C`usePreparedStmt\*(C'\fR?  That creates a statement handle when
the logger object is created and just reuses it.  That, however, may
be problematic for long-running processes like webservers, in which case
you can use this parameter instead
.PP
.Vb 1
\&    log4j.appender.DBAppndr.bufferSize=2
.Ve
.PP
This copies log4j's JDBCAppender's behavior, it saves up that many
log statements and writes them all out at once.  If your \s-1INSERT\s0
statement uses only ? placeholders and no \f(CW%x\fR conversion specifiers
it should be quite efficient because the logger can re-use the
same statement handle for the inserts.
.PP
If the program ends while the buffer is only partly full, the \s-1DESTROY\s0
block should flush the remaining statements, if the \s-1DESTROY\s0 block
runs of course.
.PP
* \fIAs I was writing this, Danko Mannhaupt was coming out with his
improved log4j JDBCAppender (http://www.mannhaupt.com/danko/projects/)
which overcomes many of the drawbacks of the original JDBCAppender.\fR
.SH "DESCRIPTION 2"
.IX Header "DESCRIPTION 2"
Or another way to say the same thing:
.PP
The idea is that if you're logging to a database table, you probably
want specific parts of your log information in certain columns.  To this
end, you pass an list to the log statement, like
.PP
.Vb 1
\&    $logger\->warn(\*(Aqbig problem!!\*(Aq,$userid,$subpoena_nr,$ip_addr);
.Ve
.PP
and the array members drop into the positions defined by the placeholders
in your \s-1SQL\s0 statement. You can also define information in the config
file like
.PP
.Vb 1
\&    log4j.appender.DBAppndr.params.2 = %p
.Ve
.PP
in which case those numbered placeholders will be filled in with
the specified values, and the rest of the placeholders will be
filled in with the values from your log statement's array.
.SH "MISC PARAMETERS"
.IX Header "MISC PARAMETERS"
.IP "usePreparedStmt" 4
.IX Item "usePreparedStmt"
See above.
.IP "warp_message" 4
.IX Item "warp_message"
see Log::Log4perl::Appender
.IP "max_col_size" 4
.IX Item "max_col_size"
If you're used to just throwing debugging messages like huge stacktraces
into your logger, some databases (Sybase's \s-1DBD\s0!!) may suprise you 
by choking on data size limitations.  Normally, the data would
just be truncated to fit in the column, but Sybases's \s-1DBD\s0 it turns out
maxes out at 255 characters.  Use this parameter in such a situation
to truncate long messages before they get to the \s-1INSERT\s0 statement.
.SH "CHANGING DBH CONNECTIONS (POOLING)"
.IX Header "CHANGING DBH CONNECTIONS (POOLING)"
If you want to get your dbh from some place in particular, like
maybe a pool, subclass and override \fI_init()\fR and/or \fIcreate_statement()\fR, 
for instance
.PP
.Vb 5
\&    sub _init {
\&        ; #no\-op, no pooling at this level
\&    }
\&    sub create_statement {
\&        my ($self, $stmt) = @_;
\&    
\&        $stmt || croak "Log4perl: sql not set in "._\|_PACKAGE_\|_;
\&    
\&        return My::Connections\->getConnection\->prepare($stmt) 
\&            || croak "Log4perl: DBI\->prepare failed $DBI::errstr\en$stmt";
\&    }
.Ve
.SH "LIFE OF CONNECTIONS"
.IX Header "LIFE OF CONNECTIONS"
If you're using \f(CW\*(C`log4j.appender.DBAppndr.usePreparedStmt\*(C'\fR
this module creates an sth when it starts and keeps it for the life
of the program.  For long-running processes (e.g. mod_perl), connections
might go stale, but if \f(CW\*(C`Log::Log4perl::Appender::DBI\*(C'\fR tries to write
a message and figures out that the \s-1DB\s0 connection is no longer working
(using \s-1DBI\s0's ping method), it will reconnect.
.PP
The reconnection process can be controlled by two parameters,
\&\f(CW\*(C`reconnect_attempts\*(C'\fR and \f(CW\*(C`reconnect_sleep\*(C'\fR. \f(CW\*(C`reconnect_attempts\*(C'\fR
specifies the number of reconnections attempts the \s-1DBI\s0 appender 
performs until it gives up and dies. \f(CW\*(C`reconnect_sleep\*(C'\fR is the
time between reconnection attempts, measured in seconds.
\&\f(CW\*(C`reconnect_attempts\*(C'\fR defaults to 1,  \f(CW\*(C`reconnect_sleep\*(C'\fR to 0.
.PP
Alternatively, use \f(CW\*(C`Apache::DBI\*(C'\fR or \f(CW\*(C`Apache::DBI::Cache\*(C'\fR and read
\&\s-1CHANGING\s0 \s-1DB\s0 \s-1CONNECTIONS\s0 above.
.PP
Note that \f(CW\*(C`Log::Log4perl::Appender::DBI\*(C'\fR holds one connection open
for every appender, which might be too many.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Dispatch::DBI
.PP
Log::Log4perl::JavaMap::JDBCAppender
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2002\-2009 by Mike Schilli <m@perlmeister.com> 
and Kevin Goess <cpan@goess.org>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
