.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::View::Download::CSV 3"
.TH Catalyst::View::Download::CSV 3 "2011-11-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::View::Download::CSV
.SH "VERSION"
.IX Header "VERSION"
0.03
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # lib/MyApp/View/Download/CSV.pm
\&  package MyApp::View::Download::CSV;
\&  use base qw( Catalyst::View::Download::CSV );
\&  1;
\&
\&  # lib/MyApp/Controller/SomeController.pm
\&  sub example_action_1 : Local {
\&    my ($self, $c) = @_;
\&  
\&    # Array reference of array references.
\&    my $data = [
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq], # row 1
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq], # row 2
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq], # row ...
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq]  # row N
\&    ];
\&
\&    # To output your data in comma seperated values pass your array by reference 
\&    # into a hashref as the key \*(Aqdata\*(Aq and then into whatever stash key you have 
\&    # defined (default is \*(Aqcsv\*(Aq). Content passed via the stash must be passed in 
\&    # a hashref in the key labeled \*(Aqdata\*(Aq.
\&    $c\->stash\->{\*(Aqcsv\*(Aq} = {
\&                        \*(Aqdata\*(Aq => $data
\&                };
\&
\&    # Finally forward processing to the CSV View
\&    $c\->forward(\*(AqMyApp::View::Download::CSV\*(Aq);
\&  }
\&
\&  # Other ways of storing data
\&  sub example_action_2 : Local {
\&    my ($self, $c) = @_;
\&
\&    # Array of array references
\&    my @data;
\&
\&    push(@data,[\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq]); # row 1
\&    push(@data,[\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq]); # row 2
\&    push(@data,[\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq]); # row ...
\&    push(@data,[\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq]); # row N
\&
\&    # OR to produce a single column of data you can simply do the following 
\&    my @data = (
\&                \*(Aqcol 1 row 1\*(Aq,
\&                \*(Aqcol 1 row 2\*(Aq,
\&                \*(Aqcol 1 row ...\*(Aq,
\&                \*(Aqcol 1 row N\*(Aq
\&               );
\&
\&    $c\->stash\->{\*(Aqcsv\*(Aq} = {
\&                        \*(Aqdata\*(Aq => \e@data
\&                };
\&
\&    $c\->forward(\*(AqMyApp::View::Download::CSV\*(Aq);
\&  }
\&
\&  # Available Options to produce other types of delimiter seperated output
\&  sub  example_action_3 : Local {
\&    my ($self, $c) = @_;
\&
\&    my $data = [
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq], # row 1
\&      [\*(Aqcol 1\*(Aq,\*(Aqcol 2\*(Aq,\*(Aqcol ...\*(Aq,\*(Aqcol N\*(Aq] # row 2
\&    ];
\&
\&    # You can change any of the aspects of a delimiter seperated values format by change the view configuration
\&    # This is an example of tab seperated values for instance
\&
\&                $c\->view(\*(AqDownload\*(Aq)\->config(
\&                        \*(Aqstash_key\*(Aq => \*(Aqdata\*(Aq,
\&                        \*(Aqquote_char\*(Aq => \*(Aq"\*(Aq,
\&                        \*(Aqescape_char\*(Aq => \*(Aq"\*(Aq,
\&                        \*(Aqsep_char\*(Aq => "\et",
\&                        \*(Aqeol\*(Aq => "\en",
\&      \*(Aqbinary\*(Aq => 1,
\&      \*(Aqallow_loose_quotes\*(Aq => 1,
\&      \*(Aqallow_loose_escapes\*(Aq => 1,
\&      \*(Aqallow_whitespace\*(Aq => 1,
\&      \*(Aqalways_quote\*(Aq => 1
\&                );
\&
\&    $c\->stash\->{\*(Aqdata\*(Aq} = {
\&                        \*(Aqdata\*(Aq => $data
\&                };
\&                
\&                $c\->forward(\*(AqMyApp::View::Download::CSV\*(Aq);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Takes a nested array and outputs \s-1CSV\s0 formatted content.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "process"
.IX Subsection "process"
This method will be called by Catalyst if it is asked to forward to a component without a specified action.
.SS "render"
.IX Subsection "render"
Allows others to use this view for much more fine-grained content generation.
.SH "CONFIG"
.IX Header "CONFIG"
.IP "stash_key" 4
.IX Item "stash_key"
Determines the key in the stash this view will look for when attempting to retrieve data to process. If this key isn't found it will then look at the stash as a whole, find any array references and process them. Data passed into the defined stash_key must be a \s-1HASHREF\s0 with at least the key 'data' existing with the nested array of data to create a \s-1CSV\s0 from.
.Sp
.Vb 1
\&        $c\->view(\*(AqMyApp::View::Download::CSV\*(Aq)\->config\->{\*(Aqstash_key\*(Aq} = \*(Aqdata\*(Aq;
.Ve
.IP "quote_char" 4
.IX Item "quote_char"
Determines what value will be enclosed within if it contains whitespace or the delimiter character. \s-1DEFAULT:\s0 '"'
.Sp
.Vb 1
\&  $c\->view(\*(AqMyApp::View::Download::CSV\*(Aq)\->config\->{\*(Aqquote_char\*(Aq} = \*(Aq/\*(Aq;
.Ve
.IP "escape_char" 4
.IX Item "escape_char"
Determines what value will be to escape any delimiter's found in a column. \s-1DEFAULT:\s0 '"'
.Sp
.Vb 1
\&  $c\->view(\*(AqMyApp::View::Download::CSV\*(Aq)\->config\->{\*(Aqescape_char\*(Aq} = \*(Aq/\*(Aq;
.Ve
.IP "sep_char" 4
.IX Item "sep_char"
Determines the separator between columns. \s-1DEFAULT:\s0 ','
.Sp
.Vb 1
\&  $c\->view(\*(AqMyApp::View::Download::CSV\*(Aq)\->config\->{\*(Aqsep_char\*(Aq} = \*(Aq|\*(Aq;
.Ve
.IP "eol" 4
.IX Item "eol"
Any characters defined in eol will be placed at the end of a row. \s-1DEFAULT:\s0 '\en'
.Sp
.Vb 1
\&  $c\->view(\*(AqMyApp::View::Download::CSV\*(Aq)\->config\->{\*(Aqeol\*(Aq} = \*(Aq\e0\*(Aq;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Travis Chase, \f(CW\*(C`<gaudeon at cpan.org>\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst Catalyst::View Catalyst::View::Download Text::CSV
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2011 Travis Chase.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
