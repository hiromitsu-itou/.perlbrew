.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Email::Sender::Manual::QuickStart 3"
.TH Email::Sender::Manual::QuickStart 3 "2012-02-02" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::Sender::Manual::QuickStart \- how to start using Email::Sender right now
.SH "VERSION"
.IX Header "VERSION"
version 0.110003
.SH "QUICK START"
.IX Header "QUICK START"
.SS "Let's Send Some Mail!"
.IX Subsection "Let's Send Some Mail!"
No messing around, let's just send some mail.
.PP
.Vb 4
\&  use strict;
\&  use Email::Sender::Simple qw(sendmail);
\&  use Email::Simple;
\&  use Email::Simple::Creator;
\&
\&  my $email = Email::Simple\->create(
\&    header => [
\&      To      => \*(Aq"Xavier Q. Ample" <x.ample@example.com>\*(Aq,
\&      From    => \*(Aq"Bob Fishman" <orz@example.mil>\*(Aq,
\&      Subject => "don\*(Aqt forget to *enjoy the sauce*",
\&    ],
\&    body => "This message is short, but at least it\*(Aqs cheap.\en",
\&  );
\&
\&  sendmail($email);
.Ve
.PP
That's it.  Your message goes out into the internet and tries to get delivered
to \f(CW\*(C`x.ample@example.com\*(C'\fR.
.PP
In the example above, \f(CW$email\fR could be an Email::Simple object, a
MIME::Entity, a string containing an email message, or one of several other
types of input.  If \f(CW\*(C`Email::Abstract\*(C'\fR can understand a value, it can be passed
to Email::Sender::Simple.  Email::Sender::Simple tries to make a good guess
about how to send the message.  It will usually try to use the \fIsendmail\fR
program on unix-like systems and to use \s-1SMTP\s0 on Windows.  You can specify a
transport, if you need to, but normally that shouldn't be an issue.  (See
\&\*(L"Picking a Transport\*(R", though, for more information.)
.PP
Also note that we imported and used a \f(CW\*(C`sendmail\*(C'\fR routine in the example above.
This is exactly the same as saying:
.PP
.Vb 1
\&  Email::Sender::Simple\->send($email);
.Ve
.PP
\&...but it's a lot easier to type.  You can use either one.
.PP
\fIenvelope information\fR
.IX Subsection "envelope information"
.PP
We didn't have to tell Email::Sender::Simple where to send the message.  If you
don't specify recipients, it will use all the email addresses it can find in
the \fITo\fR and \fICc\fR headers by default.  It will use Email::Address to parse
those fields.  Similarly, if no sender is specified, it will use the first
address found in the \fIFrom\fR header.
.PP
In most email transmission systems, though, the headers are not by necessity
tied to the addresses used as the sender and recipients.  For example, your
message header might say \*(L"From: mailing\-list@example.com\*(R" while your \s-1SMTP\s0
client says \*(L"\s-1MAIL\s0 FROM:<verp\-1234@lists.example.com>\*(R".  This is a
powerful feature, and is necessary for many email application.  Being able to
set those distinctly is important, and Email::Sender::Simple lets you do this:
.PP
.Vb 1
\&  sendmail($email, { to => [ $to_1, $to_2 ], from => $sender });
.Ve
.PP
\fIin case of error\fR
.IX Subsection "in case of error"
.PP
When the message is sent successfully (at least on to its next hop),
\&\f(CW\*(C`sendmail\*(C'\fR will return a true value \*(-- specifically, an
Email::Sender::Success object.  This object only rarely has much use.
What's more useful is what happens if the message can't be sent.
.PP
If there is an error sending the message, an exception will be thrown.  It will
be an object belonging to the class Email::Sender::Failure.  This object
will have a \f(CW\*(C`message\*(C'\fR attribute describing the nature of the failure.  There
are several specialized forms of failure, like
Email::Sender::Failure::Multi, which is thrown when more than one error is
encountered when trying to send.  You don't need to know about these to use
Email::Sender::Simple, though.  All you need to know is that \f(CW\*(C`sendmail\*(C'\fR
returns true on success and dies on failure.
.PP
If you'd rather not have to catch exceptions for failure to send mail, you can
use the \f(CW\*(C`try_to_send\*(C'\fR method, which can be imported as \f(CW\*(C`try_to_sendmail\*(C'\fR.
This method will return just false on failure to send mail.
.PP
For example:
.PP
.Vb 1
\&  Email::Sender::Simple\->try_to_send($email, { ... });
\&
\&  use Email::Sender::Simple qw(try_to_sendmail);
\&  try_to_sendmail($email, { ... });
.Ve
.PP
Some Email::Sender transports can signal success if some, but not all,
recipients could be reached.  Email::Sender::Simple does its best to ensure
that this never happens.  When you are using Email::Sender::Simple, mail should
either be sent or not.  Partial success should never occur.
.SS "Picking a Transport"
.IX Subsection "Picking a Transport"
\fIpassing in your own transport\fR
.IX Subsection "passing in your own transport"
.PP
If Email::Sender::Simple doesn't pick the transport you want, or if you have
more specific needs, you can specify a transport in several ways.  The simplest
is to build a transport object and pass it in.  You can read more about
transports elsewhere.  For now, we'll just assume that you need to send mail
via \s-1SMTP\s0 on an unusual port.  You can send mail like this:
.PP
.Vb 4
\&  my $transport = Email::Sender::Transport::SMTP\->new({
\&    host => \*(Aqsmtp.example.com\*(Aq,
\&    port => 2525,
\&  });
\&
\&  sendmail($email, { transport => $transport });
.Ve
.PP
Now, instead of guessing at what transport to use, Email::Sender::Simple will
use the one you provided.  This transport will have to be specified for each
call to \f(CW\*(C`sendmail\*(C'\fR, so you might want to look at other options, which follow.
.PP
\fIspecifying transport in the environment\fR
.IX Subsection "specifying transport in the environment"
.PP
If you have a program that makes several calls to Email::Sender::Simple, and
you need to run this program using a different mailserver, you can set
environment variables to change the default.  For example:
.PP
.Vb 3
\&  $ export EMAIL_SENDER_TRANSPORT=SMTP
\&  $ export EMAIL_SENDER_TRANSPORT_host=smtp.example.com
\&  $ export EMAIL_SENDER_TRANSPORT_port=2525
\&
\&  $ perl your\-program
.Ve
.PP
It is important to note that if you have set the default transport by using the
environment, \fIno subsequent \f(CI\*(C`transport\*(C'\fI args to \f(CI\*(C`sendmail\*(C'\fI will be
respected\fR.  If you set the default transport via the environment, that's it.
Everything will use that transport.  (Also, note that while we gave the host and
port arguments above in lower case, the casing of arguments in the environment
is flattened to support systems where environment variables are of a fixed
case.  So, \f(CW\*(C`EMAIL_SENDER_TRANSPORT_PORT\*(C'\fR would also work.
.PP
This is extremely valuable behavior, as it allows you to audit every message
that would be sent by a program by running something like this:
.PP
.Vb 2
\&  $ export EMAIL_SENDER_TRANSPORT=Maildir
\&  $ perl your\-program
.Ve
.PP
In that example, any message sent via Email::Sender::Simple would be delivered
to a maildir in the current directory.
.PP
\fIsubclassing to change the default transport\fR
.IX Subsection "subclassing to change the default transport"
.PP
If you want to use a library that will behave like Email::Sender::Simple but
with a different default transport, you can subclass Email::Sender::Simple and
replace the \f(CW\*(C`build_default_transport\*(C'\fR method.
.SS "Testing"
.IX Subsection "Testing"
Email::Sender::Simple makes it very, very easy to test code that sends email.
The simplest way is to do something like this:
.PP
.Vb 3
\&  use Test::More;
\&  BEGIN { $ENV{EMAIL_SENDER_TRANSPORT} = \*(AqTest\*(Aq }
\&  use YourCode;
\&
\&  YourCode\->run;
\&
\&  my @deliveries = Email::Sender::Simple\->default_transport\->deliveries;
.Ve
.PP
Now you've got an array containing every delivery performed through
Email::Sender::Simple, in order.  Because you set the transport via the
environment, no other code will be able to force a different transport.
.PP
When testing code that forks, Email::Sender::Transport::SQLite can be used
to allow every child process to deliver to a single, easy to inspect
destination database.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "This is awesome!  Where can I learn more?"
.IX Subsection "This is awesome!  Where can I learn more?"
Have a look at Email::Sender::Manual, where all the manual's documents are
listed.  You can also look at the documentation for Email::Sender::Simple
and the various Email::Sender::Transport classes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
