.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Producer::TT::Table 3"
.TH SQL::Translator::Producer::TT::Table 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Producer::TT::Table \-
    Produces output using the Template Toolkit from a SQL schema, per table.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  # Normal STDOUT version
\&  #
\&  my $translator     = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      filename       => \*(Aqfoo_schema.sql\*(Aq,
\&      to             => \*(AqTT::Table\*(Aq,
\&      producer_args  => {
\&          tt_table     => \*(Aqfoo_table.tt\*(Aq,
\&      },
\&  );
\&  print $translator\->translate;
\&
\&  # To generate a file per table
\&  #
\&  my $translator     = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      filename       => \*(Aqfoo_schema.sql\*(Aq,
\&      to             => \*(AqTT::Table\*(Aq,
\&      producer_args  => {
\&          tt_table       => \*(Aqfoo_table.tt.html\*(Aq,
\&          mk_files      => 1,
\&          mk_files_base => "./doc/tables",
\&          mk_file_ext   => ".html",
\&          on_exists     => "replace",
\&      },
\&  );
\&  #
\&  # ./doc/tables/ now contains the templated tables as $tablename.html
\&  #
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Produces schema output using a given Template Tookit template,
processing that template for each table in the schema. Optionally
allows you to write the result for each table to a separate file.
.PP
It needs one additional producer_arg of \f(CW\*(C`tt_table\*(C'\fR which is the file
name of the template to use.  This template will be passed a template
var of \f(CW\*(C`table\*(C'\fR, which is the current
SQL::Translator::Producer::Table table we are producing, which you
can then use to walk the schema via the methods documented in that
module. You also get schema as a shortcut to the
SQL::Translator::Producer::Schema for the table and \f(CW\*(C`translator\*(C'\fR,
the SQL::Translator object for this parse in case you want to get
access to any of the options etc set here.
.PP
Here's a brief example of what the template could look like:
.PP
.Vb 5
\&  [% table.name %]
\&  ================
\&  [% FOREACH field = table.get_fields %]
\&      [% field.name %]   [% field.data_type %]([% field.size %])
\&  [% END \-%]
.Ve
.PP
See \fIt/data/template/table.tt\fR for a more complete example.
.PP
You can also set any of the options used to initiallize the Template
object by adding them to your producer_args. See Template Toolkit docs
for details of the options.
.PP
.Vb 8
\&  $translator          = SQL::Translator\->new(
\&      to               => \*(AqTT\*(Aq,
\&      producer_args    => {
\&          ttfile       => \*(Aqfoo_template.tt\*(Aq,
\&          INCLUDE_PATH => \*(Aq/foo/templates/tt\*(Aq,
\&          INTERPOLATE  => 1,
\&      },
\&  );
.Ve
.PP
If you set \f(CW\*(C`mk_files\*(C'\fR and its additional options the producer will
write a separate file for each table in the schema. This is useful for
producing things like \s-1HTML\s0 documentation where every table gets its
own page (you could also use TTSchema producer to add an index page).
Its also particulary good for code generation where you want to
produce a class file per table.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "tt_table" 4
.IX Item "tt_table"
File name of the template to run for each table.
.IP "mk_files" 4
.IX Item "mk_files"
Set to true to output a file for each table in the schema (as well as
returning the whole lot back to the Translalor and hence \s-1STDOUT\s0). The
file will be named after the table, with the optional \f(CW\*(C`mk_files_ext\*(C'\fR
added and placed in the directory \f(CW\*(C`mk_files_base\*(C'\fR.
.IP "mk_files_ext" 4
.IX Item "mk_files_ext"
Extension (without the dot) to add to the filename when using mk_files.
.IP "mk_files_base = \s-1DIR\s0" 4
.IX Item "mk_files_base = DIR"
Dir to build the table files into when using mk_files. Defaults to the
current directory.
.IP "mk_file_dir" 4
.IX Item "mk_file_dir"
Set true and if the file needs to written to a directory that doesn't
exist, it will be created first.
.IP "on_exists [Default:replace]" 4
.IX Item "on_exists [Default:replace]"
What to do if we are running with mk_files and a file already exists
where we want to write our output. One of \*(L"skip\*(R", \*(L"die\*(R", \*(L"replace\*(R",
\&\*(L"insert\*(R".  The default is die.
.Sp
\&\fBreplace\fR \- Over-write the existing file with the new one, clobbering
anything already there.
.Sp
\&\fBskip\fR \- Leave the origional file as it was and don't write the new
version anywhere.
.Sp
\&\fBdie\fR \- Die with an existing file error.
.Sp
\&\fBinsert\fR \- Insert the generated output into the file bewteen a set of
special comments (defined by the following options.) Any code between
the comments will be overwritten (ie the results from a previous
produce) but the rest of the file is left alone (your custom code).
This is particularly useful for code generation as it allows you to
generate schema derived code and then add your own custom code
to the file.  Then when the schema changes you just re-produce to
insert the new code.
.IP "insert_comment_start" 4
.IX Item "insert_comment_start"
The comment to look for in the file when on_exists is \f(CW\*(C`insert\*(C'\fR. Default
is \f(CW\*(C`SQLF INSERT START\*(C'\fR. Must appear on it own line, with only
whitespace either side, to be recognised.
.IP "insert_comment_end" 4
.IX Item "insert_comment_end"
The end comment to look for in the file when on_exists is \f(CW\*(C`insert\*(C'\fR.
Default is \f(CW\*(C`SQLF INSERT END\*(C'\fR. Must appear on it own line, with only
whitespace either side, to be recognised.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Addison <grommit@users.sourceforge.net>.
.SH "TODO"
.IX Header "TODO"
\&\- Some tests for the various on exists options (they have been tested
implicitley through use in a project but need some proper tests).
.PP
\&\- More docs on code generation strategies.
.PP
\&\- Better hooks for filename generation.
.PP
\&\- Integrate with TT::Base and TTSchema.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Translator.
