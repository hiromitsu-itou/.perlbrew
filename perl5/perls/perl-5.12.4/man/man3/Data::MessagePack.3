.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::MessagePack 3"
.TH Data::MessagePack 3 "2011-12-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::MessagePack \- MessagePack serialising/deserialising
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::MessagePack;
\&
\&    my $mp = Data::MessagePack\->new();
\&    $mp\->canonical\->utf8\->prefer_integer if $needed;
\&
\&    my $packed   = $mp\->pack($dat);
\&    my $unpacked = $mp\->unpack($dat);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module converts Perl data structures to MessagePack and vice versa.
.SH "ABOUT MESSAGEPACK FORMAT"
.IX Header "ABOUT MESSAGEPACK FORMAT"
MessagePack is a binary-based efficient object serialization format.
It enables to exchange structured objects between many languages like \s-1JSON\s0.
But unlike \s-1JSON\s0, it is very fast and small.
.SS "\s-1ADVANTAGES\s0"
.IX Subsection "ADVANTAGES"
.IP "\s-1PORTABLE\s0" 4
.IX Item "PORTABLE"
The MessagePack format does not depend on language nor byte order.
.IP "\s-1SMALL\s0 \s-1IN\s0 \s-1SIZE\s0" 4
.IX Item "SMALL IN SIZE"
.Vb 3
\&    say length(JSON::XS::encode_json({a=>1, b=>2}));   # => 13
\&    say length(Storable::nfreeze({a=>1, b=>2}));       # => 21
\&    say length(Data::MessagePack\->pack({a=>1, b=>2})); # => 7
.Ve
.Sp
The MessagePack format saves memory than \s-1JSON\s0 and Storable format.
.IP "\s-1STREAMING\s0 \s-1DESERIALIZER\s0" 4
.IX Item "STREAMING DESERIALIZER"
MessagePack supports streaming deserializer. It is useful for networking such as \s-1RPC\s0.
See Data::MessagePack::Unpacker for details.
.PP
If you want to get more information about the MessagePack format, please visit to <http://msgpack.org/>.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """my $packed = Data::MessagePack\->pack($data[, $max_depth]);""" 4
.el .IP "\f(CWmy $packed = Data::MessagePack\->pack($data[, $max_depth]);\fR" 4
.IX Item "my $packed = Data::MessagePack->pack($data[, $max_depth]);"
Pack the \f(CW$data\fR to messagepack format string.
.Sp
This method throws an exception when the perl structure is nested more than \f(CW$max_depth\fR levels(default: 512) in order to detect circular references.
.Sp
Data::MessagePack\->\fIpack()\fR throws an exception when encountering blessed object, because MessagePack is language-independent format.
.ie n .IP """my $unpacked = Data::MessagePack\->unpack($msgpackstr);""" 4
.el .IP "\f(CWmy $unpacked = Data::MessagePack\->unpack($msgpackstr);\fR" 4
.IX Item "my $unpacked = Data::MessagePack->unpack($msgpackstr);"
unpack the \f(CW$msgpackstr\fR to a MessagePack format string.
.ie n .IP """my $mp = Data::MesssagePack\->new()""" 4
.el .IP "\f(CWmy $mp = Data::MesssagePack\->new()\fR" 4
.IX Item "my $mp = Data::MesssagePack->new()"
Creates a new MessagePack instance.
.ie n .IP """$mp = $mp\->prefer_integer([ $enable ])""" 4
.el .IP "\f(CW$mp = $mp\->prefer_integer([ $enable ])\fR" 4
.IX Item "$mp = $mp->prefer_integer([ $enable ])"
.PD 0
.ie n .IP """$enabled = $mp\->get_prefer_integer()""" 4
.el .IP "\f(CW$enabled = $mp\->get_prefer_integer()\fR" 4
.IX Item "$enabled = $mp->get_prefer_integer()"
.PD
If \fI\f(CI$enable\fI\fR is true (or missing), then the \f(CW\*(C`pack\*(C'\fR method tries a string
as an integer if the string looks like an integer.
.ie n .IP """$mp = $mp\->canonical([ $enable ])""" 4
.el .IP "\f(CW$mp = $mp\->canonical([ $enable ])\fR" 4
.IX Item "$mp = $mp->canonical([ $enable ])"
.PD 0
.ie n .IP """$enabled = $mp\->get_canonical()""" 4
.el .IP "\f(CW$enabled = $mp\->get_canonical()\fR" 4
.IX Item "$enabled = $mp->get_canonical()"
.PD
If \fI\f(CI$enable\fI\fR is true (or missing), then the \f(CW\*(C`pack\*(C'\fR method will output
packed data by sorting their keys. This is adding a comparatively high
overhead.
.ie n .IP """$mp = $mp\->utf8([ $enable ])""" 4
.el .IP "\f(CW$mp = $mp\->utf8([ $enable ])\fR" 4
.IX Item "$mp = $mp->utf8([ $enable ])"
.PD 0
.ie n .IP """$enabled = $mp\->get_utf8()""" 4
.el .IP "\f(CW$enabled = $mp\->get_utf8()\fR" 4
.IX Item "$enabled = $mp->get_utf8()"
.PD
If \fI\f(CI$enable\fI\fR is true (or missing), then the \f(CW\*(C`pack\*(C'\fR method will
apply \f(CW\*(C`utf8::encode()\*(C'\fR to all the string values.
.Sp
In other words, this property tell \f(CW$mp\fR to deal with \fBtext strings\fR.
See perlunifaq for the meaning of \fBtext string\fR.
.ie n .IP """$packed = $mp\->pack($data)""" 4
.el .IP "\f(CW$packed = $mp\->pack($data)\fR" 4
.IX Item "$packed = $mp->pack($data)"
.PD 0
.ie n .IP """$packed = $mp\->encode($data)""" 4
.el .IP "\f(CW$packed = $mp\->encode($data)\fR" 4
.IX Item "$packed = $mp->encode($data)"
.PD
Same as \f(CW\*(C`Data::MessagePack\->pack()\*(C'\fR, but properties are respected.
.ie n .IP """$data = $mp\->unpack($data)""" 4
.el .IP "\f(CW$data = $mp\->unpack($data)\fR" 4
.IX Item "$data = $mp->unpack($data)"
.PD 0
.ie n .IP """$data = $mp\->decode($data)""" 4
.el .IP "\f(CW$data = $mp\->decode($data)\fR" 4
.IX Item "$data = $mp->decode($data)"
.PD
Same as \f(CW\*(C`Data::MessagePack\->unpack()\*(C'\fR, but properties are respected.
.SH "Configuration Variables (DEPRECATED)"
.IX Header "Configuration Variables (DEPRECATED)"
.ie n .IP "$Data::MessagePack::PreferInteger" 4
.el .IP "\f(CW$Data::MessagePack::PreferInteger\fR" 4
.IX Item "$Data::MessagePack::PreferInteger"
Packs a string as an integer, when it looks like an integer.
.Sp
This variable is \fBdeprecated\fR.
Use \f(CW\*(C`$msgpack\->prefer_integer\*(C'\fR property instead.
.SH "SPEED"
.IX Header "SPEED"
This is a result of benchmark/serialize.pl and benchmark/deserialize.pl on my \s-1SC440\s0(Linux 2.6.32\-23\-server #37\-Ubuntu \s-1SMP\s0).
(You should benchmark them with \fByour\fR data if the speed matters, of course.)
.PP
.Vb 12
\&    \-\- serialize
\&    JSON::XS: 2.3
\&    Data::MessagePack: 0.24
\&    Storable: 2.21
\&    Benchmark: running json, mp, storable for at least 1 CPU seconds...
\&          json:  1 wallclock secs ( 1.00 usr +  0.01 sys =  1.01 CPU) @ 141939.60/s (n=143359)
\&            mp:  1 wallclock secs ( 1.06 usr +  0.00 sys =  1.06 CPU) @ 355500.94/s (n=376831)
\&      storable:  1 wallclock secs ( 1.12 usr +  0.00 sys =  1.12 CPU) @ 38399.11/s (n=43007)
\&                 Rate storable     json       mp
\&    storable  38399/s       \-\-     \-73%     \-89%
\&    json     141940/s     270%       \-\-     \-60%
\&    mp       355501/s     826%     150%       \-\-
\&
\&    \-\- deserialize
\&    JSON::XS: 2.3
\&    Data::MessagePack: 0.24
\&    Storable: 2.21
\&    Benchmark: running json, mp, storable for at least 1 CPU seconds...
\&          json:  0 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 179442.86/s (n=188415)
\&            mp:  0 wallclock secs ( 1.01 usr +  0.00 sys =  1.01 CPU) @ 212909.90/s (n=215039)
\&      storable:  2 wallclock secs ( 1.14 usr +  0.00 sys =  1.14 CPU) @ 114974.56/s (n=131071)
\&                 Rate storable     json       mp
\&    storable 114975/s       \-\-     \-36%     \-46%
\&    json     179443/s      56%       \-\-     \-16%
\&    mp       212910/s      85%      19%       \-\-
.Ve
.SH "CAVEAT"
.IX Header "CAVEAT"
.SS "Unpacking 64 bit integers"
.IX Subsection "Unpacking 64 bit integers"
This module can unpack 64 bit integers even if your perl does not support them
(i.e. where \f(CW\*(C`perl \-V:ivsize\*(C'\fR is 4), but you cannot calculate these values
unless you use \f(CW\*(C`Math::BigInt\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.IP "Error handling" 4
.IX Item "Error handling"
MessagePack cannot deal with complex scalars such as object references,
filehandles, and code references. We should report the errors more kindly.
.IP "Streaming deserializer" 4
.IX Item "Streaming deserializer"
The current implementation of the streaming deserializer does not have internal
buffers while some other bindings (such as Ruby binding) does. This limitation
will astonish those who try to unpack byte streams with an arbitrary buffer size
(e.g. \f(CW\*(C`while(read($socket, $buffer, $arbitrary_buffer_size)) { ... }\*(C'\fR).
We should implement the internal buffer for the unpacker.
.SH "AUTHORS"
.IX Header "AUTHORS"
Tokuhiro Matsuno
.PP
Makamaka Hannyaharamitu
.PP
gfx
.SH "THANKS TO"
.IX Header "THANKS TO"
Jun Kuriyama
.PP
Dan Kogai
.PP
\&\s-1FURUHASHI\s0 Sadayuki
.PP
hanekomu
.PP
Kazuho Oku
.PP
shohex
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://msgpack.org/> is the official web site for the  MessagePack format.
.PP
Data::MessagePack::Unpacker
.PP
AnyEvent::MPRPC
