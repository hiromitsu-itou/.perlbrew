.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::FormValidator::Results 3"
.TH Data::FormValidator::Results 3 "2012-02-08" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::FormValidator::Results \- results of form input validation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $results = Data::FormValidator\->check(\e%input_hash, \e%dfv_profile);
\&
\&    # Print the name of missing fields
\&    if ( $results\->has_missing ) {
\&    for my $f ( $results\->missing ) {
\&        print $f, " is missing\en";
\&    }
\&    }
\&
\&    # Print the name of invalid fields
\&    if ( $results\->has_invalid ) {
\&    for my $f ( $results\->invalid ) {
\&        print $f, " is invalid: ", $results\->invalid( $f ), "\en";
\&    }
\&    }
\&
\&    # Print unknown fields
\&    if ( $results\->has_unknown ) {
\&    for my $f ( $results\->unknown ) {
\&        print $f, " is unknown\en";
\&    }
\&    }
\&
\&    # Print valid fields
\&    for my $f ( $results\->valid() ) {
\&        print $f, " =  ", $results\->valid( $f ), "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object is returned by the Data::FormValidator \f(CW\*(C`check\*(C'\fR method.
It can be queried for information about the validation results.
.SH "\fIsuccess()\fP;"
.IX Header "success();"
This method returns true if there were no invalid or missing fields,
else it returns false.
.PP
As a shorthand, When the \f(CW$results\fR object is used in boolean context, it is overloaded
to use the value of \fIsuccess()\fR instead. That allows creation of a syntax like this one used
in \f(CW\*(C`CGI::Application::Plugin::ValidateRM\*(C'\fR:
.PP
.Vb 1
\& my $results = $self\->check_rm(\*(Aqform_display\*(Aq,\*(Aq_form_profile\*(Aq) || return $self\->dfv_error_page;
.Ve
.SH "valid( [[field] [, value]] );"
.IX Header "valid( [[field] [, value]] );"
In an array context with no arguments, it returns the list of fields which
contain valid values:
.PP
.Vb 1
\& @all_valid_field_names = $r\->valid;
.Ve
.PP
In a scalar context with no arguments, it returns an hash reference which
contains the valid fields as keys and their input as values:
.PP
.Vb 1
\& $all_valid_href = $r\->valid;
.Ve
.PP
If called with one argument in scalar context, it returns the value of that
\&\f(CW\*(C`field\*(C'\fR if it contains valid data, \f(CW\*(C`undef\*(C'\fR otherwise. The value will be an
array ref if the field had multiple values:
.PP
.Vb 1
\& $value = $r\->valid(\*(Aqfield\*(Aq);
.Ve
.PP
If called with one argument in array context, it returns the values of \f(CW\*(C`field\*(C'\fR
as an array:
.PP
.Vb 1
\& @values = $r\->valid(\*(Aqfield\*(Aq);
.Ve
.PP
If called with two arguments, it sets \f(CW\*(C`field\*(C'\fR to \f(CW\*(C`value\*(C'\fR and returns \f(CW\*(C`value\*(C'\fR.
This form is useful to alter the results from within some constraints.
See the Data::FormValidator::Constraints documentation.
.PP
.Vb 1
\& $new_value = $r\->valid(\*(Aqfield\*(Aq,$new_value);
.Ve
.SH "\fIhas_missing()\fP"
.IX Header "has_missing()"
This method returns true if the results contain missing fields.
.SH "missing( [field] )"
.IX Header "missing( [field] )"
In an array context it returns the list of fields which are missing.
In a scalar context, it returns an array reference to the list of missing fields.
.PP
If called with an argument, it returns true if that \f(CW\*(C`field\*(C'\fR is missing,
undef otherwise.
.SH "\fIhas_invalid()\fP"
.IX Header "has_invalid()"
This method returns true if the results contain fields with invalid
data.
.SH "invalid( [field] )"
.IX Header "invalid( [field] )"
In an array context, it returns the list of fields which contains invalid value.
.PP
In a scalar context, it returns an hash reference which contains the invalid
fields as keys, and references to arrays of failed constraints as values.
.PP
If called with an argument, it returns the reference to an array of failed
constraints for \f(CW\*(C`field\*(C'\fR.
.SH "\fIhas_unknown()\fP"
.IX Header "has_unknown()"
This method returns true if the results contain unknown fields.
.SH "unknown( [field] )"
.IX Header "unknown( [field] )"
In an array context, it returns the list of fields which are unknown.
In a scalar context, it returns an hash reference which contains the unknown
fields and their values.
.PP
If called with an argument, it returns the value of that \f(CW\*(C`field\*(C'\fR if it
is unknown, undef otherwise.
.SH "msgs([config parameters])"
.IX Header "msgs([config parameters])"
This method returns a hash reference to error messages. The exact format
is determined by parameters in the \f(CW\*(C`msgs\*(C'\fR area of the validation profile,
described in the Data::FormValidator documentation.
.PP
\&\fB\s-1NOTE:\s0\fR the \f(CW\*(C`msgs\*(C'\fR parameter in the profile can take a code reference as a
value, allowing complete control of how messages are generated. If such a code
reference was provided there, it will be called here instead of the usual
processing, described below. It will receive as arguments the Data::FormValidator::Results
object and a hash reference of control parameters.
.PP
The hashref passed in should contain the same options that you can define in
the validation profile. This allows you to separate the controls for message
display from the rest of the profile. While validation profiles may be
different for every form, you may wish to format messages the same way across
many projects.
.PP
Controls passed into the <msgs> method will be applied first, followed by ones
applied in the profile. This allows you to keep the controls you pass to
\&\f(CW\*(C`msgs\*(C'\fR as \*(L"global\*(R" and override them in a specific profile if needed.
.SH "\fImeta()\fP"
.IX Header "meta()"
In a few cases, a constraint may discover meta data that is useful
to access later. For example, when using Data::FormValidator::Constraints::Upload, several bits of meta data are discovered about files in the process
of validating. These can include \*(L"bytes\*(R", \*(L"width\*(R", \*(L"height\*(R" and \*(L"extension\*(R".
The \f(CW\*(C`meta()\*(C'\fR function is used by constraint methods to set this data. It's
also used to access this data. Here are some examples.
.PP
.Vb 2
\& # return all field names that have meta data
\& my @fields = $results\->meta();
\&
\& # To retrieve all meta data for a field:
\& $meta_href = $results\->meta(\*(Aqimg\*(Aq);
\&
\& # Access a particular piece:
\& $width = $results\->meta(\*(Aqimg\*(Aq)\->{width};
.Ve
.PP
Here's how to set some meta data. This is useful to know if you are
writing your own complex constraint.
.PP
.Vb 4
\&    $self\->meta(\*(Aqimg\*(Aq, {
\&        width  => \*(Aq50\*(Aq,
\&        height => \*(Aq60\*(Aq,
\&    });
.Ve
.PP
This function does not currently support multi-valued fields. If it
does in the future, the above syntax will still work.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::FormValidator, Data::FormValidator::Filters,
Data::FormValidator::Constraints, Data::FormValidator::ConstraintsFactory
.SH "AUTHOR"
.IX Header "AUTHOR"
Author: Francis J. Lacoste <francis.lacoste@iNsu.COM>
Maintainer: Mark Stosberg <mark@summersault.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999,2000 iNsu Innovations Inc.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms as perl itself.
