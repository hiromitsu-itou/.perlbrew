.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Routing 3"
.TH Mojolicious::Guides::Routing 3 "2012-03-14" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Routing \- Routing
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This document contains a simple and fun introduction to the Mojolicious
router and its underlying concepts.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Essentials every Mojolicious developer should know.
.SS "Dispatcher"
.IX Subsection "Dispatcher"
The foundation of every web framework is a tiny black box connecting incoming
requests with code generating the appropriate response.
.PP
.Vb 1
\&  GET /user/show/1 \-> $self\->render(text => \*(AqSebastian\*(Aq);
.Ve
.PP
This black box is usually called a dispatcher. There are many implementations
using different strategies to establish these connections, but pretty much
all are based around mapping the requests path to some kind of response
generator.
.PP
.Vb 4
\&  /user/show/1 \-> $self\->render(text => \*(AqSebastian\*(Aq);
\&  /user/show/2 \-> $self\->render(text => \*(AqSara\*(Aq);
\&  /user/show/3 \-> $self\->render(text => \*(AqBaerbel\*(Aq);
\&  /user/show/4 \-> $self\->render(text => \*(AqWolfgang\*(Aq);
.Ve
.PP
While it is very well possible to make all these connections static, it is
also rather inefficient. That's why regular expressions are commonly used to
make the dispatch process more dynamic.
.PP
.Vb 1
\&  qr|/user/show/(\ed+)| \-> $self\->render(text => $users{$1});
.Ve
.PP
Modern dispatchers have pretty much everything \s-1HTTP\s0 has to offer at their
disposal and can use many more variables than just the request path, such as
request method and headers like \f(CW\*(C`Host\*(C'\fR, \f(CW\*(C`User\-Agent\*(C'\fR and \f(CW\*(C`Accept\*(C'\fR.
.PP
.Vb 4
\&  GET /user/show/23 HTTP/1.1
\&  Host: mojolicio.us
\&  User\-Agent: Mozilla/5.0 (compatible; Mojolicious; Perl)
\&  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
.Ve
.SS "Routes"
.IX Subsection "Routes"
While regular expressions are quite powerful they also tend to be unpleasant
to look at and are generally overkill for ordinary path matching.
.PP
.Vb 1
\&  qr|/user/show/(\ed+)| \-> $self\->render(text => $users{$1});
.Ve
.PP
This is where routes come into play, they have been designed from the ground
up to represent paths with placeholders.
.PP
.Vb 1
\&  /user/show/:id \-> $self\->render(text => $users{$id});
.Ve
.PP
The only difference between a static path and the route above is the \f(CW\*(C`:id\*(C'\fR
placeholder. One or more placeholders can be anywhere in the route.
.PP
.Vb 1
\&  /user/:action/:id
.Ve
.PP
A fundamental concept of the Mojolicious router is that extracted
placeholder values are turned into a hash.
.PP
.Vb 1
\&  /user/show/23 \-> /user/:action/:id \-> {action => \*(Aqshow\*(Aq, id => 23}
.Ve
.PP
This hash is basically the center of every Mojolicious application, you
will learn more about this later on. Internally routes get compiled to
regular expressions, so you can get the best of both worlds with a little bit
of experience.
.PP
.Vb 1
\&  /user/show/:id \-> qr/(?\-xism:^\e/user\e/show/([^\e/\e.]+))/
.Ve
.PP
A trailing slash is always optional.
.PP
.Vb 1
\&  /user/show/23/ \-> /user/:action/:id \-> {action => \*(Aqshow\*(Aq, id => 23}
.Ve
.SS "Reversibility"
.IX Subsection "Reversibility"
One more huge advantage routes have over regular expressions is that they are
easily reversible, extracted placeholders can be turned back into a path at
any time.
.PP
.Vb 2
\&  /sebastian \-> /:name \-> {name => \*(Aqsebastian\*(Aq}
\&  {name => \*(Aqsebastian\*(Aq} \-> /:name \-> /sebastian
.Ve
.SS "Generic placeholders"
.IX Subsection "Generic placeholders"
Generic placeholders are the simplest form of placeholders and match
all characters except \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`.\*(C'\fR.
.PP
.Vb 6
\&  /hello              \-> /:name/hello \-> undef
\&  /sebastian/23/hello \-> /:name/hello \-> undef
\&  /sebastian.23/hello \-> /:name/hello \-> undef
\&  /sebastian/hello    \-> /:name/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /:name/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /:name/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.PP
A generic placeholder can be surrounded by parentheses to separate it from
the surrounding text.
.PP
.Vb 6
\&  /hello             \-> /(:name)hello \-> undef
\&  /sebastian/23hello \-> /(:name)hello \-> undef
\&  /sebastian.23hello \-> /(:name)hello \-> undef
\&  /sebastianhello    \-> /(:name)hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23hello  \-> /(:name)hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23hello \-> /(:name)hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.SS "Wildcard placeholders"
.IX Subsection "Wildcard placeholders"
Wildcard placeholders are just like generic placeholders, but match
absolutely everything.
.PP
.Vb 6
\&  /hello              \-> /*name/hello \-> undef
\&  /sebastian/23/hello \-> /*name/hello \-> {name => \*(Aqsebastian/23\*(Aq}
\&  /sebastian.23/hello \-> /*name/hello \-> {name => \*(Aqsebastian.23\*(Aq}
\&  /sebastian/hello    \-> /*name/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /*name/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /*name/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.SS "Relaxed placeholders"
.IX Subsection "Relaxed placeholders"
Relaxed placeholders are similar to the two placeholders above, but always
require parentheses and match all characters except \f(CW\*(C`/\*(C'\fR.
.PP
.Vb 6
\&  /hello              \-> /(.name)/hello \-> undef
\&  /sebastian/23/hello \-> /(.name)/hello \-> undef
\&  /sebastian.23/hello \-> /(.name)/hello \-> {name => \*(Aqsebastian.23\*(Aq}
\&  /sebastian/hello    \-> /(.name)/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /(.name)/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /(.name)/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.SH "BASICS"
.IX Header "BASICS"
Most commonly used features every Mojolicious developer should know about.
.SS "Minimal route"
.IX Subsection "Minimal route"
Every Mojolicious application has a router object you can use to generate
routes structures.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Router
\&    my $r = $self\->routes;
\&
\&    # Route
\&    $r\->route(\*(Aq/welcome\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
The minimal static route above will load and instantiate the class
\&\f(CW\*(C`MyApp::Foo\*(C'\fR and call its \f(CW\*(C`welcome\*(C'\fR method.
.PP
.Vb 3
\&  # Controller
\&  package MyApp::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub welcome {
\&    my $self = shift;
\&
\&    # Render response
\&    $self\->render(text => \*(AqHello there.\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Routes are usually configured in the \f(CW\*(C`startup\*(C'\fR method of the application
class, but the router can be accessed from everywhere (even at runtime).
.SS "Routing destination"
.IX Subsection "Routing destination"
After you start a new route with the method \*(L"route\*(R" in Mojolicious::Routes,
you can also give it a destination in the form of a hash using the chained
method \*(L"to\*(R" in Mojolicious::Routes.
.PP
.Vb 2
\&  # /welcome \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq}
\&  $r\->route(\*(Aq/welcome\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq);
.Ve
.PP
Now if the route matches an incoming request it will use the content of this
hash to try and find appropriate code to generate a response.
.SS "Stash"
.IX Subsection "Stash"
The generated hash of a matching route is actually the center of the whole
Mojolicious request cycle. We call it the stash, and it persists until a
response has been generated.
.PP
.Vb 3
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq}
\&  $r\->route(\*(Aq/bye\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq);
.Ve
.PP
There are a few stash values with special meaning, such as \f(CW\*(C`controller\*(C'\fR and
\&\f(CW\*(C`action\*(C'\fR, but you can generally fill it with whatever data you need to
generate a response. Once dispatched the whole stash content can be changed
at any time.
.PP
.Vb 2
\&  sub bye {
\&    my $self = shift;
\&
\&    # Get message from stash
\&    my $message = $self\->stash(\*(Aqmymessage\*(Aq);
\&
\&    # Change message in stash
\&    $self\->stash(mymessage => \*(AqWelcome\*(Aq);
\&  }
.Ve
.PP
For a full list of reserved stash values see
\&\*(L"stash\*(R" in Mojolicious::Controller.
.SS "Nested routes"
.IX Subsection "Nested routes"
It is also possible to build tree structures from routes to remove repetitive
code. A route with children can't match on it's own though, only the actual
endpoints of these nested routes can.
.PP
.Vb 4
\&  # /foo     \-> undef
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->route(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq);
\&  $foo\->route(\*(Aq/bar\*(Aq)\->to(action => \*(Aqbar\*(Aq);
.Ve
.PP
The stash is simply inherited from route to route and newer values override
old ones.
.PP
.Vb 9
\&  # /foo     \-> undef
\&  # /foo/abc \-> undef
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo/baz \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq}
\&  # /foo/cde \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqabc\*(Aq}
\&  my $foo = $r\->route(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqabc\*(Aq);
\&  $foo\->route(\*(Aq/bar\*(Aq)\->to(action => \*(Aqbar\*(Aq);
\&  $foo\->route(\*(Aq/baz\*(Aq)\->to(action => \*(Aqbaz\*(Aq);
\&  $foo\->route(\*(Aq/cde\*(Aq);
.Ve
.SS "Special stash values"
.IX Subsection "Special stash values"
When the dispatcher sees \f(CW\*(C`controller\*(C'\fR and \f(CW\*(C`action\*(C'\fR values in the stash it
will always try to turn them into a class and method to dispatch to. The
\&\f(CW\*(C`controller\*(C'\fR value gets camelized using \*(L"camelize\*(R" in Mojo::Util and
prefixed with a \f(CW\*(C`namespace\*(C'\fR (defaulting to the applications class). While
the action value is not changed at all, because of this both values are case
sensitive.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq} \-> MyApp::Foo\->bye
\&    $self\->routes\->route(\*(Aq/bye\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq);
\&  }
\&
\&  1;
\&
\&  # Controller
\&  package MyApp::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub bye {
\&    my $self = shift;
\&
\&    # Render response
\&    $self\->render(text => \*(AqGood bye.\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Controller classes are perfect for organizing code in larger projects. There
are more dispatch strategies, but because controllers are the most commonly
used ones they also got a special shortcut in the form of
\&\f(CW\*(C`controller#action\*(C'\fR.
.PP
.Vb 2
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq}
\&  $r\->route(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo#bye\*(Aq, mymessage => \*(AqBye\*(Aq);
.Ve
.PP
During camelization \f(CW\*(C`\-\*(C'\fR gets replaced with \f(CW\*(C`::\*(C'\fR, this allows multi level
\&\f(CW\*(C`controller\*(C'\fR hierarchies.
.PP
.Vb 2
\&  # / \-> {controller => \*(Aqfoo\-bar\*(Aq, action => \*(Aqhi\*(Aq} \-> MyApp::Foo::Bar\->hi
\&  $r\->route(\*(Aq/\*(Aq)\->to(\*(Aqfoo\-bar#hi\*(Aq);
.Ve
.PP
For security reasons the dispatcher will always check if the \f(CW\*(C`controller\*(C'\fR is
actually a subclass of Mojolicious::Controller or Mojo before
dispatching to it.
.SS "Route to class"
.IX Subsection "Route to class"
You can use the \f(CW\*(C`namespace\*(C'\fR stash value to change the namespace of a whole
route with all its children.
.PP
.Vb 3
\&  # /bye \-> MyApp::Controller::Foo\->bye
\&  $r\->route(\*(Aq/bye\*(Aq)
\&    \->to(namespace => \*(AqMyApp::Controller::Foo\*(Aq, action => \*(Aqbye\*(Aq);
.Ve
.PP
The \f(CW\*(C`controller\*(C'\fR is always appended to the \f(CW\*(C`namespace\*(C'\fR if available.
.PP
.Vb 2
\&  # /bye \-> MyApp::Controller::Foo\->bye
\&  $r\->route(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo#bye\*(Aq, namespace => \*(AqMyApp::Controller\*(Aq);
.Ve
.PP
You can also change the default namespace for all routes in the application
with the router attribute \*(L"namespace\*(R" in Mojolicious::Routes.
.PP
.Vb 1
\&  $r\->namespace(\*(AqMyApp::Controller\*(Aq);
.Ve
.SS "Route to callback"
.IX Subsection "Route to callback"
The \f(CW\*(C`cb\*(C'\fR stash value can be used to bypass controllers and execute a
callback instead.
.PP
.Vb 4
\&  $r\->route(\*(Aq/bye\*(Aq)\->to(cb => sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqGood bye.\*(Aq);
\&  });
.Ve
.PP
This technique is the foundation of Mojolicious::Lite, you can learn more
about it from the included tutorial.
.SS "Placeholders and destinations"
.IX Subsection "Placeholders and destinations"
Extracted placeholder values will simply redefine older stash values if they
already exist.
.PP
.Vb 4
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqbye\*(Aq}
\&  # /hey \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhey\*(Aq}
\&  $r\->route(\*(Aq/:mymessage\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhi\*(Aq);
.Ve
.PP
One more interesting effect, if a placeholder is at the end of a route and
there is already a stash value of the same name present, it automatically
becomes optional.
.PP
.Vb 3
\&  # / \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhi\*(Aq}
\&  $r\->route(\*(Aq/:mymessage\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhi\*(Aq);
.Ve
.PP
This is also the case if multiple placeholders are right after another and
not separated by other characters than \f(CW\*(C`/\*(C'\fR.
.PP
.Vb 5
\&  # /           \-> {controller => \*(Aqfoo\*(Aq,   action => \*(Aqbar\*(Aq}
\&  # /users      \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /users/list \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqlist\*(Aq}
\&  $r\->route(\*(Aq/:controller/:action\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.PP
Special stash values like \f(CW\*(C`controller\*(C'\fR and \f(CW\*(C`action\*(C'\fR can also be
placeholders, this allows for extremely flexible routes constructs.
.SS "More restrictive placeholders"
.IX Subsection "More restrictive placeholders"
A very easy way to make placeholders more restrictive are alternatives, you
just make a list of possible values.
.PP
.Vb 5
\&  # /bender \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqbender\*(Aq}
\&  # /leela  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqleela\*(Aq}
\&  # /fry    \-> undef
\&  $r\->route(\*(Aq/:name\*(Aq, name => [\*(Aqbender\*(Aq, \*(Aqleela\*(Aq])
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.PP
You can also adjust the regular expressions behind placeholders to better
suit your needs. Just make sure not to use \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR or capturing groups
\&\f(CW\*(C`(...)\*(C'\fR, because placeholders become part of a larger regular expression
internally, \f(CW\*(C`(?:...)\*(C'\fR is fine though.
.PP
.Vb 4
\&  # /23   \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, number => 23}
\&  # /test \-> undef
\&  $r\->route(\*(Aq/:number\*(Aq, number => qr/\ed+/)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&
\&  # /23   \-> undef
\&  # /test \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqtest\*(Aq}
\&  $r\->route(\*(Aq/:name\*(Aq, name => qr/[a\-zA\-Z]+/)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.PP
This way you get easily readable routes and the raw power of regular
expressions.
.SS "Formats"
.IX Subsection "Formats"
File extensions like \f(CW\*(C`.html\*(C'\fR and \f(CW\*(C`.txt\*(C'\fR at the end of a route are
automatically detected and stored in the stash value \f(CW\*(C`format\*(C'\fR.
.PP
.Vb 4
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo.html \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqhtml\*(Aq}
\&  # /foo.txt  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqtxt\*(Aq}
\&  $r\->route(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.PP
This for example allows multiple templates for different formats to share the
same code. You can also mention a format in the route pattern to only match
one, just make sure the more specific routes go first.
.PP
.Vb 2
\&  # /foo.txt \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqtext\*(Aq, format => \*(Aqtxt\*(Aq}
\&  $r\->route(\*(Aq/foo.txt\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqtext\*(Aq);
\&
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqhyper\*(Aq}
\&  # /foo.html \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqhyper\*(Aq, format => \*(Aqhtml\*(Aq}
\&  $r\->route(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqhyper\*(Aq);
.Ve
.PP
Restrictive placeholders can also be used for format detection.
.PP
.Vb 5
\&  # /foo.rss \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqfeed\*(Aq, format => \*(Aqrss\*(Aq}
\&  # /foo.xml \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqfeed\*(Aq, format => \*(Aqxml\*(Aq}
\&  # /foo.txt \-> undef
\&  $r\->route(\*(Aq/foo\*(Aq, format => [\*(Aqrss\*(Aq, \*(Aqxml\*(Aq])
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqfeed\*(Aq);
.Ve
.PP
Or you can just disable format detection.
.PP
.Vb 3
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo.html \-> undef
\&  $r\->route(\*(Aq/foo\*(Aq, format => 0)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.SS "Named routes"
.IX Subsection "Named routes"
Naming your routes will allow backreferencing in many methods and helpers
throughout the whole framework, most of them internally rely on
\&\*(L"url_for\*(R" in Mojolicious::Controller for this.
.PP
.Vb 3
\&  # /foo/abc \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqabc\*(Aq}
\&  $r\->route(\*(Aq/foo/:name\*(Aq)\->name(\*(Aqtest\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&
\&  # Generate URL "/foo/abc" for route "test"
\&  my $url = $self\->url_for(\*(Aqtest\*(Aq);
\&
\&  # Generate URL "/foo/sebastian" for route "test"
\&  my $url = $self\->url_for(\*(Aqtest\*(Aq, name => \*(Aqsebastian\*(Aq);
.Ve
.PP
Nameless routes get an automatically generated one assigned that is simply
equal to the route itself without non-word characters.
.PP
.Vb 2
\&  # /foo/bar ("foobar")
\&  $r\->route(\*(Aq/foo/bar\*(Aq)\->to(\*(Aqtest#stuff\*(Aq);
\&
\&  # Generate URL "/foo/bar"
\&  my $url = $self\->url_for(\*(Aqfoobar\*(Aq);
.Ve
.PP
To refer to the current route you can use the reserved name \f(CW\*(C`current\*(C'\fR or no
name at all.
.PP
.Vb 3
\&  # Generate URL for current route
\&  my $url = $self\->url_for(\*(Aqcurrent\*(Aq);
\&  my $url = $self\->url_for;
.Ve
.PP
To check or get the name of the current route you can use the helper
\&\*(L"current_route\*(R" in Mojolicious::Plugin::DefaultHelpers.
.PP
.Vb 2
\&  # Name for current route
\&  my $name = $self\->current_route;
\&
\&  # Check route name in code shared by multiple routes
\&  $self\->stash(button => \*(Aqgreen\*(Aq) if $self\->current_route(\*(Aqlogin\*(Aq);
.Ve
.SS "\s-1HTTP\s0 methods"
.IX Subsection "HTTP methods"
The method \*(L"via\*(R" in Mojolicious::Routes allows only specific \s-1HTTP\s0 methods to
pass.
.PP
.Vb 4
\&  # GET /bye    \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq}
\&  # POST /bye   \-> undef
\&  # DELETE /bye \-> undef
\&  $r\->route(\*(Aq/bye\*(Aq)\->via(\*(AqGET\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq);
\&
\&  # GET /bye    \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq}
\&  # POST /bye   \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq}
\&  # DELETE /bye \-> undef
\&  $r\->route(\*(Aq/bye\*(Aq)\->via(\*(AqGET\*(Aq, \*(AqPOST\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq);
.Ve
.SS "Bridges"
.IX Subsection "Bridges"
Bridges can be used to share code with multiple nested routes, because unlike
normal nested routes, they always match and result in additional dispatch
cycles.
.PP
.Vb 5
\&  # /foo     \-> undef
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq}
\&  #             {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->bridge(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq);
\&  $foo\->route(\*(Aq/bar\*(Aq)\->to(action => \*(Aqbar\*(Aq);
.Ve
.PP
The actual bridge code needs to return a true value or the dispatch chain
will be broken, this makes bridges a very powerful tool for authentication.
.PP
.Vb 5
\&  # /foo     \-> undef
\&  # /foo/bar \-> {cb => sub {...}}
\&  #             {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->bridge(\*(Aq/foo\*(Aq)\->to(cb => sub {
\&    my $self = shift;
\&
\&    # Authenticated
\&    return 1 if $self\->req\->headers\->header(\*(AqX\-Bender\*(Aq);
\&
\&    # Not authenticated
\&    $self\->render(text => "You\*(Aqre not Bender.");
\&    return;
\&  });
\&  $foo\->route(\*(Aq/bar\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.SS "Waypoints"
.IX Subsection "Waypoints"
Waypoints are very similar to normal nested routes but can match even if they
have children.
.PP
.Vb 4
\&  # /foo     \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq}
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->waypoint(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq);
\&  $foo\->route(\*(Aq/bar\*(Aq)\->to(action => \*(Aqbar\*(Aq);
.Ve
.PP
All children will be ignored if a waypoint matches.
.SS "Hooks"
.IX Subsection "Hooks"
Hooks operate outside the routing system and allow you to extend
Mojolicious itself by sharing code with all requests indiscriminately,
which makes them a very powerful tool especially for plugins.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Check all requests for a "/test" prefix
\&    $self\->hook(before_dispatch => sub {
\&      my $self = shift;
\&      $self\->render(text => \*(AqThis request did not reach the router.\*(Aq)
\&        if $self\->req\->url\->path\->contains(\*(Aq/test\*(Aq);
\&    });
\&
\&    # These will not be reached if the hook above renders a response
\&    my $r = $self\->routes;
\&    $r\->route(\*(Aq/welcome\*(Aq)\->to(\*(Aqfoo#welcome\*(Aq);
\&    $r\->route(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo#bye\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
For a full list of available hooks see \*(L"hook\*(R" in Mojolicious.
.SS "Mojolicious::Lite routes"
.IX Subsection "Mojolicious::Lite routes"
Mojolicious::Lite routes are in fact just a small convenience layer around
everything described above and also part of the normal router.
.PP
.Vb 2
\&  # GET /foo \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqabc\*(Aq}
\&  $r\->get(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqabc\*(Aq);
.Ve
.PP
This makes the process of growing your Mojolicious::Lite prototypes into
full Mojolicious applications very straightforward.
.PP
.Vb 5
\&  # POST /bar
\&  $r\->post(\*(Aq/bar\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqJust like a Mojolicious::Lite action.\*(Aq);
\&  });
.Ve
.PP
Even the more abstract concepts are available.
.PP
.Vb 11
\&  # GET  /yada
\&  # POST /yada
\&  my $yada = $r\->under(\*(Aq/yada\*(Aq);
\&  $yada\->get(sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqHello.\*(Aq);
\&  });
\&  $yada\->post(sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqGo away.\*(Aq);
\&  });
.Ve
.SS "Shortcuts"
.IX Subsection "Shortcuts"
You can also add your own shortcuts to make route generation more expressive.
.PP
.Vb 3
\&  # Simple "resource" shortcut
\&  $r\->add_shortcut(resource => sub {
\&    my ($r, $name) = @_;
\&
\&    # Generate "/$name" route
\&    my $resource = $r\->route("/$name")\->to("$name#");
\&
\&    # Handle POST requests
\&    $resource\->post\->to(\*(Aq#create\*(Aq)\->name("create_$name");
\&
\&    # Handle GET requests
\&    $resource\->get\->to(\*(Aq#show\*(Aq)\->name("show_$name");
\&
\&    return $resource;
\&  });
\&
\&  # POST /user \-> {controller => \*(Aquser\*(Aq, action => \*(Aqcreate\*(Aq}
\&  # GET  /user \-> {controller => \*(Aquser\*(Aq, action => \*(Aqshow\*(Aq}
\&  $r\->resource(\*(Aquser\*(Aq);
.Ve
.PP
Shortcuts can lead to anything, routes, bridges or maybe even both. And watch
out for quicksand!
.SS "Introspection"
.IX Subsection "Introspection"
The \f(CW\*(C`routes\*(C'\fR command can be used from the command line to list all available
routes together with name and underlying regular expressions.
.PP
.Vb 3
\&  $ script/myapp routes \-v
\&  /foo/:name  GET   fooname  ^/foo/([^/\e.]+))(?:\e.([^/]+)$)?
\&  /bar        POST  bar      ^/bar(?:\e.([^/]+)$)?
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
Less commonly used and more powerful features.
.SS "IRIs"
.IX Subsection "IRIs"
IRIs are handled transparently, that means paths are guaranteed to be
unescaped and decoded to Perl characters.
.PP
.Vb 1
\&  use utf8;
\&
\&  # /X (unicode snowman) \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqsnowman\*(Aq}
\&  $r\->route(\*(Aq/X\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqsnowman\*(Aq);
.Ve
.PP
Just don't forget to use the utf8 pragma or you'll make the unicode
snowman very sad.
.SS "WebSockets"
.IX Subsection "WebSockets"
You can restrict access to WebSocket handshakes using the method
\&\*(L"websocket\*(R" in Mojolicious::Routes.
.PP
.Vb 2
\&  # /echo (WebSocket handshake)
\&  $r\->websocket(\*(Aq/echo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqecho\*(Aq);
\&
\&  # Controller
\&  package MyApp::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub echo {
\&    my $self = shift;
\&    $self\->on(message => sub {
\&      my ($self, $message) = @_;
\&      $self\->send("echo: $message");
\&    });
\&  }
\&
\&  1;
.Ve
.SS "Conditions"
.IX Subsection "Conditions"
Sometimes you might need a little more power, for example to check the
\&\f(CW\*(C`User\-Agent\*(C'\fR header in multiple routes. This is where conditions come into
play, they are basically router plugins.
.PP
.Vb 4
\&  # Simple "User\-Agent" condition
\&  $r\->add_condition(
\&    agent => sub {
\&      my ($r, $c, $captures, $pattern) = @_;
\&
\&      # User supplied regular expression
\&      return unless $pattern && ref $pattern eq \*(AqRegexp\*(Aq;
\&
\&      # Match "User\-Agent" header and return true on success
\&      my $agent = $c\->req\->headers\->user_agent;
\&      return 1 if $agent && $agent =~ $pattern;
\&
\&      # No success
\&      return;
\&    }
\&  );
\&
\&  # /firefox_only (Firefox) \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  $r\->route(\*(Aq/firefox_only\*(Aq)\->over(agent => qr/Firefox/)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
.Ve
.PP
The method \*(L"add_condition\*(R" in Mojolicious::Routes registers the new condition
in the router, while \*(L"over\*(R" in Mojolicious::Routes actually applies it to the
route.
.SS "Condition plugins"
.IX Subsection "Condition plugins"
You can also package your conditions as reusable plugins.
.PP
.Vb 3
\&  # Plugin
\&  package Mojolicious::Plugin::WerewolfCondition;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  use Astro::MoonPhase;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Add "werewolf" condition
\&    $app\->routes\->add_condition(
\&      werewolf => sub {
\&        my ($r, $c, $captures, $days) = @_;
\&
\&        # Keep the werewolfs out!
\&        return if abs(14 \- (phase(time))[2]) > ($days / 2);
\&
\&        # It\*(Aqs ok, no werewolf
\&        return 1;
\&      }
\&    );
\&  }
\&
\&  1;
.Ve
.PP
Now just load the plugin and you are ready to use the condition in all your
applications.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Plugin
\&    $self\->plugin(\*(AqWerewolfCondition\*(Aq);
\&
\&    # /hideout (keep them out for 4 days after full moon)
\&    $self\->routes\->route(\*(Aq/hideout\*(Aq)\->over(werewolf => 4)
\&      \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  }
\&
\&  1;
.Ve
.SS "Embedding applications"
.IX Subsection "Embedding applications"
You can easily embed whole applications simply by using them instead of a
controller. This allows for example the use of the Mojolicious::Lite
domain specific language in normal Mojolicious controllers.
.PP
.Vb 3
\&  # Controller
\&  package MyApp::Bar;
\&  use Mojolicious::Lite;
\&
\&  # /hello
\&  get \*(Aq/hello\*(Aq => sub {
\&    my $self = shift;
\&    my $name = $self\->param(\*(Aqname\*(Aq);
\&    $self\->render(text => "Hello $name.");
\&  };
\&
\&  1;
.Ve
.PP
With the method \*(L"detour\*(R" in Mojolicious::Routes which is very similar to
\&\*(L"to\*(R" in Mojolicious::Routes, you can allow the route to partially match and
use only the remaining path in the embedded application, the base path will
be passed along in the \f(CW\*(C`path\*(C'\fR stash value.
.PP
.Vb 2
\&  # /foo/*
\&  $r\->route(\*(Aq/foo\*(Aq)\->detour(\*(Aqbar#\*(Aq, name => \*(AqMojo\*(Aq);
.Ve
.PP
A minimal embeddable application is nothing more than a subclass of Mojo,
containing a \f(CW\*(C`handler\*(C'\fR method accepting Mojolicious::Controller objects.
.PP
.Vb 2
\&  package MyApp::Bar;
\&  use Mojo::Base \*(AqMojo\*(Aq;
\&
\&  sub handler {
\&    my ($self, $c) = @_;
\&    $c\->res\->code(200);
\&    my $name = $c\->param(\*(Aqname\*(Aq);
\&    $c\->res\->body("Hello $name.");
\&  }
\&
\&  1;
.Ve
.PP
You can also just use Mojolicious::Plugin::Mount to mount whole
self-contained applications under a prefix.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Whole application mounted under "/prefix"
\&  plugin Mount => {\*(Aq/prefix\*(Aq => \*(Aq/home/sri/myapp.pl\*(Aq};
\&
\&  # Normal route
\&  get \*(Aq/\*(Aq => sub { shift\->render_text(\*(AqHello World!\*(Aq) };
\&
\&  app\->start;
.Ve
.SS "Application plugins"
.IX Subsection "Application plugins"
Embedding Mojolicious applications is easy, but it gets even easier if you
package the whole thing as a self contained reusable plugin.
.PP
.Vb 3
\&  # Plugin
\&  package Mojolicious::Plugin::MyEmbeddedApp;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Automatically add route
\&    $app\->routes\->route(\*(Aq/foo\*(Aq)\->detour(app => EmbeddedApp::app());
\&  }
\&
\&  package EmbeddedApp;
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/bar\*(Aq => \*(Aqbar\*(Aq;
\&
\&  1;
\&  _\|_DATA_\|_
\&  @@ bar.html.ep
\&  Hello World!
.Ve
.PP
The \f(CW\*(C`app\*(C'\fR stash value can be used for already instantiated applications. Now
just load the plugin and you're done.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Plugin
\&    $self\->plugin(\*(AqMyEmbeddedApp\*(Aq);
\&  }
\&
\&  1;
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
