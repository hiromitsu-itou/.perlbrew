.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Diff 3"
.TH SQL::Translator::Diff 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Diff \- determine differences between two schemas
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Takes two input SQL::Translator::Schemas (or \s-1SQL\s0 files) and produces \s-1ALTER\s0 
statments to make them the same
.SH "SNYOPSIS"
.IX Header "SNYOPSIS"
Simplest usage:
.PP
.Vb 2
\& use SQL::Translator::Diff;
\& my $sql = SQL::Translator::Diff::schema_diff($source_schema, \*(AqMySQL\*(Aq, $target_schema, \*(AqMySQL\*(Aq, $options_hash)
.Ve
.PP
\&\s-1OO\s0 usage:
.PP
.Vb 7
\& use SQL::Translator::Diff;
\& my $diff = SQL::Translator::Diff\->new({
\&   output_db     => \*(AqMySQL\*(Aq,
\&   source_schema => $source_schema,
\&   target_schema => $target_schema,
\&   %$options_hash,
\& })\->compute_differences\->produce_diff_sql;
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fBignore_index_names\fR" 4
.IX Item "ignore_index_names"
Match indexes based on types and fields, ignoring name.
.IP "\fBignore_constraint_names\fR" 4
.IX Item "ignore_constraint_names"
Match constrains based on types, fields and tables, ignoring name.
.IP "\fBoutput_db\fR" 4
.IX Item "output_db"
Which producer to use to produce the output.
.IP "\fBcase_insensitive\fR" 4
.IX Item "case_insensitive"
Ignore case of table, field, index and constraint names when comparing
.IP "\fBno_batch_alters\fR" 4
.IX Item "no_batch_alters"
Produce each alter as a distinct \f(CW\*(C`ALTER TABLE\*(C'\fR statement even if the producer
supports the ability to do all alters for a table as one statement.
.IP "\fBignore_missing_methods\fR" 4
.IX Item "ignore_missing_methods"
If the diff would need a method that is missing from the producer, just emit a
comment showing the method is missing, rather than dieing with an error
.SH "PRODUCER FUNCTIONS"
.IX Header "PRODUCER FUNCTIONS"
The following producer functions should be implemented for completeness. If
any of them are needed for a given diff, but not found, an error will be 
thrown.
.IP "\(bu" 4
\&\f(CW\*(C`alter_create_constraint($con)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`alter_drop_constraint($con)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`alter_create_index($idx)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`alter_drop_index($idx)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`add_field($fld)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`alter_field($old_fld, $new_fld)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rename_field($old_fld, $new_fld)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`drop_field($fld)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`alter_table($table)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`drop_table($table)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rename_table($old_table, $new_table)\*(C'\fR (optional)
.IP "\(bu" 4
\&\f(CW\*(C`batch_alter_table($table, $hash)\*(C'\fR (optional)
.Sp
If the producer supports \f(CW\*(C`batch_alter_table\*(C'\fR, it will be called with the 
table to alter and a hash, the keys of which will be the method names listed
above; values will be arrays of fields or constraints to operate on. In the 
case of the field functions that take two arguments this will appear as a hash.
.Sp
I.e. the hash might look something like the following:
.Sp
.Vb 5
\& {
\&   alter_create_constraint => [ $constraint1, $constraint2 ],
\&   add_field   => [ $field ],
\&   alter_field => [ [$old_field, $new_field] ]
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`preprocess_schema($class, $schema)\*(C'\fR (optional)
.Sp
\&\f(CW\*(C`preprocess_schema\*(C'\fR is called by the Diff code to allow the producer to
normalize any data it needs to first. For example, the MySQL producer uses
this method to ensure that \s-1FK\s0 contraint names are unique.
.Sp
Basicaly any changes that need to be made to produce the \s-1SQL\s0 file for the
schema should be done here, so that a diff between a parsed \s-1SQL\s0 file and (say)
a parsed DBIx::Class::Schema object will be sane.
.Sp
(As an aside, DBIx::Class, for instance, uses the presence of a 
\&\f(CW\*(C`preprocess_schema\*(C'\fR function on the producer to know that it can diff between
the previous \s-1SQL\s0 file and its own internal representation. Without this method
on th producer it will diff the two \s-1SQL\s0 files which is slower, but known to 
work better on old-style producers.)
.SH "AUTHOR"
.IX Header "AUTHOR"
Original Author(s) unknown.
.PP
Refactor/re\-write and more comprehensive tests by Ash Berlin \f(CW\*(C`ash@cpan.org\*(C'\fR.
.PP
Redevelopment sponsored by Takkle Inc.
