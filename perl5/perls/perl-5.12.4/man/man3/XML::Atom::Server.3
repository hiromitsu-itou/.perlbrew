.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Atom::Server 3"
.TH XML::Atom::Server 3 "2011-09-19" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Atom::Server \- A server for the Atom API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    package My::Server;
\&    use base qw( XML::Atom::Server );
\&    sub handle_request {
\&        my $server = shift;
\&        $server\->authenticate or return;
\&        my $method = $server\->request_method;
\&        if ($method eq \*(AqPOST\*(Aq) {
\&            return $server\->new_post;
\&        }
\&        ...
\&    }
\&
\&    my %Passwords;
\&    sub password_for_user {
\&        my $server = shift;
\&        my($username) = @_;
\&        $Passwords{$username};
\&    }
\&
\&    sub new_post {
\&        my $server = shift;
\&        my $entry = $server\->atom_body or return;
\&        ## $entry is an XML::Atom::Entry object.
\&        ## ... Save the new entry ...
\&    }
\&
\&    package main;
\&    my $server = My::Server\->new;
\&    $server\->run;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIXML::Atom::Server\fR provides a base class for Atom \s-1API\s0 servers. It handles
all core server processing, both the \s-1SOAP\s0 and \s-1REST\s0 formats of the protocol,
and \s-1WSSE\s0 authentication. It can also run as either a mod_perl handler or as
part of a \s-1CGI\s0 program.
.PP
It does not provide functions specific to any particular implementation,
such as posting an entry, retrieving a list of entries, deleting an entry, etc.
Implementations should subclass \fIXML::Atom::Server\fR, overriding the
\&\fIhandle_request\fR method, and handle all functions such as this themselves.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Request Handling"
.IX Subsection "Request Handling"
Subclasses of \fIXML::Atom::Server\fR must override the \fIhandle_request\fR
method to perform all request processing. The implementation must set all
response headers, including the response code and any relevant \s-1HTTP\s0 headers,
and should return a scalar representing the response body to be sent back
to the client.
.PP
For example:
.PP
.Vb 8
\&    sub handle_request {
\&        my $server = shift;
\&        my $method = $server\->request_method;
\&        if ($method eq \*(AqPOST\*(Aq) {
\&            return $server\->new_post;
\&        }
\&        ## ... handle GET, PUT, etc
\&    }
\&    
\&    sub new_post {
\&        my $server = shift;
\&        my $entry = $server\->atom_body or return;
\&        my $id = save_this_entry($entry);  ## Implementation\-specific
\&        $server\->response_header(Location => $server\->uri . \*(Aq/entry_id=\*(Aq . $id);
\&        $server\->response_code(201);
\&        $server\->response_content_type(\*(Aqapplication/x.atom+xml\*(Aq);
\&        return serialize_entry($entry);    ## Implementation\-specific
\&    }
.Ve
.SS "Authentication"
.IX Subsection "Authentication"
Servers that require authentication for posting or retrieving entries or
feeds should override the \fIpassword_for_user\fR method. Given a username
(from the \s-1WSSE\s0 header), \fIpassword_for_user\fR should return that user's
password in plaintext. This will then be combined with the nonce and the
creation time to generate the digest, which will be compared with the
digest sent in the \s-1WSSE\s0 header. If the supplied username doesn't exist in
your user database or alike, just return \f(CW\*(C`undef\*(C'\fR.
.PP
For example:
.PP
.Vb 6
\&    my %Passwords = ( foo => \*(Aqbar\*(Aq );   ## The password for "foo" is "bar".
\&    sub password_for_user {
\&        my $server = shift;
\&        my($username) = @_;
\&        $Passwords{$username};
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
\&\fIXML::Atom::Server\fR provides a variety of methods to be used by subclasses
for retrieving headers, content, and other request information, and for
setting the same on the response.
.SS "Client Request Parameters"
.IX Subsection "Client Request Parameters"
.IP "\(bu" 4
\&\f(CW$server\fR\->uri
.Sp
Returns the \s-1URI\s0 of the Atom server implementation.
.IP "\(bu" 4
\&\f(CW$server\fR\->request_method
.Sp
Returns the name of the request method sent to the server from the client
(for example, \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, etc). Note that if the client sent the
request in a \s-1SOAP\s0 envelope, the method is obtained from the \fISOAPAction\fR
\&\s-1HTTP\s0 header.
.IP "\(bu" 4
\&\f(CW$server\fR\->request_header($header)
.Sp
Retrieves the value of the \s-1HTTP\s0 request header \fI\f(CI$header\fI\fR.
.IP "\(bu" 4
\&\f(CW$server\fR\->request_content
.Sp
Returns a scalar containing the contents of a \s-1POST\s0 or \s-1PUT\s0 request from the
client.
.IP "\(bu" 4
\&\f(CW$server\fR\->request_param($param)
.Sp
\&\fIXML::Atom::Server\fR automatically parses the \s-1PATH_INFO\s0 sent in the request
and breaks it up into key-value pairs. This can be used to pass parameters.
For example, in the \s-1URI\s0
.Sp
.Vb 1
\&    http://localhost/atom\-server/entry_id=1
.Ve
.Sp
the \fIentry_id\fR parameter would be set to \f(CW1\fR.
.Sp
\&\fIrequest_param\fR returns the value of the value of the parameter \fI\f(CI$param\fI\fR.
.SS "Setting up the Response"
.IX Subsection "Setting up the Response"
.IP "\(bu" 4
\&\f(CW$server\fR\->response_header($header, \f(CW$value\fR)
.Sp
Sets the value of the \s-1HTTP\s0 response header \fI\f(CI$header\fI\fR to \fI\f(CI$value\fI\fR.
.IP "\(bu" 4
\&\f(CW$server\fR\->response_code([ \f(CW$code\fR ])
.Sp
Returns the current response code to be sent back to the client, and if
\&\fI\f(CI$code\fI\fR is given, sets the response code.
.IP "\(bu" 4
\&\f(CW$server\fR\->response_content_type([ \f(CW$type\fR ])
.Sp
Returns the current \fIContent-Type\fR header to be sent back to the client, and
\&\fI\f(CI$type\fI\fR is given, sets the value for that header.
.SS "Processing the Request"
.IX Subsection "Processing the Request"
.IP "\(bu" 4
\&\f(CW$server\fR\->authenticate
.Sp
Attempts to authenticate the request based on the authentication
information present in the request (currently just \s-1WSSE\s0). This will call
the \fIpassword_for_user\fR method in the subclass to obtain the cleartext
password for the username given in the request.
.IP "\(bu" 4
\&\f(CW$server\fR\->atom_body
.Sp
Returns an \fIXML::Atom::Entry\fR object containing the entry sent in the
request.
.SH "USAGE"
.IX Header "USAGE"
Once you have defined your server subclass, you can set it up either as a
\&\s-1CGI\s0 program or as a mod_perl handler.
.PP
A simple \s-1CGI\s0 program would look something like this:
.PP
.Vb 2
\&    #!/usr/bin/perl \-w
\&    use strict;
\&
\&    use My::Server;
\&    my $server = My::Server\->new;
\&    $server\->run;
.Ve
.PP
A simple mod_perl handler configuration would look something like this:
.PP
.Vb 5
\&    PerlModule My::Server
\&    <Location /atom\-server>
\&        SetHandler perl\-script
\&        PerlHandler My::Server
\&    </Location>
.Ve
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
If you wish to return an error from \fIhandle_request\fR, you can use the
built-in \fIerror\fR method:
.PP
.Vb 5
\&    sub handle_request {
\&        my $server = shift;
\&        ...
\&        return $server\->error(500, "Something went wrong");
\&    }
.Ve
.PP
This will be returned to the client with a response code of 500 and an
error string of \f(CW\*(C`Something went wrong\*(C'\fR. Errors are automatically
serialized into \s-1SOAP\s0 faults if the incoming request is enclosed in a \s-1SOAP\s0
envelope.
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Please see the \fIXML::Atom\fR manpage for author, copyright, and license
information.
