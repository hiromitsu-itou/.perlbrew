.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Schema::Object 3"
.TH SQL::Translator::Schema::Object 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Schema::Object \- Base class SQL::Translator Schema objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCSIPTION"
.IX Header "DESCSIPTION"
Base class for Schema objects. Sub classes Class::Base and adds the following
extra functionality.
.SH "Construction"
.IX Header "Construction"
Derived classes should declare their attributes using the \f(CW\*(C`_attributes\*(C'\fR
method. They can then inherit the \f(CW\*(C`init\*(C'\fR method from here which will call
accessors of the same name for any values given in the hash passed to \f(CW\*(C`new\*(C'\fR.
Note that you will have to impliment the accessors your self and we expect perl
style methods; call with no args to get and with arg to set.
.PP
e.g. If we setup our class as follows;
.PP
.Vb 2
\& package SQL::Translator::Schema::Table;
\& use base qw/SQL::Translator::Schema::Object/;
\& 
\& _\|_PACKAGE_\|_\->_attributes( qw/schema name/ );
\&
\& sub name   { ... }
\& sub schema { ... }
.Ve
.PP
Then we can construct it with
.PP
.Vb 4
\& my $table  =  SQL::Translator::Schema::Table\->new( 
\&     schema => $schema,
\&     name   => \*(Aqfoo\*(Aq,
\& );
.Ve
.PP
and init will call \f(CW\*(C`$table\->name("foo")\*(C'\fR and \f(CW\*(C`$table\->schema($schema)\*(C'\fR
to set it up. Any undefined args will be ignored.
.PP
Multiple calls to \f(CW\*(C`_attributes\*(C'\fR are cumulative and sub classes will inherit
their parents attribute names.
.PP
This is currently experimental, but will hopefull go on to form an introspection
\&\s-1API\s0 for the Schema objects.
.SH "Global Attributes"
.IX Header "Global Attributes"
The following attributes are defined here, therefore all schema objects will
have them.
.SS "extra"
.IX Subsection "extra"
Get or set the objects \*(L"extra\*(R" attibutes (e.g., \*(L"\s-1ZEROFILL\s0\*(R" for MySQL fields).
Call with no args to get all the extra data.
Call with a single name arg to get the value of the named extra attribute,
returned as a scalar. Call with a hash or hashref to set extra attributes.
Returns a hash or a hashref.
.PP
.Vb 1
\&  $field\->extra( qualifier => \*(AqZEROFILL\*(Aq );
\&  
\&  $qualifier = $field\->extra(\*(Aqqualifier\*(Aq);
\&  
\&  %extra = $field\->extra;
\&  $extra = $field\->extra;
.Ve
.SS "remove_extra"
.IX Subsection "remove_extra"
\&\*(L"extra\*(R" can only be used to get or set \*(L"extra\*(R" attributes but not to
remove some. Call with no args to remove all extra attributes that
have been set before. Call with a list of key names to remove
certain extra attributes only.
.PP
.Vb 2
\&  # remove all extra attributes
\&  $field\->remove_extra(); 
\&  
\&  # remove timezone and locale attributes only
\&  $field\->remove_extra(qw/timezone locale/);
.Ve
.SS "equals"
.IX Subsection "equals"
Determines if this object is the same as another.
.PP
.Vb 1
\&  my $isIdentical = $object1\->equals( $object2 );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SH "TODO"
.IX Header "TODO"
.SH "BUGS"
.IX Header "BUGS"
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Youens-Clark <kclark@cpan.org>, 
Mark Addison <mark.addison@itn.co.uk>.
