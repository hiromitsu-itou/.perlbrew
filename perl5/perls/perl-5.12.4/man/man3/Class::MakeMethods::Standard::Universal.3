.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Standard::Universal 3"
.TH MakeMethods::Standard::Universal 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Standard::Universal \- Generic Methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    no_op => \*(Aqthis\*(Aq,
\&    abstract => \*(Aqthat\*(Aq,
\&    delegate => { name=>\*(Aqplay_music\*(Aq, target=>\*(Aqinstrument\*(Aq, method=>\*(Aqplay\*(Aq },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Standard::Universal suclass of MakeMethods provides a [\s-1INCOMPLETE\s0].
.SS "Calling Conventions"
.IX Subsection "Calling Conventions"
When you \f(CW\*(C`use\*(C'\fR this package, the method names you provide
as arguments cause subroutines to be generated and installed in
your module.
.PP
See \*(L"Calling Conventions\*(R" in Class::MakeMethods::Standard for more information.
.SS "Declaration Syntax"
.IX Subsection "Declaration Syntax"
To declare methods, pass in pairs of a method-type name followed
by one or more method names.
.PP
Valid method-type names for this package are listed in \*(L"\s-1METHOD\s0
\&\s-1GENERATOR\s0 \s-1TYPES\s0\*(R".
.PP
See \*(L"Declaration Syntax\*(R" in Class::MakeMethods::Standard and \*(L"Parameter Syntax\*(R" in Class::MakeMethods::Standard for more information.
.SH "METHOD GENERATOR TYPES"
.IX Header "METHOD GENERATOR TYPES"
.SS "no_op \- Placeholder"
.IX Subsection "no_op - Placeholder"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Does nothing.
.PP
You might want to create and use such methods to provide hooks for
subclass activity.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    no_op => \*(Aqwhatever\*(Aq,
\&  );
\&  ...
\&  
\&  # Doesn\*(Aqt do anything
\&  MyObject\->whatever();
.Ve
.SS "abstract \- Placeholder"
.IX Subsection "abstract - Placeholder"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Fails with an error message.
.PP
This is intended to support the use of abstract methods, that must
be overidden in a useful subclass.
.PP
If each subclass is expected to provide an implementation of a given method, using this abstract method will replace the generic error message below with the clearer, more explicit error message that follows it:
.PP
.Vb 2
\&  Can\*(Aqt locate object method "foo" via package "My::Subclass"
\&  The "foo" method is abstract and can not be called on My::Subclass
.Ve
.PP
However, note that the existence of this method will be detected by \fIUNIVERSAL::can()\fR, so it is not suitable for use in optional interfaces, for which you may wish to be able to detect whether the method is supported or not.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    abstract => \*(Aqwhatever\*(Aq,
\&  );
\&  ...
\&  
\&  package MySubclass;
\&  sub whatever { ... }
\&  
\&  # Failure
\&  MyObject\->whatever();
\&  
\&  # Success
\&  MySubclass\->whatever();
.Ve
.SS "call_methods \- Call methods by name"
.IX Subsection "call_methods - Call methods by name"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Accepts a hash of key-value pairs, or a reference to hash of such pairs. For each pair, the key is interpreted as the name of a method to call, and the value is the argument to be passed to that method.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    call_methods => \*(Aqinit\*(Aq,
\&  );
\&  ...
\&  
\&  my $object = MyObject\->new()
\&  $object\->init( foo => \*(AqFoozle\*(Aq, bar => \*(AqBarbados\*(Aq );
\&  
\&  # Equivalent to:
\&  $object\->foo(\*(AqFoozle\*(Aq);
\&  $object\->bar(\*(AqBarbados\*(Aq);
.Ve
.SS "join_methods \- Concatenate results of other methods"
.IX Subsection "join_methods - Concatenate results of other methods"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Has a list of other methods names as an arrayref in the 'methods' parameter. \fBRequired\fR.
.IP "\(bu" 4
When called, calls each of the named method on itself, in order, and returns the concatenation of their results.
.IP "\(bu" 4
If a 'join' parameter is provided it is included between each method result.
.IP "\(bu" 4
If the 'skip_blanks' parameter is omitted, or is provided with a true value, removes all undefined or empty-string values from the results.
.SS "alias \- Call another method"
.IX Subsection "alias - Call another method"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Calls another method on the same callee.
.PP
You might create such a method to extend or adapt your class' interface.
.PP
Sample declaration and usage:
.PP
.Vb 6
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    alias => { name=>\*(Aqclick_here\*(Aq, target=>\*(Aqcomplex_machinery\*(Aq }
\&  );
\&  sub complex_machinery { ... }
\&  ...
\&  
\&  $myobj\->click_here(...); # calls $myobj\->complex_machinery(...)
.Ve
.SS "delegate \- Use another object to provide method"
.IX Subsection "delegate - Use another object to provide method"
For each method name passed, returns a subroutine with the following characteristics:
.IP "\(bu" 4
Calls a method on self to retrieve another object, and then calls a method on that object and returns its value.
.PP
You might want to create and use such methods to faciliate composition of objects from smaller objects.
.PP
Sample declaration and usage:
.PP
.Vb 6
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Universal (
\&    \*(AqStandard::Hash:object\*(Aq => { name=>\*(Aqinstrument\*(Aq },
\&    delegate => { name=>\*(Aqplay_music\*(Aq, target=>\*(Aqinstrument\*(Aq, method=>\*(Aqplay\*(Aq }
\&  );
\&  ...
\&  
\&  my $object = MyObject\->new();
\&  $object\->instrument( MyInstrument\->new );
\&  $object\->play_music;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.PP
See Class::MakeMethods::Standard for more about this family of subclasses.
