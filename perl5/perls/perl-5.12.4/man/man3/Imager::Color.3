.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Color 3"
.TH Imager::Color 3 "2011-06-06" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Color \- Color handling for Imager.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Imager;
\&
\&  $color = Imager::Color\->new($red, $green, $blue);
\&  $color = Imager::Color\->new($red, $green, $blue, $alpha);
\&  $color = Imager::Color\->new("#C0C0FF"); # html color specification
\&
\&  $color\->set($red, $green, $blue);
\&  $color\->set($red, $green, $blue, $alpha);
\&  $color\->set("#C0C0FF"); # html color specification
\&
\&  ($red, $green, $blue, $alpha) = $color\->rgba();
\&  @hsv = $color\->hsv();
\&
\&  $color\->info();
\&
\&  if ($color\->equals(other=>$other_color)) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module handles creating color objects used by Imager.  The idea
is that in the future this module will be able to handle color space
calculations as well.
.PP
An Imager color consists of up to four components, each in the range 0
to 255. Unfortunately the meaning of the components can change
depending on the type of image you're dealing with:
.IP "\(bu" 4
for 3 or 4 channel images the color components are red, green, blue,
alpha.
.IP "\(bu" 4
for 1 or 2 channel images the color components are gray, alpha, with
the other two components ignored.
.PP
An alpha value of zero is fully transparent, an alpha value of 255 is
fully opaque.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
This creates a color object to pass to functions that need a color argument.
.IP "set" 4
.IX Item "set"
This changes an already defined color.  Note that this does not affect any places
where the color has been used previously.
.IP "\fIrgba()\fR" 4
.IX Item "rgba()"
This returns the red, green, blue and alpha channels of the color the
object contains.
.IP "info" 4
.IX Item "info"
Calling info merely dumps the relevant color to the log.
.IP "equals(other=>$other_color)" 4
.IX Item "equals(other=>$other_color)"
.PD 0
.IP "equals(other=>$other_color, ignore_alpha=>1)" 4
.IX Item "equals(other=>$other_color, ignore_alpha=>1)"
.PD
Compares \f(CW$self\fR and color \f(CW$other_color\fR returning true if the color
components are the same.
.Sp
Compares all four channels unless \f(CW\*(C`ignore_alpha\*(C'\fR is set.  If
\&\f(CW\*(C`ignore_alpha\*(C'\fR is set only the first three channels are compared.
.PP
You can specify colors in several different ways, you can just supply
simple values:
.IP "\(bu" 4
simple numeric parameters \- if you supply 3 or 4 numeric arguments, you get a color made up of those \s-1RGB\s0 (and possibly A) components.
.IP "\(bu" 4
a six hex digit web color, either \f(CW\*(C`RRGGBB\*(C'\fR or \f(CW\*(C`#RRGGBB\*(C'\fR
.IP "\(bu" 4
an eight hex digit web color, either \f(CW\*(C`RRGGBBAA\*(C'\fR or \f(CW\*(C`#RRGGBBAA\*(C'\fR.
.IP "\(bu" 4
a 3 hex digit web color, \f(CW\*(C`#RGB\*(C'\fR \- a value of F becomes 255.
.IP "\(bu" 4
a color name, from whichever of the gimp \f(CW\*(C`Named_Colors\*(C'\fR file or X
\&\f(CW\*(C`rgb.txt\*(C'\fR is found first.  The same as using the \f(CW\*(C`name\*(C'\fR keyword.
.PP
You can supply named parameters:
.IP "\(bu" 4
\&'red', 'green' and 'blue', optionally shortened to 'r', 'g' and 'b'.
The color components in the range 0 to 255.
.Sp
.Vb 4
\& # all of the following are equivalent
\& my $c1 = Imager::Color\->new(red=>100, blue=>255, green=>0);
\& my $c2 = Imager::Color\->new(r=>100, b=>255, g=>0);
\& my $c3 = Imager::Color\->new(r=>100, blue=>255, g=>0);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`hue\*(C'\fR, \f(CW\*(C`saturation\*(C'\fR and \f(CW\*(C`value\*(C'\fR, optionally shortened to \f(CW\*(C`h\*(C'\fR, \f(CW\*(C`s\*(C'\fR and
\&\f(CW\*(C`v\*(C'\fR, to specify a \s-1HSV\s0 color.  0 <= hue < 360, 0 <= s <= 1 and 0 <= v
<= 1.
.Sp
.Vb 3
\&  # the same as RGB(127,255,127)
\&  my $c1 = Imager::Color\->new(hue=>120, v=>1, s=>0.5);
\&  my $c1 = Imager::Color\->new(hue=>120, value=>1, saturation=>0.5);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`web\*(C'\fR, which can specify a 6 or 3 hex digit web color, in any of the
forms \f(CW\*(C`#RRGGBB\*(C'\fR, \f(CW\*(C`#RGB\*(C'\fR, \f(CW\*(C`RRGGBB\*(C'\fR or \f(CW\*(C`RGB\*(C'\fR.
.Sp
.Vb 1
\&  my $c1 = Imager::Color\->new(web=>\*(Aq#FFC0C0\*(Aq); # pale red
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gray\*(C'\fR or \f(CW\*(C`grey\*(C'\fR which specifies a single channel, from 0 to 255.
.Sp
.Vb 3
\&  # exactly the same
\&  my $c1 = Imager::Color\->new(gray=>128);
\&  my $c1 = Imager::Color\->new(grey=>128);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`rgb\*(C'\fR which takes a 3 member arrayref, containing each of the red,
green and blue values.
.Sp
.Vb 3
\&  # the same
\&  my $c1 = Imager::Color\->new(rgb=>[255, 100, 0]);
\&  my $c1 = Imager::Color\->new(r=>255, g=>100, b=>0);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`hsv\*(C'\fR which takes a 3 member arrayref, containing each of hue,
saturation and value.
.Sp
.Vb 3
\&  # the same
\&  my $c1 = Imager::Color\->new(hsv=>[120, 0.5, 1]);
\&  my $c1 = Imager::Color\->new(hue=>120, v=>1, s=>0.5);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gimp\*(C'\fR which specifies a color from a \s-1GIMP\s0 palette file.  You can
specify the file name of the palette file with the 'palette'
parameter, or let Imager::Color look in various places, typically
\&\f(CW\*(C`$HOME/gimp\-1.x/palettes/Named_Colors\*(C'\fR with and without the version
number, and in \f(CW\*(C`/usr/share/gimp/palettes/\*(C'\fR.  The palette file must
have color names.
.Sp
.Vb 2
\&  my $c1 = Imager::Color\->new(gimp=>\*(Aqsnow\*(Aq);
\&  my $c1 = Imager::Color\->new(gimp=>\*(Aqsnow\*(Aq, palette=>\*(Aqtestimg/test_gimp_pal);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`xname\*(C'\fR which specifies a color from an X11 \f(CW\*(C`rgb.txt\*(C'\fR file.  You can
specify the file name of the \f(CW\*(C`rgb.txt\*(C'\fR file with the \f(CW\*(C`palette\*(C'\fR
parameter, or let Imager::Color look in various places, typically
\&\f(CW\*(C`/usr/lib/X11/rgb.txt\*(C'\fR.
.Sp
.Vb 1
\&  my $c1 = Imager::Color\->new(xname=>\*(Aqblue\*(Aq) # usually RGB(0, 0, 255)
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`builtin\*(C'\fR which specifies a color from the built-in color table in
Imager::Color::Table.  The colors in this module are the same as the
default X11 \f(CW\*(C`rgb.txt\*(C'\fR file.
.Sp
.Vb 1
\&  my $c1 = Imager::Color\->new(builtin=>\*(Aqblack\*(Aq) # always RGB(0, 0, 0)
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR which specifies a name from either a \s-1GIMP\s0 palette, an X
\&\f(CW\*(C`rgb.txt\*(C'\fR file or the built-in color table, whichever is found first.
.IP "\(bu" 4
\&'channel0', 'channel1', etc, each of which specifies a single channel.  These can be abbreviated to 'c0', 'c1' etc.
.IP "\(bu" 4
\&'channels' which takes an arrayref of the channel values.
.PP
Optionally you can add an alpha channel to a color with the 'alpha' or
\&'a' parameter.
.PP
These color specifications can be used for both constructing new
colors with the \fInew()\fR method and modifying existing colors with the
\&\fIset()\fR method.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIhsv()\fR" 4
.IX Item "hsv()"
.Vb 1
\&    my($h, $s, $v, $alpha) = $color\->hsv();
.Ve
.Sp
Returns the color as a Hue/Saturation/Value/Alpha tuple.
.SH "AUTHOR"
.IX Header "AUTHOR"
Arnar M. Hrafnkelsson, addi@umich.edu
And a great deal of help from others \- see the \f(CW\*(C`README\*(C'\fR for a complete
list.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIImager\fR\|(3), Imager::Color
http://imager.perl.org/
