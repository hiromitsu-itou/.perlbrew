.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Files 3"
.TH Imager::Files 3 "2011-11-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Files \- working with image files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Imager;
\&  my $img = ...;
\&  $img\->write(file=>$filename, type=>$type)
\&    or die "Cannot write: ",$img\->errstr;
\&
\&  # type is optional if we can guess the format from the filename
\&  $img\->write(file => "foo.png")
\&    or die "Cannot write: ",$img\->errstr;
\&
\&  $img = Imager\->new;
\&  $img\->read(file=>$filename, type=>$type)
\&    or die "Cannot read: ", $img\->errstr;
\&
\&  # type is optional if we can guess the type from the file data
\&  # and we normally can guess
\&  $img\->read(file => $filename)
\&    or die "Cannot read: ", $img\->errstr;
\&
\&  Imager\->write_multi({ file=> $filename, ... }, @images)
\&    or die "Cannot write: ", Imager\->errstr;
\&
\&  my @imgs = Imager\->read_multi(file=>$filename)
\&    or die "Cannot read: ", Imager\->errstr;
\&
\&  Imager\->set_file_limits(width=>$max_width, height=>$max_height)
\&
\&  my @read_types = Imager\->read_types;
\&  my @write_types = Imager\->write_types;
\&
\&  # we can write/write_multi to things other than filenames
\&  my $data;
\&  $img\->write(data => \e$data, type => $type) or die;
\&
\&  my $fh = ... ; # eg. IO::File
\&  $img\->write(fh => $fh, type => $type) or die;
\&
\&  $img\->write(fd => fileno($fh), type => $type) or die;
\&
\&  # some file types need seek callbacks too
\&  $img\->write(callback => \e&write_callback, type => $type) or die;
\&
\&  # and similarly for read/read_multi
\&  $img\->read(data => $data) or die;
\&  $img\->read(fh => $fh) or die;
\&  $img\->read(fd => fileno($fh)) or die;
\&  $img\->read(callback => \e&read_callback) or die;
\&
\&  use Imager 0.68;
\&  my $img = Imager\->new(file => $filename)
\&    or die Imager\->errstr;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You can read and write a variety of images formats, assuming you have
the appropriate libraries, and images can be read or written to/from
files, file handles, file descriptors, scalars, or through callbacks.
.PP
To see which image formats Imager is compiled to support the following
code snippet is sufficient:
.PP
.Vb 2
\&  use Imager;
\&  print join " ", keys %Imager::formats;
.Ve
.PP
This will include some other information identifying libraries rather
than file formats.  For new code you might find the \*(L"\fIread_types()\fR\*(R"
or \*(L"\fIwrite_types()\fR\*(R" methods useful.
.IP "\fIread()\fR" 4
.IX Item "read()"
Reading writing to and from files is simple, use the \f(CW\*(C`read()\*(C'\fR
method to read an image:
.Sp
.Vb 3
\&  my $img = Imager\->new;
\&  $img\->read(file=>$filename, type=>$type)
\&    or die "Cannot read $filename: ", $img\->errstr;
.Ve
.Sp
In most cases Imager can auto-detect the file type, so you can just
supply the file name:
.Sp
.Vb 2
\&  $img\->read(file => $filename)
\&    or die "Cannot read $filename: ", $img\->errstr;
.Ve
.Sp
The \fIread()\fR method accepts the \f(CW\*(C`allow_incomplete\*(C'\fR parameter.  If this
is non-zero then \fIread()\fR can return true on an incomplete image and set
the \f(CW\*(C`i_incomplete\*(C'\fR tag.
.Sp
From Imager 0.68 you can supply most \fIread()\fR parameters to the \fInew()\fR
method to read the image file on creation.  If the read fails, check
Imager\->\fIerrstr()\fR for the cause:
.Sp
.Vb 3
\&  use Imager 0.68;
\&  my $img = Imager\->new(file => $filename)
\&    or die "Cannot read $filename: ", Imager\->errstr;
.Ve
.IP "\fIwrite()\fR" 4
.IX Item "write()"
and the \f(CW\*(C`write()\*(C'\fR method to write an image:
.Sp
.Vb 2
\&  $img\->write(file=>$filename, type=>$type)
\&    or die "Cannot write $filename: ", $img\->errstr;
.Ve
.IP "\fIread_multi()\fR" 4
.IX Item "read_multi()"
If you're reading from a format that supports multiple images per
file, use the \f(CW\*(C`read_multi()\*(C'\fR method:
.Sp
.Vb 2
\&  my @imgs = Imager\->read_multi(file=>$filename, type=>$type)
\&    or die "Cannot read $filename: ", Imager\->errstr;
.Ve
.Sp
As with the \fIread()\fR method, Imager will normally detect the \f(CW\*(C`type\*(C'\fR
automatically.
.IP "\fIwrite_multi()\fR" 4
.IX Item "write_multi()"
and if you want to write multiple images to a single file use the
\&\f(CW\*(C`write_multi()\*(C'\fR method:
.Sp
.Vb 2
\&  Imager\->write_multi({ file=> $filename, type=>$type }, @images)
\&    or die "Cannot write $filename: ", Imager\->errstr;
.Ve
.IP "\fIread_types()\fR" 4
.IX Item "read_types()"
This is a class method that returns a list of the image file types
that Imager can read.
.Sp
.Vb 1
\&  my @types = Imager\->read_types;
.Ve
.Sp
These types are the possible values for the \f(CW\*(C`type\*(C'\fR parameter, not
necessarily the extension of the files you're reading.
.Sp
It is possible for extra file read handlers to be loaded when
attempting to read a file, which may modify the list of available read
types.
.IP "\fIwrite_types()\fR" 4
.IX Item "write_types()"
This is a class method that returns a list of the image file types
that Imager can write.
.Sp
.Vb 1
\&  my @types = Imager\->write_types;
.Ve
.Sp
Note that these are the possible values for the \f(CW\*(C`type\*(C'\fR parameter, not
necessarily the extension of the files you're writing.
.Sp
It is possible for extra file write handlers to be loaded when
attempting to write a file, which may modify the list of available
write types.
.PP
When writing, if the \f(CW\*(C`filename\*(C'\fR includes an extension that Imager
recognizes, then you don't need the \f(CW\*(C`type\*(C'\fR, but you may want to
provide one anyway.  See \*(L"Guessing types\*(R" for information on
controlling this recognition.
.PP
The \f(CW\*(C`type\*(C'\fR parameter is a lowercase representation of the file type,
and can be any of the following:
.PP
.Vb 9
\&  bmp   Windows BitMaP (BMP)
\&  gif   Graphics Interchange Format (GIF)
\&  jpeg  JPEG/JFIF
\&  png   Portable Network Graphics (PNG)
\&  pnm   Portable aNyMap (PNM)
\&  raw   Raw
\&  sgi   SGI .rgb files
\&  tga   TARGA
\&  tiff  Tagged Image File Format (TIFF)
.Ve
.PP
When you read an image, Imager may set some tags, possibly including
information about the spatial resolution, textual information, and
animation information.  See \*(L"Tags\*(R" in Imager::ImageTypes for specifics.
.PP
The \fIopen()\fR method is a historical alias for the \fIread()\fR method.
.SS "Input and output"
.IX Subsection "Input and output"
When reading or writing you can specify one of a variety of sources or
targets:
.IP "\(bu" 4
\&\f(CW\*(C`file\*(C'\fR \- The \f(CW\*(C`file\*(C'\fR parameter is the name of the image file to be
written to or read from.  If Imager recognizes the extension of the
file you do not need to supply a \f(CW\*(C`type\*(C'\fR.
.Sp
.Vb 3
\&  # write in tiff format
\&  $image\->write(file => "example.tif")
\&    or die $image\->errstr;
\&
\&  $image\->write(file => \*(Aqfoo.tmp\*(Aq, type => \*(Aqtiff\*(Aq)
\&    or die $image\->errstr;
\&
\&  my $image = Imager\->new;
\&  $image\->read(file => \*(Aqexample.tif\*(Aq)
\&    or die $image\->errstr;
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`fh\*(C'\fR \- \f(CW\*(C`fh\*(C'\fR is a file handle, typically either returned from
\&\f(CW\*(C`<IO::File\-\*(C'\fR\fInew()\fR>>, or a glob from an \f(CW\*(C`open\*(C'\fR call.  You should call
\&\f(CW\*(C`binmode\*(C'\fR on the handle before passing it to Imager.
.Sp
Imager will set the handle to autoflush to make sure any buffered data
is flushed , since Imager will write to the file descriptor (from
\&\fIfileno()\fR) rather than writing at the perl level.
.Sp
.Vb 2
\&  $image\->write(fh => \e*STDOUT, type => \*(Aqgif\*(Aq)
\&    or die $image\->errstr;
\&
\&  # for example, a file uploaded via CGI.pm
\&  $image\->read(fd => $cgi\->param(\*(Aqfile\*(Aq)) 
\&    or die $image\->errstr;
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`fd\*(C'\fR \- \f(CW\*(C`fd\*(C'\fR is a file descriptor.  You can get this by calling the
\&\f(CW\*(C`fileno()\*(C'\fR function on a file handle, or by using one of the standard
file descriptor numbers.
.Sp
If you get this from a perl file handle, you may need to flush any
buffered output, otherwise it may appear in the output stream after
the image.
.Sp
.Vb 2
\&  $image\->write(fd => file(STDOUT), type => \*(Aqgif\*(Aq)
\&    or die $image\->errstr;
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- When reading data, \f(CW\*(C`data\*(C'\fR is a scalar containing the image
file data, when writing, \f(CW\*(C`data\*(C'\fR is a reference to the scalar to save
the image file data too.  For \s-1GIF\s0 images you will need \f(CW\*(C`giflib\*(C'\fR 4 or
higher, and you may need to patch \f(CW\*(C`giflib\*(C'\fR to use this option for
writing.
.Sp
.Vb 3
\&  my $data;
\&  $image\->write(data => \e$data, type => \*(Aqtiff\*(Aq)
\&    or die $image\->errstr;
\&
\&  my $data = $row\->{someblob}; # eg. from a database
\&  my @images = Imager\->read_multi(data => $data)
\&    or die Imager\->errstr;
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`callback\*(C'\fR, \f(CW\*(C`readcb\*(C'\fR, \f(CW\*(C`writecb\*(C'\fR, \f(CW\*(C`seekcb\*(C'\fR, \f(CW\*(C`closecb\*(C'\fR \- Imager
will make calls back to your supplied coderefs to read, write and seek
from/to/through the image file.  See \*(L"I/O Callbacks\*(R" below for details.
.IP "\(bu" 4
\&\f(CW\*(C`io\*(C'\fR \- an Imager::IO object.
.PP
By default Imager will use buffered I/O when
reading or writing an image.  You can disabled buffering for output by
supplying a \f(CW\*(C`buffered => 0\*(C'\fR parameter to \f(CW\*(C`write()\*(C'\fR or
\&\f(CW\*(C`write_multi()\*(C'\fR.
.IX Xref "buffering unbuffered"
.SS "I/O Callbacks"
.IX Subsection "I/O Callbacks"
When reading from a file you can use either \f(CW\*(C`callback\*(C'\fR or \f(CW\*(C`readcb\*(C'\fR
to supply the read callback, and when writing \f(CW\*(C`callback\*(C'\fR or
\&\f(CW\*(C`writecb\*(C'\fR to supply the write callback.
.PP
Some file formats, currently only \f(CW\*(C`TIFF\*(C'\fR, also require a \f(CW\*(C`seekcb\*(C'\fR
parameter to change position in the file.  If no \f(CW\*(C`seekcb\*(C'\fR parameter
is provided a default will be provided that fails.
.PP
You can also provide a \f(CW\*(C`closecb\*(C'\fR parameter called when writing the
file is complete.
.PP
.Vb 8
\&  # contrived
\&  my $data;
\&  sub mywrite {
\&    $data .= unpack("H*", shift);
\&    1;
\&  }
\&  Imager\->write_multi({ callback => \e&mywrite, type => \*(Aqgif\*(Aq}, @images)
\&    or die Imager\->errstr;
.Ve
.PP
\fI\f(CI\*(C`readcb\*(C'\fI\fR
.IX Subsection "readcb"
.PP
The read callback is called with 2 parameters:
.IP "\(bu" 4
\&\f(CW\*(C`size\*(C'\fR \- the minimum amount of data required.
.IP "\(bu" 4
\&\f(CW\*(C`maxsize\*(C'\fR \- previously this was the maximum amount of data returnable
\&\- currently it's always the same as \f(CW\*(C`size\*(C'\fR
.PP
Your read callback should return the data as a scalar:
.IP "\(bu" 4
on success, a string containing the bytes read.
.IP "\(bu" 4
on end of file, an empty string
.IP "\(bu" 4
on error, \f(CW\*(C`undef\*(C'\fR.
.PP
If your return value contains more data than \f(CW\*(C`size\*(C'\fR Imager will
panic.
.PP
Your return value must not contain any characters over \f(CW\*(C`\exFF\*(C'\fR or
Imager will panic.
.PP
\fI\f(CI\*(C`writecb\*(C'\fI\fR
.IX Subsection "writecb"
.PP
Your write callback takes exactly one parameter, a scalar containing
the data to be written.
.PP
Return true for success.
.PP
\fI\f(CI\*(C`seekcb\*(C'\fI\fR
.IX Subsection "seekcb"
.PP
The seek callback takes 2 parameters, a \fI\s-1POSITION\s0\fR, and a \fI\s-1WHENCE\s0\fR,
defined in the same way as perl's seek function.
.PP
Previously you always needed a \f(CW\*(C`seekcb\*(C'\fR callback if you called
Imager's \*(L"\fIread()\fR\*(R" or \*(L"\fIread_multi()\fR\*(R" without a \f(CW\*(C`type\*(C'\fR parameter,
but this is no longer necessary unless the file handler requires
seeking, such as for \s-1TIFF\s0 files.
.PP
Returns the new position in the file, or \-1 on failure.
.PP
\fI\f(CI\*(C`closecb\*(C'\fI\fR
.IX Subsection "closecb"
.PP
You can also supply a \f(CW\*(C`closecb\*(C'\fR which is called with no parameters
when there is no more data to be written.  This could be used to flush
buffered data.
.PP
Return true on success.
.SS "Guessing types"
.IX Xref "FORMATGUESS"
.IX Subsection "Guessing types"
When writing to a file, if you don't supply a \f(CW\*(C`type\*(C'\fR parameter Imager
will attempt to guess it from the file name.  This is done by calling
the code reference stored in \f(CW$Imager::FORMATGUESS\fR.  This is only
done when \fIwrite()\fR or \fIwrite_multi()\fR is called with a \f(CW\*(C`file\*(C'\fR parameter,
or if \fIread()\fR or \fIread_multi()\fR can't determine the type from the file's
header.
.PP
The default function value of \f(CW$Imager::FORMATGUESS\fR is
\&\f(CW\*(C`\e&Imager::def_guess_type\*(C'\fR.
.IP "\fIdef_guess_type()\fR" 4
.IX Xref "methods, def_guess_type()"
.IX Item "def_guess_type()"
This is the default function Imager uses to derive a file type from a
file name.  This is a function, not a method.
.Sp
Accepts a single parameter, the file name and returns the type or
undef.
.PP
You can replace function with your own implementation if you have some
specialized need.  The function takes a single parameter, the name of
the file, and should return either a file type or under.
.PP
.Vb 2
\&  # I\*(Aqm writing jpegs to weird filenames
\&  local $Imager::FORMATGUESS = sub { \*(Aqjpeg\*(Aq };
.Ve
.PP
When reading a file Imager examines beginning of the file for
identifying information.  The current implementation attempts to
detect the following image types beyond those supported by Imager:
.Sp
.RS 4
\&\f(CW\*(C`xpm\*(C'\fR, \f(CW\*(C`mng\*(C'\fR, \f(CW\*(C`jng\*(C'\fR, \f(CW\*(C`ilbm\*(C'\fR, \f(CW\*(C`pcx\*(C'\fR, \f(CW\*(C`fits\*(C'\fR, \f(CW\*(C`psd\*(C'\fR (Photoshop), \f(CW\*(C`eps\*(C'\fR, Utah
\&\f(CW\*(C`RLE\*(C'\fR.
.RE
.SS "Limiting the sizes of images you read"
.IX Subsection "Limiting the sizes of images you read"
.IP "\fIset_file_limits()\fR" 4
.IX Item "set_file_limits()"
In some cases you will be receiving images from an untested source,
such as submissions via \s-1CGI\s0.  To prevent such images from consuming
large amounts of memory, you can set limits on the dimensions of
images you read from files:
.RS 4
.IP "\(bu" 4
width \- limit the width in pixels of the image
.IP "\(bu" 4
height \- limit the height in pixels of the image
.IP "\(bu" 4
bytes \- limits the amount of storage used by the image.  This depends
on the width, height, channels and sample size of the image.  For
paletted images this is calculated as if the image was expanded to a
direct color image.
.RE
.RS 4
.Sp
To set the limits, call the class method set_file_limits:
.Sp
.Vb 1
\&  Imager\->set_file_limits(width=>$max_width, height=>$max_height);
.Ve
.Sp
You can pass any or all of the limits above, any limits you do not
pass are left as they were.
.Sp
Any limit of zero is treated as unlimited.
.Sp
By default, the width and height limits are zero, or unlimited.  The
default memory size limit is one gigabyte.
.Sp
You can reset all limits to unlimited with the reset parameter:
.Sp
.Vb 2
\&  # no limits
\&  Imager\->set_file_limits(reset=>1);
.Ve
.Sp
This can be used with the other limits to reset all but the limit you
pass:
.Sp
.Vb 2
\&  # only width is limited
\&  Imager\->set_file_limits(reset=>1, width=>100);
\&
\&  # only bytes is limited
\&  Imager\->set_file_limits(reset=>1, bytes=>10_000_000);
.Ve
.RE
.IP "\fIget_file_limits()\fR" 4
.IX Item "get_file_limits()"
You can get the current limits with the \fIget_file_limits()\fR method:
.Sp
.Vb 2
\&  my ($max_width, $max_height, $max_bytes) =
\&     Imager\->get_file_limits();
.Ve
.SH "TYPE SPECIFIC INFORMATION"
.IX Header "TYPE SPECIFIC INFORMATION"
The different image formats can write different image type, and some have
different options to control how the images are written.
.PP
When you call \f(CW\*(C`write()\*(C'\fR or \f(CW\*(C`write_multi()\*(C'\fR with an option that has
the same name as a tag for the image format you're writing, then the
value supplied to that option will be used to set the corresponding
tag in the image.  Depending on the image format, these values will be
used when writing the image.
.PP
This replaces the previous options that were used when writing \s-1GIF\s0
images.  Currently if you use an obsolete option, it will be converted
to the equivalent tag and Imager will produced a warning.  You can
suppress these warnings by calling the \f(CW\*(C`Imager::init()\*(C'\fR function with
the \f(CW\*(C`warn_obsolete\*(C'\fR option set to false:
.PP
.Vb 1
\&  Imager::init(warn_obsolete=>0);
.Ve
.PP
At some point in the future these obsolete options will no longer be
supported.
.SS "\s-1PNM\s0 (Portable aNy Map)"
.IX Subsection "PNM (Portable aNy Map)"
Imager can write \f(CW\*(C`PGM\*(C'\fR (Portable Gray Map) and \f(CW\*(C`PPM\*(C'\fR (Portable
PixMaps) files, depending on the number of channels in the image.
Currently the images are written in binary formats.  Only 1 and 3
channel images can be written, including 1 and 3 channel paletted
images.
.PP
.Vb 1
\&  $img\->write(file=>\*(Aqfoo.ppm\*(Aq) or die $img\->errstr;
.Ve
.PP
Imager can read both the \s-1ASCII\s0 and binary versions of each of the
\&\f(CW\*(C`PBM\*(C'\fR (Portable BitMap), \f(CW\*(C`PGM\*(C'\fR and \f(CW\*(C`PPM\*(C'\fR formats.
.PP
.Vb 1
\&  $img\->read(file=>\*(Aqfoo.ppm\*(Aq) or die $img\->errstr;
.Ve
.PP
\&\s-1PNM\s0 does not support the spatial resolution tags.
.PP
The following tags are set when reading a \s-1PNM\s0 file:
.IP "\(bu" 4
\&\f(CW\*(C`pnm_maxval\*(C'\fR \- the \f(CW\*(C`maxvals\*(C'\fR number from the \s-1PGM/PPM\s0 header.
Always set to 2 for a \f(CW\*(C`PBM\*(C'\fR file.
.IX Xref "pnm_maxval"
.IP "\(bu" 4
\&\f(CW\*(C`pnm_type\*(C'\fR \- the type number from the \f(CW\*(C`PNM\*(C'\fR header, 1 for \s-1ASCII\s0
\&\f(CW\*(C`PBM\*(C'\fR files, 2 for \s-1ASCII\s0 \f(CW\*(C`PGM\*(C'\fR files, 3 for \s-1ASCII\s0 c<\s-1PPM\s0> files, 4 for binary
\&\f(CW\*(C`PBM\*(C'\fR files, 5 for binary \f(CW\*(C`PGM\*(C'\fR files, 6 for binary \f(CW\*(C`PPM\*(C'\fR files.
.IX Xref "pnm_type"
.PP
The following tag is checked when writing an image with more than
8\-bits/sample:
.IP "\(bu" 4
pnm_write_wide_data \- if this is non-zero then
\&\fIwrite()\fR can write \f(CW\*(C`PGM\*(C'\fR/\f(CW\*(C`PPM\*(C'\fR files with 16\-bits/sample.  Some
applications, for example \s-1GIMP\s0 2.2, and tools can only read
8\-bit/sample binary \s-1PNM\s0 files, so Imager will only write a 16\-bit
image when this tag is non-zero.
.IX Xref "pnm_write_wide_data"
.SS "\s-1JPEG\s0"
.IX Subsection "JPEG"
You can supply a \f(CW\*(C`jpegquality\*(C'\fR parameter (0\-100) when writing a \s-1JPEG\s0
file, which defaults to 75%.  If you write an image with an alpha
channel to a \s-1JPEG\s0 file then it will be composited against the
background set by the \f(CW\*(C`i_background\*(C'\fR parameter (or tag).
.PP
.Vb 1
\&  $img\->write(file=>\*(Aqfoo.jpg\*(Aq, jpegquality=>90) or die $img\->errstr;
.Ve
.PP
Imager will read a gray scale \s-1JPEG\s0 as a 1 channel image and a color
\&\s-1JPEG\s0 as a 3 channel image.
.PP
.Vb 1
\&  $img\->read(file=>\*(Aqfoo.jpg\*(Aq) or die $img\->errstr;
.Ve
.PP
The following tags are set in a \s-1JPEG\s0 image when read, and can be set
to control output:
.IP "\(bu" 4
\&\f(CW\*(C`jpeg_density_unit\*(C'\fR \- The value of the density unit field in the
\&\f(CW\*(C`JFIF\*(C'\fR header.  This is ignored on writing if the \f(CW\*(C`i_aspect_only\*(C'\fR
tag is non-zero.
.Sp
The \f(CW\*(C`i_xres\*(C'\fR and \f(CW\*(C`i_yres\*(C'\fR tags are expressed in pixels per inch no
matter the value of this tag, they will be converted to/from the value
stored in the \s-1JPEG\s0 file.
.IP "\(bu" 4
\&\f(CW\*(C`jpeg_density_unit_name\*(C'\fR \- This is set when reading a \s-1JPEG\s0 file to
the name of the unit given by \f(CW\*(C`jpeg_density_unit\*(C'\fR.  Possible results
include \f(CW\*(C`inch\*(C'\fR, \f(CW\*(C`centimeter\*(C'\fR, \f(CW\*(C`none\*(C'\fR (the \f(CW\*(C`i_aspect_only\*(C'\fR tag is
also set reading these files).  If the value of \f(CW\*(C`jpeg_density_unit\*(C'\fR
is unknown then this tag isn't set.
.IP "\(bu" 4
\&\f(CW\*(C`jpeg_comment\*(C'\fR \- Text comment.
.IP "\(bu" 4
\&\f(CW\*(C`jpeg_progressive\*(C'\fR \- Whether the \s-1JPEG\s0 file is a progressive
file. (Imager 0.84)
.PP
\&\s-1JPEG\s0 supports the spatial resolution tags \f(CW\*(C`i_xres\*(C'\fR, \f(CW\*(C`i_yres\*(C'\fR and
\&\f(CW\*(C`i_aspect_only\*(C'\fR.
.PP
If an \f(CW\*(C`APP1\*(C'\fR block containing \s-1EXIF\s0 information is found, then any of the
following tags can be set when reading a \s-1JPEG\s0 image:
.Sp
.RS 4
exif_aperture exif_artist exif_brightness exif_color_space
exif_contrast exif_copyright exif_custom_rendered exif_date_time
exif_date_time_digitized exif_date_time_original
exif_digital_zoom_ratio exif_exposure_bias exif_exposure_index
exif_exposure_mode exif_exposure_program exif_exposure_time
exif_f_number exif_flash exif_flash_energy exif_flashpix_version
exif_focal_length exif_focal_length_in_35mm_film
exif_focal_plane_resolution_unit exif_focal_plane_x_resolution
exif_focal_plane_y_resolution exif_gain_control exif_image_description
exif_image_unique_id exif_iso_speed_rating exif_make exif_max_aperture
exif_metering_mode exif_model exif_orientation exif_related_sound_file
exif_resolution_unit exif_saturation exif_scene_capture_type
exif_sensing_method exif_sharpness exif_shutter_speed exif_software
exif_spectral_sensitivity exif_sub_sec_time
exif_sub_sec_time_digitized exif_sub_sec_time_original
exif_subject_distance exif_subject_distance_range
exif_subject_location exif_tag_light_source exif_user_comment
exif_version exif_white_balance exif_x_resolution exif_y_resolution
.RE
.PP
The following derived tags can also be set when reading a \s-1JPEG\s0 image:
.Sp
.RS 4
exif_color_space_name exif_contrast_name exif_custom_rendered_name
exif_exposure_mode_name exif_exposure_program_name exif_flash_name
exif_focal_plane_resolution_unit_name exif_gain_control_name
exif_light_source_name exif_metering_mode_name
exif_resolution_unit_name exif_saturation_name
exif_scene_capture_type_name exif_sensing_method_name
exif_sharpness_name exif_subject_distance_range_name
exif_white_balance_name
.RE
.PP
The derived tags are for enumerated fields, when the value for the
base field is valid then the text that appears in the \s-1EXIF\s0
specification for that value appears in the derived field.  So for
example if \f(CW\*(C`exf_metering_mode\*(C'\fR is \f(CW5\fR then
\&\f(CW\*(C`exif_metering_mode_name\*(C'\fR is set to \f(CW\*(C`Pattern\*(C'\fR.
.PP
eg.
.PP
.Vb 6
\&  my $image = Imager\->new;
\&  $image\->read(file => \*(Aqexiftest.jpg\*(Aq)
\&    or die "Cannot load image: ", $image\->errstr;
\&  print $image\->tags(name => "exif_image_description"), "\en";
\&  print $image\->tags(name => "exif_exposure_mode"), "\en";
\&  print $image\->tags(name => "exif_exposure_mode_name"), "\en";
\&
\&  # for the exiftest.jpg in the Imager distribution the output would be:
\&  Imager Development Notes
\&  0
\&  Auto exposure
.Ve
.PP
Imager will not write \s-1EXIF\s0 tags to any type of image, if you need more
advanced \s-1EXIF\s0 handling, consider Image::ExifTool.
.IP "\fIparseiptc()\fR" 4
.IX Item "parseiptc()"
Historically, Imager saves \s-1IPTC\s0 data when reading a \s-1JPEG\s0 image, the
\&\fIparseiptc()\fR method returns a list of key/value pairs resulting from a
simple decoding of that data.
.Sp
Any future \s-1IPTC\s0 data decoding is likely to go into tags.
.SS "\s-1GIF\s0"
.IX Subsection "GIF"
When writing one of more \s-1GIF\s0 images you can use the same
Quantization Options as you can when converting
an \s-1RGB\s0 image into a paletted image.
.PP
When reading a \s-1GIF\s0 all of the sub-images are combined using the screen
size and image positions into one big image, producing an \s-1RGB\s0 image.
This may change in the future to produce a paletted image where possible.
.PP
When you read a single \s-1GIF\s0 with \f(CW\*(C`$img\->read()\*(C'\fR you can supply a
reference to a scalar in the \f(CW\*(C`colors\*(C'\fR parameter, if the image is read
the scalar will be filled with a reference to an anonymous array of
Imager::Color objects, representing the palette of the image.  This
will be the first palette found in the image.  If you want the
palettes for each of the images in the file, use \f(CW\*(C`read_multi()\*(C'\fR and
use the \f(CW\*(C`getcolors()\*(C'\fR method on each image.
.PP
\&\s-1GIF\s0 does not support the spatial resolution tags.
.PP
Imager will set the following tags in each image when reading, and can
use most of them when writing to \s-1GIF:\s0
.IP "\(bu" 4
gif_left \- the offset of the image from the left of the \*(L"screen\*(R"
(\*(L"Image Left Position\*(R")
.IP "\(bu" 4
gif_top \- the offset of the image from the top of the \*(L"screen\*(R" (\*(L"Image
Top Position\*(R")
.IP "\(bu" 4
gif_interlace \- non-zero if the image was interlaced (\*(L"Interlace
Flag\*(R")
.IP "\(bu" 4
gif_screen_width, gif_screen_height \- the size of the logical
screen. When writing this is used as the minimum.  If any image being
written would extend beyond this then the screen size is extended.
(\*(L"Logical Screen Width\*(R", \*(L"Logical Screen Height\*(R").
.IP "\(bu" 4
gif_local_map \- Non-zero if this image had a local color map.  If set
for an image when writing the image is quantized separately from the
other images in the file.
.IP "\(bu" 4
gif_background \- The index in the global color map of the logical
screen's background color.  This is only set if the current image uses
the global color map.  You can set this on write too, but for it to
choose the color you want, you will need to supply only paletted
images and set the \f(CW\*(C`gif_eliminate_unused\*(C'\fR tag to 0.
.IP "\(bu" 4
gif_trans_index \- The index of the color in the color map used for
transparency.  If the image has a transparency then it is returned as
a 4 channel image with the alpha set to zero in this palette entry.
This value is not used when writing. (\*(L"Transparent Color Index\*(R")
.IP "\(bu" 4
gif_trans_color \- A reference to an Imager::Color object, which is the
color to use for the palette entry used to represent transparency in
the palette.  You need to set the \f(CW\*(C`transp\*(C'\fR option (see
\&\*(L"Quantization options\*(R" in Imager::ImageTypes) for this value to be
used.
.IP "\(bu" 4
gif_delay \- The delay until the next frame is displayed, in 1/100 of a
second.  (\*(L"Delay Time\*(R").
.IP "\(bu" 4
gif_user_input \- whether or not a user input is expected before
continuing (view dependent) (\*(L"User Input Flag\*(R").
.IP "\(bu" 4
gif_disposal \- how the next frame is displayed (\*(L"Disposal Method\*(R")
.IP "\(bu" 4
gif_loop \- the number of loops from the Netscape Loop extension.  This
may be zero to loop forever.
.IP "\(bu" 4
gif_comment \- the first block of the first \s-1GIF\s0 comment before each
image.
.IP "\(bu" 4
gif_eliminate_unused \- If this is true, when you write a paletted
image any unused colors will be eliminated from its palette.  This is
set by default.
.IP "\(bu" 4
gif_colormap_size \- the original size of the color map for the image.
The color map of the image may have been expanded to include out of
range color indexes.
.PP
Where applicable, the (\*(L"name\*(R") is the name of that field from the \f(CW\*(C`GIF89\*(C'\fR
standard.
.PP
The following \s-1GIF\s0 writing options are obsolete, you should set the
corresponding tag in the image, either by using the tags functions, or
by supplying the tag and value as options.
.IP "\(bu" 4
gif_each_palette \- Each image in the \s-1GIF\s0 file has it's own palette if
this is non-zero.  All but the first image has a local color table
(the first uses the global color table.
.Sp
Use \f(CW\*(C`gif_local_map\*(C'\fR in new code.
.IP "\(bu" 4
interlace \- The images are written interlaced if this is non-zero.
.Sp
Use \f(CW\*(C`gif_interlace\*(C'\fR in new code.
.IP "\(bu" 4
gif_delays \- A reference to an array containing the delays between
images, in 1/100 seconds.
.Sp
Use \f(CW\*(C`gif_delay\*(C'\fR in new code.
.IP "\(bu" 4
gif_positions \- A reference to an array of references to arrays which
represent screen positions for each image.
.Sp
New code should use the \f(CW\*(C`gif_left\*(C'\fR and \f(CW\*(C`gif_top\*(C'\fR tags.
.IP "\(bu" 4
gif_loop_count \- If this is non-zero the Netscape loop extension block
is generated, which makes the animation of the images repeat.
.Sp
This is currently unimplemented due to some limitations in \f(CW\*(C`giflib\*(C'\fR.
.PP
You can supply a \f(CW\*(C`page\*(C'\fR parameter to the \f(CW\*(C`read()\*(C'\fR method to read
some page other than the first.  The page is 0 based:
.PP
.Vb 3
\&  # read the second image in the file
\&  $image\->read(file=>"example.gif", page=>1)
\&    or die "Cannot read second page: ",$image\->errstr,"\en";
.Ve
.PP
Before release 0.46, Imager would read multiple image \s-1GIF\s0 image files
into a single image, overlaying each of the images onto the virtual
\&\s-1GIF\s0 screen.
.PP
As of 0.46 the default is to read the first image from the file, as if
called with \f(CW\*(C`page => 0\*(C'\fR.
.PP
You can return to the previous behavior by calling read with the
\&\f(CW\*(C`gif_consolidate\*(C'\fR parameter set to a true value:
.PP
.Vb 1
\&  $img\->read(file=>$some_gif_file, gif_consolidate=>1);
.Ve
.PP
As with the \fIto_paletted()\fR method, if you supply a colors parameter as
a reference to an array, this will be filled with Imager::Color
objects of the color table generated for the image file.
.SS "\s-1TIFF\s0 (Tagged Image File Format)"
.IX Subsection "TIFF (Tagged Image File Format)"
Imager can write images to either paletted or \s-1RGB\s0 \s-1TIFF\s0 images,
depending on the type of the source image.
.PP
When writing direct color images to \s-1TIFF\s0 the sample size of the
output file depends on the input:
.IP "\(bu" 4
double/sample \- written as 32\-bit/sample \s-1TIFF\s0
.IP "\(bu" 4
16\-bit/sample \- written as 16\-bit/sample \s-1TIFF\s0
.IP "\(bu" 4
8\-bit/sample \- written as 8\-bit/sample \s-1TIFF\s0
.PP
For paletted images:
.IP "\(bu" 4
\&\f(CW\*(C`$img\->is_bilevel\*(C'\fR is true \- the image is written as bi-level
.IP "\(bu" 4
otherwise \- image is written as paletted.
.PP
If you are creating images for faxing you can set the \fIclass\fR
parameter set to \f(CW\*(C`fax\*(C'\fR.  By default the image is written in fine
mode, but this can be overridden by setting the \fIfax_fine\fR parameter
to zero.  Since a fax image is bi-level, Imager uses a threshold to
decide if a given pixel is black or white, based on a single channel.
For gray scale images channel 0 is used, for color images channel 1
(green) is used.  If you want more control over the conversion you can
use \f(CW$img\fR\->\fIto_paletted()\fR to product a bi-level image.  This way you can
use dithering:
.PP
.Vb 3
\&  my $bilevel = $img\->to_paletted(make_colors => \*(Aqmono\*(Aq,
\&                                  translate => \*(Aqerrdiff\*(Aq,
\&                                  errdiff => \*(Aqstucki\*(Aq);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`class\*(C'\fR \- If set to 'fax' the image will be written as a bi-level fax
image.
.IP "\(bu" 4
\&\f(CW\*(C`fax_fine\*(C'\fR \- By default when \f(CW\*(C`class\*(C'\fR is set to 'fax' the image is
written in fine mode, you can select normal mode by setting
\&\f(CW\*(C`fax_fine\*(C'\fR to 0.
.PP
Imager should be able to read any \s-1TIFF\s0 image you supply.  Paletted
\&\s-1TIFF\s0 images are read as paletted Imager images, since paletted \s-1TIFF\s0
images have 16\-bits/sample (48\-bits/color) this means the bottom
8\-bits are lost, but this shouldn't be a big deal.
.PP
\&\s-1TIFF\s0 supports the spatial resolution tags.  See the
\&\f(CW\*(C`tiff_resolutionunit\*(C'\fR tag for some extra options.
.PP
As of Imager 0.62 Imager reads:
.IP "\(bu" 4
8\-bit/sample gray, \s-1RGB\s0 or \s-1CMYK\s0 images, including a possible alpha
channel as an 8\-bit/sample image.
.IP "\(bu" 4
16\-bit gray, \s-1RGB\s0, or \s-1CMYK\s0 image, including a possible alpha channel as
a 16\-bit/sample image.
.IP "\(bu" 4
32\-bit gray, \s-1RGB\s0 image, including a possible alpha channel as a
double/sample image.
.IP "\(bu" 4
bi-level images as paletted images containing only black and white,
which other formats will also write as bi-level.
.IP "\(bu" 4
tiled paletted images are now handled correctly
.IP "\(bu" 4
other images are read using \f(CW\*(C`tifflib\*(C'\fR's \s-1RGBA\s0 interface as
8\-bit/sample images.
.PP
The following tags are set in a \s-1TIFF\s0 image when read, and can be set
to control output:
.IP "\(bu" 4
\&\f(CW\*(C`tiff_compression\*(C'\fR \- When reading an image this is set to the numeric
value of the \s-1TIFF\s0 compression tag.
.Sp
On writing you can set this to either a numeric compression tag value,
or one of the following values:
.Sp
.Vb 10
\&  Ident     Number  Description
\&  none         1    No compression
\&  packbits   32773  Macintosh RLE
\&  ccittrle     2    CCITT RLE
\&  fax3         3    CCITT Group 3 fax encoding (T.4)
\&  t4           3    As above
\&  fax4         4    CCITT Group 4 fax encoding (T.6)
\&  t6           4    As above
\&  lzw          5    LZW
\&  jpeg         7    JPEG
\&  zip          8    Deflate (GZIP) Non\-standard
\&  deflate      8    As above.
\&  oldzip     32946  Deflate with an older code.
\&  ccittrlew  32771  Word aligned CCITT RLE
.Ve
.Sp
In general a compression setting will be ignored where it doesn't make
sense, eg. \f(CW\*(C`jpeg\*(C'\fR will be ignored for compression if the image is
being written as bilevel.
.Sp
Imager attempts to check that your build of \f(CW\*(C`libtiff\*(C'\fR supports the
given compression, and will fallback to \f(CW\*(C`packbits\*(C'\fR if it isn't
enabled.  eg. older distributions didn't include \s-1LZW\s0 compression, and
\&\s-1JPEG\s0 compression is only available if \f(CW\*(C`libtiff\*(C'\fR is configured with
\&\f(CW\*(C`libjpeg\*(C'\fR's location.
.Sp
.Vb 2
\&  $im\->write(file => \*(Aqfoo.tif\*(Aq, tiff_compression => \*(Aqlzw\*(Aq)
\&    or die $im\->errstr;
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`tags, tiff_jpegquality\*(C'\fR\f(CW\*(C`tiff_jpegquality\*(C'\fR \- If \f(CW\*(C`tiff_compression\*(C'\fR
is \f(CW\*(C`jpeg\*(C'\fR then this can be a number from 1 to 100 giving the \s-1JPEG\s0
compression quality.  High values are better quality and larger files.
.IP "\(bu" 4
\&\f(CW\*(C`tiff_resolutionunit\*(C'\fR \- The value of the
\&\f(CW\*(C`ResolutionUnit\*(C'\fR tag.  This is ignored on writing if the
i_aspect_only tag is non-zero.
.IX Xref "tags, tiff_resolutionunit"
.Sp
The \f(CW\*(C`i_xres\*(C'\fR and \f(CW\*(C`i_yres\*(C'\fR tags are expressed in pixels per inch no
matter the value of this tag, they will be converted to/from the value
stored in the \s-1TIFF\s0 file.
.IP "\(bu" 4
\&\f(CW\*(C`tiff_resolutionunit_name\*(C'\fR \- This is
set when reading a \s-1TIFF\s0 file to the name of the unit given by
\&\f(CW\*(C`tiff_resolutionunit\*(C'\fR.  Possible results include \f(CW\*(C`inch\*(C'\fR,
\&\f(CW\*(C`centimeter\*(C'\fR, \f(CW\*(C`none\*(C'\fR (the \f(CW\*(C`i_aspect_only\*(C'\fR tag is also set reading
these files) or \f(CW\*(C`unknown\*(C'\fR.
.IX Xref "tags, tiff_resolutionunit_name"
.IP "\(bu" 4
\&\f(CW\*(C`tiff_bitspersample\*(C'\fR \- Bits per sample
from the image.  This value is not used when writing an image, it is
only set on a read image.
.IX Xref "tags, tiff_bitspersample"
.IP "\(bu" 4
\&\f(CW\*(C`tiff_photometric\*(C'\fR \- Value of the
\&\f(CW\*(C`PhotometricInterpretation\*(C'\fR tag from the image.  This value is not
used when writing an image, it is only set on a read image.
.IX Xref "tags, tiff_photometric"
.IP "\(bu" 4
\&\f(CW\*(C`tiff_documentname\*(C'\fR, \f(CW\*(C`tiff_imagedescription\*(C'\fR, \f(CW\*(C`tiff_make\*(C'\fR,
\&\f(CW\*(C`tiff_model\*(C'\fR, \f(CW\*(C`tiff_pagename\*(C'\fR, \f(CW\*(C`tiff_software\*(C'\fR, \f(CW\*(C`tiff_datetime\*(C'\fR,
\&\f(CW\*(C`tiff_artist\*(C'\fR, \f(CW\*(C`tiff_hostcomputer\*(C'\fR \- Various strings describing the
image.  \f(CW\*(C`tiff_datetime\*(C'\fR must be formatted as \*(L"\s-1YYYY:MM:DD\s0 \s-1HH:MM:SS\s0\*(R".
These correspond directly to the mixed case names in the \s-1TIFF\s0
specification.  These are set in images read from a \s-1TIFF\s0 and saved
when writing a \s-1TIFF\s0 image.
.PP
You can supply a \f(CW\*(C`page\*(C'\fR parameter to the \f(CW\*(C`read()\*(C'\fR method to read
some page other than the first.  The page is 0 based:
.PP
.Vb 3
\&  # read the second image in the file
\&  $image\->read(file=>"example.tif", page=>1)
\&    or die "Cannot read second page: ",$image\->errstr,"\en";
.Ve
.PP
If you read an image with multiple alpha channels, then only the first
alpha channel will be read.
.SS "\s-1BMP\s0 (Windows Bitmap)"
.IX Subsection "BMP (Windows Bitmap)"
Imager can write 24\-bit \s-1RGB\s0, and 8, 4 and 1\-bit per pixel paletted
Windows \s-1BMP\s0 files.  Currently you cannot write compressed \s-1BMP\s0 files
with Imager.
.PP
Imager can read 24\-bit \s-1RGB\s0, and 8, 4 and 1\-bit perl pixel paletted
Windows \s-1BMP\s0 files.  There is some support for reading 16\-bit per pixel
images, but I haven't found any for testing.
.PP
\&\s-1BMP\s0 has no support for multiple image files.
.PP
\&\s-1BMP\s0 files support the spatial resolution tags, but since \s-1BMP\s0 has no
support for storing only an aspect ratio, if \f(CW\*(C`i_aspect_only\*(C'\fR is set
when you write the \f(CW\*(C`i_xres\*(C'\fR and \f(CW\*(C`i_yres\*(C'\fR values are scaled so the
smaller is 72 \s-1DPI\s0.
.PP
The following tags are set when you read an image from a \s-1BMP\s0 file:
.IP "bmp_compression" 4
.IX Item "bmp_compression"
The type of compression, if any.  This can be any of the following
values:
.RS 4
.IP "\s-1BI_RGB\s0 (0)" 4
.IX Item "BI_RGB (0)"
Uncompressed.
.IP "\s-1BI_RLE8\s0 (1)" 4
.IX Item "BI_RLE8 (1)"
8\-bits/pixel paletted value \s-1RLE\s0 compression.
.IP "\s-1BI_RLE4\s0 (2)" 4
.IX Item "BI_RLE4 (2)"
4\-bits/pixel paletted value \s-1RLE\s0 compression.
.IP "\s-1BI_BITFIELDS\s0 (3)" 4
.IX Item "BI_BITFIELDS (3)"
Packed \s-1RGB\s0 values.
.RE
.RS 4
.RE
.IP "bmp_compression_name" 4
.IX Item "bmp_compression_name"
The bmp_compression value as a BI_* string
.IP "bmp_important_colors" 4
.IX Item "bmp_important_colors"
The number of important colors as defined by the writer of the image.
.IP "bmp_used_colors" 4
.IX Item "bmp_used_colors"
Number of color used from the \s-1BMP\s0 header
.IP "bmp_filesize" 4
.IX Item "bmp_filesize"
The file size from the \s-1BMP\s0 header
.IP "bmp_bit_count" 4
.IX Item "bmp_bit_count"
Number of bits stored per pixel. (24, 8, 4 or 1)
.SS "\s-1TGA\s0 (Targa)"
.IX Subsection "TGA (Targa)"
When storing Targa images \s-1RLE\s0 compression can be activated with the
\&\f(CW\*(C`compress\*(C'\fR parameter, the \f(CW\*(C`idstring\*(C'\fR parameter can be used to set the
Targa comment field and the \f(CW\*(C`wierdpack\*(C'\fR option can be used to use the
15 and 16 bit Targa formats for \s-1RGB\s0 and \s-1RGBA\s0 data.  The 15 bit format
has 5 of each red, green and blue.  The 16 bit format in addition
allows 1 bit of alpha.  The most significant bits are used for each
channel.
.PP
Tags:
.IP "tga_idstring" 4
.IX Item "tga_idstring"
.PD 0
.IP "tga_bitspp" 4
.IX Item "tga_bitspp"
.IP "compressed" 4
.IX Item "compressed"
.PD
.SS "\s-1RAW\s0"
.IX Subsection "RAW"
When reading raw images you need to supply the width and height of the
image in the \f(CW\*(C`xsize\*(C'\fR and \f(CW\*(C`ysize\*(C'\fR options:
.PP
.Vb 2
\&  $img\->read(file=>\*(Aqfoo.raw\*(Aq, xsize=>100, ysize=>100)
\&    or die "Cannot read raw image\en";
.Ve
.PP
If your input file has more channels than you want, or (as is common),
junk in the fourth channel, you can use the \f(CW\*(C`datachannels\*(C'\fR and
\&\f(CW\*(C`storechannels\*(C'\fR options to control the number of channels in your input
file and the resulting channels in your image.  For example, if your
input image uses 32\-bits per pixel with red, green, blue and junk
values for each pixel you could do:
.PP
.Vb 3
\&  $img\->read(file=>\*(Aqfoo.raw\*(Aq, xsize=>100, ysize=>100, datachannels=>4,
\&             storechannels=>3)
\&    or die "Cannot read raw image\en";
.Ve
.PP
Read parameters:
.IP "\(bu" 4
raw_interleave \- controls the ordering of samples within the image.
Default: 1.  Alternatively and historically spelled \f(CW\*(C`interleave\*(C'\fR.
Possible values:
.RS 4
.IP "\(bu" 4
0 \- samples are pixel by pixel, so all samples for the first pixel,
then all samples for the second pixel and so on.  eg. for a four pixel
scan line the channels would be laid out as:
.Sp
.Vb 1
\&  012012012012
.Ve
.IP "\(bu" 4
1 \- samples are line by line, so channel 0 for the entire scan line is
followed by channel 1 for the entire scan line and so on.  eg. for a
four pixel scan line the channels would be laid out as:
.Sp
.Vb 1
\&  000011112222
.Ve
.Sp
This is the default.
.RE
.RS 4
.Sp
Unfortunately, historically, the default \f(CW\*(C`raw_interleave\*(C'\fR for read
has been 1, while writing only supports the \f(CW\*(C`raw_interleave\*(C'\fR = 0
format.
.Sp
For future compatibility, you should always supply the
\&\f(CW\*(C`raw_interleave\*(C'\fR (or \f(CW\*(C`interleave\*(C'\fR) parameter.  As of 0.68, Imager
will warn if you attempt to read a raw image without a
\&\f(CW\*(C`raw_interleave\*(C'\fR parameter.
.RE
.IP "\(bu" 4
raw_storechannels \- the number of channels to store in the image.
Range: 1 to 4.  Default: 3.  Alternatively and historically spelled
\&\f(CW\*(C`storechannels\*(C'\fR.
.IP "\(bu" 4
raw_datachannels \- the number of channels to read from the file.
Range: 1 or more.  Default: 3.  Alternatively and historically spelled
\&\f(CW\*(C`datachannels\*(C'\fR.
.PP
.Vb 2
\&  $img\->read(file=>\*(Aqfoo.raw\*(Aq, xsize=100, ysize=>100, raw_interleave=>1)
\&    or die "Cannot read raw image\en";
.Ve
.SS "\s-1PNG\s0"
.IX Subsection "PNG"
There are no \s-1PNG\s0 specific tags.
.SS "\s-1ICO\s0 (Microsoft Windows Icon) and \s-1CUR\s0 (Microsoft Windows Cursor)"
.IX Subsection "ICO (Microsoft Windows Icon) and CUR (Microsoft Windows Cursor)"
Icon and Cursor files are very similar, the only differences being a
number in the header and the storage of the cursor hot spot.  I've
treated them separately so that you're not messing with tags to
distinguish between them.
.PP
The following tags are set when reading an icon image and are used
when writing it:
.IP "ico_mask" 4
.IX Item "ico_mask"
This is the \s-1AND\s0 mask of the icon.  When used as an icon in Windows 1
bits in the mask correspond to pixels that are modified by the source
image rather than simply replaced by the source image.
.Sp
Rather than requiring a binary bitmap this is accepted in a specific format:
.RS 4
.IP "\(bu" 4
first line consisting of the 0 placeholder, the 1 placeholder and a
newline.
.IP "\(bu" 4
following lines which contain 0 and 1 placeholders for each scan line
of the image, starting from the top of the image.
.RE
.RS 4
.Sp
When reading an image, '.' is used as the 0 placeholder and '*' as the
1 placeholder.  An example:
.Sp
.Vb 10
\&  .*
\&  ..........................******
\&  ..........................******
\&  ..........................******
\&  ..........................******
\&  ...........................*****
\&  ............................****
\&  ............................****
\&  .............................***
\&  .............................***
\&  .............................***
\&  .............................***
\&  ..............................**
\&  ..............................**
\&  ...............................*
\&  ...............................*
\&  ................................
\&  ................................
\&  ................................
\&  ................................
\&  ................................
\&  ................................
\&  *...............................
\&  **..............................
\&  **..............................
\&  ***.............................
\&  ***.............................
\&  ****............................
\&  ****............................
\&  *****...........................
\&  *****...........................
\&  *****...........................
\&  *****...........................
.Ve
.RE
.PP
The following tags are set when reading an icon:
.IP "ico_bits" 4
.IX Item "ico_bits"
The number of bits per pixel used to store the image.
.PP
For cursor files the following tags are set and read when reading and
writing:
.IP "cur_mask" 4
.IX Item "cur_mask"
This is the same as the ico_mask above.
.IP "cur_hotspotx" 4
.IX Item "cur_hotspotx"
.PD 0
.IP "cur_hotspoty" 4
.IX Item "cur_hotspoty"
.PD
The \*(L"hot\*(R" spot of the cursor image.  This is the spot on the cursor
that you click with.  If you set these to out of range values they are
clipped to the size of the image when written to the file.
.PP
The following parameters can be supplied to \fIread()\fR or \fIread_multi()\fR to
control reading of \s-1ICO/CUR\s0 files:
.IP "\(bu" 4
ico_masked \- if true, the default, then the icon/cursors mask is
applied as an alpha channel to the image.  This may result in a
paletted image being returned as a direct color image.  Default: 1
.Sp
.Vb 4
\&  # retrieve the image as stored, without using the mask as an alpha
\&  # channel
\&  $img\->read(file => \*(Aqfoo.ico\*(Aq, ico_masked => 0)
\&    or die $img\->errstr;
.Ve
.Sp
This was introduced in Imager 0.60.  Previously reading \s-1ICO\s0 images
acted as if \f(CW\*(C`ico_masked => 0\*(C'\fR.
.PP
\&\f(CW\*(C`cur_bits\*(C'\fR is set when reading a cursor.
.PP
Examples:
.PP
.Vb 3
\&  my $img = Imager\->new(xsize => 32, ysize => 32, channels => 4);
\&  $im\->box(color => \*(AqFF0000\*(Aq);
\&  $im\->write(file => \*(Aqbox.ico\*(Aq);
\&
\&  $im\->settag(name => \*(Aqcur_hotspotx\*(Aq, value => 16);
\&  $im\->settag(name => \*(Aqcur_hotspoty\*(Aq, value => 16);
\&  $im\->write(file => \*(Aqbox.cur\*(Aq);
.Ve
.SS "\s-1SGI\s0 (\s-1RGB\s0, \s-1BW\s0)"
.IX Subsection "SGI (RGB, BW)"
\&\s-1SGI\s0 images, often called by the extensions, \s-1RGB\s0 or \s-1BW\s0, can be stored
either uncompressed or compressed using an \s-1RLE\s0 compression.
.PP
By default, when saving to an extension of \f(CW\*(C`rgb\*(C'\fR, \f(CW\*(C`bw\*(C'\fR, \f(CW\*(C`sgi\*(C'\fR,
\&\f(CW\*(C`rgba\*(C'\fR the file will be saved in \s-1SGI\s0 format.  The file extension is
otherwise ignored, so saving a 3\-channel image to a \f(CW\*(C`.bw\*(C'\fR file will
result in a 3\-channel image on disk.
.PP
The following tags are set when reading a \s-1SGI\s0 image:
.IP "\(bu" 4
i_comment \- the \f(CW\*(C`IMAGENAME\*(C'\fR field from the image.  Also written to
the file when writing.
.IP "\(bu" 4
sgi_pixmin, sgi_pixmax \- the \f(CW\*(C`PIXMIN\*(C'\fR and \f(CW\*(C`PIXMAX\*(C'\fR fields from the
image.  On reading image data is expanded from this range to the full
range of samples in the image.
.IP "\(bu" 4
sgi_bpc \- the number of bytes per sample for the image.  Ignored when
writing.
.IP "\(bu" 4
sgi_rle \- whether or not the image is compressed.  If this is non-zero
when writing the image will be compressed.
.SH "ADDING NEW FORMATS"
.IX Header "ADDING NEW FORMATS"
To support a new format for reading, call the \fIregister_reader()\fR class
method:
.IP "\fIregister_reader()\fR" 4
.IX Item "register_reader()"
Registers single or multiple image read functions.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
type \- the identifier of the file format, if Imager's
\&\fIi_test_format_probe()\fR can identify the format then this value should
match \fIi_test_format_probe()\fR's result.
.Sp
This parameter is required.
.IP "\(bu" 4
single \- a code ref to read a single image from a file.  This is
supplied:
.RS 4
.IP "\(bu" 4
the object that \fIread()\fR was called on,
.IP "\(bu" 4
an Imager::IO object that should be used to read the file, and
.IP "\(bu" 4
all the parameters supplied to the \fIread()\fR method.
.RE
.RS 4
.Sp
The single parameter is required.
.RE
.IP "\(bu" 4
multiple \- a code ref which is called to read multiple images from a
file. This is supplied:
.RS 4
.IP "\(bu" 4
an Imager::IO object that should be used to read the file, and
.IP "\(bu" 4
all the parameters supplied to the \fIread_multi()\fR method.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 8
\&  # from Imager::File::ICO
\&  Imager\->register_reader
\&    (
\&     type=>\*(Aqico\*(Aq,
\&     single => 
\&     sub { 
\&       my ($im, $io, %hsh) = @_;
\&       $im\->{IMG} = i_readico_single($io, $hsh{page} || 0);
\&
\&       unless ($im\->{IMG}) {
\&         $im\->_set_error(Imager\->_error_as_msg);
\&         return;
\&       }
\&       return $im;
\&     },
\&     multiple =>
\&     sub {
\&       my ($io, %hsh) = @_;
\&     
\&       my @imgs = i_readico_multi($io);
\&       unless (@imgs) {
\&         Imager\->_set_error(Imager\->_error_as_msg);
\&         return;
\&       }
\&       return map { 
\&         bless { IMG => $_, DEBUG => $Imager::DEBUG, ERRSTR => undef }, \*(AqImager\*(Aq
\&       } @imgs;
\&     },
\&    );
.Ve
.RE
.IP "\fIregister_writer()\fR" 4
.IX Item "register_writer()"
Registers single or multiple image write functions.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
type \- the identifier of the file format.  This is typically the
extension in lowercase.
.Sp
This parameter is required.
.IP "\(bu" 4
single \- a code ref to write a single image to a file.  This is
supplied:
.RS 4
.IP "\(bu" 4
the object that \fIwrite()\fR was called on,
.IP "\(bu" 4
an Imager::IO object that should be used to write the file, and
.IP "\(bu" 4
all the parameters supplied to the \fIwrite()\fR method.
.RE
.RS 4
.Sp
The single parameter is required.
.RE
.IP "\(bu" 4
multiple \- a code ref which is called to write multiple images to a
file. This is supplied:
.RS 4
.IP "\(bu" 4
the class name \fIwrite_multi()\fR was called on, this is typically
\&\f(CW\*(C`Imager\*(C'\fR.
.IP "\(bu" 4
an Imager::IO object that should be used to write the file, and
.IP "\(bu" 4
all the parameters supplied to the \fIread_multi()\fR method.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
If you name the reader module \f(CW\*(C`Imager::File::\*(C'\fR\fIyour-format-name\fR
where \fIyour-format-name\fR is a fully upper case version of the type
value you would pass to \fIread()\fR, \fIread_multi()\fR, \fIwrite()\fR or \fIwrite_multi()\fR
then Imager will attempt to load that module if it has no other way to
read or write that format.
.PP
For example, if you create a module Imager::File::GIF and the user has
built Imager without it's normal \s-1GIF\s0 support then an attempt to read a
\&\s-1GIF\s0 image will attempt to load Imager::File::GIF.
.PP
If your module can only handle reading then you can name your module
\&\f(CW\*(C`Imager::File::\*(C'\fR\fIyour-format-name\fR\f(CW\*(C`Reader\*(C'\fR and Imager will attempt
to autoload it.
.PP
If your module can only handle writing then you can name your module 
\&\f(CW\*(C`Imager::File::\*(C'\fR\fIyour-format-name\fR\f(CW\*(C`Writer\*(C'\fR and Imager will attempt
to autoload it.
.SH "PRELOADING FILE MODULES"
.IX Header "PRELOADING FILE MODULES"
.IP "\fIpreload()\fR" 4
.IX Item "preload()"
This preloads the file support modules included with or that have been
included with Imager in the past.  This is intended for use in forking
servers such as mod_perl.
.Sp
If the module is not available no error occurs.
.Sp
Preserves $@.
.Sp
.Vb 2
\&  use Imager;
\&  Imager\->preload;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Producing an image from a \s-1CGI\s0 script"
.IX Subsection "Producing an image from a CGI script"
Once you have an image the basic mechanism is:
.IP "1." 4
set \s-1STDOUT\s0 to autoflush
.IP "2." 4
output a content-type header, and optionally a content-length header
.IP "3." 4
put \s-1STDOUT\s0 into binmode
.IP "4." 4
call \fIwrite()\fR with the \f(CW\*(C`fd\*(C'\fR or \f(CW\*(C`fh\*(C'\fR parameter.  You will need to
provide the \f(CW\*(C`type\*(C'\fR parameter since Imager can't use the extension to
guess the file format you want.
.PP
.Vb 8
\&  # write an image from a CGI script
\&  # using CGI.pm
\&  use CGI qw(:standard);
\&  $| = 1;
\&  binmode STDOUT;
\&  print header(\-type=>\*(Aqimage/gif\*(Aq);
\&  $img\->write(type=>\*(Aqgif\*(Aq, fd=>fileno(STDOUT))
\&    or die $img\->errstr;
.Ve
.PP
If you want to send a content length you can send the output to a
scalar to get the length:
.PP
.Vb 6
\&  my $data;
\&  $img\->write(type=>\*(Aqgif\*(Aq, data=>\e$data)
\&    or die $img\->errstr;
\&  binmode STDOUT;
\&  print header(\-type=>\*(Aqimage/gif\*(Aq, \-content_length=>length($data));
\&  print $data;
.Ve
.SS "Writing an animated \s-1GIF\s0"
.IX Subsection "Writing an animated GIF"
The basic idea is simple, just use \fIwrite_multi()\fR:
.PP
.Vb 2
\&  my @imgs = ...;
\&  Imager\->write_multi({ file=>$filename, type=>\*(Aqgif\*(Aq }, @imgs);
.Ve
.PP
If your images are \s-1RGB\s0 images the default quantization mechanism will
produce a very good result, but can take a long time to execute.  You
could either use the standard web color map:
.PP
.Vb 4
\&  Imager\->write_multi({ file=>$filename, 
\&                        type=>\*(Aqgif\*(Aq,
\&                        make_colors=>\*(Aqwebmap\*(Aq },
\&                      @imgs);
.Ve
.PP
or use a median cut algorithm to built a fairly optimal color map:
.PP
.Vb 4
\&  Imager\->write_multi({ file=>$filename,
\&                        type=>\*(Aqgif\*(Aq,
\&                        make_colors=>\*(Aqmediancut\*(Aq },
\&                      @imgs);
.Ve
.PP
By default all of the images will use the same global color map, which
will produce a smaller image.  If your images have significant color
differences, you may want to generate a new palette for each image:
.PP
.Vb 5
\&  Imager\->write_multi({ file=>$filename,
\&                        type=>\*(Aqgif\*(Aq,
\&                        make_colors=>\*(Aqmediancut\*(Aq,
\&                        gif_local_map => 1 },
\&                      @imgs);
.Ve
.PP
which will set the \f(CW\*(C`gif_local_map\*(C'\fR tag in each image to 1.
Alternatively, if you know only some images have different colors, you
can set the tag just for those images:
.PP
.Vb 2
\&  $imgs[2]\->settag(name=>\*(Aqgif_local_map\*(Aq, value=>1);
\&  $imgs[4]\->settag(name=>\*(Aqgif_local_map\*(Aq, value=>1);
.Ve
.PP
and call \fIwrite_multi()\fR without a \f(CW\*(C`gif_local_map\*(C'\fR parameter, or supply
an arrayref of values for the tag:
.PP
.Vb 5
\&  Imager\->write_multi({ file=>$filename,
\&                        type=>\*(Aqgif\*(Aq,
\&                        make_colors=>\*(Aqmediancut\*(Aq,
\&                        gif_local_map => [ 0, 0, 1, 0, 1 ] },
\&                      @imgs);
.Ve
.PP
Other useful parameters include \f(CW\*(C`gif_delay\*(C'\fR to control the delay
between frames and \f(CW\*(C`transp\*(C'\fR to control transparency.
.SS "Reading tags after reading an image"
.IX Subsection "Reading tags after reading an image"
This is pretty simple:
.PP
.Vb 7
\&  # print the author of a TIFF, if any
\&  my $img = Imager\->new;
\&  $img\->read(file=>$filename, type=\*(Aqtiff\*(Aq) or die $img\->errstr;
\&  my $author = $img\->tags(name=>\*(Aqtiff_author\*(Aq);
\&  if (defined $author) {
\&    print "Author: $author\en";
\&  }
.Ve
.SH "BUGS"
.IX Header "BUGS"
When saving \s-1GIF\s0 images the program does \s-1NOT\s0 try to shave off extra
colors if it is possible.  If you specify 128 colors and there are
only 2 colors used \- it will have a 128 color table anyway.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIImager\fR\|(3)
