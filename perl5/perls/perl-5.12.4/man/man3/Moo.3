.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moo 3"
.TH Moo 3 "2011-12-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moo \- Minimalist Object Orientation (with Moose compatiblity)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package Cat::Food;
\&
\& use Moo;
\& use Sub::Quote;
\&
\& sub feed_lion {
\&   my $self = shift;
\&   my $amount = shift || 1;
\&
\&   $self\->pounds( $self\->pounds \- $amount );
\& }
\&
\& has taste => (
\&   is => \*(Aqro\*(Aq,
\& );
\&
\& has brand => (
\&   is  => \*(Aqro\*(Aq,
\&   isa => sub {
\&     die "Only SWEET\-TREATZ supported!" unless $_[0] eq \*(AqSWEET\-TREATZ\*(Aq
\&   },
\&);
\&
\& has pounds => (
\&   is  => \*(Aqrw\*(Aq,
\&   isa => quote_sub q{ die "$_[0] is too much cat food!" unless $_[0] < 15 },
\& );
\&
\& 1;
.Ve
.PP
and else where
.PP
.Vb 5
\& my $full = Cat::Food\->new(
\&    taste  => \*(AqDELICIOUS.\*(Aq,
\&    brand  => \*(AqSWEET\-TREATZ\*(Aq,
\&    pounds => 10,
\& );
\&
\& $full\->feed_lion;
\&
\& say $full\->pounds;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an extremely light-weight, high-performance Moose replacement.
It also avoids depending on any \s-1XS\s0 modules to allow simple deployments.  The
name \f(CW\*(C`Moo\*(C'\fR is based on the idea that it provides almost \-but not quite\- two
thirds of Moose.
.PP
Unlike \f(CW\*(C`Mouse\*(C'\fR this module does not aim at full Moose compatibility.  See
\&\*(L"\s-1INCOMPATIBILITIES\s0\*(R" for more details.
.SH "WHY MOO EXISTS"
.IX Header "WHY MOO EXISTS"
If you want a full object system with a rich Metaprotocol, Moose is
already wonderful.
.PP
I've tried several times to use Mouse but it's 3x the size of Moo and
takes longer to load than most of my Moo based \s-1CGI\s0 scripts take to run.
.PP
If you don't want Moose, you don't want \*(L"less metaprotocol\*(R" like Mouse,
you want \*(L"as little as possible\*(R" \- which means \*(L"no metaprotocol\*(R", which is
what Moo provides.
.PP
By Moo 1.0 I intend to have Moo's equivalent of Any::Moose built in \-
if Moose gets loaded, any Moo class or role will act as a Moose equivalent
if treated as such.
.PP
Hence \- Moo exists as its name \- Minimal Object Orientation \- with a pledge
to make it smooth to upgrade to Moose when you need more than minimal
features.
.SH "IMPORTED METHODS"
.IX Header "IMPORTED METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\& Foo::Bar\->new( attr1 => 3 );
.Ve
.PP
or
.PP
.Vb 1
\& Foo::Bar\->new({ attr1 => 3 });
.Ve
.SS "\s-1BUILDARGS\s0"
.IX Subsection "BUILDARGS"
.Vb 3
\& around BUILDARGS => sub {
\&   my $orig = shift;
\&   my ( $class, @args ) = @_;
\&
\&   unshift @args, "attr1" if @args % 2 == 1;
\&
\&   return $class\->$orig(@args);
\& };
\&
\& Foo::Bar\->new( 3 );
.Ve
.PP
The default implementation of this method accepts a hash or hash reference of
named parameters. If it receives a single argument that isn't a hash reference
it throws an error.
.PP
You can override this method in your class to handle other types of options
passed to the constructor.
.PP
This method should always return a hash reference of named options.
.SS "\s-1BUILD\s0"
.IX Subsection "BUILD"
Define a \f(CW\*(C`BUILD\*(C'\fR method on your class and the constructor will automatically
call the \f(CW\*(C`BUILD\*(C'\fR method from parent down to child after the object has
been instantiated.  Typically this is used for object validation or possibly
logging.
.SS "\s-1DEMOLISH\s0"
.IX Subsection "DEMOLISH"
If you have a \f(CW\*(C`DEMOLISH\*(C'\fR method anywhere in your inheritance hierarchy,
a \f(CW\*(C`DESTROY\*(C'\fR method is created on first object construction which will call
\&\f(CW\*(C`$instance\->DEMOLISH($in_global_destruction)\*(C'\fR for each \f(CW\*(C`DEMOLISH\*(C'\fR
method from child upwards to parents.
.PP
Note that the \f(CW\*(C`DESTROY\*(C'\fR method is created on first construction of an object
of your class in order to not add overhead to classes without \f(CW\*(C`DEMOLISH\*(C'\fR
methods; this may prove slightly surprising if you try and define your own.
.SS "does"
.IX Subsection "does"
.Vb 3
\& if ($foo\->does(\*(AqSome::Role1\*(Aq)) {
\&   ...
\& }
.Ve
.PP
Returns true if the object composes in the passed role.
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
.SS "extends"
.IX Subsection "extends"
.Vb 1
\& extends \*(AqParent::Class\*(Aq;
.Ve
.PP
Declares base class. Multiple superclasses can be passed for multiple
inheritance (but please use roles instead).
.PP
Calling extends more than once will \s-1REPLACE\s0 your superclasses, not add to
them like 'use base' would.
.SS "with"
.IX Subsection "with"
.Vb 2
\& with \*(AqSome::Role1\*(Aq;
\& with \*(AqSome::Role2\*(Aq;
.Ve
.PP
Composes a Role::Tiny into current class.  Only one role may be composed in
at a time to allow the code to remain as simple as possible.
.SS "has"
.IX Subsection "has"
.Vb 3
\& has attr => (
\&   is => \*(Aqro\*(Aq,
\& );
.Ve
.PP
Declares an attribute for the class.
.PP
The options for \f(CW\*(C`has\*(C'\fR are as follows:
.IP "\(bu" 2
is
.Sp
\&\fBrequired\fR, must be \f(CW\*(C`ro\*(C'\fR or \f(CW\*(C`rw\*(C'\fR.  Unsurprisingly, \f(CW\*(C`ro\*(C'\fR generates an
accessor that will not respond to arguments; to be clear: a getter only. \f(CW\*(C`rw\*(C'\fR
will create a perlish getter/setter.
.IP "\(bu" 2
isa
.Sp
Takes a coderef which is meant to validate the attribute.  Unlike Moose Moo
does not include a basic type system, so instead of doing \f(CW\*(C`isa => \*(AqNum\*(Aq\*(C'\fR,
one should do
.Sp
.Vb 3
\& isa => quote_sub q{
\&   die "$_[0] is not a number!" unless looks_like_number $_[0]
\& },
.Ve
.Sp
Sub::Quote aware
.IP "\(bu" 2
coerce
.Sp
Takes a coderef which is meant to coerce the attribute.  The basic idea is to
do something like the following:
.Sp
.Vb 3
\& coerce => quote_sub q{
\&   $_[0] + 1 unless $_[0] % 2
\& },
.Ve
.Sp
Coerce does not require \f(CW\*(C`isa\*(C'\fR to be defined.
.Sp
Sub::Quote aware
.IP "\(bu" 2
handles
.Sp
Takes a string
.Sp
.Vb 1
\&  handles => \*(AqRobotRole\*(Aq
.Ve
.Sp
Where \f(CW\*(C`RobotRole\*(C'\fR is a role (Moo::Role) that defines an interface which
becomes the list of methods to handle.
.Sp
Takes a list of methods
.Sp
.Vb 1
\& handles => [ qw( one two ) ]
.Ve
.Sp
Takes a hashref
.Sp
.Vb 3
\& handles => {
\&   un => \*(Aqone\*(Aq,
\& }
.Ve
.IP "\(bu" 2
trigger
.Sp
Takes a coderef which will get called any time the attribute is set. Coderef
will be invoked against the object with the new value as an argument.
.Sp
Note that Moose also passes the old value, if any; this feature is not yet
supported.
.Sp
Sub::Quote aware
.IP "\(bu" 2
default
.Sp
Takes a coderef which will get called with \f(CW$self\fR as its only argument
to populate an attribute if no value is supplied to the constructor \- or
if the attribute is lazy, when the attribute is first retrieved if no
value has yet been provided.
.Sp
Note that if your default is fired during \fInew()\fR there is no guarantee that
other attributes have been populated yet so you should not rely on their
existence.
.Sp
Sub::Quote aware
.IP "\(bu" 2
predicate
.Sp
Takes a method name which will return true if an attribute has a value.
.Sp
A common example of this would be to call it \f(CW\*(C`has_$foo\*(C'\fR, implying that the
object has a \f(CW$foo\fR set.
.IP "\(bu" 2
builder
.Sp
Takes a method name which will be called to create the attribute \- functions
exactly like default except that instead of calling
.Sp
.Vb 1
\&  $default\->($self);
.Ve
.Sp
Moo will call
.Sp
.Vb 1
\&  $self\->$builder;
.Ve
.IP "\(bu" 2
clearer
.Sp
Takes a method name which will clear the attribute.
.IP "\(bu" 2
lazy
.Sp
\&\fBBoolean\fR.  Set this if you want values for the attribute to be grabbed
lazily.  This is usually a good idea if you have a \*(L"builder\*(R" which requires
another attribute to be set.
.IP "\(bu" 2
required
.Sp
\&\fBBoolean\fR.  Set this if the attribute must be passed on instantiation.
.IP "\(bu" 2
reader
.Sp
The value of this attribute will be the name of the method to get the value of
the attribute.  If you like Java style methods, you might set this to
\&\f(CW\*(C`get_foo\*(C'\fR
.IP "\(bu" 2
writer
.Sp
The value of this attribute will be the name of the method to set the value of
the attribute.  If you like Java style methods, you might set this to
\&\f(CW\*(C`set_foo\*(C'\fR
.IP "\(bu" 2
weak_ref
.Sp
\&\fBBoolean\fR.  Set this if you want the reference that the attribute contains to
be weakened; use this when circular references are possible, which will cause
leaks.
.IP "\(bu" 2
init_arg
.Sp
Takes the name of the key to look for at instantiation time of the object.  A
common use of this is to make an underscored attribute have a non-underscored
initialization name. \f(CW\*(C`undef\*(C'\fR means that passing the value in on instantiation
.SS "before"
.IX Subsection "before"
.Vb 1
\& before foo => sub { ... };
.Ve
.PP
See \*(L"before method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SS "around"
.IX Subsection "around"
.Vb 1
\& around foo => sub { ... };
.Ve
.PP
See \*(L"around method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SS "after"
.IX Subsection "after"
.Vb 1
\& after foo => sub { ... };
.Ve
.PP
See \*(L"after method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SH "SUB QUOTE AWARE"
.IX Header "SUB QUOTE AWARE"
\&\*(L"quote_sub\*(R" in Sub::Quote allows us to create coderefs that are \*(L"inlineable,\*(R"
giving us a handy, XS-free speed boost.  Any option that is Sub::Quote
aware can take advantage of this.
.SH "INCOMPATIBILITIES WITH MOOSE"
.IX Header "INCOMPATIBILITIES WITH MOOSE"
You can only compose one role at a time.  If your application is large or
complex enough to warrant complex composition, you wanted Moose.
.PP
There is no complex type system.  \f(CW\*(C`isa\*(C'\fR is verified with a coderef, if you
need complex types, just make a library of coderefs, or better yet, functions
that return quoted subs.
.PP
\&\f(CW\*(C`initializer\*(C'\fR is not supported in core since the author considers it to be a
bad idea but may be supported by an extension in future.
.PP
There is no meta object.  If you need this level of complexity you wanted
Moose \- Moo succeeds at being small because it explicitly does not
provide a metaprotocol.
.PP
No support for \f(CW\*(C`super\*(C'\fR, \f(CW\*(C`override\*(C'\fR, \f(CW\*(C`inner\*(C'\fR, or \f(CW\*(C`augment\*(C'\fR \- override can
be handled by around albeit with a little more typing, and the author considers
augment to be a bad idea.
.PP
\&\*(L"default\*(R" only supports coderefs, because doing otherwise is usually a
mistake anyway.
.PP
\&\f(CW\*(C`lazy_build\*(C'\fR is not supported per se, but of course it will work if you
manually set all the options it implies.
.PP
\&\f(CW\*(C`auto_deref\*(C'\fR is not supported since the author considers it a bad idea.
.PP
\&\f(CW\*(C`documentation\*(C'\fR is not supported since it's a very poor replacement for \s-1POD\s0.
.PP
Handling of warnings: when you \f(CW\*(C`use Moo\*(C'\fR we enable \s-1FATAL\s0 warnings.  The nearest
similar invocation for Moose would be:
.PP
.Vb 2
\&  use Moose;
\&  use warnings FATAL => "all";
.Ve
.PP
Additionally, Moo supports a set of attribute option shortcuts intended to
reduce common boilerplate.  The set of shortcuts is the same as in the Moose
module MooseX::AttributeShortcuts.  So if you:
.PP
.Vb 2
\&    package MyClass;
\&    use Moo;
.Ve
.PP
The nearest Moose invocation would be:
.PP
.Vb 1
\&    package MyClass;
\&
\&    use Moose;
\&    use warnings FATAL => "all";
\&    use MooseX::AttributeShortcuts;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
dg \- David Leadbeater (cpan:DGL) <dgl@dgl.cx>
.PP
frew \- Arthur Axel \*(L"fREW\*(R" Schmidt (cpan:FREW) <frioux@gmail.com>
.PP
hobbs \- Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
.PP
jnap \- John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
.PP
ribasushi \- Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
.PP
chip \- Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
.PP
ajgb \- Alex J. G. BurzyXski (cpan:AJGB) <ajgb@cpan.org>
.PP
doy \- Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2011 the Moo \*(L"\s-1AUTHOR\s0\*(R" and \*(L"\s-1CONTRIBUTORS\s0\*(R"
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
