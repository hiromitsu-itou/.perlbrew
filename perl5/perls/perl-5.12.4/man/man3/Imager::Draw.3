.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Draw 3"
.TH Imager::Draw 3 "2011-06-06" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Draw \- Draw primitives to images
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Imager;
\&  use Imager::Fill;
\&
\&  $img = ...;
\&  $blue = Imager::Color\->new( 0, 0, 255 );
\&  $fill = Imager::Fill\->new(hatch=>\*(Aqstipple\*(Aq);
\&
\&  $img\->line(color=>$blue, x1=>10, x2=>100,
\&                           y1=>20, y2=>50, aa=>1, endp=>1 );
\&
\&  $img\->polyline(points=>[[$x0,$y0], [$x1,$y1], [$x2,$y2]],
\&                 color=>$blue);
\&  $img\->polyline(x=>[$x0,$x1,$x2], y=>[$y0,$y1,$y2], aa=>1);
\&
\&  $img\->box(color=> $blue, xmin=> 10, ymin=>30,
\&                           xmax=>200, ymax=>300, filled=>1);
\&  $img\->box(fill=>$fill);
\&
\&  $img\->arc(color=>$blue, r=>20, x=>200, y=>100,
\&            d1=>10, d2=>20 );
\&
\&  $img\->circle(color=>$blue, r=>50, x=>200, y=>100);
\&
\&  $img\->polygon(points=>[[$x0,$y0], [$x1,$y1], [$x2,$y2]], 
\&                color=>$blue);
\&
\&  $img\->polygon(x=>[$x0,$x1,$x2], y=>[$y0,$y1,$y2]);
\&  
\&  $img\->flood_fill(x=>50, y=>50, color=>$color);
\&
\&  $img\->setpixel(x=>50, y=>70, color=>$color);
\&
\&  $img\->setpixel(x=>[ 50, 60, 70 ], y=>[20, 30, 40], color=>$color);
\&
\&  my $color = $img\->getpixel(x=>50, y=>70);
\&
\&  my @colors = $img\->getpixel(x=>[ 50, 60, 70 ], y=>[20, 30, 40]);
\&
\&  # drawing text
\&  my $font = Imager::Font\->new(...) or die;
\&  $img\->string(x => 50, y => 70,
\&               font => $font,
\&               string => "Hello, World!",
\&               color => \*(Aqred\*(Aq,
\&               size => 30,
\&               aa => 1);
\&
\&  # bottom right\-hand corner of the image
\&  $img\->align_string(x => $img\->getwidth() \- 1,
\&                     y => $img\->getheight() \- 1,
\&                     halign => \*(Aqright\*(Aq,
\&                     valign => \*(Aqbottom\*(Aq,
\&                     string => \*(AqImager\*(Aq,
\&                     font => $font,
\&                     size => 12);
\&
\&  # low\-level functions
\&  my @colors = $img\->getscanline(y=>50, x=>10, width=>20);
\&  
\&  $img\->setscanline(y=>60, x=>20, pixels=>\e@colors);
\&
\&  my @samples = $img\->getsamples(y=>50, x=>10, width=>20, 
\&                                 channels=>[ 2, 0 ]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is possible to draw with graphics primitives onto images.  Such
primitives include boxes, arcs, circles, polygons and lines.  The
coordinate system in Imager has the origin \f(CW\*(C`(0,0)\*(C'\fR in the upper left
corner of an image with co-ordinates increasing to the right and
bottom.  For non anti-aliasing operation all coordinates are rounded
towards the nearest integer.  For anti-aliased operations floating
point coordinates are used.
.PP
Drawing is assumed to take place in a coordinate system of infinite
resolution.  This is the typical convention and really only matters when
it is necessary to check for off-by-one cases.  Typically it's useful to 
think of \f(CW\*(C`(10, 20)\*(C'\fR as \f(CW\*(C`(10.00, 20.00)\*(C'\fR and consider the consequences.
.SS "Color Parameters"
.IX Subsection "Color Parameters"
The \f(CW\*(C`color\*(C'\fR parameter for any of the drawing
methods can be an Imager::Color object, a simple scalar that
Imager::Color can understand, a hashref of parameters that
Imager::Color\->new understands, or an arrayref of red, green, blue
values, for example:
.IX Xref "color parameters"
.PP
.Vb 3
\&  $image\->box(..., color=>\*(Aqred\*(Aq);
\&  $image\->line(..., color=>\*(Aq#FF0000\*(Aq);
\&  $image\->flood_fill(..., color=>[ 255, 0, 255 ]);
.Ve
.PP
While supplying colors as names, array references or \s-1CSS\s0 color
specifiers is convenient, for maximum performance you should supply
the color as an Imager::Color object:
.PP
.Vb 4
\&  my @colors = map Imager::Color\->new($_), qw/red green blue/
\&  for my $i (1..1000) {
\&    $image\->box(..., color => $colors[rand @colors]);
\&  }
.Ve
.SS "Fill Parameters"
.IX Subsection "Fill Parameters"
All filled primitives, i.e. \f(CW\*(C`arc()\*(C'\fR, \f(CW\*(C`box()\*(C'\fR,
\&\f(CW\*(C`circle()\*(C'\fR, \f(CW\*(C`polygon()\*(C'\fR and the \f(CW\*(C`flood_fill()\*(C'\fR method can take a
\&\f(CW\*(C`fill\*(C'\fR parameter instead of a \f(CW\*(C`color\*(C'\fR parameter which can either be
an Imager::Fill object, or a reference to a hash containing the
parameters used to create the fill, for example:
.IX Xref "fill parameters"
.PP
.Vb 4
\&  $image\->box(..., fill=>{ hatch => \*(Aqcheck1x1\*(Aq });
\&  my $fillimage = Imager\->new;
\&  $fillimage\->read(file=>$somefile) or die;
\&  $image\->flood_fill(..., fill=>{ image=>$fillimage });
.Ve
.PP
Currently you can create opaque or transparent plain color fills,
hatched fills, image based fills and fountain fills.  See
Imager::Fill for more information.
.SS "List of primitives"
.IX Subsection "List of primitives"
.IP "\fIline()\fR" 4
.IX Item "line()"
.Vb 2
\&  $img\->line(color=>$green, x1=>10, x2=>100,
\&                            y1=>20, y2=>50, aa=>1, endp=>1 );
.Ve
.Sp
Draws a line from (x1,y1) to (x2,y2).  The endpoint
(x2,y2) is drawn by default.  If \f(CW\*(C`endp\*(C'\fR of 0 is specified then the
endpoint will not be drawn.  If \f(CW\*(C`aa\*(C'\fR is set then the line will be
drawn anti-aliased.  The \f(CW\*(C`antialias\*(C'\fR parameter is still available for
backwards compatibility.
.IX Xref "line method"
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x1\*(C'\fR, \f(CW\*(C`y1\*(C'\fR \- starting point of the line.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`x2\*(C'\fR, \f(CW\*(C`y2\*(C'\fR \- end point of the line. Required.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the line.  See \*(L"Color Parameters\*(R".  Default:
black.
.IP "\(bu" 4
\&\f(CW\*(C`endp\*(C'\fR \- if zero the end point of the line is not drawn.  Default: 1
\&\- the end point is drawn.  This is useful to set to 0 when drawing a
series of connected lines.
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if true the line is drawn anti-aliased.  Default: 0.
.RE
.RS 4
.RE
.IP "\fIpolyline()\fR" 4
.IX Item "polyline()"
.Vb 2
\&  $img\->polyline(points=>[[$x0,$y0],[$x1,$y1],[$x2,$y2]],color=>$red);
\&  $img\->polyline(x=>[$x0,$x1,$x2], y=>[$y0,$y1,$y2], aa=>1);
.Ve
.Sp
\&\f(CW\*(C`polyline\*(C'\fR is used to draw multiple lines between a
series of points.  The point set can either be specified as an
arrayref to an array of array references (where each such array
represents a point).  The other way is to specify two array
references.
.IX Xref "polyline method"
.Sp
The \f(CW\*(C`antialias\*(C'\fR parameter is still available for backwards compatibility.
.RS 4
.IP "\(bu" 4
points \- a reference to an array of references to arrays containing
the co-ordinates of the points in the line, for example:
.Sp
.Vb 2
\&  my @points = ( [ 0, 0 ], [ 100, 0 ], [ 100, 100 ], [ 0, 100 ] );
\&  $img\->polyline(points => \e@points);
.Ve
.IP "\(bu" 4
x, y \- each is an array of x or y ordinates.  This is an alternative
to supplying the \f(CW\*(C`points\*(C'\fR parameter.
.Sp
.Vb 4
\&  # same as the above points example
\&  my @x = ( 0, 100, 100, 0 );
\&  my @y = ( 0, 0, 100, 100 );
\&  $img\->polyline(x => \e@x, y => \e@y);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the line.  See \*(L"Color Parameters\*(R".
Default: black.
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if true the line is drawn anti-aliased.  Default: 0.  Can also
be supplied as \f(CW\*(C`antialias\*(C'\fR for backward compatibility.
.RE
.RS 4
.RE
.IP "\fIbox()\fR" 4
.IX Item "box()"
.Vb 3
\&  $blue = Imager::Color\->new( 0, 0, 255 );
\&  $img\->box(color => $blue, xmin=>10, ymin=>30, xmax=>200, ymax=>300, 
\&            filled=>1);
.Ve
.Sp
If any of the edges of the box are omitted it will snap
to the outer edge of the image in that direction.  If \f(CW\*(C`filled\*(C'\fR is
omitted the box is drawn as an outline.  Instead of a color it is
possible to use a \f(CW\*(C`fill\*(C'\fR pattern:
.IX Xref "box method"
.Sp
.Vb 2
\&  $fill = Imager::Fill\->new(hatch=>\*(Aqstipple\*(Aq);
\&  $img\->box(fill=>$fill);  # fill entire image with a given fill pattern
\&
\&  $img\->box(xmin=>10, ymin=>30, xmax=>150, ymax=>60,
\&            fill => { hatch=>\*(Aqcross2\*(Aq });
.Ve
.Sp
Also if a color is omitted a color with (255,255,255,255) is used
instead.  [\s-1NOTE:\s0 This may change to use \f(CW\*(C`$img\->fgcolor()\*(C'\fR in the future].
.Sp
Box does not support fractional coordinates yet.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`xmin\*(C'\fR \- left side of the box.  Default: 0 (left edge of the image)
.IP "\(bu" 4
\&\f(CW\*(C`ymin\*(C'\fR \- top side of the box.  Default: 0 (top edge of the image)
.IP "\(bu" 4
\&\f(CW\*(C`xmax\*(C'\fR \- right side of the box.  Default: \f(CW\*(C`$img\->getwidth\-1\*(C'\fR. (right edge of the image)
.IP "\(bu" 4
\&\f(CW\*(C`ymax\*(C'\fR \- bottom side of the box.  Default: \f(CW\*(C`$img\->getheight\-1\*(C'\fR. (bottom edge of the image)
.Sp
Note: \f(CW\*(C`xmax\*(C'\fR and \f(CW\*(C`ymax\*(C'\fR are \fIinclusive\fR \- the number of pixels
drawn for a filled box is \f(CW\*(C`(xmax\-xmin+1) * (ymax\-ymin+1)\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`box\*(C'\fR \- a reference to an array of (left, top, right, bottom)
co-ordinates.  This is an alternative to supplying \f(CW\*(C`xmin\*(C'\fR, \f(CW\*(C`ymin\*(C'\fR,
\&\f(CW\*(C`xmax\*(C'\fR, \f(CW\*(C`ymax\*(C'\fR and overrides their values.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the line.  See \*(L"Color Parameters\*(R".
Default: white.  This is ignored if the filled parameter
.IP "\(bu" 4
\&\f(CW\*(C`filled\*(C'\fR \- if non-zero the box is filled with \fIcolor\fR instead of
outlined.  Default: an outline is drawn.
.IP "\(bu" 4
\&\f(CW\*(C`fill\*(C'\fR \- the fill for the box.  If this is supplied then the box will be
filled.  See \*(L"Fill Parameters\*(R".
.RE
.RS 4
.RE
.IP "\fIarc()\fR" 4
.IX Item "arc()"
.Vb 1
\&  $img\->arc(color=>$red, r=>20, x=>200, y=>100, d1=>10, d2=>20 );
.Ve
.Sp
This creates a filled red arc with a 'center' at (200, 100) and spans
10 degrees and the slice has a radius of 20.
.Sp
It's also possible to supply a \f(CW\*(C`fill\*(C'\fR parameter.
.Sp
To draw just an arc outline \- just the curve, not the radius lines,
set filled to 0:
.Sp
Parameters:
.Sp
.Vb 1
\&  $img\->arc(color=>$red, r=>20, x=>200, y=>100, d1=>10, d2=>20, filled=>0 );
.Ve
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- center of the filled arc.  Default: center of the image.
.IP "\(bu" 4
\&\f(CW\*(C`r\*(C'\fR \- radius of the arc.  Default: 1/3 of min(image height, image width).
.IP "\(bu" 4
\&\f(CW\*(C`d1\*(C'\fR \- starting angle of the arc, in degrees.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`d2\*(C'\fR \- ending angle of the arc, in degrees.  Default: 361.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the filled arc.  See \*(L"Color Parameters\*(R".
Default: white.  Overridden by \f(CW\*(C`fill\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`fill\*(C'\fR \- the fill for the filled arc.  See \*(L"Fill Parameters\*(R"
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if true the filled arc is drawn anti-aliased.  Default: false.
.Sp
Anti-aliased \fIarc()\fR is experimental for now, I'm not entirely happy
with the results in some cases.
.IP "\(bu" 4
\&\f(CW\*(C`filled\*(C'\fR \- set to 0 to draw only an outline.
.RE
.RS 4
.Sp
.Vb 2
\&  # arc going through angle zero:
\&  $img\->arc(d1=>320, d2=>40, x=>100, y=>100, r=>50, color=>\*(Aqblue\*(Aq);
\&
\&  # complex fill arc
\&  $img\->arc(d1=>135, d2=>45, x=>100, y=>150, r=>50, 
\&            fill=>{ solid=>\*(Aqred\*(Aq, combine=>\*(Aqdiff\*(Aq });
\&
\&  # draw an anti\-aliased circle outline
\&  $img\->arc(x => 100, y => 150, r => 150, filled => 0, 
\&            color => \*(Aq#F00\*(Aq, aa => 1);
\&
\&  # draw an anti\-aliased arc
\&  $img\->arc(x => 100, y => 150, r => 90, filled => 0,
\&            color => \*(Aq#0f0\*(Aq, aa => 1, d1 => 90, d2 => 180);
.Ve
.RE
.IP "\fIcircle()\fR" 4
.IX Item "circle()"
.Vb 1
\&  $img\->circle(color=>$green, r=>50, x=>200, y=>100, aa=>1, filled=>1);
.Ve
.Sp
This creates an anti-aliased green circle with its center at (200, 100)
and has a radius of 50.  It's also possible to supply a \f(CW\*(C`fill\*(C'\fR parameter
instead of a color parameter.
.Sp
.Vb 1
\&  $img\->circle(r => 50, x=> 150, y => 150, fill=>{ hatch => \*(Aqstipple\*(Aq });
.Ve
.Sp
To draw a circular outline, set \f(CW\*(C`filled\*(C'\fR to 0:
.Sp
.Vb 1
\&  $img\->circle(color=>$green, r=>50, x=>200, y=>100, aa=>1, filled=>0);
.Ve
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- center of the filled circle.  Default: center of the image.
.IP "\(bu" 4
\&\f(CW\*(C`r\*(C'\fR \- radius of the circle.  Default: 1/3 of min(image height, image width).
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the filled circle.  See \*(L"Color Parameters\*(R".
Default: white.  Overridden by \f(CW\*(C`fill\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`fill\*(C'\fR \- the fill for the filled circle.  See \*(L"Fill Parameters\*(R"
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if true the filled circle is drawn anti-aliased.  Default: false.
.IP "\(bu" 4
\&\f(CW\*(C`filled\*(C'\fR \- set to 0 to just draw an outline.
.RE
.RS 4
.RE
.IP "\fIpolygon()\fR" 4
.IX Item "polygon()"
.Vb 2
\&  $img\->polygon(points=>[[$x0,$y0],[$x1,$y1],[$x2,$y2]],color=>$red);
\&  $img\->polygon(x=>[$x0,$x1,$x2], y=>[$y0,$y1,$y2], fill=>$fill);
.Ve
.Sp
Polygon is used to draw a filled polygon.  Currently the polygon is
always drawn anti-aliased, although that will change in the future.
Like other anti-aliased drawing functions its coordinates can be
specified with floating point values.  As with other filled shapes 
it's possible to use a \f(CW\*(C`fill\*(C'\fR instead of a color.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`points\*(C'\fR \- a reference to an array of references to arrays containing
the co-ordinates of the points in the line, for example:
.Sp
.Vb 2
\&  my @points = ( [ 0, 0 ], [ 100, 0 ], [ 100, 100 ], [ 0, 100 ] );
\&  $img\->polygon(points => \e@points);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- each is an array of x or y ordinates.  This is an alternative
to supplying the \f(CW\*(C`points\*(C'\fR parameter.
.Sp
.Vb 4
\&  # same as the above points example
\&  my @x = ( 0, 100, 100, 0 );
\&  my @y = ( 0, 0, 100, 100 );
\&  $img\->polygon(x => \e@x, y => \e@y);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the filled polygon.  See \*(L"Color Parameters\*(R".
Default: black.  Overridden by \f(CW\*(C`fill\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`fill\*(C'\fR \- the fill for the filled circle.  See \*(L"Fill Parameters\*(R"
.RE
.RS 4
.RE
.IP "\fIflood_fill()\fR" 4
.IX Item "flood_fill()"
You can fill a region that all has the same color using
the \fIflood_fill()\fR method, for example:
.IX Xref "flood_fill"
.Sp
.Vb 1
\&  $img\->flood_fill(x=>50, y=>50, color=>$color);
.Ve
.Sp
will fill all regions the same color connected to the point (50, 50).
.Sp
Alternatively you can fill a region limited by a given border color:
.Sp
.Vb 2
\&  # stop at the red border
\&  $im\->flood_fill(x=>50, y=>50, color=>$color, border=>"red");
.Ve
.Sp
You can also fill with a complex fill:
.Sp
.Vb 1
\&  $img\->flood_fill(x=>50, y=>50, fill=>{ hatch=>\*(Aqcross1x1\*(Aq });
.Ve
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- the start point of the fill.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color of the filled area.  See \*(L"Color Parameters\*(R".
Default: white.  Overridden by \f(CW\*(C`fill\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`fill\*(C'\fR \- the fill for the filled area.  See \*(L"Fill Parameters\*(R"
.IP "\(bu" 4
\&\f(CW\*(C`border\*(C'\fR \- the border color of the region to be filled.  If this
parameter is supplied \fIflood_fill()\fR will stop when it finds this color.
If this is not supplied then a normal fill is done.  \f(CW\*(C`border\*(C'\fR can be
supplied as a \*(L"Color Parameters\*(R".
.RE
.RS 4
.RE
.IP "\fIsetpixel()\fR" 4
.IX Item "setpixel()"
.Vb 2
\&  $img\->setpixel(x=>50, y=>70, color=>$color);
\&  $img\->setpixel(x=>[ 50, 60, 70 ], y=>[20, 30, 40], color=>$color);
.Ve
.Sp
\&\fIsetpixel()\fR is used to set one or more individual pixels.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
x, y \- either integers giving the co-ordinates of the pixel to set or
array references containing a set of pixels to be set.
.IP "\(bu" 4
color \- the color of the pixels drawn.  See \*(L"Color Parameters\*(R".
Default: white.
.RE
.RS 4
.Sp
When called with array parameters, returns the number of pixels
successfully set, or false if none.
.Sp
When called with scalars for x and y, return \f(CW$img\fR on success, false on
failure.
.RE
.IP "\fIgetpixel()\fR" 4
.IX Item "getpixel()"
.Vb 3
\&  my $color = $img\->getpixel(x=>50, y=>70);
\&  my @colors = $img\->getpixel(x=>[ 50, 60, 70 ], y=>[20, 30, 40]);
\&  my $colors_ref = $img\->getpixel(x=>[ 50, 60, 70 ], y=>[20, 30, 40]);
.Ve
.Sp
\&\fIgetpixel()\fR is used to retrieve one or more individual pixels.
.Sp
For either method you can supply a single set of co-ordinates as
scalar x and y parameters, or set each to an arrayref of ordinates.
.Sp
When called with arrays, \fIgetpixel()\fR will return a list of colors in
list context, and an arrayref in scalar context.
.Sp
To receive floating point colors from \fIgetpixel()\fR, set the \f(CW\*(C`type\*(C'\fR
parameter to 'float'.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
x, y \- either integers giving the co-ordinates of the pixel to set or
array references containing a set of pixels to be set.
.IP "\(bu" 4
type \- the type of color object to return, either \f(CW\*(Aq8bit\*(Aq\fR for
Imager::Color objects or \f(CW\*(Aqfloat\*(Aq\fR for Imager::Color::Float objects.
Default: \f(CW\*(Aq8bit\*(Aq\fR.
.RE
.RS 4
.RE
.IP "\fIstring()\fR" 4
.IX Item "string()"
.Vb 7
\&  my $font = Imager::Font\->new(file=>"foo.ttf");
\&  $img\->string(x => 50, y => 70,
\&               string => "Hello, World!",
\&               font => $font,
\&               size => 30,
\&               aa => 1,
\&               color => \*(Aqwhite\*(Aq);
.Ve
.Sp
Draws text on the image.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- the point to draw the text from.  If \f(CW\*(C`align\*(C'\fR is 0 this
is the top left of the string.  If \f(CW\*(C`align\*(C'\fR is 1 (the default) then
this is the left of the string on the baseline.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`string\*(C'\fR \- the text to draw.  Required unless you supply the \f(CW\*(C`text\*(C'\fR
parameter.
.IP "\(bu" 4
\&\f(CW\*(C`font\*(C'\fR \- an Imager::Font object representing the font to draw the
text with.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if non-zero the output will be anti-aliased.  Default: the value
set in Imager::Font\->\fInew()\fR or 0 if not set.
.IP "\(bu" 4
\&\f(CW\*(C`align\*(C'\fR \- if non-zero the point supplied in (x,y) will be on the
base-line, if zero then (x,y) will be at the top-left of the string.
.Sp
i.e. if drawing the string \f(CW"yA"\fR and align is 0 the point (x,y) will
aligned with the top of the A.  If align is 1 (the default) it will be
aligned with the baseline of the font, typically bottom of the A,
depending on the font used.
.Sp
Default: the value set in Imager::Font\->new, or 1 if not set.
.IP "\(bu" 4
\&\f(CW\*(C`channel\*(C'\fR \- if present, the text will be written to the specified
channel of the image and the color parameter will be ignore.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color to draw the text in.  Default: the color supplied to
Imager::Font\->new, or red if none.
.IP "\(bu" 4
\&\f(CW\*(C`size\*(C'\fR \- the point size to draw the text at.  Default: the size
supplied to Imager::Font\->new, or 15.
.IP "\(bu" 4
\&\f(CW\*(C`sizew\*(C'\fR \- the width scaling to draw the text at.  Default: the value
of \f(CW\*(C`size\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`utf8\*(C'\fR \- for drivers that support it, treat the string as \s-1UTF\-8\s0
encoded.  For versions of perl that support Unicode (5.6 and later),
this will be enabled automatically if the \f(CW\*(C`string\*(C'\fR parameter is
already a \s-1UTF\-8\s0 string. See \*(L"\s-1UTF\-8\s0\*(R" in Imager::Font for more
information.
.IP "\(bu" 4
\&\f(CW\*(C`vlayout\*(C'\fR \- for drivers that support it, draw the text vertically.
Note: I haven't found a font that has the appropriate metrics yet.
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR \- alias for the \f(CW\*(C`string\*(C'\fR parameter.
.RE
.RS 4
.Sp
On error, \fIstring()\fR returns false and you can use \f(CW$img\fR\->errstr to get
the reason for the error.
.RE
.IP "\fIalign_string()\fR" 4
.IX Item "align_string()"
Draws text aligned around a point on the image.
.Sp
.Vb 6
\&  # "Hello" centered at 100, 100 in the image.
\&  my ($left, $top, $right, $bottom) = 
\&    $img\->align_string(string=>"Hello",
\&                       x=>100, y=>100, 
\&                       halign=>\*(Aqcenter\*(Aq, valign=>\*(Aqcenter\*(Aq, 
\&                       font=>$font);
.Ve
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR \- the point to draw the text from.  If \f(CW\*(C`align\*(C'\fR is 0 this
is the top left of the string.  If \f(CW\*(C`align\*(C'\fR is 1 (the default) then
this is the left of the string on the baseline.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`string\*(C'\fR \- the text to draw.  Required unless you supply the \f(CW\*(C`text\*(C'\fR
parameter.
.IP "\(bu" 4
\&\f(CW\*(C`font\*(C'\fR \- an Imager::Font object representing the font to draw the
text with.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`aa\*(C'\fR \- if non-zero the output will be anti-aliased
.IP "\(bu" 4
\&\f(CW\*(C`valign\*(C'\fR \- vertical alignment of the text against (x,y)
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`top\*(C'\fR \- Point is at the top of the text.
.IP "\(bu" 4
\&\f(CW\*(C`bottom\*(C'\fR \- Point is at the bottom of the text.
.IP "\(bu" 4
\&\f(CW\*(C`baseline\*(C'\fR \- Point is on the baseline of the text.  This is the default.
.IP "\(bu" 4
\&\f(CW\*(C`center\*(C'\fR \- Point is vertically centered within the text.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`halign\*(C'\fR \- horizontal alignment of the text against (x,y)
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`left\*(C'\fR \- The point is at the left of the text.  This is the default.
.IP "\(bu" 4
\&\f(CW\*(C`start\*(C'\fR \- The point is at the start point of the text.
.IP "\(bu" 4
\&\f(CW\*(C`center\*(C'\fR \- The point is horizontally centered within the text.
.IP "\(bu" 4
\&\f(CW\*(C`right\*(C'\fR \- The point is at the right end of the text.
.IP "\(bu" 4
\&\f(CW\*(C`end\*(C'\fR \- The point is at the end point of the text.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`channel\*(C'\fR \- if present, the text will be written to the specified
channel of the image and the color parameter will be ignore.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR \- the color to draw the text in.  Default: the color supplied to
Imager::Font\->new, or red if none.
.IP "\(bu" 4
\&\f(CW\*(C`size\*(C'\fR \- the point size to draw the text at.  Default: the size supplied
to Imager::Font\->new, or 15.
.IP "\(bu" 4
\&\f(CW\*(C`sizew\*(C'\fR \- the width scaling to draw the text at.  Default: the value of
\&\f(CW\*(C`size\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`utf8\*(C'\fR \- for drivers that support it, treat the string as \s-1UTF\-8\s0
encoded.  For versions of perl that support Unicode (5.6 and later),
this will be enabled automatically if the \f(CW\*(C`string\*(C'\fR parameter is
already a \s-1UTF\-8\s0 string. See \*(L"\s-1UTF\-8\s0\*(R" in Imager::Font for more
information.
.IP "\(bu" 4
\&\f(CW\*(C`vlayout\*(C'\fR \- for drivers that support it, draw the text vertically.
Note: I haven't found a font that has the appropriate metrics yet.
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR \- alias for the \f(CW\*(C`string\*(C'\fR parameter.
.RE
.RS 4
.Sp
On success returns a list of bounds of the drawn text, in the order
left, top, right, bottom.
.Sp
On error, \fIalign_string()\fR returns an empty list and you can use 
\&\f(CW\*(C`$img\->errstr\*(C'\fR to get the reason for the error.
.RE
.IP "\fIsetscanline()\fR" 4
.IX Item "setscanline()"
Set all or part of a horizontal line of pixels to an image.  This
method is most useful in conjunction with \*(L"\fIgetscanline()\fR\*(R".
.Sp
The parameters you can pass are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`y\*(C'\fR \- vertical position of the scan line.  This parameter is required.
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR \- position to start on the scan line.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`pixels\*(C'\fR \- either a reference to an array containing Imager::Color
objects, an reference to an array containing Imager::Color::Float
objects or a scalar containing packed color data.
.Sp
If \f(CW\*(C`type\*(C'\fR is \f(CW\*(C`index\*(C'\fR then this can either be a reference to an array
of palette color indexes or a scalar containing packed indexes.
.Sp
See \*(L"Packed Color Data\*(R" for information on the format of packed
color data.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- the type of pixel data supplied.  If you supply an array
reference of object then this is determined automatically.  If you
supply packed color data this defaults to \f(CW\*(Aq8bit\*(Aq\fR, if your data is
packed floating point color data then set this to \f(CW\*(Aqfloat\*(Aq\fR.
.Sp
You can use \f(CW\*(C`float\*(C'\fR or \f(CW\*(C`8bit\*(C'\fR samples with any image.
.Sp
If this is 'index' then pixels should be either an array of palette
color indexes or a packed string of color indexes.
.RE
.RS 4
.Sp
Returns the number of pixels set.
.Sp
Each of the following sets 5 pixels from (5, 10) through (9, 10) to
blue, red, blue, red, blue:
.Sp
.Vb 2
\&  my $red_color = Imager::Color\->new(255, 0, 0);
\&  my $blue_color = Imager::Color\->new(0, 0, 255);
\&
\&  $image\->setscanline(y=>10, x=>5, pixels=>
\&                      [ ($blue_color, $red_color) x 2, $blue_color ]);
\&
\&  # use floating point color instead, for 16\-bit plus images
\&  my $red_colorf = Imager::Color::Float\->new(1.0, 0, 0);
\&  my $blue_colorf = Imager::Color::Float\->new(0, 0, 1.0);
\&
\&  $image\->setscanline(y=>10, x=>5, pixels=>
\&                      [ ($blue_colorf, $red_colorf) x 2, $blue_colorf ]);
\&
\&  # packed 8\-bit data
\&  $image\->setscanline(y=>10, x=>5, pixels=>
\&                      pack("C*", ((0, 0, 255, 255), (255, 0, 0, 255)) x 2,
\&                            (0, 0, 255, 255)));
\&
\&  # packed floating point samples
\&  $image\->setscanline(y=>10, x=>5, type=>\*(Aqfloat\*(Aq, pixels=>
\&                      pack("d*", ((0, 0, 1.0, 1.0), (1.0, 0, 0, 1.0)) x 2,
\&                            (0, 0, 1.0, 1.0)));
.Ve
.Sp
Copy even rows from one image to another:
.Sp
.Vb 4
\&  for (my $y = 0; $y < $im2\->getheight; $y+=2) {
\&    $im1\->setscanline(y=>$y,
\&                      pixels=>scalar($im2\->getscanline(y=>$y)));
\&  }
.Ve
.Sp
Set the blue channel to 0 for all pixels in an image.  This could be
done with convert too:
.Sp
.Vb 5
\&  for my $y (0..$im\->getheight\-1) {
\&    my $row = $im\->getscanline(y=>$y);
\&    $row =~ s/(..).(.)/$1\e0$2/gs;
\&    $im\->setscanline(y=>$y, pixels=>$row);
\&  }
.Ve
.RE
.IP "\fIgetscanline()\fR" 4
.IX Item "getscanline()"
Read all or part of a horizontal line of pixels from an image.  This
method is most useful in conjunction with \*(L"\fIsetscanline()\fR\*(R".
.Sp
The parameters you can pass are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`y\*(C'\fR \- vertical position of the scan line.  This parameter is required.
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR \- position to start on the scan line.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR \- number of pixels to read.  Default: \f(CW$img\fR\->getwidth \- x
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- the type of pixel data to return.  Default: \f(CW\*(C`8bit\*(C'\fR.
.Sp
Permitted values are \f(CW\*(C`8bit\*(C'\fR and \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`index\*(C'\fR.
.RE
.RS 4
.Sp
In list context this method will return a list of Imager::Color
objects when \fItype\fR is \f(CW\*(C`8bit\*(C'\fR, or a list of Imager::Color::Float
objects when \fItype\fR if \f(CW\*(C`float\*(C'\fR, or a list of integers when \fItype\fR
is \f(CW\*(C`index\*(C'\fR.
.Sp
In scalar context this returns a packed 8\-bit pixels when \fItype\fR is
\&\f(CW\*(C`8bit\*(C'\fR, or a list of packed floating point pixels when \fItype\fR is
\&\f(CW\*(C`float\*(C'\fR, or packed palette color indexes when \fItype\fR is \f(CW\*(C`index\*(C'\fR.
.Sp
The values of samples for which the image does not have channels is
undefined.  For example, for a single channel image the values of
channels 1 through 3 are undefined.
.Sp
Check image for a given color:
.Sp
.Vb 12
\&  my $found;
\&  YLOOP: for my $y (0..$img\->getheight\-1) {
\&    my @colors = $img\->getscanline(y=>$y);
\&    for my $color (@colors) {
\&      my ($red, $green, $blue, $alpha) = $color\->rgba;
\&      if ($red == $test_red && $green == $test_green && $blue == $test_blue
\&          && $alpha == $test_alpha) {
\&        ++$found;
\&        last YLOOP;
\&      }
\&    }
\&  }
.Ve
.Sp
Or do it using packed data:
.Sp
.Vb 12
\&  my $found;
\&  my $test_packed = pack("CCCC", $test_red, $test_green, $test_blue, 
\&                         $test_alpha);
\&  YLOOP: for my $y (0..$img\->getheight\-1) {
\&    my $colors = $img\->getscanline(y=>$y);
\&    while (length $colors) {
\&      if (substr($colors, 0, 4, \*(Aq\*(Aq) eq $test_packed) {
\&        ++$found;
\&        last YLOOP;
\&      }
\&    }
\&  }
.Ve
.Sp
Some of the examples for \*(L"\fIsetscanline()\fR\*(R" for more examples.
.RE
.IP "\fIgetsamples()\fR" 4
.IX Item "getsamples()"
Read specified channels from all or part of a horizontal line of
pixels from an image.
.Sp
The parameters you can pass are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`y\*(C'\fR \- vertical position of the scan line.  This parameter is required.
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR \- position to start on the scan line.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR \- number of pixels to read.  Default: \f(CW\*(C`$img\->getwidth \- x\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- the type of sample data to return.  Default: \f(CW\*(C`8bit\*(C'\fR.
.Sp
Permitted values are \f(CW\*(C`8bit\*(C'\fR and \f(CW\*(C`float\*(C'\fR.
.Sp
As of Imager 0.61 this can be \f(CW\*(C`16bit\*(C'\fR only for 16 bit images.
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- a reference to an array of channels to return, where 0
is the first channel.  Default: \f(CW\*(C`[ 0 .. $self\->getchannels()\-1 ]\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target\*(C'\fR \- if an array reference is supplied in target then the samples
will be stored here instead of being returned.
.IP "\(bu" 4
\&\f(CW\*(C`offset\*(C'\fR \- the offset within the array referenced by \fItarget\fR
.RE
.RS 4
.Sp
In list context this will return a list of integers between 0 and 255
inclusive when \fItype\fR is \f(CW\*(C`8bit\*(C'\fR, or a list of floating point numbers
between 0.0 and 1.0 inclusive when \fItype\fR is \f(CW\*(C`float\*(C'\fR.
.Sp
In scalar context this will return a string of packed bytes, as with
\&\f(CW\*(C` pack("C*", ...) \*(C'\fR when \fItype\fR is \f(CW\*(C`8bit\*(C'\fR or a string of packed
doubles as with \f(CW\*(C` pack("d*", ...) \*(C'\fR when \fItype\fR is \f(CW\*(C`float\*(C'\fR.
.Sp
If the \fItarget\fR option is supplied then only a count of samples is
returned.
.Sp
Example: Check if any pixels in an image have a non-zero alpha
channel:
.Sp
.Vb 8
\&  my $has_coverage;
\&  for my $y (0 .. $img\->getheight()\-1) {
\&    my $alpha = $img\->getsamples(y=>$y, channels=>[0]);
\&    if ($alpha =~ /[^\e0]/) {
\&      ++$has_coverage;
\&      last;
\&    }
\&  }
.Ve
.Sp
Example: Convert a 2 channel gray image into a 4 channel \s-1RGBA\s0 image:
.Sp
.Vb 8
\&  # this could be done with convert() instead
\&  my $out = Imager\->new(xsize => $src\->getwidth(), 
\&                        ysize => $src\->getheight(),
\&                        channels => 4);
\&  for my $y ( 0 .. $src\->getheight()\-1 ) {
\&    my $data = $src\->getsamples(y=>$y, channels=>[ 0, 0, 0, 1 ]);
\&    $out\->setscanline(y=>$y, pixels=>$data);
\&  }
.Ve
.Sp
Retrieve 16\-bit samples:
.Sp
.Vb 4
\&  if ($img\->bits == 16) {
\&    my @samples;
\&    $img\->getsamples(x => 0, y => $y, target => \e@samples, type => \*(Aq16bit\*(Aq);
\&  }
.Ve
.RE
.IP "\fIsetsamples()\fR" 4
.IX Item "setsamples()"
This allows writing of samples back to some images.  Currently this is
only supported for 16\-bit/sample images.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`y\*(C'\fR \- vertical position of the scan line.  This parameter is required.
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR \- position to start on the scan line.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR \- number of pixels to write.  Default: \f(CW\*(C`$img\->getwidth \- x\*(C'\fR.
The minimum of this and the number of pixels represented by the
samples provided will be written.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- the type of sample data to write.  This parameter is required.
.Sp
As of Imager 0.61 this can only be \f(CW\*(C`16bit\*(C'\fR only for 16 bit images.
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- a reference to an array of channels to return, where 0 is
the first channel.  Default: \f(CW\*(C`[ 0 .. $self\->getchannels()\-1 ]\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- a reference to an array of samples to write.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`offset\*(C'\fR \- the starting offset within the array referenced by \fIdata\fR
.RE
.RS 4
.Sp
Returns the number of samples written.
.RE
.SH "Packed Color Data"
.IX Header "Packed Color Data"
The \fIgetscanline()\fR and \fIsetscanline()\fR functions can work with pixels
packed into scalars.  This is useful to remove the cost of creating
color objects, but should only be used when performance is an issue.
.PP
Packed data can either be 1 byte per sample or 1 double per sample.
.PP
Each pixel returned by \fIgetscanline()\fR or supplied to \fIsetscanline()\fR
contains 4 samples, even if the image has fewer then 4 channels.  The
values of the extra samples as returned by \fIgetscanline()\fR is not
specified.  The extra samples passed to \fIsetscanline()\fR are ignored.
.PP
To produce packed 1 byte/sample pixels, use the pack \f(CW\*(C`C\*(C'\fR template:
.PP
.Vb 1
\&  my $packed_8bit_pixel = pack("CCCC", $red, $blue, $green, $alpha);
.Ve
.PP
To produce packed double/sample pixels, use the pack \f(CW\*(C`d\*(C'\fR template:
.PP
.Vb 1
\&  my $packed_float_pixel = pack("dddd", $red, $blue, $green, $alpha);
.Ve
.PP
If you use a \fItype\fR parameter of \f(CW\*(C`index\*(C'\fR then the values are palette
color indexes, not sample values:
.PP
.Vb 6
\&  my $im = Imager\->new(xsize => 100, ysize => 100, type => \*(Aqpaletted\*(Aq);
\&  my $black_index = $im\->addcolors(colors => [ \*(Aqblack\*(Aq ]);
\&  my $red_index = $im\->addcolors(colors => [ \*(Aqred\*(Aq ]);
\&  # 2 pixels
\&  my $packed_index_data = pack("C*", $black_index, $red_index);
\&  $im\->setscanline(y => $y, pixels => $packed_index_data, type => \*(Aqindex\*(Aq);
.Ve
.SH "Combine Types"
.IX Header "Combine Types"
Some methods accept a \f(CW\*(C`combine\*(C'\fR parameter, this can be any of the
following:
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
The fill pixel replaces the target pixel.
.ie n .IP """normal""" 4
.el .IP "\f(CWnormal\fR" 4
.IX Item "normal"
The fill pixels alpha value is used to combine it with the target pixel.
.ie n .IP """multiply""" 4
.el .IP "\f(CWmultiply\fR" 4
.IX Item "multiply"
.PD 0
.ie n .IP """mult""" 4
.el .IP "\f(CWmult\fR" 4
.IX Item "mult"
.PD
Each channel of fill and target is multiplied, and the result is
combined using the alpha channel of the fill pixel.
.ie n .IP """dissolve""" 4
.el .IP "\f(CWdissolve\fR" 4
.IX Item "dissolve"
If the alpha of the fill pixel is greater than a random number, the
fill pixel is alpha combined with the target pixel.
.ie n .IP """add""" 4
.el .IP "\f(CWadd\fR" 4
.IX Item "add"
The channels of the fill and target are added together, clamped to the range of the samples and alpha combined with the target.
.ie n .IP """subtract""" 4
.el .IP "\f(CWsubtract\fR" 4
.IX Item "subtract"
The channels of the fill are subtracted from the target, clamped to be
>= 0, and alpha combined with the target.
.ie n .IP """diff""" 4
.el .IP "\f(CWdiff\fR" 4
.IX Item "diff"
The channels of the fill are subtracted from the target and the
absolute value taken this is alpha combined with the target.
.ie n .IP """lighten""" 4
.el .IP "\f(CWlighten\fR" 4
.IX Item "lighten"
The higher value is taken from each channel of the fill and target
pixels, which is then alpha combined with the target.
.ie n .IP """darken""" 4
.el .IP "\f(CWdarken\fR" 4
.IX Item "darken"
The higher value is taken from each channel of the fill and target
pixels, which is then alpha combined with the target.
.ie n .IP """hue""" 4
.el .IP "\f(CWhue\fR" 4
.IX Item "hue"
The combination of the saturation and value of the target is combined
with the hue of the fill pixel, and is then alpha combined with the
target.
.ie n .IP """sat""" 4
.el .IP "\f(CWsat\fR" 4
.IX Item "sat"
The combination of the hue and value of the target is combined
with the saturation of the fill pixel, and is then alpha combined with the
target.
.ie n .IP """value""" 4
.el .IP "\f(CWvalue\fR" 4
.IX Item "value"
The combination of the hue and value of the target is combined
with the value of the fill pixel, and is then alpha combined with the
target.
.ie n .IP """color""" 4
.el .IP "\f(CWcolor\fR" 4
.IX Item "color"
The combination of the value of the target is combined with the hue
and saturation of the fill pixel, and is then alpha combined with the
target.
.IP "\fIcombines()\fR" 4
.IX Item "combines()"
Returns a list of possible combine types.
.SH "BUGS"
.IX Header "BUGS"
\&\fIbox()\fR does not support anti-aliasing yet.  Default color is not
unified yet.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>, Arnar M. Hrafnkelsson.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager(3), Imager::Cookbook(3)
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Revision\fR$
