.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Plugin::Authentication::Internals 3"
.TH Catalyst::Plugin::Authentication::Internals 3 "2011-07-29" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Plugin::Authentication::Internals \- All about authentication Stores and Credentials
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Catalyst::Plugin::Authentication provides
a standard authentication interface to application developers using the
Catalyst framework. It is designed to allow application developers to use
various methods of user storage and credential verification. It is also
designed to provide for minimal change to the application when switching
between different storage and credential verification methods.
.PP
While Catalyst::Plugin::Authentication
provides the interface to the application developer, the actual work of
verifying the credentials and retrieving users is delegated to separate
modules. These modules are called \fBCredentials\fR and storage backends, or
\&\fBStores\fR, respectively. For authentication to function there must be at least
one credential and one store. A pairing of a store and a credential
is referred to as a \fBRealm\fR. There may be any number of realms defined for an
application, though most applications will not require more than one or two.
.PP
The details of using this module can be found in the
Catalyst::Plugin::Authentication
documentation.
.PP
What follows is an explanation of how the module functions internally and what
is required to implement a credential or a store.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
There are two main entry points you need to be aware of when writing a store
or credential module. The first is initialization and the second is during the
actual call to the Catalyst application's authenticate method.
.PP
A simplified description of the authentication process follows:
.PP
\&\fBInitialization\fR
.Sp
.RS 4
\&\fBRealm Setup\fR \- for each realm:
.Sp
.RS 4
1) The Realm is instantiated using \fInew()\fR method
.Sp
2) The Store is instantiated using \fInew()\fR method
.Sp
3) The Credential Instantiated using \fInew()\fR method
.Sp
4) Credential and Store objects tied to realm for use during requests
.RE
.RE
.RS 4
.RE
.PP
\&\fBAuthentication\fR
.Sp
.RS 4
\&\f(CW\*(C`$c\->authenticate( $userinfo, $realm )\*(C'\fR called
.Sp
.RS 4
1) Credential object retrieved for realm provided
.Sp
2) Credential's \fIauthenticate()\fR method called with authinfo and realm object for current realm
.Sp
.RS 4
The realm object and the authinfo hash are provided to the credential object's
authenticate call. In most cases the credential object will attempt to
retrieve a user using the realm's \fIfind_user()\fR method, which by default relays
the call directly to the Store's \fIfind_user()\fR method. It will then usually
compare the retrieved user's information with the information provided in the
\&\f(CW$authinfo\fR hash. This is how the default 'Password' credential functions. If
the credentials match, the \fIauthenticate()\fR method should return a user object.
.RE
.RE
.RS 4
.Sp
3) User object stored in session
.Sp
.RS 4
If the user object supports session storage, the successfully authenticated
user will be placed in session storage. This is done by calling the realm
object's \fIpersist_user()\fR method. The \fIpersist_user()\fR routine by
default calls the Store's \fIfor_session()\fR method, which should return serialized
data (\s-1IE\s0 a scalar). This serialized data is passed back to the store via the
\&\fIfrom_session()\fR method, so the data should contain enough information for the
store to recreate / reload the user.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\&\fBSessions\fR \- Per-Request operations
.Sp
.RS 4
When any user-related activity occurs, and \f(CW$c\fR\->authenticate has not
yet been called, the Catalyst::Plugin::Authentication module will
attempt to restore the persisted user (normally from the session if one is available).
There is only one step in this process:
.Sp
.RS 4
1) Store object's \fIfrom_session()\fR is called
.RE
.RE
.RS 4
.Sp
The serialized data previously returned by the store's \fIfor_session()\fR
method is provided to the \fIfrom_session()\fR method. The \fIfrom_session()\fR
method should return a valid user object.
.Sp
Note that the \fIfor_session()\fR is only called during the original
\&\f(CW$c\fR\->\fIauthenticate()\fR call, so if changes are made to the user that need
to be reflected in your session data, you will want to call the
\&\f(CW$c\fR\->\fIpersist_user()\fR method \- which will perform the session
storage process again (complete with call to \fIfor_session()\fR).
.RE
.PP
More detailed information about these processes is below.
.SS "\s-1INITIALIZATION\s0"
.IX Subsection "INITIALIZATION"
When the authentication module is loaded, it reads it's configuration to
determine the realms to set up for the application and which realm is to be
the default. For each realm defined in the application's config,
Catalyst::Plugin::Authentication
instantiates both a new credential object and a new store object. See below
for the details of how credentials and stores are instantiated.
.PP
\&\fB\s-1NOTE\s0\fR: The instances created will remain active throughout the entire 
lifetime of the application, and so should be relatively lightweight. 
Care should be taken to ensure that they do not grow, or retain 
information per request, because they will be involved in each 
authentication request and could therefore substantially
hurt memory consumption over time.
.SS "\s-1AUTHENTICATION\s0"
.IX Subsection "AUTHENTICATION"
When \f(CW\*(C`$c\->authenticate()\*(C'\fR is called from within an application, the
objects created in the initialization process come into play.
\&\f(CW\*(C`$c\->authenticate()\*(C'\fR takes two arguments. The first is a hash reference
containing all the information available about the user. This will be used to
locate the user in the store and verify the user's credentials. The second
argument is the realm to authenticate against. If the second argument is
omitted, the default realm is assumed.
.PP
The main authentication module then locates the credential and store objects
for the realm specified and calls the credential object's \f(CW\*(C`authenticate()\*(C'\fR
method. It provides three arguments, first the application object, or \f(CW$c\fR,
then a reference to the store object, and finally the hashref provided in the
\&\f(CW\*(C`$c\->authenticate\*(C'\fR call. The main authentication module expects the
return value to be a reference to a user object upon successful
authentication. If it receives anything aside from a reference, it is
considered to be an authentication failure. Upon success, the returned user is
marked as authenticated and the application can act accordingly, using
\&\f(CW\*(C`$c\->user\*(C'\fR to access the authenticated user, etc.
.PP
Astute readers will note that the main
Catalyst::Plugin::Authentication module
does not interact with the store in any way, save for passing a reference to
it to the credential. This is correct. The credential object is responsible
for obtaining the user from the provided store using information from the
userinfo hashref and/or data obtained during the credential verification
process.
.SH "WRITING A STORE"
.IX Header "WRITING A STORE"
There are two parts to an authentication store, the store object and the user object.
.SS "\s-1STORAGE\s0 \s-1BACKEND\s0"
.IX Subsection "STORAGE BACKEND"
Writing a store is actually quite simple.  There are only five methods
that must be implemented. They are:
.PP
.Vb 5
\&    new()           \- instantiates the store object
\&    find_user()     \- locates a user using data contained in the hashref
\&    for_session()   \- prepares a user to be stored in the session
\&    from_session()  \- does any restoration required when obtaining a user from the session
\&    user_supports() \- provides information about what the user object supports
.Ve
.PP
\fI\s-1STORE\s0 \s-1METHODS\s0\fR
.IX Subsection "STORE METHODS"
.ie n .IP "new( $config, $app, $realm )" 4
.el .IP "new( \f(CW$config\fR, \f(CW$app\fR, \f(CW$realm\fR )" 4
.IX Item "new( $config, $app, $realm )"
The \f(CW\*(C`new()\*(C'\fR method is called only once, during the setup process of
Catalyst::Plugin::Authentication. The
first argument, \f(CW$config\fR, is a hash reference containing the configuration
information for the store module. The second argument is a reference to the
Catalyst application.
.Sp
Note that when \fInew()\fR is called, Catalyst has not yet loaded 
the various controller and model classes, nor is it definite
that other plugins have been loaded, so your \fInew()\fR method 
must not rely on any of those being present.  If any of 
this is required for your store to function, you should
defer that part of initialization until the first method call.
.Sp
The \f(CW\*(C`new()\*(C'\fR method should return a blessed reference to your store object.
.ie n .IP "find_user( $authinfo, $c )" 4
.el .IP "find_user( \f(CW$authinfo\fR, \f(CW$c\fR )" 4
.IX Item "find_user( $authinfo, $c )"
This is the workhorse of any authentication store. It's job is to take the
information provided to it via the \f(CW$authinfo\fR hashref and locate the user
that matches it. It should return a reference to a user object. A return value
of anything else is considered to mean no user was found that matched the
information provided.
.Sp
How \f(CW\*(C`find_user()\*(C'\fR accomplishes it's job is entirely up to you, the author, as
is what \f(CW$authinfo\fR is required to contain.  Many stores will simply use a 
username element in \f(CW$authinfo\fR to locate the user, but more advanced functionality
is possible and you may bend the \f(CW$authinfo\fR to your needs.  Be aware, however, that
both Credentials and Stores usually work with the same \f(CW$authinfo\fR hash, so take 
care to avoid overlapping element names.
.Sp
Please note that this routine may be called numerous times in various
circumstances, and that a successful match for a user here does \fB\s-1NOT\s0\fR
necessarily constitute successful authentication. Your store class should
never assume this and in most cases \f(CW$c\fR \fBshould not be modified\fR by your
store object.
.ie n .IP "for_session( $c, $user )" 4
.el .IP "for_session( \f(CW$c\fR, \f(CW$user\fR )" 4
.IX Item "for_session( $c, $user )"
This method is responsible for preparing a user object for storage in the session.
It should return information that can be placed in the session and later used to 
restore a user object (using the \f(CW\*(C`from_session()\*(C'\fR method).  It should therefore
ensure that whatever information provided can be used by the \f(CW\*(C`from_session()\*(C'\fR
method to locate the unique user being saved.  Note that there is no guarantee
that the same Catalyst instance will receive both the \f(CW\*(C`for_session()\*(C'\fR and 
\&\f(CW\*(C`from_session()\*(C'\fR calls.  You should take care to provide information that can
be used to restore a user, regardless of the current state of the application. 
A good rule of thumb is that if \f(CW\*(C`from_session()\*(C'\fR can revive the user with the
given information even if the Catalyst application has just started up, you are 
in good shape.
.ie n .IP "from_session( $c, $frozenuser )" 4
.el .IP "from_session( \f(CW$c\fR, \f(CW$frozenuser\fR )" 4
.IX Item "from_session( $c, $frozenuser )"
This method is called whenever a user is being restored from the session.  
\&\f(CW$frozenuser\fR contains the information that was stored in the session for the user.
This will under normal circumstances be the exact data your store returned from 
the previous call to \f(CW\*(C`for_session()\*(C'\fR.  \f(CW\*(C`from_session()\*(C'\fR should return a valid
user object.
.ie n .IP "user_supports( $feature, ...  )" 4
.el .IP "user_supports( \f(CW$feature\fR, ...  )" 4
.IX Item "user_supports( $feature, ...  )"
This method allows credentials and other objects to inquire as to what the
underlying user object is capable of. This is pretty-well free-form and the
main purpose is to allow graceful integration with credentials and
applications that may provide advanced functionality based on whether the
underlying user object can do certain things. In most cases you will want to
pass this directly to the underlying user class' \f(CW\*(C`supports\*(C'\fR method. Note that 
this is used as a \fBclass\fR method against the user class and therefore must 
be able to function without an instantiated user object.
.SS "\s-1USER\s0 \s-1OBJECT\s0"
.IX Subsection "USER OBJECT"
The user object is an important piece of your store module. It will be the
part of the system that the application developer will interact with most. As
such, the \s-1API\s0 for the user object is very rigid. All user objects \fB\s-1MUST\s0\fR
inherit from
Catalyst::Authentication::User.
.PP
\fI\s-1USER\s0 \s-1METHODS\s0\fR
.IX Subsection "USER METHODS"
.PP
The routines required by the
Catalyst::Plugin::Authentication plugin
are below. Note that of these, only get_object is strictly required, as the
Catalyst::Authentication::User
base class contains reasonable implementations of the rest. If you do choose
to implement only the \f(CW\*(C`get_object()\*(C'\fR routine, please read the base class code
and documentation so that you fully understand how the other routines will be
implemented for you.
.PP
Also, your user object can implement whatever additional methods you require
to provide the functionality you need. So long as the below are implemented,
and you don't overlap the base class' methods with incompatible routines, you
should experience no problems.
.IP "id( )" 4
.IX Item "id( )"
The \f(CW\*(C`id()\*(C'\fR method should return a unique id (scalar) that can be used to 
retreive this user from the store.  Often this will be provided to the store's
\&\f(CW\*(C`find_user()\*(C'\fR routine as \f(CW\*(C`id => $user\->id\*(C'\fR so you should ensure that your 
store's \f(CW\*(C`find_user()\*(C'\fR can cope with that.
.ie n .IP "supports( $feature, $subfeature ... )" 4
.el .IP "supports( \f(CW$feature\fR, \f(CW$subfeature\fR ... )" 4
.IX Item "supports( $feature, $subfeature ... )"
This method checks to see if the user class supports a particular feature.  It
is implemented such that each argument provides a subfeature of the previous 
argument. In other words, passing 'foo', 'bar'  would return true if the user
supported the 'foo' feature, and the 'bar' feature of 'foo'.   This is implemented
in Catalyst::Authentication::User, so if your class inherits from that, you
do not need to implement this and can instead implement \fIsupported_features()\fR.
.Sp
\&\fBNote:\fR If you want the authentication module to be able to save your user in
the session you must return true when presented with the feature 'session'.
.IP "supported_features( )" 4
.IX Item "supported_features( )"
This method should return a hashref of features supported by the user class.
This is for more flexible integration with some Credentials / applications. It
is not required that you support anything, and returning \f(CW\*(C`undef\*(C'\fR is perfectly
acceptable and in most cases what you will do.
.ie n .IP "get( $fieldname )" 4
.el .IP "get( \f(CW$fieldname\fR )" 4
.IX Item "get( $fieldname )"
This method should return the value of the field matching fieldname provided,
or undef if there is no field matching that fieldname. In most cases this will
access the underlying storage mechanism for the user data and return the
information. This is used as a standard method of accessing an authenticated
user's data, and \s-1MUST\s0 be implemented by all user objects.
.Sp
\&\fBNote\fR: There is no equivalent 'set' method. Each user class is 
likely to vary greatly in how data must be saved and it is 
therefore impractical to try to provide a standard way of 
accomplishing it. When an application developer needs to save 
data, they should obtain the underlying object / data by 
calling get_object, and work with it directly.
.IP "get_object( )" 4
.IX Item "get_object( )"
This method returns the underlying user object. If your user object is backed
by another object class, this method should return that underlying object.
This allows the application developer to obtain an editable object. Generally
speaking this will only be done by developers who know what they are doing and
require advanced functionality which is either unforeseen or inconsistent
across user classes. If your object is not backed by another class, or you
need to provide additional intermediate functionality, it is perfectly
reasonable to return \f(CW$self\fR.
.SH "WRITING A CREDENTIAL"
.IX Header "WRITING A CREDENTIAL"
Compared to writing a store, writing a credential is very simple.  There is only
one class to implement, and it consists of only two required routines. They are:
.PP
.Vb 2
\&    new()           \- instantiates the credential object
\&    authenticate()  \- performs the authentication and returns a user object
.Ve
.SS "\s-1CREDENTIAL\s0 \s-1METHODS\s0"
.IX Subsection "CREDENTIAL METHODS"
.ie n .IP "new( $config, $app, $realm )" 4
.el .IP "new( \f(CW$config\fR, \f(CW$app\fR, \f(CW$realm\fR )" 4
.IX Item "new( $config, $app, $realm )"
Like the Store method of the same name, the \f(CW\*(C`new()\*(C'\fR method is called only 
once, during the setup process of 
Catalyst::Plugin::Authentication. The
first argument, \f(CW$config\fR, is a hash reference containing the configuration
information for the credential module. The second argument is a reference 
to the Catalyst application.  \f(CW$realm\fR is the instantiated Realm object, which
you may use to access realm routines \- such as find_user.
.Sp
Again, when the credential's \fInew()\fR method is called, Catalyst 
has not yet loaded the various controller and model classes.
.Sp
The new method should perform any necessary setup required and instantiate 
your credential object.  It should return your instantiated credential.
.ie n .IP "authenticate( $c, $realm, $authinfo )" 4
.el .IP "authenticate( \f(CW$c\fR, \f(CW$realm\fR, \f(CW$authinfo\fR )" 4
.IX Item "authenticate( $c, $realm, $authinfo )"
This is the workhorse of your credential.  When \f(CW$c\fR\->\fIauthenticate()\fR is called
the Catalyst::Plugin::Authentication module retrieves the
realm object and passes it, along with the \f(CW$authinfo\fR hash
to your credential's authenticate method.  Your module should use the 
\&\f(CW$authinfo\fR hash to obtain the user from the realm passed, and then perform 
any credential verification steps necessary to authenticate the user.  This
method should return the user object returned by the authentication store if
credential verification succeeded.  It should return undef on failure.
.Sp
How your credential module performs the credential verification is entirely
up to you.  In most cases, the credential will retrieve a user from the store
first (using the stores \fIfind_user()\fR method), and then validate the user's 
information.  However, this does not have to be the case.
.Sp
It is perfectly acceptable for your credential to perform other tasks prior to
attempting to retrieve the user from the store. It may also make sense for
your credential to perform activities which help to locate the user in
question, for example, finding a user id based on an encrypted token.
In these scenarios, the \f(CW$authinfo\fR hash passed to \fIfind_user()\fR
can be different than that which is passed in to \f(CW$c\fR\->\fIauthenticate()\fR. Once
again this is perfectly acceptable if it makes sense for your credential,
though you are strongly advised to note this behavior clearly in your 
credential's documentation \- as application authors are almost 
certainly expecting the user to be found using the information provided 
to \f(CW$c\fR\->\fIauthenticate()\fR.
.Sp
Look at the Catalyst::Authentication::Credential::Password
module source to see this in action.  In order to avoid possible 
mismatches between the encrypted and unencrypted passwords, the password 
credential actually removes the provided password from the authinfo 
array.  It does this because, in many cases, the store's password 
field will be encrypted in some way, and the password passed to 
\&\f(CW$c\fR\->authenticate is almost certainly in plaintext.
.Sp
\&\s-1NOTE:\s0 You should always assume that a store is going to use all
the information passed to it to locate the user in question. 
If there are fields in the \f(CW$authinfo\fR hash that you are sure
are specific to your credential, you may want to consider 
removing them before user retrieval.  A better solution is to
place those arguments that are specific to your credential 
within their own subhash named after your module.
.Sp
The Catalyst::Authentication::Store::DBIx::Class module does this
in order to encapsulate arguments intended specifically for 
that module. See the Catalyst::Authentication::Store::DBIx::Class::User
source for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jay Kuri, \f(CW\*(C`jayk@cpan.org\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2005 the aforementioned authors. All rights
reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
