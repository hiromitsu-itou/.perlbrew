.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader::Base 3"
.TH DBIx::Class::Schema::Loader::Base 3 "2012-02-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema::Loader::Base \- Base DBIx::Class::Schema::Loader Implementation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See DBIx::Class::Schema::Loader.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for the storage-specific \f(CW\*(C`DBIx::Class::Schema::*\*(C'\fR
classes, and implements the common functionality between them.
.SH "CONSTRUCTOR OPTIONS"
.IX Header "CONSTRUCTOR OPTIONS"
These constructor options are the base options for
\&\*(L"loader_options\*(R" in DBIx::Class::Schema::Loader.  Available constructor options are:
.SS "skip_relationships"
.IX Subsection "skip_relationships"
Skip setting up relationships.  The default is to attempt the loading
of relationships.
.SS "skip_load_external"
.IX Subsection "skip_load_external"
Skip loading of other classes in \f(CW@INC\fR. The default is to merge all other classes
with the same name found in \f(CW@INC\fR into the schema file we are creating.
.SS "naming"
.IX Subsection "naming"
Static schemas (ones dumped to disk) will, by default, use the new-style
relationship names and singularized Results, unless you're overwriting an
existing dump made by an older version of DBIx::Class::Schema::Loader, in
which case the backward compatible RelBuilder will be activated, and the
appropriate monikerization used.
.PP
Specifying
.PP
.Vb 1
\&    naming => \*(Aqcurrent\*(Aq
.Ve
.PP
will disable the backward-compatible RelBuilder and use
the new-style relationship names along with singularized Results, even when
overwriting a dump made with an earlier version.
.PP
The option also takes a hashref:
.PP
.Vb 6
\&    naming => {
\&        relationships    => \*(Aqv8\*(Aq,
\&        monikers         => \*(Aqv8\*(Aq,
\&        column_accessors => \*(Aqv8\*(Aq,
\&        force_ascii      => 1,
\&    }
.Ve
.PP
or
.PP
.Vb 1
\&    naming => { ALL => \*(Aqv8\*(Aq, force_ascii => 1 }
.Ve
.PP
The keys are:
.IP "\s-1ALL\s0" 4
.IX Item "ALL"
Set \*(L"relationships\*(R", \*(L"monikers\*(R" and \*(L"column_accessors\*(R" to the specified
value.
.IP "relationships" 4
.IX Item "relationships"
How to name relationship accessors.
.IP "monikers" 4
.IX Item "monikers"
How to name Result classes.
.IP "column_accessors" 4
.IX Item "column_accessors"
How to name column accessors in Result classes.
.IP "force_ascii" 4
.IX Item "force_ascii"
For \*(L"v8\*(R" mode and later, uses String::ToIdentifier::EN instead of
String::ToIdentifier::EM::Unicode to force monikers and other identifiers to
\&\s-1ASCII\s0.
.PP
The values can be:
.IP "current" 4
.IX Item "current"
Latest style, whatever that happens to be.
.IP "v4" 4
.IX Item "v4"
Unsingularlized monikers, \f(CW\*(C`has_many\*(C'\fR only relationships with no _id stripping.
.IP "v5" 4
.IX Item "v5"
Monikers singularized as whole words, \f(CW\*(C`might_have\*(C'\fR relationships for FKs on
\&\f(CW\*(C`UNIQUE\*(C'\fR constraints, \f(CW\*(C`_id\*(C'\fR stripping for belongs_to relationships.
.Sp
Some of the \f(CW\*(C`_id\*(C'\fR stripping edge cases in \f(CW0.05003\fR have been reverted for
the v5 RelBuilder.
.IP "v6" 4
.IX Item "v6"
All monikers and relationships are inflected using
Lingua::EN::Inflect::Phrase, and there is more aggressive \f(CW\*(C`_id\*(C'\fR stripping
from relationship names.
.Sp
In general, there is very little difference between v5 and v6 schemas.
.IP "v7" 4
.IX Item "v7"
This mode is identical to \f(CW\*(C`v6\*(C'\fR mode, except that monikerization of CamelCase
table names is also done better (but best in v8.)
.Sp
CamelCase column names in case-preserving mode will also be handled better
for relationship name inflection (but best in v8.) See \*(L"preserve_case\*(R".
.Sp
In this mode, CamelCase \*(L"column_accessors\*(R" are normalized based on case
transition instead of just being lowercased, so \f(CW\*(C`FooId\*(C'\fR becomes \f(CW\*(C`foo_id\*(C'\fR.
.IP "v8" 4
.IX Item "v8"
(\s-1EXPERIMENTAL\s0)
.Sp
The default mode is \*(L"v7\*(R", to get \*(L"v8\*(R" mode, you have to specify it in
\&\*(L"naming\*(R" explictly until \f(CW0.08\fR comes out.
.Sp
\&\*(L"monikers\*(R" and \*(L"column_accessors\*(R" are created using
String::ToIdentifier::EN::Unicode or String::ToIdentifier::EN if
\&\*(L"force_ascii\*(R" is set; this is only significant for names with non\-\f(CW\*(C`\ew\*(C'\fR
characters such as \f(CW\*(C`.\*(C'\fR.
.Sp
CamelCase identifiers with words in all caps, e.g. \f(CW\*(C`VLANValidID\*(C'\fR are supported
correctly in this mode.
.Sp
For relationships, belongs_to accessors are made from column names by stripping
postfixes other than \f(CW\*(C`_id\*(C'\fR as well, for example just \f(CW\*(C`Id\*(C'\fR, \f(CW\*(C`_?ref\*(C'\fR, \f(CW\*(C`_?cd\*(C'\fR,
\&\f(CW\*(C`_?code\*(C'\fR and \f(CW\*(C`_?num\*(C'\fR, case insensitively.
.IP "preserve" 4
.IX Item "preserve"
For \*(L"monikers\*(R", this option does not inflect the table names but makes
monikers based on the actual name. For \*(L"column_accessors\*(R" this option does
not normalize CamelCase column names to lowercase column accessors, but makes
accessors that are the same names as the columns (with any non\-\ew chars
replaced with underscores.)
.IP "singular" 4
.IX Item "singular"
For \*(L"monikers\*(R", singularizes the names using the most current inflector. This
is the same as setting the option to \*(L"current\*(R".
.IP "plural" 4
.IX Item "plural"
For \*(L"monikers\*(R", pluralizes the names, using the most current inflector.
.PP
Dynamic schemas will always default to the 0.04XXX relationship names and won't
singularize Results for backward compatibility, to activate the new RelBuilder
and singularization put this in your \f(CW\*(C`Schema.pm\*(C'\fR file:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqcurrent\*(Aq);
.Ve
.PP
Or if you prefer to use 0.07XXX features but insure that nothing breaks in the
next major version upgrade:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqv7\*(Aq);
.Ve
.SS "quiet"
.IX Subsection "quiet"
If true, will not print the usual \f(CW\*(C`Dumping manual schema ... Schema dump
completed.\*(C'\fR messages. Does not affect warnings (except for warnings related to
\&\*(L"really_erase_my_files\*(R".)
.SS "generate_pod"
.IX Subsection "generate_pod"
By default \s-1POD\s0 will be generated for columns and relationships, using database
metadata for the text if available and supported.
.PP
Comment metadata can be stored in two ways.
.PP
The first is that you can create two tables named \f(CW\*(C`table_comments\*(C'\fR and
\&\f(CW\*(C`column_comments\*(C'\fR respectively. These tables must exist in the same database
and schema as the tables they describe. They both need to have columns named
\&\f(CW\*(C`table_name\*(C'\fR and \f(CW\*(C`comment_text\*(C'\fR. The second one needs to have a column named
\&\f(CW\*(C`column_name\*(C'\fR. Then data stored in these tables will be used as a source of
metadata about tables and comments.
.PP
(If you wish you can change the name of these tables with the parameters
\&\*(L"table_comments_table\*(R" and \*(L"column_comments_table\*(R".)
.PP
As a fallback you can use built-in commenting mechanisms.  Currently this is
only supported for PostgreSQL, Oracle and MySQL.  To create comments in
PostgreSQL you add statements of the form \f(CW\*(C`COMMENT ON TABLE some_table IS
\&\*(Aq...\*(Aq\*(C'\fR, the same syntax is used in Oracle. To create comments in MySQL you add
\&\f(CW\*(C`COMMENT \*(Aq...\*(Aq\*(C'\fR to the end of the column or table definition.  Note that MySQL
restricts the length of comments, and also does not handle complex Unicode
characters properly.
.PP
Set this to \f(CW0\fR to turn off all \s-1POD\s0 generation.
.SS "pod_comment_mode"
.IX Subsection "pod_comment_mode"
Controls where table comments appear in the generated \s-1POD\s0. Smaller table
comments are appended to the \f(CW\*(C`NAME\*(C'\fR section of the documentation, and larger
ones are inserted into \f(CW\*(C`DESCRIPTION\*(C'\fR instead. You can force a \f(CW\*(C`DESCRIPTION\*(C'\fR
section to be generated with the comment always, only use \f(CW\*(C`NAME\*(C'\fR, or choose
the length threshold at which the comment is forced into the description.
.IP "name" 4
.IX Item "name"
Use \f(CW\*(C`NAME\*(C'\fR section only.
.IP "description" 4
.IX Item "description"
Force \f(CW\*(C`DESCRIPTION\*(C'\fR always.
.IP "auto" 4
.IX Item "auto"
Use \f(CW\*(C`DESCRIPTION\*(C'\fR if length > \*(L"pod_comment_spillover_length\*(R", this is the
default.
.SS "pod_comment_spillover_length"
.IX Subsection "pod_comment_spillover_length"
When pod_comment_mode is set to \f(CW\*(C`auto\*(C'\fR, this is the length of the comment at
which it will be forced into a separate description section.
.PP
The default is \f(CW60\fR
.SS "table_comments_table"
.IX Subsection "table_comments_table"
The table to look for comments about tables in.  By default \f(CW\*(C`table_comments\*(C'\fR.
See \*(L"generate_pod\*(R" for details.
.PP
This must not be a fully qualified name, the table will be looked for in the
same database and schema as the table whose comment is being retrieved.
.SS "column_comments_table"
.IX Subsection "column_comments_table"
The table to look for comments about columns in.  By default \f(CW\*(C`column_comments\*(C'\fR.
See \*(L"generate_pod\*(R" for details.
.PP
This must not be a fully qualified name, the table will be looked for in the
same database and schema as the table/column whose comment is being retrieved.
.SS "relationship_attrs"
.IX Subsection "relationship_attrs"
Hashref of attributes to pass to each generated relationship, listed
by type.  Also supports relationship type 'all', containing options to
pass to all generated relationships.  Attributes set for more specific
relationship types override those set in 'all'.
.PP
For example:
.PP
.Vb 3
\&  relationship_attrs => {
\&    belongs_to => { is_deferrable => 0 },
\&  },
.Ve
.PP
use this to turn off \s-1DEFERRABLE\s0 on your foreign key constraints.
.SS "debug"
.IX Subsection "debug"
If set to true, each constructive DBIx::Class statement the loader
decides to execute will be \f(CW\*(C`warn\*(C'\fR\-ed before execution.
.SS "db_schema"
.IX Subsection "db_schema"
Set the name of the schema to load (schema in the sense that your database
vendor means it).
.PP
Can be set to an arrayref of schema names for multiple schemas, or the special
value \f(CW\*(C`%\*(C'\fR for all schemas.
.PP
For \s-1MSSQL\s0, Sybase \s-1ASE\s0, and Informix can be set to a hashref of databases as
keys and arrays of owners as values, set to the value:
.PP
.Vb 1
\&    { \*(Aq%\*(Aq => \*(Aq%\*(Aq }
.Ve
.PP
for all owners in all databases.
.PP
Name clashes resulting from the same table name in different databases/schemas
will be resolved automatically by prefixing the moniker with the database
and/or schema.
.PP
To prefix/suffix all monikers with the database and/or schema, see
\&\*(L"moniker_parts\*(R".
.SS "moniker_parts"
.IX Subsection "moniker_parts"
The database table names are represented by the
DBIx::Class::Schema::Loader::Table class in the loader, the
DBIx::Class::Schema::Loader::Table::Sybase class for Sybase \s-1ASE\s0 and
DBIx::Class::Schema::Loader::Table::Informix for Informix.
.PP
Monikers are created normally based on just the
name property, corresponding to
the table name, but can consist of other parts of the fully qualified name of
the table.
.PP
The \*(L"moniker_parts\*(R" option is an arrayref of methods on the table class
corresponding to parts of the fully qualified table name, defaulting to
\&\f(CW\*(C`[\*(Aqname\*(Aq]\*(C'\fR, in the order those parts are used to create the moniker name.
.PP
The \f(CW\*(Aqname\*(Aq\fR entry \fBmust\fR be present.
.PP
Below is a table of supported databases and possible \*(L"moniker_parts\*(R".
.IP "\(bu" 4
\&\s-1DB2\s0, Firebird, mysql, Oracle, Pg, SQLAnywhere, SQLite, \s-1MS\s0 Access
.Sp
\&\f(CW\*(C`schema\*(C'\fR, \f(CW\*(C`name\*(C'\fR
.IP "\(bu" 4
Informix, \s-1MSSQL\s0, Sybase \s-1ASE\s0
.Sp
\&\f(CW\*(C`database\*(C'\fR, \f(CW\*(C`schema\*(C'\fR, \f(CW\*(C`name\*(C'\fR
.SS "constraint"
.IX Subsection "constraint"
Only load tables matching regex.  Best specified as a qr// regex.
.SS "exclude"
.IX Subsection "exclude"
Exclude tables matching regex.  Best specified as a qr// regex.
.SS "moniker_map"
.IX Subsection "moniker_map"
Overrides the default table name to moniker translation.  Can be either a
hashref of table keys and moniker values, or a coderef for a translator
function taking a table object argument
(which stringifies to the unqualified table name) and returning a scalar
moniker.  If the hash entry does not exist, or the function returns a false
value, the code falls back to default behavior for that table name.
.PP
The default behavior is to split on case transition and non-alphanumeric
boundaries, singularize the resulting phrase, then join the titlecased words
together. Examples:
.PP
.Vb 7
\&    Table Name       | Moniker Name
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    luser            | Luser
\&    luser_group      | LuserGroup
\&    luser\-opts       | LuserOpt
\&    stations_visited | StationVisited
\&    routeChange      | RouteChange
.Ve
.SS "col_accessor_map"
.IX Subsection "col_accessor_map"
Same as moniker_map, but for column accessor names.  If a coderef is
passed, the code is called with arguments of
.PP
.Vb 10
\&   the name of the column in the underlying database,
\&   default accessor name that DBICSL would ordinarily give this column,
\&   {
\&      table_class     => name of the DBIC class we are building,
\&      table_moniker   => calculated moniker for this table (after moniker_map if present),
\&      table           => table object of interface DBIx::Class::Schema::Loader::Table,
\&      full_table_name => schema\-qualified name of the database table (RDBMS specific),
\&      schema_class    => name of the schema class we are building,
\&      column_info     => hashref of column info (data_type, is_nullable, etc),
\&   }
.Ve
.PP
the table object stringifies to the
unqualified table name.
.SS "rel_name_map"
.IX Subsection "rel_name_map"
Similar in idea to moniker_map, but different in the details.  It can be
a hashref or a code ref.
.PP
If it is a hashref, keys can be either the default relationship name, or the
moniker. The keys that are the default relationship name should map to the
name you want to change the relationship to. Keys that are monikers should map
to hashes mapping relationship names to their translation.  You can do both at
once, and the more specific moniker version will be picked up first.  So, for
instance, you could have
.PP
.Vb 6
\&    {
\&        bar => "baz",
\&        Foo => {
\&            bar => "blat",
\&        },
\&    }
.Ve
.PP
and relationships that would have been named \f(CW\*(C`bar\*(C'\fR will now be named \f(CW\*(C`baz\*(C'\fR
except that in the table whose moniker is \f(CW\*(C`Foo\*(C'\fR it will be named \f(CW\*(C`blat\*(C'\fR.
.PP
If it is a coderef, the argument passed will be a hashref of this form:
.PP
.Vb 10
\&    {
\&        name           => default relationship name,
\&        type           => the relationship type eg: C<has_many>,
\&        local_class    => name of the DBIC class we are building,
\&        local_moniker  => moniker of the DBIC class we are building,
\&        local_columns  => columns in this table in the relationship,
\&        remote_class   => name of the DBIC class we are related to,
\&        remote_moniker => moniker of the DBIC class we are related to,
\&        remote_columns => columns in the other table in the relationship,
\&    }
.Ve
.PP
\&\s-1DBICSL\s0 will try to use the value returned as the relationship name.
.SS "inflect_plural"
.IX Subsection "inflect_plural"
Just like \*(L"moniker_map\*(R" above (can be hash/code\-ref, falls back to default
if hash key does not exist or coderef returns false), but acts as a map
for pluralizing relationship names.  The default behavior is to utilize
\&\*(L"to_PL\*(R" in Lingua::EN::Inflect::Phrase.
.SS "inflect_singular"
.IX Subsection "inflect_singular"
As \*(L"inflect_plural\*(R" above, but for singularizing relationship names.
Default behavior is to utilize \*(L"to_S\*(R" in Lingua::EN::Inflect::Phrase.
.SS "schema_base_class"
.IX Subsection "schema_base_class"
Base class for your schema classes. Defaults to 'DBIx::Class::Schema'.
.SS "schema_components"
.IX Subsection "schema_components"
List of components to load into the Schema class.
.SS "result_base_class"
.IX Subsection "result_base_class"
Base class for your table classes (aka result classes). Defaults to
\&'DBIx::Class::Core'.
.SS "additional_base_classes"
.IX Subsection "additional_base_classes"
List of additional base classes all of your table classes will use.
.SS "left_base_classes"
.IX Subsection "left_base_classes"
List of additional base classes all of your table classes will use
that need to be leftmost.
.SS "additional_classes"
.IX Subsection "additional_classes"
List of additional classes which all of your table classes will use.
.SS "components"
.IX Subsection "components"
List of additional components to be loaded into all of your Result
classes.  A good example would be
InflateColumn::DateTime
.SS "result_components_map"
.IX Subsection "result_components_map"
A hashref of moniker keys and component values.  Unlike \*(L"components\*(R", which
loads the given components into every Result class, this option allows you to
load certain components for specified Result classes. For example:
.PP
.Vb 7
\&  result_components_map => {
\&      StationVisited => \*(Aq+YourApp::Schema::Component::StationVisited\*(Aq,
\&      RouteChange    => [
\&                            \*(Aq+YourApp::Schema::Component::RouteChange\*(Aq,
\&                            \*(AqInflateColumn::DateTime\*(Aq,
\&                        ],
\&  }
.Ve
.PP
You may use this in conjunction with \*(L"components\*(R".
.SS "result_roles"
.IX Subsection "result_roles"
List of Moose roles to be applied to all of your Result classes.
.SS "result_roles_map"
.IX Subsection "result_roles_map"
A hashref of moniker keys and role values.  Unlike \*(L"result_roles\*(R", which
applies the given roles to every Result class, this option allows you to apply
certain roles for specified Result classes. For example:
.PP
.Vb 7
\&  result_roles_map => {
\&      StationVisited => [
\&                            \*(AqYourApp::Role::Building\*(Aq,
\&                            \*(AqYourApp::Role::Destination\*(Aq,
\&                        ],
\&      RouteChange    => \*(AqYourApp::Role::TripEvent\*(Aq,
\&  }
.Ve
.PP
You may use this in conjunction with \*(L"result_roles\*(R".
.SS "use_namespaces"
.IX Subsection "use_namespaces"
This is now the default, to go back to \*(L"load_classes\*(R" in DBIx::Class::Schema pass
a \f(CW0\fR.
.PP
Generate result class names suitable for
\&\*(L"load_namespaces\*(R" in DBIx::Class::Schema and call that instead of
\&\*(L"load_classes\*(R" in DBIx::Class::Schema. When using this option you can also
specify any of the options for \f(CW\*(C`load_namespaces\*(C'\fR (i.e. \f(CW\*(C`result_namespace\*(C'\fR,
\&\f(CW\*(C`resultset_namespace\*(C'\fR, \f(CW\*(C`default_resultset_class\*(C'\fR), and they will be added
to the call (and the generated result class names adjusted appropriately).
.SS "dump_directory"
.IX Subsection "dump_directory"
The value of this option is a perl libdir pathname.  Within
that directory this module will create a baseline manual
DBIx::Class::Schema module set, based on what it creates at runtime.
.PP
The created schema class will have the same classname as the one on
which you are setting this option (and the ResultSource classes will be
based on this name as well).
.PP
Normally you wouldn't hard-code this setting in your schema class, as it
is meant for one-time manual usage.
.PP
See \*(L"dump_to_dir\*(R" in DBIx::Class::Schema::Loader for examples of the
recommended way to access this functionality.
.SS "dump_overwrite"
.IX Subsection "dump_overwrite"
Deprecated.  See \*(L"really_erase_my_files\*(R" below, which does *not* mean
the same thing as the old \f(CW\*(C`dump_overwrite\*(C'\fR setting from previous releases.
.SS "really_erase_my_files"
.IX Subsection "really_erase_my_files"
Default false.  If true, Loader will unconditionally delete any existing
files before creating the new ones from scratch when dumping a schema to disk.
.PP
The default behavior is instead to only replace the top portion of the
file, up to and including the final stanza which contains
\&\f(CW\*(C`# DO NOT MODIFY THE FIRST PART OF THIS FILE\*(C'\fR
leaving any customizations you placed after that as they were.
.PP
When \f(CW\*(C`really_erase_my_files\*(C'\fR is not set, if the output file already exists,
but the aforementioned final stanza is not found, or the checksum
contained there does not match the generated contents, Loader will
croak and not touch the file.
.PP
You should really be using version control on your schema classes (and all
of the rest of your code for that matter).  Don't blame me if a bug in this
code wipes something out when it shouldn't have, you've been warned.
.SS "overwrite_modifications"
.IX Subsection "overwrite_modifications"
Default false.  If false, when updating existing files, Loader will
refuse to modify any Loader-generated code that has been modified
since its last run (as determined by the checksum Loader put in its
comment lines).
.PP
If true, Loader will discard any manual modifications that have been
made to Loader-generated code.
.PP
Again, you should be using version control on your schema classes.  Be
careful with this option.
.SS "custom_column_info"
.IX Subsection "custom_column_info"
Hook for adding extra attributes to the
column_info for a column.
.PP
Must be a coderef that returns a hashref with the extra attributes.
.PP
Receives the table object (which
stringifies to the unqualified table name), column name and column_info.
.PP
For example:
.PP
.Vb 2
\&  custom_column_info => sub {
\&      my ($table, $column_name, $column_info) = @_;
\&
\&      if ($column_name eq \*(Aqdog\*(Aq && $column_info\->{default_value} eq \*(Aqsnoopy\*(Aq) {
\&          return { is_snoopy => 1 };
\&      }
\&  },
.Ve
.PP
This attribute can also be used to set \f(CW\*(C`inflate_datetime\*(C'\fR on a non-datetime
column so it also receives the \*(L"datetime_timezone\*(R" and/or \*(L"datetime_locale\*(R".
.SS "datetime_timezone"
.IX Subsection "datetime_timezone"
Sets the timezone attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the \s-1DATE/DATETIME/TIMESTAMP\s0 data_types.
.SS "datetime_locale"
.IX Subsection "datetime_locale"
Sets the locale attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the \s-1DATE/DATETIME/TIMESTAMP\s0 data_types.
.SS "datetime_undef_if_invalid"
.IX Subsection "datetime_undef_if_invalid"
Pass a \f(CW0\fR for this option when using MySQL if you \fB\s-1DON\s0'T\fR want \f(CW\*(C`datetime_undef_if_invalid => 1\*(C'\fR in your column info for \s-1DATE\s0, \s-1DATETIME\s0 and
\&\s-1TIMESTAMP\s0 columns.
.PP
The default is recommended to deal with data such as \f(CW\*(C`00/00/00\*(C'\fR which
sometimes ends up in such columns in MySQL.
.SS "config_file"
.IX Subsection "config_file"
File in Perl format, which should return a \s-1HASH\s0 reference, from which to read
loader options.
.SS "preserve_case"
.IX Subsection "preserve_case"
Normally database names are lowercased and split by underscore, use this option
if you have CamelCase database names.
.PP
Drivers for case sensitive databases like Sybase \s-1ASE\s0 or \s-1MSSQL\s0 with a
case-sensitive collation will turn this option on unconditionally.
.PP
\&\fB\s-1NOTE:\s0\fR \*(L"naming\*(R" = \f(CW\*(C`v8\*(C'\fR is highly recommended with this option as the
semantics of this mode are much improved for CamelCase database names.
.PP
\&\*(L"naming\*(R" = \f(CW\*(C`v7\*(C'\fR or greater is required with this option.
.SS "qualify_objects"
.IX Subsection "qualify_objects"
Set to true to prepend the \*(L"db_schema\*(R" to table names for \f(CW\*(C`_\|_PACKAGE_\|_\->table\*(C'\fR calls, and to some other things like Oracle sequences.
.PP
This attribute is automatically set to true for multi db_schema configurations.
.SS "use_moose"
.IX Subsection "use_moose"
Creates Schema and Result classes that use Moose, MooseX::NonMoose and
MooseX::MarkAsMethods (or namespace::autoclean, see below). The default
content after the md5 sum also makes the classes immutable.
.PP
It is safe to upgrade your existing Schema to this option.
.SS "only_autoclean"
.IX Subsection "only_autoclean"
By default, we use MooseX::MarkAsMethods to remove imported functions from
your generated classes.  It uses namespace::autoclean to do this, after
telling your object's metaclass that any operator overloads in your class
are methods, which will cause namespace::autoclean to spare them from removal.
.PP
This prevents the \*(L"Hey, where'd my overloads go?!\*(R" effect.
.PP
If you don't care about operator overloads, enabling this option falls back to
just using namespace::autoclean itself.
.PP
If none of the above made any sense, or you don't have some pressing need to
only use namespace::autoclean, leaving this set to the default is
recommended.
.SS "col_collision_map"
.IX Subsection "col_collision_map"
This option controls how accessors for column names which collide with perl
methods are named. See \*(L"\s-1COLUMN\s0 \s-1ACCESSOR\s0 \s-1COLLISIONS\s0\*(R" for more information.
.PP
This option takes either a single sprintf format or a hashref of
strings which are compiled to regular expressions that map to
sprintf formats.
.PP
Examples:
.PP
.Vb 1
\&    col_collision_map => \*(Aqcolumn_%s\*(Aq
\&
\&    col_collision_map => { \*(Aq(.*)\*(Aq => \*(Aqcolumn_%s\*(Aq }
\&
\&    col_collision_map => { \*(Aq(foo).*(bar)\*(Aq => \*(Aqcolumn_%s_%s\*(Aq }
.Ve
.SS "rel_collision_map"
.IX Subsection "rel_collision_map"
Works just like \*(L"col_collision_map\*(R", but for relationship names/accessors
rather than column names/accessors.
.PP
The default is to just append \f(CW\*(C`_rel\*(C'\fR to the relationship name, see
\&\*(L"\s-1RELATIONSHIP\s0 \s-1NAME\s0 \s-1COLLISIONS\s0\*(R".
.SS "uniq_to_primary"
.IX Subsection "uniq_to_primary"
Automatically promotes the largest unique constraints with non-nullable columns
on tables to primary keys, assuming there is only one largest unique
constraint.
.SS "filter_generated_code"
.IX Subsection "filter_generated_code"
An optional hook that lets you filter the generated text for various classes
through a function that change it in any way that you want.  The function will
receive the type of file, \f(CW\*(C`schema\*(C'\fR or \f(CW\*(C`result\*(C'\fR, class and code; and returns
the new code to use instead.  For instance you could add custom comments, or do
anything else that you want.
.PP
The option can also be set to a string, which is then used as a filter program,
e.g. \f(CW\*(C`perltidy\*(C'\fR.
.PP
If this exists but fails to return text matching \f(CW\*(C`/\ebpackage\eb/\*(C'\fR, no file will
be generated.
.PP
.Vb 5
\&    filter_generated_code => sub {
\&        my ($type, $class, $text) = @_;
\&        ...
\&        return $new_code;
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
None of these methods are intended for direct invocation by regular
users of DBIx::Class::Schema::Loader. Some are proxied via
DBIx::Class::Schema::Loader.
.SS "new"
.IX Subsection "new"
Constructor for DBIx::Class::Schema::Loader::Base, used internally
by DBIx::Class::Schema::Loader.
.SS "load"
.IX Subsection "load"
Does the actual schema-construction work.
.SS "rescan"
.IX Subsection "rescan"
Arguments: schema
.PP
Rescan the database for changes. Returns a list of the newly added table
monikers.
.PP
The schema argument should be the schema class or object to be affected.  It
should probably be derived from the original schema_class used during \*(L"load\*(R".
.SS "get_dump_filename"
.IX Subsection "get_dump_filename"
Arguments: class
.PP
Returns the full path to the file for a class that the class has been or will
be dumped to. This is a file in a temp dir for a dynamic schema.
.SS "tables"
.IX Subsection "tables"
Returns a sorted list of loaded tables, using the original database table
names.
.ie n .SH "BASE CLASS: $base_class"
.el .SH "BASE CLASS: \f(CW$base_class\fP"
.IX Header "BASE CLASS: $base_class"
.SS "monikers"
.IX Subsection "monikers"
Returns a hashref of loaded table to moniker mappings.  There will
be two entries for each table, the original name and the \*(L"normalized\*(R"
name, in the case that the two are different (such as databases
that like uppercase table names, or preserve your original mixed-case
definitions, or what-have-you).
.SS "classes"
.IX Subsection "classes"
Returns a hashref of table to class mappings.  In some cases it will
contain multiple entries per table for the original and normalized table
names, as above in \*(L"monikers\*(R".
.SH "NON-ENGLISH DATABASES"
.IX Header "NON-ENGLISH DATABASES"
If you use the loader on a database with table and column names in a language
other than English, you will want to turn off the English language specific
heuristics.
.PP
To do so, use something like this in your loader options:
.PP
.Vb 3
\&    naming           => { monikers => \*(Aqv4\*(Aq },
\&    inflect_singular => sub { "$_[0]_rel" },
\&    inflect_plural   => sub { "$_[0]_rel" },
.Ve
.SH "COLUMN ACCESSOR COLLISIONS"
.IX Header "COLUMN ACCESSOR COLLISIONS"
Occasionally you may have a column name that collides with a perl method, such
as \f(CW\*(C`can\*(C'\fR. In such cases, the default action is to set the \f(CW\*(C`accessor\*(C'\fR of the
column spec to \f(CW\*(C`undef\*(C'\fR.
.PP
You can then name the accessor yourself by placing code such as the following
below the md5:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->add_column(\*(Aq+can\*(Aq => { accessor => \*(Aqmy_can\*(Aq });
.Ve
.PP
Another option is to use the \*(L"col_collision_map\*(R" option.
.SH "RELATIONSHIP NAME COLLISIONS"
.IX Header "RELATIONSHIP NAME COLLISIONS"
In very rare cases, you may get a collision between a generated relationship
name and a method in your Result class, for example if you have a foreign key
called \f(CW\*(C`belongs_to\*(C'\fR.
.PP
This is a problem because relationship names are also relationship accessor
methods in DBIx::Class.
.PP
The default behavior is to append \f(CW\*(C`_rel\*(C'\fR to the relationship name and print
out a warning that refers to this text.
.PP
You can also control the renaming with the \*(L"rel_collision_map\*(R" option.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class::Schema::Loader, dbicdump
.SH "AUTHOR"
.IX Header "AUTHOR"
See \*(L"\s-1AUTHOR\s0\*(R" in DBIx::Class::Schema::Loader and \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class::Schema::Loader.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
