.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader::Optional::Dependencies 3"
.TH DBIx::Class::Schema::Loader::Optional::Dependencies 3 "2012-02-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema::Loader::Optional::Dependencies \- Optional module dependency specifications (for module authors)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Somewhere in your build-file (e.g. Module::Install's Makefile.PL):
.PP
.Vb 1
\&  ...
\&
\&  configure_requires \*(AqDBIx::Class::Schema::Loader\*(Aq => \*(Aq0.07017\*(Aq;
\&
\&  require DBIx::Class::Schema::Loader::Optional::Dependencies;
\&
\&  my $use_moose_deps = DBIx::Class::Schema::Loader::Optional::Dependencies\->req_list_for (\*(Aquse_moose\*(Aq);
\&
\&  for (keys %$use_moose_deps) {
\&    requires $_ => $use_moose_deps\->{$_};
\&  }
\&
\&  ...
.Ve
.PP
Note that there are some caveats regarding \f(CW\*(C`configure_requires()\*(C'\fR, more info
can be found at \*(L"configure_requires\*(R" in Module::Install
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Some of the features of DBIx::Class::Schema::Loader have external
module dependencies on their own. In order not to burden the average user
with modules he will never use, these optional dependencies are not included
in the base Makefile.PL. Instead an exception with a descriptive message is
thrown when a specific feature is missing one or several modules required for
its operation. This module is the central holding place for  the current list
of such dependencies.
.SH "CURRENT REQUIREMENT GROUPS"
.IX Header "CURRENT REQUIREMENT GROUPS"
Dependencies are organized in \f(CW\*(C`groups\*(C'\fR and each group can list one or more
required modules, with an optional minimum version (or 0 for any version).
.SS "dbicdump config file"
.IX Subsection "dbicdump config file"
Modules required for using a config file with dbicdump
.IP "\(bu" 4
Config::Any
.PP
Requirement group: \fBdbicdump_config\fR
.SS "dbicdump config file testing"
.IX Subsection "dbicdump config file testing"
Modules required for using testing using a config file with dbicdump
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::General
.PP
Requirement group: \fBtest_dbicdump_config\fR
.SS "use_moose"
.IX Subsection "use_moose"
Modules required for the use_moose option
.IP "\(bu" 4
Moose >= 1.12
.IP "\(bu" 4
MooseX::MarkAsMethods >= 0.13
.IP "\(bu" 4
MooseX::NonMoose >= 0.16
.IP "\(bu" 4
namespace::autoclean >= 0.09
.PP
Requirement group: \fBuse_moose\fR
.SH "METHODS"
.IX Header "METHODS"
.SS "req_group_list"
.IX Subsection "req_group_list"
.ie n .IP "Arguments: $none" 4
.el .IP "Arguments: \f(CW$none\fR" 4
.IX Item "Arguments: $none"
.PD 0
.IP "Returns: \e%list_of_requirement_groups" 4
.IX Item "Returns: %list_of_requirement_groups"
.PD
.PP
This method should be used by DBIx::Class packagers, to get a hashref of all
dependencies keyed by dependency group. Each key (group name) can be supplied
to one of the group-specific methods below.
.SS "req_list_for"
.IX Subsection "req_list_for"
.ie n .IP "Arguments: $group_name" 4
.el .IP "Arguments: \f(CW$group_name\fR" 4
.IX Item "Arguments: $group_name"
.PD 0
.IP "Returns: \e%list_of_module_version_pairs" 4
.IX Item "Returns: %list_of_module_version_pairs"
.PD
.PP
This method should be used by DBIx::Class extension authors, to determine the
version of modules a specific feature requires in the \fBcurrent\fR version of
DBIx::Class::Schema::Loader. See the \*(L"\s-1SYNOPSIS\s0\*(R" for a real-world
example.
.SS "req_ok_for"
.IX Subsection "req_ok_for"
.ie n .IP "Arguments: $group_name" 4
.el .IP "Arguments: \f(CW$group_name\fR" 4
.IX Item "Arguments: $group_name"
.PD 0
.IP "Returns: 1|0" 4
.IX Item "Returns: 1|0"
.PD
.PP
Returns true or false depending on whether all modules required by \f(CW$group_name\fR are present on the system and loadable
.SS "req_missing_for"
.IX Subsection "req_missing_for"
.ie n .IP "Arguments: $group_name" 4
.el .IP "Arguments: \f(CW$group_name\fR" 4
.IX Item "Arguments: $group_name"
.PD 0
.ie n .IP "Returns: $error_message_string" 4
.el .IP "Returns: \f(CW$error_message_string\fR" 4
.IX Item "Returns: $error_message_string"
.PD
.PP
Returns a single line string suitable for inclusion in larger error messages.
This method would normally be used by DBIx::Class::Schema::Loader
maintainers, to indicate to the user that he needs to install specific modules
before he will be able to use a specific feature.
.PP
For example if some of the requirements for \f(CW\*(C`use_moose\*(C'\fR are not available,
the returned string could look like:
.PP
.Vb 1
\& Moose >= 0 (see use_moose for details)
.Ve
.PP
The author is expected to prepend the necessary text to this message before
returning the actual error seen by the user.
.SS "req_errorlist_for"
.IX Subsection "req_errorlist_for"
.ie n .IP "Arguments: $group_name" 4
.el .IP "Arguments: \f(CW$group_name\fR" 4
.IX Item "Arguments: $group_name"
.PD 0
.IP "Returns: \e%list_of_loaderrors_per_module" 4
.IX Item "Returns: %list_of_loaderrors_per_module"
.PD
.PP
Returns a hashref containing the actual errors that occured while attempting
to load each module in the requirement group.
.SH "AUTHOR"
.IX Header "AUTHOR"
See \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself
