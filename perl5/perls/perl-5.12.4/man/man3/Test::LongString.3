.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::LongString 3"
.TH Test::LongString 3 "2011-02-06" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::LongString \- tests strings for equality, with more helpful failures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Test::More tests => 1;
\&    use Test::LongString;
\&    like_string( $html, qr/(perl|cpan)\e.org/ );
\&
\&    #     Failed test (html\-test.t at line 12)
\&    #          got: "<!DOCTYPE HTML PUBLIC "\-//W3C//DTD HTML 4.01 Trans"...
\&    #       length: 58930
\&    #     doesn\*(Aqt match \*(Aq(?\-xism:(perl|cpan)\e.org)\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides some drop-in replacements for the string
comparison functions of Test::More, but which are more suitable
when you test against long strings.  If you've ever had to search
for text in a multi-line string like an \s-1HTML\s0 document, or find
specific items in binary data, this is the module for you.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "is_string( $string, $expected [, $label ] )"
.el .SS "is_string( \f(CW$string\fP, \f(CW$expected\fP [, \f(CW$label\fP ] )"
.IX Subsection "is_string( $string, $expected [, $label ] )"
\&\f(CW\*(C`is_string()\*(C'\fR is equivalent to \f(CW\*(C`Test::More::is()\*(C'\fR, but with more
helpful diagnostics in case of failure.
.IP "\(bu" 4
It doesn't print the entire strings in the failure message.
.IP "\(bu" 4
It reports the lengths of the strings that have been compared.
.IP "\(bu" 4
It reports the length of the common prefix of the strings.
.IP "\(bu" 4
It reports the line and column the strings started to differ on.
.IP "\(bu" 4
In the diagnostics, non-ASCII characters are escaped as \f(CW\*(C`\ex{xx}\*(C'\fR.
.PP
For example:
.PP
.Vb 1
\&    is_string( $soliloquy, $juliet );
\&
\&    #     Failed test (soliloquy.t at line 15)
\&    #          got: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #       length: 1490
\&    #     expected: "O Romeo, Romeo,\ex{0a}wherefore art thou Romeo?\ex{0a}Deny thy"...
\&    #       length: 154
\&    #     strings begin to differ at char 1 (line 1 column 1)
.Ve
.ie n .SS "is_string_nows( $string, $expected [, $label ] )"
.el .SS "is_string_nows( \f(CW$string\fP, \f(CW$expected\fP [, \f(CW$label\fP ] )"
.IX Subsection "is_string_nows( $string, $expected [, $label ] )"
Like \f(CW\*(C`is_string()\*(C'\fR, but removes whitepace (in the \f(CW\*(C`\es\*(C'\fR sense) from the
arguments before comparing them.
.ie n .SS "like_string( $string, qr/regex/ [, $label ] )"
.el .SS "like_string( \f(CW$string\fP, qr/regex/ [, \f(CW$label\fP ] )"
.IX Subsection "like_string( $string, qr/regex/ [, $label ] )"
.ie n .SS "unlike_string( $string, qr/regex/ [, $label ] )"
.el .SS "unlike_string( \f(CW$string\fP, qr/regex/ [, \f(CW$label\fP ] )"
.IX Subsection "unlike_string( $string, qr/regex/ [, $label ] )"
\&\f(CW\*(C`like_string()\*(C'\fR and \f(CW\*(C`unlike_string()\*(C'\fR are replacements for
\&\f(CW\*(C`Test::More:like()\*(C'\fR and \f(CW\*(C`unlike()\*(C'\fR that only print the beginning
of the received string in the output.  Unfortunately, they can't
print out the position where the regex failed to match.
.PP
.Vb 1
\&    like_string( $soliloquy, qr/Romeo|Juliet|Mercutio|Tybalt/ );
\&
\&    #     Failed test (soliloquy.t at line 15)
\&    #          got: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #       length: 1490
\&    #     doesn\*(Aqt match \*(Aq(?\-xism:Romeo|Juliet|Mercutio|Tybalt)\*(Aq
.Ve
.ie n .SS "contains_string( $string, $substring [, $label ] )"
.el .SS "contains_string( \f(CW$string\fP, \f(CW$substring\fP [, \f(CW$label\fP ] )"
.IX Subsection "contains_string( $string, $substring [, $label ] )"
\&\f(CW\*(C`contains_string()\*(C'\fR searches for \fI\f(CI$substring\fI\fR in \fI\f(CI$string\fI\fR.  It's
the same as \f(CW\*(C`like_string()\*(C'\fR, except that it's not a regular
expression search.
.PP
.Vb 1
\&    contains_string( $soliloquy, "Romeo" );
\&
\&    #     Failed test (soliloquy.t at line 10)
\&    #         searched: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #   and can\*(Aqt find: "Romeo"
.Ve
.PP
As of version 0.12, \f(CW\*(C`contains_string()\*(C'\fR will also report the Longest Common
SubString (\s-1LCSS\s0) found in \fI\f(CI$string\fI\fR and, if the \s-1LCSS\s0 is short enough, the
surroundings will also be shown under \fI\s-1LCSS\s0 Context\fR. This should help debug
tests for really long strings like \s-1HTML\s0 output, so you'll get something like:
.PP
.Vb 6
\&   contains_string( $html, \*(Aq<div id="MainContent">\*(Aq );
\&   #   Failed test at t/foo.t line 10.
\&   #     searched: "<!DOCTYPE html PUBLIC "\-//W3C//DTD XHTML 1.0 Stric"...
\&   #   can\*(Aqt find: "<div id="MainContent">"
\&   #         LCSS: "ainContent""
\&   # LCSS context: "dolor sit amet</span>\ex{0a}<div id="mainContent" class="
.Ve
.PP
You can turn off \s-1LCSS\s0 reporting by setting \f(CW$Test::LongString::LCSS\fR to 0,
or by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString lcss => 0;
.Ve
.ie n .SS "lacks_string( $string, $substring [, $label ] )"
.el .SS "lacks_string( \f(CW$string\fP, \f(CW$substring\fP [, \f(CW$label\fP ] )"
.IX Subsection "lacks_string( $string, $substring [, $label ] )"
\&\f(CW\*(C`lacks_string()\*(C'\fR makes sure that \fI\f(CI$substring\fI\fR does \s-1NOT\s0 exist in
\&\fI\f(CI$string\fI\fR.  It's the same as \f(CW\*(C`like_string()\*(C'\fR, except that it's not a
regular expression search.
.PP
.Vb 1
\&    lacks_string( $soliloquy, "slings" );
\&
\&    #     Failed test (soliloquy.t at line 10)
\&    #         searched: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #        and found: "slings"
\&    #      at position: 147 (line 3 column 4)
.Ve
.SH "CONTROLLING OUTPUT"
.IX Header "CONTROLLING OUTPUT"
By default, only the first 50 characters of the compared strings
are shown in the failure message.  This value is in
\&\f(CW$Test::LongString::Max\fR, and can be set at run-time.
.PP
You can also set it by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString max => 100;
.Ve
.PP
When the compared strings begin to differ after a large prefix,
Test::LongString will not print them from the beginning, but will start at the
middle, more precisely at \f(CW$Test::LongString::Context\fR characters before the
first difference. By default this value is 10 characters. If you want
Test::LongString to always print the beginning of compared strings no matter
where they differ, undefine \f(CW$Test::LongString::Context\fR.
.PP
When computing line numbers this module uses \*(L"\en\*(R" to count line endings. This
may not be appropriate for strings on your platform, and can be overriden
by setting the \f(CW$Test::LongString::EOL\fR variable to a suitable regular
expression (either a reference to a regular expression or a string that
can be interpolated into a regular expression.)
.PP
You can also set it by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString eol => "\ex{0a}\ex{0c}";
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Rafael Garcia-Suarez. Thanks to Mark Fowler (and to Joss Whedon) for
the inspirational Acme::Test::Buffy. Thanks to Andy Lester for lots of patches.
.PP
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.PP
A git repository for this module is available at
.PP
.Vb 1
\&    git://github.com/rgs/Test\-LongString.git
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder, Test::Builder::Tester, Test::More.
