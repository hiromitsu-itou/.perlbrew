.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Docs::Examples 3"
.TH MakeMethods::Docs::Examples 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Docs::Examples \- Sample Declarations and Usage
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following examples indicate some of the capabilities of
Class::MakeMethods.
.SS "A Contrived Example"
.IX Subsection "A Contrived Example"
Object-oriented Perl code is widespread \*(-- you've probably seen code like the below a million times:
.PP
.Vb 4
\&  my $obj = MyStruct\->new( foo=>"Foozle", bar=>"Bozzle" );
\&  if ( $obj\->foo() =~ /foo/i ) {
\&    $obj\->bar("Barbados!");
\&  }
.Ve
.PP
Here's a possible implementation for the class whose interface is
shown above:
.PP
.Vb 1
\&  package MyStruct;
\&  
\&  sub new {
\&    my $callee = shift;
\&    my $self = bless { @_ }, (ref $callee || $callee);
\&    return $self;
\&  }
\&
\&  sub foo {
\&    my $self = shift;
\&    if ( scalar @_ ) {
\&      $self\->{\*(Aqfoo\*(Aq} = shift();
\&    } else {
\&      $self\->{\*(Aqfoo\*(Aq}
\&    }
\&  }
\&
\&  sub bar {
\&    my $self = shift;
\&    if ( scalar @_ ) {
\&      $self\->{\*(Aqbar\*(Aq} = shift();
\&    } else {
\&      $self\->{\*(Aqbar\*(Aq}
\&    }
\&  }
.Ve
.PP
Class::MakeMethods allows you to simply declare those methods to
be of a predefined type, and it generates and installs the necessary
methods in your package at compile-time.
.PP
Here's the equivalent declaration for that same basic class:
.PP
.Vb 6
\&  package MyStruct;
\&  use Class::MakeMethods::Standard::Hash (
\&    \*(Aqnew\*(Aq       => \*(Aqnew\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqfoo\*(Aq,
\&    \*(Aqscalar\*(Aq    => \*(Aqbar\*(Aq,
\&  );
.Ve
.SS "A Typical Example"
.IX Subsection "A Typical Example"
The following example shows a common case of constructing a class with several types of accessor methods
.PP
.Vb 7
\&  package MyObject;
\&  use Class::MakeMethods::Standard::Hash (
\&    new => \*(Aqnew\*(Aq,
\&    scalar => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ],
\&    array => \*(Aqmy_list\*(Aq,
\&    hash => \*(Aqmy_index\*(Aq,
\&  );
.Ve
.PP
This class now has a constructor named new, two scalar accessors named foo and bar, and a pair of reference accessors named my_list and my_index. Typical usage of the class might include calls like the following:
.PP
.Vb 2
\&  my $obj = MyObject\->new( foo => \*(AqFoozle\*(Aq );
\&  print $obj\->foo();
\&  
\&  $obj\->bar(\*(AqBarbados\*(Aq); 
\&  print $obj\->bar();
\&  
\&  $obj\->my_list(0 => \*(AqFoozle\*(Aq, 1 => \*(AqBang!\*(Aq);
\&  print $obj\->my_list(1);
\&  
\&  $obj\->my_index(\*(Aqbroccoli\*(Aq => \*(AqBlah!\*(Aq, \*(Aqfoo\*(Aq => \*(AqFiddle\*(Aq);
\&  print $obj\->my_index(\*(Aqfoo\*(Aq);
.Ve
.SS "Lvalue Accessors"
.IX Subsection "Lvalue Accessors"
The Template subclasses support an optional \*(L"\-\-lvalue\*(R" modifer that causes your accessors method to be marked as returning an lvalue which can be assigned to. (This feature is only available on Perl 5.6 or later.)
.PP
.Vb 6
\&  package MyStruct;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq                   => \*(Aqnew\*(Aq,
\&    \*(Aqscalar \-\-get \-\-lvalue\*(Aq => \*(Aqfoo\*(Aq,
\&    \*(Aqarray \-\-get \-\-lvalue\*(Aq  => \*(Aqbar\*(Aq,
\&  );
\&
\&  $obj\->foo = "Foozle";
\&  print $obj\->foo;
\&
\&  $obj\->bar = ( \*(Aqbaz\*(Aq, \*(Aqbeep\*(Aq, \*(Aqboop\*(Aq );
\&  print $obj\->bar\->[1]; # beep
.Ve
.SS "String and Numeric Accessors"
.IX Subsection "String and Numeric Accessors"
In addition to the \f(CW\*(C`scalar\*(C'\fR accessor supported by the \f(CW\*(C`Standard::*\*(C'\fR classes, the Template subclasses also provide specialized accessors that can facilitate the use of specific types of data.
.PP
For example, we could declare the following class to hold information
about available Perl packages:
.PP
.Vb 6
\&  package MyVersionInfo;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq     => \*(Aqnew\*(Aq,
\&    \*(Aqstring\*(Aq  => \*(Aqpackage\*(Aq,
\&    \*(Aqnumber\*(Aq  => \*(Aqversion\*(Aq,
\&  );
\&
\&  sub summary {
\&    my $self = shift;
\&    return $self\->package() . " is at version " . $self\->version()
\&  }
.Ve
.PP
You could use this class as follows:
.PP
.Vb 2
\&  package main;
\&  use MyVersionInfo;
\&  
\&  my $obj = MyVersionInfo\->new( package=>"Class::MakeMethods");
\&  $obj\->version( 2.0 );
\&  print $obj\->summary();
.Ve
.PP
These accessors will provide a bit of diagnostic type checking;
an attempt to call \f(CW\*(C`$obj\->version("foo")\*(C'\fR will cause your
program to croak.
.SS "String Concatenation Interface"
.IX Subsection "String Concatenation Interface"
The following defines a get_concat method \f(CW\*(C`i\*(C'\fR, and specifies
a string to use when joining additional values when this method is
called.
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqstring\*(Aq => [ \*(Aq\-\-get_concat\*(Aq, \*(Aqi\*(Aq, { join => \*(Aq \- \*(Aq } ];
.Ve
.PP
(See Class::MakeMethods::Template::Generic for information about the \f(CW\*(C`string\*(C'\fR \f(CW\*(C`get_concat\*(C'\fR interface.)
.SS "Access Control Example"
.IX Subsection "Access Control Example"
The following defines a secret_password method, which will croak
if it is called from outside of the declaring package.
.PP
.Vb 2
\&  use Class::MakeMethods::Composite::Hash
\&    \*(Aqscalar\*(Aq => [ \*(Aqsecret_password\*(Aq => { permit => \*(Aqpp\*(Aq } ];
.Ve
.PP
(See Class::MakeMethods::Composite for information
about the \f(CW\*(C`permit\*(C'\fR modifier.)
.PP
For template classes, the same thing is accomplished with '\-\-private':
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [ \*(Aq\-\-private\*(Aq, \*(Aqsecret_password\*(Aq ];
.Ve
.PP
(See Class::MakeMethods::Template::Universal for information
about the \f(CW\*(C`private\*(C'\fR modifier.)
.SS "Lazy-Init Interface"
.IX Subsection "Lazy-Init Interface"
Templapte scalar accessors declared with the \*(L"init_and_get\*(R" interface
can be used for \*(L"memoization\*(R" or lazy-evaluation for object
attributes. If the current accessor value is undefined, they will
first call a user-provided init_* method and save its value.
.PP
.Vb 5
\&  package MyWidget;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew \-\-with_values\*(Aq => [ \*(Aqnew\*(Aq ],
\&    \*(Aqscalar \-\-init_and_get\*(Aq => [ \*(Aqfoo\*(Aq, \*(Aqcount\*(Aq, \*(Aqresult\*(Aq ],
\&  );
\&  
\&  sub init_foo { 
\&    return \*(Aqfoofle\*(Aq;
\&  }
\&  
\&  sub init_count {
\&    return \*(Aq3\*(Aq;
\&  }
\&  
\&  sub init_result {
\&    my $self = shift;
\&    return $self\->foo x $self\->count;
\&  }
\&  ...
\&  
\&  my $widget = MyWidget\->new();
\&  print $widget\->result; # output: fooflefooflefoofle
\&  
\&  # if values are predefined, the init methods are not used
\&  my $other_widget = MyWidget\->new( foo => \*(Aqbar\*(Aq, count => 2 );
\&  print $widget\->result; # output: barbar
.Ve
.PP
(See Class::MakeMethods::Template::Generic for more information about
\&\f(CW\*(C`init_and_get\*(C'\fR. This interface is also supported by all of Generic's
subclasses, so you can add lazy-init methods for global data, class
data, array objects, etc. Unfortunately, to date it is only supported
for scalar-value accessors...)
.SS "Helper Methods"
.IX Subsection "Helper Methods"
Template methods often include similarly-named \*(L"helper\*(R" methods. For example, specifying the \*(L"\-\-with_clear\*(R" interface for Template::*:scalar methods creates an extra method for each accessor x named clear_x.
.PP
.Vb 2
\&  package MyClass;
\&  use Class::MakeMethods::Template::Hash(\*(Aqscalar \-\-with_clear\*(Aq => \*(Aqfoo\*(Aq);
\&
\&  my $obj = MyClass\->new;
\&  $obj\->foo(23);
\&  $obj\->clear_foo;
\&  print $obj\->foo();
.Ve
.SS "Reference Accessor and Helper Methods"
.IX Subsection "Reference Accessor and Helper Methods"
For references to arrays and hashes, the Template subclasses provide
accessors with extra \*(L"helper methods\*(R" to facilitate method-based
interaction.
.PP
Here's a class whose instances each store a string and an array
reference, along with a method to search the directories:
.PP
.Vb 6
\&  package MySearchPath;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq     => \*(Aqnew\*(Aq,
\&    \*(Aqstring\*(Aq  => \*(Aqname\*(Aq,
\&    \*(Aqarray\*(Aq   => \*(Aqdirectories\*(Aq,
\&  );
\&  
\&  sub search {
\&    my $self = shift; 
\&    my $target = shift;
\&    foreach my $dir ( $self\->directories ) {
\&      my $candidate = $dir . \*(Aq/\*(Aq . $target;
\&      return $candidate if ( \-e $candidate );
\&    }
\&    return;
\&  }
.Ve
.PP
Note that the directories accessor returns the contents of the
array when called in a list context, making it easier to loop over.
.PP
And here's a sample usage:
.PP
.Vb 2
\&  package main;
\&  use MySearchPath;
\&  
\&  my $libs = MySearchPath\->new( name=>"libs", directories=>[\*(Aq/usr/lib\*(Aq] );
\&  $libs\->push_directories( \*(Aq/usr/local/lib\*(Aq );
\&  
\&  print "Searching in " . $libs\->count_directories() . "directories.\en";
\&  foreach ( \*(Aqlibtiff\*(Aq, \*(Aqlibjpeg\*(Aq ) {
\&    my $file = $libs\->search("$_.so"); 
\&    print "Checking $_: " . ( $file || \*(Aqnot found\*(Aq ) . "\en";
\&  }
.Ve
.PP
Note the use of the push_* and count_* \*(L"helper\*(R" accessor methods,
which are defined by default for all 'Template::*:array' declarations.
.PP
Consult Class::MakeMethods::Template::Generic for more information about
the available types of reference accessors, and the various methods
they define.
.SS "Object Accessors"
.IX Subsection "Object Accessors"
There's also a specialized accessor for object references:
.PP
.Vb 5
\&  package MyStruct;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq    => \*(Aqnew\*(Aq,
\&    \*(Aqobject\*(Aq => [ \*(Aqwidget\*(Aq => {class=>\*(AqMyWidgetClass\*(Aq, delegate=>"twiddle"} ],
\&  );
.Ve
.PP
(Note that the \f(CW\*(C`class\*(C'\fR and \f(CW\*(C`delegate\*(C'\fR values specified above are
method parameters, which provide additional information about the
\&\f(CW\*(C`widget\*(C'\fR declaration; see \*(L"Standard Declaration Syntax\*(R" for more information.)
.PP
The above declaration creates methods equivalent to the following:
.PP
.Vb 1
\&  package MyStruct;
\&
\&  sub widget {
\&    my $self = shift;
\&    if ( scalar @_ ) { 
\&      if (ref $_[0] and UNIVERSAL::isa($_[0], \*(AqMyWidgetClass\*(Aq)) { 
\&        $self\->{widget} = shift;
\&      } else {
\&        $self\->{widget} = MyWidgetClass\->new(@_);
\&      }
\&    } else {
\&      return $self\->{widget};
\&    }
\&  }
\&  
\&  sub clear_widget {
\&    my $self = shift;
\&    $self\->{widget} = undef;
\&  }
\&  
\&  sub twiddle { 
\&    my $self = shift;
\&    my $obj = $self\->widget() 
\&      or Carp::croak("Can\*(Aqt forward twiddle because widget is empty");
\&    $obj\->twiddle(@_) 
\&  }
.Ve
.SS "Mixing Object and Global Methods"
.IX Subsection "Mixing Object and Global Methods"
Here's a package declaration using two of the included subclasses, \f(CW\*(C`Standard::Hash\*(C'\fR, for creating and accessing hash-based objects, and \f(CW\*(C`Basic::Global\*(C'\fR, for simple global-value accessors:
.PP
.Vb 1
\&  package MyQueueItem;
\&  
\&  use Class::MakeMethods::Standard::Hash (
\&    new => { name => \*(Aqnew\*(Aq, defaults=>{ foo => \*(AqFoozle\*(Aq } },
\&    scalar => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ],
\&    hash => \*(Aqhistory\*(Aq
\&  );
\&  
\&  use Class::MakeMethods::Basic::Global (
\&    scalar => \*(AqDebug\*(Aq,
\&    array  => \*(AqInQueue\*(Aq,
\&  );
\&  
\&  sub AddQueueItem {
\&    my $class = shift;
\&    my $instance = shift;
\&    $instance\->history(\*(AqAddQueueItem\*(Aq => time());
\&    $class\->InQueue([0, 0], $instance);    
\&  }
\&  
\&  sub GetQueueItem {
\&    my $class = shift;
\&    $class\->InQueue([0, 1], []) or $class\->new
\&  }
.Ve
.SS "Adding Custom Initialization to Constructors"
.IX Subsection "Adding Custom Initialization to Constructors"
Frequently you'll want to provide some custom code to initialize new objects of your class. Most of the \f(CW*:new\fR constructor methods provides a way to ensure that this code is consistently called every time a new instance is created.
.IP "Composite::Hash:new { post_rules => [] }" 4
.IX Item "Composite::Hash:new { post_rules => [] }"
The Composite classes allow you to add pre\- and post-operations to any method, so you can pass in a code-ref to be executed after the \fInew()\fR method.
.Sp
.Vb 1
\&  package MyClass;
\&  
\&  sub new_post_init {
\&    my $self = ${(pop)\->{result}}; # get result of original new()
\&    length($self\->foo) or $self\->foo(\*(AqFooBar\*(Aq);   # default value
\&    warn "Initialized new object \*(Aq$self\*(Aq";       
\&  }
\&  
\&  use Class::MakeMethods (
\&    \*(AqComposite::Hash:new\*(Aq => [
\&        \*(Aqnew\*(Aq => { post_rules=>[ \e&new_post_init ] } 
\&    ],
\&    \*(AqComposite::Hash:scalar\*(Aq => \*(Aqfoo;,
\&  );
\&  ... 
\&  package main;
\&  my $self = MyClass\->new( foo => \*(AqFoozle\*(Aq )
.Ve
.IP "Template::Hash:new \-\-and_then_init" 4
.IX Item "Template::Hash:new --and_then_init"
Use 'Template::Hash:new \-\-and_then_init', which will first create the object and initialize it with the provided values, and then call an \fIinit()\fR method on the new object before returning it.
.Sp
.Vb 10
\&  package MyClass;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew \-\-and_then_init\*(Aq => \*(Aqnew\*(Aq
\&    \*(Aqstring\*(Aq  => \*(Aqfoo\*(Aq
\&  );
\&  sub init {
\&    my $self = shift;
\&    length($self\->foo) or $self\->foo(\*(AqFooBar\*(Aq);   # default value
\&    warn "Initialized new object \*(Aq$self\*(Aq";       
\&  }
\&  ... 
\&  package main;
\&  my $self = MyClass\->new( foo => \*(AqFoozle\*(Aq )
.Ve
.IP "Template::Hash:new \-\-with_init" 4
.IX Item "Template::Hash:new --with_init"
If you don't want your constructor to use the default hash-of-method-names style of initialization, use 'Template::Hash:new \-\-with_init', which will create an empty object, pass its arguments to the \fIinit()\fR method on the new object, and then return it.
.Sp
.Vb 10
\&  package MyClass;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew \-\-with_init\*(Aq => \*(Aqnew\*(Aq
\&    \*(Aqstring\*(Aq  => \*(Aqfoo\*(Aq
\&  );
\&  sub init {
\&    my $self = shift;
\&    $self\->foo( shift || \*(AqFooBar\*(Aq ); # init with arg or default
\&    warn "Initialized new object \*(Aq$self\*(Aq";       
\&  }
\&  ... 
\&  package main;
\&  my $self = MyClass\->new( \*(AqFoozle\*(Aq )
.Ve
.PP
Some additional notes about these constructors:
.IP "\(bu" 4
The \f(CW\*(C`Template::*:new\*(C'\fR methods allow you to specify a name for your method other than \f(CW\*(C`init\*(C'\fR by passing the \f(CW\*(C`init_method\*(C'\fR parameter:
.Sp
.Vb 5
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew \-\-and_then_init\*(Aq => [ 
\&        \*(Aqnew\*(Aq => { init_method =>  \*(Aqmy_init\*(Aq } 
\&    ],
\&  );
.Ve
.IP "\(bu" 4
If you know that you're not going to have a complex class hierarchy, you can reduce resource consumption a bit by changing the above declarations from \*(L"*::Hash\*(R" to \*(L"*::Array\*(R" so your objects end up as blessed arrays rather than blessed hashes.
.SS "Changing Method Names"
.IX Subsection "Changing Method Names"
The Template subclasses allow you to control the names assigned to
the methods you generate by selecting from several naming interfaces.
.PP
For example, the accessors declared above use a default, Perl-ish
style interface, in which a single method can be called without an
argument to retrieve the value, or with an argument to set it.
However, you can also select a more Java-like syntax, with separate
get* and set* methods, by including the '\-\-java' template specification:
.PP
.Vb 5
\&  package MyStruct;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq     => \*(Aqnew\*(Aq,
\&    \*(Aqscalar\*(Aq  => \*(Aq\-\-java Foo\*(Aq,
\&  );
.Ve
.PP
(Note that the declaration of Foo could also have been written as
\&\f(CW\*(Aqscalar \-\-java\*(Aq => \*(AqFoo\*(Aq\fR or \f(CW\*(C`\*(Aqscalar\*(Aq => [\*(Aq\-\-java\*(Aq,
\&\*(AqFoo\*(Aq]\*(C'\fR, or \f(CW\*(C`\*(Aqscalar\*(Aq => [ \*(Aqfoo\*(Aq =\*(C'\fR { 'interface'=>'java' }
], all of which are interpreted identically; see the
Class::MakeMethods section on \*(L"Argument Normalization\*(R" for
details.)
.PP
Usage of this accessor would then be as follows:
.PP
.Vb 2
\&  package main;
\&  use MyStruct;
\&  
\&  my $obj = MyStruct\->new( setFoo => "Foozle" );
\&  print $obj\->getFoo();
\&  $obj\->setFoo("Bozzle");
.Ve
.SS "Selecting Specific Helper Methods"
.IX Subsection "Selecting Specific Helper Methods"
You can use the ability to specify interfaces to select specific helper methods rather than getting the default collection.
.PP
For example, let's say you wanted to use a Template::Hash:array, but you only wanted two methods to be installed in your class, a \fIfoo()\fR accessor and a \fIshift_foo()\fR mutator. Any of the below combinations of syntax should do the trick:
.PP
.Vb 4
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqarray\*(Aq => [
\&      \*(Aqfoo\*(Aq => { interface=>{\*(Aqfoo\*(Aq=>\*(Aqget_set\*(Aq, \*(Aqshift_foo\*(Aq=>\*(Aqshift\*(Aq} },
\&    ];
.Ve
.PP
If you're going to have a lot of methods with the same interface, you could pre-declare a named interface once and use it repeatedly:
.PP
.Vb 6
\&  BEGIN {
\&    require Class::MakeMethods::Template::Hash;
\&    Class::MakeMethods::Template::Hash\->named_method(\*(Aqarray\*(Aq)\->
\&        {\*(Aqinterface\*(Aq}\->{\*(Aqmy_get_set_shift\*(Aq} =
\&            { \*(Aq*\*(Aq=>\*(Aqget_set\*(Aq, \*(Aqshift_*\*(Aq=>\*(Aqshift\*(Aq };
\&  }
\&
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqarray \-\-my_get_set_shift\*(Aq => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ];
.Ve
.SS "Tree Structure Example"
.IX Subsection "Tree Structure Example"
In this example we will create a pair of classes with references
to other objects.
.PP
The first class is a single-value data object implemented as a
reference to a scalar.
.PP
.Vb 5
\&  package MyTreeData;
\&  use Class::MakeMethods::Template::Scalar (
\&    \*(Aqnew\*(Aq     => \*(Aqnew\*(Aq,
\&    \*(Aqstring\*(Aq  => \*(Aqvalue\*(Aq,
\&  );
.Ve
.PP
The second class defines a node in a tree, with a constructor, an
accessor for a data object from the class above, and accessors for
a list of child nodes.
.PP
.Vb 6
\&  package MyTreeNode;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq     => \*(Aqnew\*(Aq,
\&    \*(Aqobject \-class MyTreeData\*(Aq  => \*(Aqdata\*(Aq,
\&    \*(Aqarray_of_objects \-class MyTreeNode\*(Aq => \*(Aqchildren\*(Aq,
\&  );
\&  
\&  sub depth_first_data {
\&    my $self = shift;
\&    return $self\->data, map { $_\->depth_first_data() } $self\->children;
\&  }
.Ve
.PP
Here's a sample of how the above classes could be used in a program.
.PP
.Vb 3
\&  package main;
\&  use MyTreeData;
\&  use MyTreeNode;
\&
\&  my $node = MyTreeNode\->new( 
\&      data => { value=>\*(Aqdata1\*(Aq }, 
\&      children => [ { value=>\*(Aqdata3\*(Aq } ] 
\&  );
\&  $node\->push_children( MyTreeNode\->new( data => { value=>\*(Aqdata2\*(Aq } ) );
\&  
\&  foreach my $data ( $node\->depth_first_data ) {
\&    print $data\->value();
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.SS "Annotated Tutorials"
.IX Subsection "Annotated Tutorials"
Ron Savage has posted a pair of annotated examples, linked to below.
Each demonstrates building a class with MakeMethods, and each
includes scads of comments that walk you through the logic and
demonstrate how the various methods work together.
.PP
.Vb 3
\&  http://savage.net.au/Perl\-tutorials.html
\&  http://savage.net.au/Perl\-tutorials/tut\-33.tgz
\&  http://savage.net.au/Perl\-tutorials/tut\-34.tgz
.Ve
