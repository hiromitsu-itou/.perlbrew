.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Schema::Constraint 3"
.TH SQL::Translator::Schema::Constraint 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Schema::Constraint \- SQL::Translator constraint object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use SQL::Translator::Schema::Constraint;
\&  my $constraint = SQL::Translator::Schema::Constraint\->new(
\&      name   => \*(Aqfoo\*(Aq,
\&      fields => [ id ],
\&      type   => PRIMARY_KEY,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`SQL::Translator::Schema::Constraint\*(C'\fR is the constraint object.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Object constructor.
.PP
.Vb 11
\&  my $schema           =  SQL::Translator::Schema::Constraint\->new(
\&      table            => $table,        # table to which it belongs
\&      type             => \*(Aqforeign_key\*(Aq, # type of table constraint
\&      name             => \*(Aqfk_phone_id\*(Aq, # name of the constraint
\&      fields           => \*(Aqphone_id\*(Aq,    # field in the referring table
\&      reference_fields => \*(Aqphone_id\*(Aq,    # referenced field
\&      reference_table  => \*(Aqphone\*(Aq,       # referenced table
\&      match_type       => \*(Aqfull\*(Aq,        # how to match
\&      on_delete        => \*(Aqcascade\*(Aq,     # what to do on deletes
\&      on_update        => \*(Aq\*(Aq,            # what to do on updates
\&  );
.Ve
.SS "deferrable"
.IX Subsection "deferrable"
Get or set whether the constraint is deferrable.  If not defined,
then returns \*(L"1.\*(R"  The argument is evaluated by Perl for True or
False, so the following are eqivalent:
.PP
.Vb 3
\&  $deferrable = $field\->deferrable(0);
\&  $deferrable = $field\->deferrable(\*(Aq\*(Aq);
\&  $deferrable = $field\->deferrable(\*(Aq0\*(Aq);
.Ve
.SS "expression"
.IX Subsection "expression"
Gets and set the expression used in a \s-1CHECK\s0 constraint.
.PP
.Vb 1
\&  my $expression = $constraint\->expression(\*(Aq...\*(Aq);
.Ve
.SS "is_valid"
.IX Subsection "is_valid"
Determine whether the constraint is valid or not.
.PP
.Vb 1
\&  my $ok = $constraint\->is_valid;
.Ve
.SS "fields"
.IX Subsection "fields"
Gets and set the fields the constraint is on.  Accepts a string, list or
arrayref; returns an array or array reference.  Will unique the field
names and keep them in order by the first occurrence of a field name.
.PP
The fields are returned as Field objects if they exist or as plain
names if not. (If you just want the names and want to avoid the Field's overload
magic use field_names).
.PP
Returns undef or an empty list if the constraint has no fields set.
.PP
.Vb 5
\&  $constraint\->fields(\*(Aqid\*(Aq);
\&  $constraint\->fields(\*(Aqid\*(Aq, \*(Aqname\*(Aq);
\&  $constraint\->fields( \*(Aqid, name\*(Aq );
\&  $constraint\->fields( [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ] );
\&  $constraint\->fields( qw[ id name ] );
\&
\&  my @fields = $constraint\->fields;
.Ve
.SS "field_names"
.IX Subsection "field_names"
Read-only method to return a list or array ref of the field names. Returns undef
or an empty list if the constraint has no fields set. Useful if you want to
avoid the overload magic of the Field objects returned by the fields method.
.PP
.Vb 1
\&  my @names = $constraint\->field_names;
.Ve
.SS "match_type"
.IX Subsection "match_type"
Get or set the constraint's match_type.  Only valid values are \*(L"full\*(R"
\&\*(L"partial\*(R" and \*(L"simple\*(R"
.PP
.Vb 1
\&  my $match_type = $constraint\->match_type(\*(AqFULL\*(Aq);
.Ve
.SS "name"
.IX Subsection "name"
Get or set the constraint's name.
.PP
.Vb 1
\&  my $name = $constraint\->name(\*(Aqfoo\*(Aq);
.Ve
.SS "options"
.IX Subsection "options"
Gets or adds to the constraints's options (e.g., \*(L"\s-1INITIALLY\s0 \s-1IMMEDIATE\s0\*(R").  
Returns an array or array reference.
.PP
.Vb 2
\&  $constraint\->options(\*(AqNORELY\*(Aq);
\&  my @options = $constraint\->options;
.Ve
.SS "on_delete"
.IX Subsection "on_delete"
Get or set the constraint's \*(L"on delete\*(R" action.
.PP
.Vb 1
\&  my $action = $constraint\->on_delete(\*(Aqcascade\*(Aq);
.Ve
.SS "on_update"
.IX Subsection "on_update"
Get or set the constraint's \*(L"on update\*(R" action.
.PP
.Vb 1
\&  my $action = $constraint\->on_update(\*(Aqno action\*(Aq);
.Ve
.SS "reference_fields"
.IX Subsection "reference_fields"
Gets and set the fields in the referred table.  Accepts a string, list or
arrayref; returns an array or array reference.
.PP
.Vb 5
\&  $constraint\->reference_fields(\*(Aqid\*(Aq);
\&  $constraint\->reference_fields(\*(Aqid\*(Aq, \*(Aqname\*(Aq);
\&  $constraint\->reference_fields( \*(Aqid, name\*(Aq );
\&  $constraint\->reference_fields( [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ] );
\&  $constraint\->reference_fields( qw[ id name ] );
\&
\&  my @reference_fields = $constraint\->reference_fields;
.Ve
.SS "reference_table"
.IX Subsection "reference_table"
Get or set the table referred to by the constraint.
.PP
.Vb 1
\&  my $reference_table = $constraint\->reference_table(\*(Aqfoo\*(Aq);
.Ve
.SS "table"
.IX Subsection "table"
Get or set the constraint's table object.
.PP
.Vb 1
\&  my $table = $field\->table;
.Ve
.SS "type"
.IX Subsection "type"
Get or set the constraint's type.
.PP
.Vb 1
\&  my $type = $constraint\->type( PRIMARY_KEY );
.Ve
.SS "equals"
.IX Subsection "equals"
Determines if this constraint is the same as another
.PP
.Vb 1
\&  my $isIdentical = $constraint1\->equals( $constraint2 );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Youens-Clark <kclark@cpan.org>.
