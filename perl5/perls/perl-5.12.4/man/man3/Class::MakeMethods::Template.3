.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Template 3"
.TH MakeMethods::Template 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Template \- Extensible code templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  package MyObject;
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqnew\*(Aq       => \*(Aqnew\*(Aq,
\&    \*(Aqstring\*(Aq    => \*(Aqfoo\*(Aq,
\&    \*(Aqnumber\*(Aq    => \*(Aqbar\*(Aq,
\&  );
\&   
\&  my $obj = MyObject\->new( foo => "Foozle", bar => 23 );
\&  print $obj\->foo();
\&  $obj\->bar(42);
.Ve
.SH "MOTIVATION"
.IX Header "MOTIVATION"
If you compare the source code of some of the closure-generating
methods provided by other subclasses of Class::MakeMethods,
such as the \f(CW\*(C`hash\*(C'\fR accessors provided by the various Standard::*
subclasses, you will notice a fair amount of duplication. This
module provides a way of assembling common pieces of code to
facilitate support the maintenance of much larger libraries of
generated methods.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends the Class::MakeMethods framework by providing
an abstract superclass for extensible code-templating method
generators.
.PP
Common types of methods are generalized into \fBtemplate definitions\fR.
For example, \f(CW\*(C`Template::Generic\*(C'\fR's \f(CW\*(C`new\*(C'\fR provides a template for
methods that create object instances, while \f(CW\*(C`Template::Generic\*(C'\fR's
\&\f(CW\*(C`scalar\*(C'\fR is a template for methods that allow you to get and set
individual scalar values.
.PP
Thse definitions are then re-used and modified by various \fBtemplate
subclasses\fR. For example, the \f(CW\*(C`Template::Hash\*(C'\fR subclass supports
blessed-hash objects, while the \f(CW\*(C`Template::Global\*(C'\fR subclass supports
shared data; each of them includes an appropriate version of the
\&\f(CW\*(C`scalar\*(C'\fR accessor template for those object types.
.PP
Each template defines one or more \fBbehaviors\fR, individual methods
which can be installed in a calling package, and \fBinterfaces\fR,
which select from those behaviours and indicate the names to install
the methods under.
.PP
Each individual meta-method defined by a calling package requires
a \fBmethod name\fR, and may optionally include other key-value
\&\fBparameters\fR, which can control the operation of some meta-methods.
.SH "USAGE"
.IX Header "USAGE"
.SS "Class::MakeMethods Calling Conventions"
.IX Subsection "Class::MakeMethods Calling Conventions"
When you \f(CW\*(C`use\*(C'\fR this package, the method declarations you provide
as arguments cause subroutines to be generated and installed in
your module.
.PP
You can also omit the arguments to \f(CW\*(C`use\*(C'\fR and instead make methods
at runtime by passing the declarations to a subsequent call to
\&\f(CW\*(C`make()\*(C'\fR.
.PP
You may include any number of declarations in each call to \f(CW\*(C`use\*(C'\fR
or \f(CW\*(C`make()\*(C'\fR. If methods with the same name already exist, earlier
calls to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make()\*(C'\fR win over later ones, but within each
call, later declarations superceed earlier ones.
.PP
You can install methods in a different package by passing \f(CW\*(C`\-TargetClass => \f(CIpackage\f(CW\*(C'\fR as your first arguments to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`make\*(C'\fR.
.PP
See Class::MakeMethods for more details.
.SS "Passing Parameters"
.IX Subsection "Passing Parameters"
The following types of Basic declarations are supported:
.IP "\(bu" 4
\&\fIgenerator_type\fR => "\fImethod_name\fR"
.IP "\(bu" 4
\&\fIgenerator_type\fR => "\fIname_1\fR \fIname_2\fR..."
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ "\fIname_1\fR\*(L", \*(R"\fIname_2\fR", ...]
.PP
See \*(L"\s-1TEMPLATE\s0 \s-1CLASSES\s0\*(R" in Class::MakeMethods::Docs::Catalog for a list of the supported values of \fIgenerator_type\fR.
.PP
For each method name you provide, a subroutine of the indicated
type will be generated and installed under that name in your module.
.PP
Method names should start with a letter, followed by zero or more
letters, numbers, or underscores.
.SS "Standard Declaration Syntax"
.IX Subsection "Standard Declaration Syntax"
The Standard syntax provides several ways to optionally associate
a hash of additional parameters with a given method name.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ "\fIname_1\fR" => { \fIparam\fR=>\fIvalue\fR... }, ... ]
.Sp
A hash of parameters to use just for this method name.
.Sp
(Note: to prevent confusion with self-contained definition hashes,
described below, parameter hashes following a method name must not
contain the key 'name'.)
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ [ "\fIname_1\fR\*(L", \*(R"\fIname_2\fR", ... ] => { \fIparam\fR=>\fIvalue\fR... } ]
.Sp
Each of these method names gets a copy of the same set of parameters.
.IP "\(bu" 4
\&\fIgenerator_type\fR => [ { \*(L"name\*(R"=>"\fIname_1\fR", \fIparam\fR=>\fIvalue\fR... }, ... ]
.Sp
By including the reserved parameter \f(CW\*(C`name\*(C'\fR, you create a self
contained declaration with that name and any associated hash values.
.PP
Basic declarations, as described above, are treated as having an empty parameter hash.
.SS "Default Parameters"
.IX Subsection "Default Parameters"
A set of default parameters to be used for several declarations
may be specified using any of the following types of arguments to
a Template method generator call:
.IP "\(bu" 4
\&'\-\fIparam\fR' => '\fIvalue\fR'
.Sp
Set a default value for the specified parameter.
.IP "\(bu" 4
\&'\-\-' => { '\fIparam\fR' => '\fIvalue\fR', ... }
.Sp
Set default values for one or more parameters. Equivalent to a series of '\-\fIparam\fR' => '\fIvalue\fR' pairs for each pair in the referenced hash.
.IP "\(bu" 4
\&'\-\-\fIspecial_param_value\fR'
.Sp
Specifies a value for special parameter; the two supported parameter types are:
.RS 4
.IP "\-" 4
\&'\-\-\fIinterface_name\fR'
.Sp
Select a predefined interface; equivalent to '\-interface'=> '\fIinterface_name\fR'.
.Sp
For more information about interfaces, see \*(L"Selecting Interfaces\*(R" below.
.IP "\-" 4
\&'\-\-\fImodifier_name\fR'
.Sp
Select a global behavior modifier, such as '\-\-private' or '\-\-protected'.
.Sp
For more information about modifiers, see \*(L"Selecting Modifiers\*(R" below.
.RE
.RS 4
.RE
.PP
Parameters set in these ways are passed to each declaration that
follows it until the end of the method-generator argument array,
or until overridden by another declaration. Parameters specified
in a hash for a specific method name, as discussed above, will
override the defaults of the same name for that particular method.
.SH "PARAMETER REFERENCE"
.IX Header "PARAMETER REFERENCE"
Each meta-method is allocated a hash in which to store its parameters
and optional information.
.PP
(Note that you can not override parameters on a per-object level.)
.SS "Special Parameters"
.IX Subsection "Special Parameters"
The following parameters are pre-defined or have a special meaning:
.IP "\(bu" 4
name
.Sp
The primary name of the meta-method. Note that the subroutines
installed into the calling package may be given different names,
depending on the rules specified by the interface.
.IP "\(bu" 4
interface
.Sp
The name of a predefined interface, or a reference to a custom
interface, to use for this meta-method. See \*(L"Selecting Interfaces\*(R", below.
.IP "\(bu" 4
modifier
.Sp
The names of one or more predefined modifier flags. See \*(L"Selecting Modifiers\*(R", below.
.SS "Informative Parameters"
.IX Subsection "Informative Parameters"
The following parameters are set automatically when your meta-method is declared:
.IP "\(bu" 4
target_class
.Sp
The class that requested the meta-method, into which its subroutines
will be installed.
.IP "\(bu" 4
template_name
.Sp
The Class::MakeMethods::Template method used for this declaration.
.IP "\(bu" 4
template_class
.Sp
The Class::MakeMethods::Template subclass used for this declaration.
.SS "Other Parameters"
.IX Subsection "Other Parameters"
Specific subclasses and template types provide support for additional
parameters.
.PP
Note that you generally should not arbitrarily assign additional
parameters to a meta-method unless you know that they do not conflict
with any parameters already defined or used by that meta-method.
.SS "Parameter Expansion"
.IX Subsection "Parameter Expansion"
If a parameter specification contains '*', it is replaced with
the primary method name.
.PP
Example: The following defines counter (*, *_incr, *_reset)
meta-methods j and k, which use the hash keys j_index and k_index
to fetch and store their values.
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    counter => [ \*(Aq\-hash_key\*(Aq => \*(Aq*_index\*(Aq, qw/ j k / ];
.Ve
.PP
(See Class::MakeMethods::Template::Hash for information about the \f(CW\*(C`hash_key\*(C'\fR parameter.)
.PP
If a parameter specification contains '*{\fIparam\fR}', it is replaced
with the value of that parameter.
.PP
Example: The following defines a Hash scalar meta-method which will
store its value in a hash key composed of the defining package's
name and individual method name, such as
\&\f(CW\*(C`$self\->{\f(CIMyObject\f(CW\-\f(CIfoo\f(CW}\*(C'\fR:
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [ \*(Aq\-hash_key\*(Aq => \*(Aq*{target_class}\-*{name}\*(Aq, qw/ l / ];
.Ve
.SS "Selecting Interfaces"
.IX Subsection "Selecting Interfaces"
Each template provides one or more predefined interfaces, each of which specifies one or more methods to be installed in your package, and the method names to use. Check the documentation for specific templates for a list of
which interfaces they define.
.PP
An interface may be specified for a single method by providing an
\&'interface' parameter:
.IP "\(bu" 4
\&'\fIinterface_name\fR'
.Sp
Select a predefined interface.
.Sp
Example: Instead of the normal Hash scalar method named x, the
following creates methods with \*(L"Java-style\*(R" names and behaviors,
getx and setx.
.Sp
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [ \*(Aqx\*(Aq => { interface=>\*(Aqjava\*(Aq } ];
.Ve
.Sp
(See \*(L"scalar\*(R" in Class::MakeMethods::Template::Generic for a
description of the \f(CW\*(C`java\*(C'\fR interface.)
.IP "\(bu" 4
\&'\fIbehavior_name\fR'
.Sp
A simple interface consisting only of the named behavior.
.Sp
For example, the below declaration creates a read-only methods named q. (There
are no set or clear methods, so any value would have to be placed
in the hash by other means.)
.Sp
.Vb 3
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqscalar\*(Aq => [ \*(Aqq\*(Aq => { interface=>\*(Aqget\*(Aq } ] 
\&  );
.Ve
.IP "\(bu" 4
{  '\fIsubroutine_name_pattern\fR' => '\fIbehavior_name\fR', ... }
.Sp
A custom interface consists of a hash-ref that maps subroutine names to the associated behaviors. Any \f(CW\*(C`*\*(C'\fR characters in \fIsubroutine_name_pattern\fR are replaced with the declared method name.
.Sp
For example, the below delcaration creates paired get_w and set_w methods:
.Sp
.Vb 3
\&  use Class::MakeMethods::Template::Hash (
\&    \*(Aqscalar\*(Aq => [ \*(Aqw\*(Aq => { interface=> { \*(Aqget_*\*(Aq=>\*(Aqget\*(Aq, \*(Aqset_*\*(Aq=>\*(Aqset\*(Aq } } ] 
\&  );
.Ve
.PP
Some interfaces provide very different behaviors than the default
interface.
.PP
Example: The following defines a method g, which if called with an
argument appends to, rather than overwriting, the current value:
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqstring\*(Aq => [ \*(Aq\-\-get_concat\*(Aq, \*(Aqg\*(Aq ];
.Ve
.PP
A named interface may also be specified as a default in the argument
list with a leading '\-\-' followed by the interface's name.
.PP
Example: Instead of the normal Hash scalar methods (named x and
clear_x), the following creates methods with \*(L"Java-style\*(R" names
and behaviors (getx, setx).
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [ \*(Aq\-\-java\*(Aq, \*(Aqx\*(Aq  ];
.Ve
.PP
An interface set in this way affects all meta-methods that follow it
until another interface is selected or the end of the array is
reached; to return to the original names request the 'default'
interface.
.PP
Example: The below creates \*(L"Java-style\*(R" methods for e and f, \*(L"normal
scalar\*(R" methods for g, and \*(L"Eiffel-style\*(R" methods for h.
.PP
.Vb 6
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [
\&      \*(Aq\-\-java\*(Aq=> \*(Aqe\*(Aq, \*(Aqf\*(Aq, 
\&      \*(Aq\-\-default\*(Aq=> \*(Aqg\*(Aq, 
\&      \*(Aq\-\-eiffel\*(Aq=> \*(Aqh\*(Aq,
\&    ];
.Ve
.SS "Selecting Modifiers"
.IX Subsection "Selecting Modifiers"
You may select modifiers, which will affect all behaviors.
.PP
.Vb 2
\&  use Class::MakeMethods::Template::Hash
\&      \*(Aqscalar\*(Aq => [ \*(Aqa\*(Aq, \*(Aq\-\-protected\*(Aq => \*(Aqb\*(Aq, \-\-private\*(Aq => \*(Aqc\*(Aq ];
.Ve
.PP
Method b croaks if it's called from outside of the current package
or its subclasses.
.PP
Method c croaks if it's called from outside of the current package.
.PP
See the documentation for each template to learn which modifiers it supports.
.SS "Runtime Parameter Access"
.IX Subsection "Runtime Parameter Access"
If the meta-method is defined using an interface which includes the
attributes method, run-time access to meta-method parameters is
available.
.PP
Example: The following defines a counter meta-method named y, and
then later changes the 'join' parameter for that method at runtime.
.PP
.Vb 1
\&  use Class::MakeMethods ( get_concat => \*(Aqy\*(Aq );
\&  
\&  y_attributes(undef, \*(Aqjoin\*(Aq, "\et" )
\&  print y_attributes(undef, \*(Aqjoin\*(Aq)
.Ve
.SH "EXTENDING"
.IX Header "EXTENDING"
You can create your own method-generator templates by following the below outline.
.SS "Mechanisms"
.IX Subsection "Mechanisms"
Dynamic generation of methods in Perl generally depends on one of two approaches: string evals, which can be as flexible as your string-manipulation functions allow, but are run-time resource intensive; or closures, which are limited by the number of subroutine constructors you write ahead of time but which are faster and smaller than evals.
.PP
Class::MakeMethods::Template uses both of these approaches: To generate different types of subroutines, a simple text-substitution mechanism combines bits of Perl to produce the source code for a subroutine, and then evals those to produce code refs. Any differences which can be handled with only data changes are managed at the closure layer; once the subroutines are built, they are repeatedly bound as closures to hashes of parameter data.
.SS "Code Generation"
.IX Subsection "Code Generation"
A substitution-based \*(L"macro language\*(R" is used to assemble code strings. This happens only once per specific subclass/template/behavior combination used in your program. (If you have disk-caching enabled, the template interpretation is only done once, and then saved; see below.)
.PP
There are numerous examples of this within the Generic interface and its subclasses; for examples, look at the following methods: Universal:generic, Generic:scalar, Hash:generic, and Hash:scalar.
.PP
See Class::MakeMethods::Utility::TextBuilder for more information.
.SS "Template Definitions"
.IX Subsection "Template Definitions"
Template method generators are declared by creating a subroutine that returns a hash-ref of information about the template. When these subroutines are first called, the template information is filled in with imported and derived values, blessed as a Class::MakeMethods::Template object, and cached.
.PP
Each \f(CW\*(C`use\*(C'\fR of your subclass, or call to its \f(CW\*(C`make\*(C'\fR, causes these objects to assemble the requested methods and return them to Class::MakeMethods for installation in the calling package.
.PP
Method generators defined this way will have support for parameters, custom interfaces, and the other features discussed above.
.PP
(Your module may also use the \*(L"Aliasing\*(R" and \*(L"Rewriting\*(R" functionality described in \*(L"\s-1EXTENDING\s0\*(R" in Class::MakeMethods.)
.PP
Definition hashes contain several types of named resources in a second level of hash-refs under the following keys:
.IP "\(bu" 4
interface \- Naming styles (see \*(L"Defining Interfaces\*(R", below)
.IP "\(bu" 4
params \- Default parameters for meta-methods declared with this template (see \*(L"Default Parameters\*(R", below)
.IP "\(bu" 4
behavior \- Method recipes (see \*(L"Defining Behaviors\*(R", below)
.IP "\(bu" 4
code_expr \- Bits of code used by the behaviors
.SS "Minimum Template Definition"
.IX Subsection "Minimum Template Definition"
You must at least specify one behavior; all other information is optional.
.PP
Class::MakeMethods will automatically fill in the template name and class
as 'template_name' and 'template_class' entries in the version of your
template definition hash that it caches and uses for future execution.
.PP
For example a simple sub-class that defines a method type
upper_case_get_set might look like this:
.PP
.Vb 2
\&  package Class::MakeMethods::UpperCase;
\&  use Class::MakeMethods \*(Aq\-isasubclass\*(Aq;
\&  
\&  sub uc_scalar {
\&    return { 
\&      \*(Aqbehavior\*(Aq => {
\&        \*(Aqdefault\*(Aq => sub { 
\&          my $m_info = $_[0]; 
\&          return sub {
\&            my $self = shift;
\&            if ( scalar @_ ) { 
\&              $self\->{ $m_info\->{\*(Aqname\*(Aq} } = uc( shift ) 
\&            } else {
\&              $self\->{ $m_info\->{\*(Aqname\*(Aq} };
\&            }
\&          }
\&        },
\&      }
\&    }
\&  }
.Ve
.PP
And a caller could then use it to generate methods in their package by invoking:
.PP
.Vb 1
\&  Class::MakeMethods::UpperCase\->make( \*(Aquc_scalar\*(Aq => [ \*(Aqfoo\*(Aq ] );
.Ve
.SS "Default Parameters"
.IX Subsection "Default Parameters"
Each template may include a set of default parameters for all declarations as \f(CW\*(C`params => \f(CIhash_ref\f(CW\*(C'\fR.
.PP
Template-default parameters can be overrridden by interface '\-params', described below, and and method-specific parameters, described above.
.SS "Defining Interfaces"
.IX Subsection "Defining Interfaces"
Template definitions may have one or more interfaces, including
the default one, named 'default', which is automatically selected
if another interface is not requested. (If no default interface is
provided, one is constructed, which simply calls for a behavior
named default.)
.PP
Most commonly, an interface is specified as a hash which maps one or
more subroutine names to the behavior to use for each. The interface
subroutine names generally contain an asterisk character, '*', which
will be replaced by the name of each meta-method.
.PP
Example: The below defines methods e_get, e_set, and e_clear.
.PP
.Vb 4
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [
\&      \-interface=>{ \*(Aq*_clear\*(Aq=>clear, \*(Aq*_get\*(Aq=>\*(Aqget\*(Aq, \*(Aq*_set\*(Aq=>\*(Aqset\*(Aq }, \*(Aqe\*(Aq 
\&    ];
.Ve
.PP
If the provided name does not contain an asterisk, it will not be
modified for individual meta-methods; for examples, see the bit_fields
method generated by Generic bits, and the \s-1DESTROY\s0 method generated
by InsideOut meta-methods.
.PP
In addition to the name-to-behavior correspondences described above,
interfaces may also contain additional entries with keys begining
with the '\-' character which are interpreted as follows:
.IP "\(bu" 4
\&\f(CW\*(C`\-params => \f(CIhash_ref\f(CW\*(C'\fR
.Sp
Interfaces may include a '\-params' key and associated reference
to a hash of default parameters for that interface.
.IP "\(bu" 4
\&\f(CW\*(C`\-base => \f(CIinterface_name\f(CW\*(C'\fR
.Sp
Interfaces can be based on previously existing ones by including
a \-base specification in the the hash. The base value should contain
one or more space-separated names of the interfaces to be included.
.Sp
Example: The below defines methods getG, setG, and clearG.
.Sp
.Vb 4
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [
\&      \-interface => { \-base=>\*(Aqjava\*(Aq, \*(Aqclear*\*(Aq=>\*(Aqclear\*(Aq }, qw/ G / 
\&    ];
.Ve
.Sp
If multiple interfaces are included in the \-base specification and
specify different behaviors for the same subroutine name, the later
ones will override the earlier. Names which appear in the base
interface can be overridden by providing a new value, or a name
can be removed by mapping it to undef or the empty string.
.Sp
Example: The following defines a get-set meta-method h, but supresses
the clear_h method:
.Sp
.Vb 4
\&  use Class::MakeMethods::Template::Hash
\&    \*(Aqscalar\*(Aq => [
\&      \-interface => { \-base=>\*(Aqwith_clear\*(Aq, \*(Aqclear_*\*(Aq=>\*(Aq\*(Aq }, qw/ h / 
\&    ];
.Ve
.SS "Defining Behaviors"
.IX Subsection "Defining Behaviors"
Behaviors can be provided as text which is eval'd to form a
closure-generating subroutine when it's first used; \f(CW$self\fR is
automatically defined and assigned the value of the first argument.
.PP
.Vb 6
\&      \*(Aqbehavior\*(Aq => {
\&        \*(Aqdefault\*(Aq => q{
\&            if ( scalar @_ ) { $self\->{ $m_info\->{\*(Aqname\*(Aq} } = uc shift }
\&            $self\->{ $m_info\->{\*(Aqname\*(Aq} };
\&        },
\&      }
.Ve
.PP
A simple substitution syntax provides for macro interpretation with
definition strings. This functionality is currently undocumented;
for additional details see the _interpret_text_builder function in
Class::MakeMethods, and review the code_expr hashes defined in
Class::MakeMethods::Generic.
.SS "Importing"
.IX Subsection "Importing"
You can copy values out of other template definitions by specifying
an '\-import' key and corresponding hash reference. You can specify
an \-import for inside any of the template definition sub-hashes.
If no \-import is specified for a subhash, and there is a top-level
\&\-import value, it is used instead.
.PP
Inside an \-import hash, provide \f(CW\*(C`\f(CITemplateClass\f(CW:\f(CItype\f(CW\*(C'\fR names
for each source you wish to copy from, and the values to import,
which can be a string, a reference to an array of strings, or '*'
to import everything available. (The order of copying is not
defined.)
.PP
Example: The below definition creates a new template
which is identical to an existing one.
.PP
.Vb 4
\&  package Class::MakeMethods::MyMethods;
\&  sub scalarama {
\&    { \-import => { \*(AqTemplate::Hash:scalar\*(Aq => \*(Aq*\*(Aq } }
\&  }
.Ve
.PP
Values that are already set are not modified, unless they're an
array ref, in which case they're added to.
.PP
Example:
.PP
.Vb 10
\&  package Class::MakeMethods::MyMethods;
\&  sub foo_method {
\&    { \*(Aqbehavior\*(Aq => {
\&      \*(Aq\-init\*(Aq => [ sub {  warn "Defining foo_method $_[0]\->{\*(Aqname\*(Aq}" } ],
\&      \*(Aqdefault\*(Aq => q{ warn "Calling foo_method behavior" }.
\&    } }
\&  }
\&  sub bar_method {
\&    { \*(Aqbehavior\*(Aq => {
\&      \-import => { \*(AqMyMethods:foo_method\*(Aq => \*(Aq*\*(Aq },
\&      \*(Aq\-init\*(Aq => [ sub {  warn "Defining bar_method $_[0]\->{\*(Aqname\*(Aq}" } ],
\&      \*(Aqdefault\*(Aq => q{ warn "Calling bar_method behavior" }.
\&    } }
\&  }
.Ve
.PP
In this case, the bar_method ends up with an array of two '\-init'
subroutines, its own and the imported one, but only its own default
behavior.
.SS "Modifying Existing Templates"
.IX Subsection "Modifying Existing Templates"
You can over-write information contained in template definitions
to alter their subsequent behavior.
.PP
Example: The following extends the Hash:scalar template definition
by adding a new interface, and then uses it to create scalar accessor
methods named access_p and access_q that get and set values for
the hash keys 'p' and 'q':
.PP
.Vb 2
\&  Class::MakeMethods::Template::Hash\->named_method(\*(Aqscalar\*(Aq)\->
\&          {\*(Aqinterface\*(Aq}{\*(Aqfrozzle\*(Aq} = { \*(Aqaccess_*\*(Aq=>\*(Aqget_set\*(Aq };
\&
\&  package My::Object;
\&  Class::MakeMethods::Template::Hash\->make( \*(Aqscalar\*(Aq => [ \-\-frozzle => qw( p q ) ] );
\&
\&  $object\->access_p(\*(AqPotato\*(Aq);    # $object\->{p} = \*(AqPotato\*(Aq
\&  print $object\->access_q();      # print $object\->{q}
.Ve
.PP
Note that this constitutes \*(L"action at a distance\*(R" and will affect subsequent use by other packages; unless you are \*(L"fixing\*(R" the current behavior, you are urged to create your own template definition which imports the base behavior of the existing template and overrides the information in question.
.PP
Example: The following safely declares a new version of Hash:scalar with the desired additional interface:
.PP
.Vb 1
\&  package My::Methods;
\&  
\&  sub scalar {
\&    { 
\&      \-import => { \*(AqTemplate::Hash:scalar\*(Aq => \*(Aq*\*(Aq } ,
\&      interface => { \*(Aqfrozzle\*(Aq => { \*(Aqaccess_*\*(Aq=>\*(Aqget_set\*(Aq } },
\&    }
\&  }
\&
\&  package My::Object;
\&  My::Methods\->make( \*(Aqscalar\*(Aq => [ \-\-frozzle => qw( p q ) ] );
.Ve
.SS "Disk Caching"
.IX Subsection "Disk Caching"
To enable disk caching of generated code, create an empty directory and pass it to the DiskCache package:
.PP
.Vb 1
\&  use Class::MakeMethods::Utility::DiskCache qw( /my/code/dir );
.Ve
.PP
This has a mixed effect on performance, but has the notable advantage of letting you view the subroutines that are being generated by your templates.
.PP
See Class::MakeMethods::Utility::DiskCache for more information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.PP
See Class::MakeMethods::Examples for some illustrations of what you can do with this package.
.PP
For distribution, installation, support, copyright and license 
information, see Class::MakeMethods::Docs::ReadMe.
