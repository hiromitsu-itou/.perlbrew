.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::View::JSON 3"
.TH Catalyst::View::JSON 3 "2011-04-13" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::View::JSON \- JSON view for your data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # lib/MyApp/View/JSON.pm
\&  package MyApp::View::JSON;
\&  use base qw( Catalyst::View::JSON );
\&  1;
\&
\&  # configure in lib/MyApp.pm
\&  MyApp\->config({
\&      ...
\&      \*(AqView::JSON\*(Aq => {
\&          allow_callback  => 1,    # defaults to 0
\&          callback_param  => \*(Aqcb\*(Aq, # defaults to \*(Aqcallback\*(Aq
\&          expose_stash    => [ qw(foo bar) ], # defaults to everything
\&      },
\&  });
\&
\&  sub hello : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Catalyst::View::JSON is a Catalyst View handler that returns stash
data in \s-1JSON\s0 format.
.SH "CONFIG VARIABLES"
.IX Header "CONFIG VARIABLES"
.IP "allow_callback" 4
.IX Item "allow_callback"
Flag to allow callbacks by adding \f(CW\*(C`callback=function\*(C'\fR. Defaults to 0
(doesn't allow callbacks). See \*(L"\s-1CALLBACKS\s0\*(R" for details.
.IP "callback_param" 4
.IX Item "callback_param"
Name of \s-1URI\s0 parameter to specify \s-1JSON\s0 callback function name. Defaults
to \f(CW\*(C`callback\*(C'\fR. Only effective when \f(CW\*(C`allow_callback\*(C'\fR is turned on.
.IP "expose_stash" 4
.IX Item "expose_stash"
Scalar, List or regular expression object, to specify which stash keys are
exposed as a \s-1JSON\s0 response. Defaults to everything. Examples configuration:
.Sp
.Vb 2
\&  # use \*(Aqjson_data\*(Aq value as a data to return
\&  expose_stash => \*(Aqjson_data\*(Aq,
\&
\&  # only exposes keys \*(Aqfoo\*(Aq and \*(Aqbar\*(Aq
\&  expose_stash => [ qw( foo bar ) ],
\&
\&  # only exposes keys that matches with /^json_/
\&  expose_stash => qr/^json_/,
.Ve
.Sp
Suppose you have data structure of the following.
.Sp
.Vb 2
\&  $c\->stash\->{foo} = [ 1, 2 ];
\&  $c\->stash\->{bar} = [ 3, 4 ];
.Ve
.Sp
By default, this view will return:
.Sp
.Vb 1
\&  {"foo":[1,2],"bar":2}
.Ve
.Sp
When you set \f(CW\*(C`expose_stash => [ \*(Aqfoo\*(Aq ]\*(C'\fR, it'll return
.Sp
.Vb 1
\&  {"foo":[1,2]}
.Ve
.Sp
and in the case of \f(CW\*(C`expose_stash => \*(Aqfoo\*(Aq\*(C'\fR, it'll just return
.Sp
.Vb 1
\&  [1,2]
.Ve
.Sp
instead of the whole object (hashref in perl). This option will be
useful when you share the method with different views (e.g. \s-1TT\s0) and
don't want to expose non-irrelevant stash variables as in \s-1JSON\s0.
.IP "json_driver" 4
.IX Item "json_driver"
.Vb 1
\&  json_driver: JSON::Syck
.Ve
.Sp
By default this plugin uses \s-1JSON\s0 to encode the object, but you can
switch to the other drivers like JSON::Syck, whichever JSON::Any
supports.
.IP "no_x_json_header" 4
.IX Item "no_x_json_header"
.Vb 1
\&  no_x_json_header: 1
.Ve
.Sp
By default this plugin sets X\-JSON header if the requested client is a
Prototype.js with X\-JSON support. By setting 1, you can opt-out this
behavior so that you can do \fIeval()\fR by your own. Defaults to 0.
.SH "OVERRIDING JSON ENCODER"
.IX Header "OVERRIDING JSON ENCODER"
By default it uses JSON::Any to serialize perl data strucuture into
\&\s-1JSON\s0 data format. If you want to avoid this and encode with your own
encoder (like passing options to \s-1JSON::XS\s0 etc.), you can implement
\&\f(CW\*(C`encode_json\*(C'\fR method in your View class.
.PP
.Vb 2
\&  package MyApp::View::JSON;
\&  use base qw( Catalyst::View::JSON );
\&
\&  use JSON::XS ();
\&
\&  sub encode_json {
\&      my($self, $c, $data) = @_;
\&      my $encoder = JSON::XS\->new\->ascii\->pretty\->allow_nonref;
\&      $encoder\->encode($data);
\&  }
\&
\&  1;
.Ve
.SH "ENCODINGS"
.IX Header "ENCODINGS"
Due to the browser gotchas like those of Safari and Opera, sometimes
you have to specify a valid charset value in the response's
Content-Type header, e.g. \f(CW\*(C`text/javascript; charset=utf\-8\*(C'\fR.
.PP
Catalyst::View::JSON comes with the configuration variable \f(CW\*(C`encoding\*(C'\fR
which defaults to utf\-8. You can change it via \f(CW\*(C`YourApp\->config\*(C'\fR
or even runtime, using \f(CW\*(C`component\*(C'\fR.
.PP
.Vb 1
\&  $c\->component(\*(AqView::JSON\*(Aq)\->encoding(\*(Aqeuc\-jp\*(Aq);
.Ve
.PP
This assumes you set your stash data in raw euc-jp bytes, or Unicode
flagged variable. In case of Unicode flagged variable,
Catalyst::View::JSON automatically encodes the data into your
\&\f(CW\*(C`encoding\*(C'\fR value (euc-jp in this case) before emitting the data to
the browser.
.PP
Another option would be to use \fIJavaScript-UCS\fR as an encoding (and
pass Unicode flagged string to the stash). That way all non-ASCII
characters in the output \s-1JSON\s0 will be automatically encoded to
JavaScript Unicode encoding like \fI\euXXXX\fR. You have to install
Encode::JavaScript::UCS to use the encoding.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
By default it returns raw \s-1JSON\s0 data so your JavaScript app can deal
with using XMLHttpRequest calls. Adding callbacks (\s-1JSONP\s0) to the \s-1API\s0
gives more flexibility to the end users of the \s-1API:\s0 overcome the
cross-domain restrictions of XMLHttpRequest. It can be done by
appending \fIscript\fR node with dynamic \s-1DOM\s0 manipulation, and associate
callback handler to the returned data.
.PP
For example, suppose you have the following code.
.PP
.Vb 8
\&  sub end : Private {
\&      my($self, $c) = @_;
\&      if ($c\->req\->param(\*(Aqoutput\*(Aq) eq \*(Aqjson\*(Aq) {
\&          $c\->forward(\*(AqView::JSON\*(Aq);
\&      } else {
\&          ...
\&      }
\&  }
.Ve
.PP
\&\f(CW\*(C`/foo/bar?output=json\*(C'\fR will just return the data set in
\&\f(CW\*(C`$c\->stash\*(C'\fR as \s-1JSON\s0 format, like:
.PP
.Vb 1
\&  { result: "foo", message: "Hello" }
.Ve
.PP
but \f(CW\*(C`/foo/bar?output=json&callback=handle_result\*(C'\fR will give you:
.PP
.Vb 1
\&  handle_result({ result: "foo", message: "Hello" });
.Ve
.PP
and you can write a custom \f(CW\*(C`handle_result\*(C'\fR function to handle the
returned data asynchronously.
.PP
The valid characters you can use in the callback function are
.PP
.Vb 1
\&  [a\-zA\-Z0\-9\e.\e_\e[\e]]
.Ve
.PP
but you can customize the behaviour by overriding the
\&\f(CW\*(C`validate_callback_param\*(C'\fR method in your View::JSON class.
.PP
See <http://developer.yahoo.net/common/json.html> and
http://ajaxian.com/archives/jsonp\-json\-with\-padding <http://ajaxian.com/archives/jsonp-json-with-padding> for more about
\&\s-1JSONP\s0.
.SH "INTEROPERABILITY"
.IX Header "INTEROPERABILITY"
\&\s-1JSON\s0 use is still developing and has not been standardized. This
section provides some notes on various libraries.
.PP
Dojo Toolkit: Setting dojo.io.bind's mimetype to 'text/json' in
the JavaScript request will instruct dojo.io.bind to expect \s-1JSON\s0
data in the response body and auto-eval it. Dojo ignores the
server response Content-Type. This works transparently with
Catalyst::View::JSON.
.PP
Prototype.js: prototype.js will auto-eval \s-1JSON\s0 data that is
returned in the custom X\-JSON header. The reason given for this is
to allow a separate \s-1HTML\s0 fragment in the response body, however
this of limited use because \s-1IE\s0 6 has a max header length that will
cause the \s-1JSON\s0 evaluation to silently fail when reached. The
recommened approach is to use Catalyst::View::JSON which will \s-1JSON\s0
format all the response data and return it in the response body.
.PP
In at least prototype 1.5.0 rc0 and above, prototype.js will send the
X\-Prototype-Version header. If this is encountered, a JavaScript eval
will be returned in the X\-JSON resonse header to automatically eval
the response body, unless you set \fIno_x_json_header\fR to 1. If your
version of prototype does not send this header, you can manually eval
the response body using the following JavaScript:
.PP
.Vb 7
\&  evalJSON: function(request) {
\&    try {
\&      return eval(\*(Aq(\*(Aq + request.responseText + \*(Aq)\*(Aq);
\&    } catch (e) {}
\&  }
\&  // elsewhere
\&  var json = this.evalJSON(request);
.Ve
.SH "SECURITY CONSIDERATION"
.IX Header "SECURITY CONSIDERATION"
Catalyst::View::JSON makes the data available as a (sort of)
JavaScript to the client, so you might want to be careful about the
security of your data.
.SS "Use callbacks only for public data"
.IX Subsection "Use callbacks only for public data"
When you enable callbacks (\s-1JSONP\s0) by setting \f(CW\*(C`allow_callbacks\*(C'\fR, all
your \s-1JSON\s0 data will be available cross-site. This means embedding
private data of logged-in user to \s-1JSON\s0 is considered bad.
.PP
.Vb 3
\&  # MyApp.yaml
\&  View::JSON:
\&    allow_callbacks: 1
\&
\&  sub foo : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{address} = $c\->user\->street_address; # BAD
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.PP
If you want to enable callbacks in a controller (for public \s-1API\s0) and
disable in another, you need to create two different View classes,
like MyApp::View::JSON and MyApp::View::JSONP, because
\&\f(CW\*(C`allow_callbacks\*(C'\fR is a static configuration of the View::JSON class.
.PP
See http://ajaxian.com/archives/gmail\-csrf\-security\-flaw <http://ajaxian.com/archives/gmail-csrf-security-flaw> for more.
.SS "Avoid valid cross-site \s-1JSON\s0 requests"
.IX Subsection "Avoid valid cross-site JSON requests"
Even if you disable the callbacks, the nature of JavaScript still has
a possiblity to access private \s-1JSON\s0 data cross-site, by overriding
Array constructor \f(CW\*(C`[]\*(C'\fR.
.PP
.Vb 3
\&  # MyApp.yaml
\&  View::JSON:
\&    expose_stash: json
\&
\&  sub foo : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{json} = [ $c\->user\->street_address ]; # BAD
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.PP
When you return logged-in user's private data to the response \s-1JSON\s0,
you might want to disable \s-1GET\s0 requests (because \fIscript\fR tag invokes
\&\s-1GET\s0 requests), or include a random digest string and validate it.
.PP
See
http://jeremiahgrossman.blogspot.com/2006/01/advanced\-web\-attack\-techniques\-using.html <http://jeremiahgrossman.blogspot.com/2006/01/advanced-web-attack-techniques-using.html>
for more.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Following people has been contributing patches, bug reports and
suggestions for the improvement of Catalyst::View::JSON.
.PP
John Wang
kazeburo
Daisuke Murase
Jun Kuriyama
Tomas Doran
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst, \s-1JSON\s0, Encode::JavaScript::UCS
.PP
<http://www.prototypejs.org/learn/json>
<http://docs.jquery.com/Ajax/jQuery.getJSON>
<http://manual.dojotoolkit.org/json.html>
<http://developer.yahoo.com/yui/json/>
