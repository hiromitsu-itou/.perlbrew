.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Email::Simple 3"
.TH Email::Simple 3 "2011-12-24" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::Simple \- simple parsing of RFC2822 message format and headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Email::Simple;
\&  my $email = Email::Simple\->new($text);
\&
\&  my $from_header = $email\->header("From");
\&  my @received = $email\->header("Received");
\&
\&  $email\->header_set("From", \*(AqSimon Cozens <simon@cpan.org>\*(Aq);
\&
\&  my $old_body = $email\->body;
\&  $email\->body_set("Hello world\enSimon");
\&
\&  print $email\->as_string;
.Ve
.PP
\&...or, to create a message from scratch...
.PP
.Vb 8
\&  my $email = Email::Simple\->create(
\&      header => [
\&        From    => \*(Aqcasey@geeknest.com\*(Aq,
\&        To      => \*(Aqdrain@example.com\*(Aq,
\&        Subject => \*(AqMessage in a bottle\*(Aq,
\&      ],
\&      body => \*(Aq...\*(Aq,
\&  );
\&  
\&  $email\->header_set( \*(AqX\-Content\-Container\*(Aq => \*(Aqbottle/glass\*(Aq );
\&  
\&  print $email\->as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Email::Simple\*(C'\fR is the first deliverable of the \*(L"Perl Email Project.\*(R"  The
Email:: namespace was begun as a reaction against the increasing complexity and
bugginess of Perl's existing email modules.  \f(CW\*(C`Email::*\*(C'\fR modules are meant to
be simple to use and to maintain, pared to the bone, fast, minimal in their
external dependencies, and correct.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $email = Email::Simple\->new($message, \e%arg);
.Ve
.PP
This method parses an email from a scalar containing an \s-1RFC2822\s0 formatted
message and returns an object.  \f(CW$message\fR may be a reference to a message
string, in which case the string will be altered in place.  This can result in
significant memory savings.
.PP
If you want to create a message from scratch, you should use the \f(CW"create"\fR
method.
.PP
Valid arguments are:
.PP
.Vb 2
\&  header_class \- the class used to create new header objects
\&                 The named module is not \*(Aqrequire\*(Aq\-ed by Email::Simple!
.Ve
.SS "create"
.IX Subsection "create"
.Vb 1
\&  my $email = Email::Simple\->create(header => [ @headers ], body => \*(Aq...\*(Aq);
.Ve
.PP
This method is a constructor that creates an Email::Simple object
from a set of named parameters. The \f(CW\*(C`header\*(C'\fR parameter's value is a
list reference containing a set of headers to be created. The \f(CW\*(C`body\*(C'\fR
parameter's value is a scalar value holding the contents of the message
body.  Line endings in the body will normalized to \s-1CRLF\s0.
.PP
If no \f(CW\*(C`Date\*(C'\fR header is specified, one will be provided for you based on the
\&\f(CW\*(C`gmtime\*(C'\fR of the local machine. This is because the \f(CW\*(C`Date\*(C'\fR field is a required
header and is a pain in the neck to create manually for every message. The
\&\f(CW\*(C`From\*(C'\fR field is also a required header, but it is \fInot\fR provided for you.
.SS "header_obj"
.IX Subsection "header_obj"
.Vb 1
\&  my $header = $email\->header_obj;
.Ve
.PP
This method returns the object representing the email's header.  For the
interface for this object, see Email::Simple::Header.
.SS "header_obj_set"
.IX Subsection "header_obj_set"
.Vb 1
\&  $email\->header_obj_set($new_header_obj);
.Ve
.PP
This method substitutes the given new header object for the email's existing
header object.
.SS "header"
.IX Subsection "header"
.Vb 2
\&  my @values = $email\->header($header_name);
\&  my $first  = $email\->header($header_name);
.Ve
.PP
In list context, this returns every value for the named header.  In scalar
context, it returns the \fIfirst\fR value for the named header.
.SS "header_set"
.IX Subsection "header_set"
.Vb 1
\&    $email\->header_set($field, $line1, $line2, ...);
.Ve
.PP
Sets the header to contain the given data. If you pass multiple lines
in, you get multiple headers, and order is retained.  If no values are given to
set, the header will be removed from to the message entirely.
.SS "header_names"
.IX Subsection "header_names"
.Vb 1
\&    my @header_names = $email\->header_names;
.Ve
.PP
This method returns the list of header names currently in the email object.
These names can be passed to the \f(CW\*(C`header\*(C'\fR method one-at-a-time to get header
values. You are guaranteed to get a set of headers that are unique. You are not
guaranteed to get the headers in any order at all.
.PP
For backwards compatibility, this method can also be called as \fBheaders\fR.
.SS "header_pairs"
.IX Subsection "header_pairs"
.Vb 1
\&  my @headers = $email\->header_pairs;
.Ve
.PP
This method returns a list of pairs describing the contents of the header.
Every other value, starting with and including zeroth, is a header name and the
value following it is the header value.
.SS "body"
.IX Subsection "body"
Returns the body text of the mail.
.SS "body_set"
.IX Subsection "body_set"
Sets the body text of the mail.
.SS "as_string"
.IX Subsection "as_string"
Returns the mail as a string, reconstructing the headers.
.SS "crlf"
.IX Subsection "crlf"
This method returns the type of newline used in the email.  It is an accessor
only.
.SS "default_header_class"
.IX Subsection "default_header_class"
This returns the class used, by default, for header objects, and is provided
for subclassing.  The default default is Email::Simple::Header.
.SH "CAVEATS"
.IX Header "CAVEATS"
Email::Simple handles only \s-1RFC2822\s0 formatted messages.  This means you cannot
expect it to cope well as the only parser between you and the outside world,
say for example when writing a mail filter for invocation from a .forward file
(for this we recommend you use Email::Filter anyway).  For more information
on this issue please consult \s-1RT\s0 issue 2478,
<http://rt.cpan.org/NoAuth/Bug.html?id=2478>.
.SH "PERL EMAIL PROJECT"
.IX Header "PERL EMAIL PROJECT"
This module is maintained by the Perl Email Project
.PP
<http://emailproject.perl.org/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Simon Cozens originally wrote Email::Simple in 2003.  Casey West took over
maintenance in 2004, and Ricardo \s-1SIGNES\s0 took over maintenance in 2006.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004 by Casey West
.PP
Copyright 2003 by Simon Cozens
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
