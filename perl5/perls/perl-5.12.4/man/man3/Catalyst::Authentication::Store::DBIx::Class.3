.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Store::DBIx::Class 3"
.TH Catalyst::Authentication::Store::DBIx::Class 3 "2011-12-08" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Authentication::Store::DBIx::Class \- A storage class for Catalyst Authentication using DBIx::Class
.SH "VERSION"
.IX Header "VERSION"
This documentation refers to version 0.1503.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Catalyst qw/
\&                    Authentication
\&                    Authorization::Roles/;
\&
\&    _\|_PACKAGE_\|_\->config(\*(AqPlugin::Authentication\*(Aq => {
\&        default_realm => \*(Aqmembers\*(Aq,
\&        realms => {
\&            members => {
\&                credential => {
\&                    class => \*(AqPassword\*(Aq,
\&                    password_field => \*(Aqpassword\*(Aq,
\&                    password_type => \*(Aqclear\*(Aq
\&                },
\&                store => {
\&                    class => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqMyApp::User\*(Aq,
\&                    role_relation => \*(Aqroles\*(Aq,
\&                    role_field => \*(Aqrolename\*(Aq,
\&                }
\&            }
\&        }
\&    });
\&
\&    # Log a user in:
\&
\&    sub login : Global {
\&        my ( $self, $ctx ) = @_;
\&
\&        $ctx\->authenticate({
\&                          screen_name => $ctx\->req\->params\->{username},
\&                          password => $ctx\->req\->params\->{password},
\&                          status => [ \*(Aqregistered\*(Aq, \*(Aqloggedin\*(Aq, \*(Aqactive\*(Aq]
\&                          }))
\&    }
\&
\&    # verify a role
\&
\&    if ( $ctx\->check_user_roles( \*(Aqeditor\*(Aq ) ) {
\&        # do editor stuff
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Catalyst::Authentication::Store::DBIx::Class class provides
access to authentication information stored in a database via DBIx::Class.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The DBIx::Class authentication store is activated by setting the store
config's \fBclass\fR element to DBIx::Class as shown above. See the
Catalyst::Plugin::Authentication documentation for more details on
configuring the store. You can also use
Catalyst::Authentication::Realm::SimpleDB for a simplified setup.
.PP
The DBIx::Class storage module has several configuration options
.PP
.Vb 10
\&    _\|_PACKAGE_\|_\->config(\*(AqPlugin::Authentication\*(Aq => {
\&        default_realm => \*(Aqmembers\*(Aq,
\&        realms => {
\&            members => {
\&                credential => {
\&                    # ...
\&                },
\&                store => {
\&                    class => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqMyApp::User\*(Aq,
\&                    role_relation => \*(Aqroles\*(Aq,
\&                    role_field => \*(Aqrolename\*(Aq,
\&                    ignore_fields_in_find => [ \*(Aqremote_name\*(Aq ],
\&                    use_userdata_from_session => 1,
\&                }
\&            }
\&        }
\&    });
.Ve
.IP "class" 4
.IX Item "class"
Class is part of the core Catalyst::Plugin::Authentication module; it
contains the class name of the store to be used.
.IP "user_model" 4
.IX Item "user_model"
Contains the model name (as passed to \f(CW\*(C`$ctx\->model()\*(C'\fR) of the DBIx::Class schema
to use as the source for user information. This config item is \fB\s-1REQUIRED\s0\fR.
.Sp
(Note that this option used to be called \f(CW\*(C`user_class\*(C'\fR. \f(CW\*(C`user_class\*(C'\fR is
still functional, but should be used only for compatibility with previous configs.
The setting called \f(CW\*(C`user_class\*(C'\fR on other authentication stores is
present, but named \f(CW\*(C`store_user_class\*(C'\fR in this store)
.IP "role_column" 4
.IX Item "role_column"
If your role information is stored in the same table as the rest of your user
information, this item tells the module which field contains your role
information.  The DBIx::Class authentication store expects the data in this
field to be a series of role names separated by some combination of spaces,
commas, or pipe characters.
.IP "role_relation" 4
.IX Item "role_relation"
If your role information is stored in a separate table, this is the name of
the relation that will lead to the roles the user is in.  If this is
specified, then a role_field is also required.  Also when using this method
it is expected that your role table will return one row for each role
the user is in.
.IP "role_field" 4
.IX Item "role_field"
This is the name of the field in the role table that contains the string
identifying the role.
.IP "ignore_fields_in_find" 4
.IX Item "ignore_fields_in_find"
This item is an array containing fields that may be passed to the
\&\f(CW\*(C`$ctx\->authenticate()\*(C'\fR routine (and therefore find_user in the storage class), but
which should be ignored when creating the DBIx::Class search to retrieve a
user. This makes it possible to avoid problems when a credential requires an
authinfo element whose name overlaps with a column name in your users table.
If this doesn't make sense to you, you probably don't need it.
.IP "use_userdata_from_session" 4
.IX Item "use_userdata_from_session"
Under normal circumstances, on each request the user's data is re-retrieved
from the database using the primary key for the user table.  When this flag
is set in the configuration, it causes the DBIx::Class store to avoid this
database hit on session restore.  Instead, the user object's column data
is retrieved from the session and used as-is.
.Sp
\&\fB\s-1NOTE\s0\fR: Since the user object's column
data is only stored in the session during the initial authentication of
the user, turning this on can potentially lead to a situation where the data
in \f(CW\*(C`$ctx\->user\*(C'\fR is different from what is stored the database.  You can force
a reload of the data from the database at any time by calling \f(CW\*(C`$ctx\->user\->get_object(1);\*(C'\fR
Note that this will update \f(CW\*(C`$ctx\->user\*(C'\fR for the remainder of this request.
It will \s-1NOT\s0 update the session.  If you need to update the session
you should call \f(CW\*(C`$ctx\->update_user_in_session()\*(C'\fR as well.
.IP "store_user_class" 4
.IX Item "store_user_class"
This allows you to override the authentication user class that the
DBIx::Class store module uses to perform its work.  Most of the
work done in this module is actually done by the user class,
Catalyst::Authentication::Store::DBIx::Class::User, so
overriding this doesn't make much sense unless you are using your
own class to extend the functionality of the existing class.
Chances are you do not want to set this.
.IP "id_field" 4
.IX Item "id_field"
In most cases, this config variable does not need to be set, as
Catalyst::Authentication::Store::DBIx::Class will determine the primary
key of the user table on its own.  If you need to override the default,
or your user table has multiple primary keys, then id_field
should contain the column name that should be used to restore the user.
A given value in this column should correspond to a single user in the database.
Note that this is used \fB\s-1ONLY\s0\fR when restoring a user from the session and
has no bearing whatsoever in the initial authentication process.  Note also
that if use_userdata_from_session is enabled, this config parameter
is not used at all.
.SH "USAGE"
.IX Header "USAGE"
The Catalyst::Authentication::Store::DBIx::Class storage module
is not called directly from application code.  You interface with it
through the \f(CW$ctx\fR\->\fIauthenticate()\fR call.
.PP
There are three methods you can use to retrieve information from the DBIx::Class
storage module.  They are Simple retrieval, and the advanced retrieval methods
Searchargs and Resultset.
.SS "Simple Retrieval"
.IX Subsection "Simple Retrieval"
The first, and most common, method is simple retrieval. As its name implies
simple retrieval allows you to simply to provide the column => value pairs
that should be used to locate the user in question. An example of this usage
is below:
.PP
.Vb 5
\&    if ($ctx\->authenticate({
\&                          screen_name => $ctx\->req\->params\->{\*(Aqusername\*(Aq},
\&                          password => $ctx\->req\->params\->{\*(Aqpassword\*(Aq},
\&                          status => [ \*(Aqregistered\*(Aq, \*(Aqactive\*(Aq, \*(Aqloggedin\*(Aq]
\&                         })) {
\&
\&        # ... authenticated user code here
\&    }
.Ve
.PP
The above example would attempt to retrieve a user whose username column (here,
screen_name) matched the username provided, and whose status column matched one of the
values provided. These name => value pairs are used more or less directly in
the DBIx::Class \fIsearch()\fR routine, so in most cases, you can use DBIx::Class
syntax to retrieve the user according to whatever rules you have.
.PP
\&\s-1NOTE:\s0 Because the password in most cases is encrypted \- it is not used
directly but its encryption and comparison with the value provided is usually
handled by the Password Credential. Part of the Password Credential's behavior
is to remove the password argument from the authinfo that is passed to the
storage module. See Catalyst::Authentication::Credential::Password.
.PP
One thing you need to know about this retrieval method is that the name
portion of the pair is checked against the user class's column list. Pairs are
only used if a matching column is found. Other pairs will be ignored. This
means that you can only provide simple name-value pairs, and that some more
advanced DBIx::Class constructs, such as '\-or', '\-and', etc. are in most cases
not possible using this method. For queries that require this level of
functionality, see the 'searchargs' method below.
.SS "Advanced Retrieval"
.IX Subsection "Advanced Retrieval"
The Searchargs and Resultset retrieval methods are used when more advanced
features of the underlying DBIx::Class schema are required. These methods
provide a direct interface with the DBIx::Class schema and therefore
require a better understanding of the DBIx::Class module.
.PP
\fIThe dbix_class key\fR
.IX Subsection "The dbix_class key"
.PP
Since the format of these arguments are often complex, they are not keys in
the base authinfo hash.  Instead, both of these arguments are placed within
a hash attached to the store-specific 'dbix_class' key in the base \f(CW$authinfo\fR
hash.  When the DBIx::Class authentication store sees the 'dbix_class' key
in the passed authinfo hash, all the other information in the authinfo hash
is ignored and only the values within the 'dbix_class' hash are used as
though they were passed directly within the authinfo hash.  In other words, if
\&'dbix_class' is present, it replaces the authinfo hash for processing purposes.
.PP
The 'dbix_class' hash can be used to directly pass arguments to the
DBIx::Class authentication store. Reasons to do this are to avoid credential
modification of the authinfo hash, or to avoid overlap between credential and
store key names. It's a good idea to avoid using it in this way unless you are
sure you have an overlap/modification issue. However, the two advanced
retrieval methods, \fBsearchargs\fR, \fBresult\fR and \fBresultset\fR, require its use,
as they are only processed as part of the 'dbix_class' hash.
.IP "Searchargs" 4
.IX Item "Searchargs"
The \fBsearchargs\fR method of retrieval allows you to specify an arrayref containing
the two arguments to the \fIsearch()\fR method from DBIx::Class::ResultSet.  If provided,
all other args are ignored, and the search args provided are used directly to locate
the user.  An example will probably make more sense:
.Sp
.Vb 10
\&    if ($ctx\->authenticate(
\&        {
\&            password => $password,
\&            \*(Aqdbix_class\*(Aq =>
\&                {
\&                    searchargs => [ { \-or => [ username => $username,
\&                                              email => $email,
\&                                              clientid => $clientid ]
\&                                   },
\&                                   { prefetch => qw/ preferences / }
\&                                 ]
\&                }
\&        } ) )
\&    {
\&        # do successful authentication actions here.
\&    }
.Ve
.Sp
The above would allow authentication based on any of the three items \-
username, email, or clientid \- and would prefetch the data related to that user
from the preferences table. The searchargs array is passed directly to the
\&\fIsearch()\fR method associated with the user_model.
.IP "Result" 4
.IX Item "Result"
The \fBresult\fR method of retrieval allows you to look up the user yourself and
pass on the loaded user to the authentication store.
.Sp
.Vb 1
\&    my $user = $ctx\->model(\*(AqMyApp::User\*(Aq)\->find({ ... });
\&
\&    if ($ctx\->authenticate({ dbix_class => { result => $user } })) {
\&        ...
\&    }
.Ve
.Sp
Be aware that the result method will not verify that you are passing a result
that is attached to the same user_model as specified in the config or even
loaded from the database, as opposed to existing only in memory. It's your
responsibility to make sure of that.
.IP "Resultset" 4
.IX Item "Resultset"
The \fBresultset\fR method of retrieval allows you to directly specify a
resultset to be used for user retrieval. This allows you to create a resultset
within your login action and use it for retrieving the user. A simple example:
.Sp
.Vb 2
\&    my $rs = $ctx\->model(\*(AqMyApp::User\*(Aq)\->search({ email => $ctx\->request\->params\->{\*(Aqemail\*(Aq} });
\&       ... # further $rs adjustments
\&
\&    if ($ctx\->authenticate({
\&                           password => $password,
\&                           \*(Aqdbix_class\*(Aq => { resultset => $rs }
\&                         })) {
\&       # do successful authentication actions here.
\&    }
.Ve
.Sp
Be aware that the resultset method will not verify that you are passing a
resultset that is attached to the same user_model as specified in the config.
.Sp
\&\s-1NOTE:\s0 The resultset and searchargs methods of user retrieval, consider the first
row returned to be the matching user. In most cases there will be only one
matching row, but it is easy to produce multiple rows, especially when using the
advanced retrieval methods. Remember, what you get when you use this module is
what you would get when calling search(...)\->first;
.Sp
\&\s-1NOTE\s0 \s-1ALSO:\s0  The user info used to save the user to the session and to retrieve
it is the same regardless of what method of retrieval was used.  In short,
the value in the id field (see 'id_field' config item) is used to retrieve the
user from the database upon restoring from the session.  When the DBIx::Class storage
module does this, it does so by doing a simple search using the id field.  In other
words, it will not use the same arguments you used to request the user initially.
This is especially important to those using the advanced methods of user retrieval.
If you need more complicated logic when reviving the user from the session, you will
most likely want to subclass the Catalyst::Authentication::Store::DBIx::Class::User class
and provide your own for_session and from_session routines.
.SH "METHODS"
.IX Header "METHODS"
There are no publicly exported routines in the DBIx::Class authentication
store (or indeed in most authentication stores). However, below is a
description of the routines required by Catalyst::Plugin::Authentication
for all authentication stores.  Please see the documentation for
Catalyst::Plugin::Authentication::Internals for more information.
.ie n .SS "new ( $config, $app )"
.el .SS "new ( \f(CW$config\fP, \f(CW$app\fP )"
.IX Subsection "new ( $config, $app )"
Constructs a new store object.
.ie n .SS "find_user ( $authinfo, $c )"
.el .SS "find_user ( \f(CW$authinfo\fP, \f(CW$c\fP )"
.IX Subsection "find_user ( $authinfo, $c )"
Finds a user using the information provided in the \f(CW$authinfo\fR hashref and
returns the user, or undef on failure. This is usually called from the
Credential. This translates directly to a call to
Catalyst::Authentication::Store::DBIx::Class::User's \fIload()\fR method.
.ie n .SS "for_session ( $c, $user )"
.el .SS "for_session ( \f(CW$c\fP, \f(CW$user\fP )"
.IX Subsection "for_session ( $c, $user )"
Prepares a user to be stored in the session. Currently returns the value of
the user's id field (as indicated by the 'id_field' config element)
.ie n .SS "from_session ( $c, $frozenuser)"
.el .SS "from_session ( \f(CW$c\fP, \f(CW$frozenuser\fP)"
.IX Subsection "from_session ( $c, $frozenuser)"
Revives a user from the session based on the info provided in \f(CW$frozenuser\fR.
Currently treats \f(CW$frozenuser\fR as an id and retrieves a user with a matching id.
.SS "user_supports"
.IX Subsection "user_supports"
Provides information about what the user object supports.
.ie n .SS "auto_update_user( $authinfo, $c, $res )"
.el .SS "auto_update_user( \f(CW$authinfo\fP, \f(CW$c\fP, \f(CW$res\fP )"
.IX Subsection "auto_update_user( $authinfo, $c, $res )"
This method is called if the realm's auto_update_user setting is true. It
will delegate to the user object's \f(CW\*(C`auto_update\*(C'\fR method.
.ie n .SS "auto_create_user( $authinfo, $c )"
.el .SS "auto_create_user( \f(CW$authinfo\fP, \f(CW$c\fP )"
.IX Subsection "auto_create_user( $authinfo, $c )"
This method is called if the realm's auto_create_user setting is true. It
will delegate to the user class's (resultset) \f(CW\*(C`auto_create\*(C'\fR method.
.SH "NOTES"
.IX Header "NOTES"
As of the current release, session storage consists of simply storing the user's
id in the session, and then using that same id to re-retrieve the user's information
from the database upon restoration from the session.  More dynamic storage of
user information in the session is intended for a future release.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
None known currently; please email the author if you find any.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Plugin::Authentication, Catalyst::Plugin::Authentication::Internals,
and Catalyst::Plugin::Authorization::Roles
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Kuri (jayk@cpan.org)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2007 the aforementioned authors. All rights
reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
