.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::OAuth 3"
.TH Net::OAuth 3 "2012-03-13" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::OAuth \- OAuth 1.0 for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Web Server Example (Dancer)
\&
\&  # This example is simplified for illustrative purposes, see the complete code in /demo
\&
\&  # Note that client_id is the Consumer Key and client_secret is the Consumer Secret
\&
\&  use Dancer;
\&  use Net::OAuth::Client;
\&
\&  sub client {
\&        Net::OAuth::Client\->new(
\&                config\->{client_id},
\&                config\->{client_secret},
\&                site => \*(Aqhttps://www.google.com/\*(Aq,
\&                request_token_path => \*(Aq/accounts/OAuthGetRequestToken?scope=https%3A%2F%2Fwww.google.com%2Fm8%2Ffeeds%2F\*(Aq,
\&                authorize_path => \*(Aq/accounts/OAuthAuthorizeToken\*(Aq,
\&                access_token_path => \*(Aq/accounts/OAuthGetAccessToken\*(Aq,
\&                callback => uri_for("/auth/google/callback"),
\&                session => \e&session,
\&        );
\&  }
\&
\&  # Send user to authorize with service provider
\&  get \*(Aq/auth/google\*(Aq => sub {
\&        redirect client\->authorize_url;
\&  };
\&
\&  # User has returned with token and verifier appended to the URL.
\&  get \*(Aq/auth/google/callback\*(Aq => sub {
\&
\&        # Use the auth code to fetch the access token
\&        my $access_token =  client\->get_access_token(params\->{oauth_token}, params\->{oauth_verifier});
\&
\&        # Use the access token to fetch a protected resource
\&        my $response = $access_token\->get(\*(Aq/m8/feeds/contacts/default/full\*(Aq);
\&
\&        # Do something with said resource...
\&
\&        if ($response\->is_success) {
\&          return "Yay, it worked: " . $response\->decoded_content;
\&        }
\&        else {
\&          return "Error: " . $response\->status_line;
\&        }
\&  };
\&
\&  dance;
.Ve
.SH "IMPORTANT"
.IX Header "IMPORTANT"
Net::OAuth provides a low-level \s-1API\s0 for reading and writing OAuth messages.
.PP
You probably should start with Net::OAuth::Client.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
OAuth is
.PP
\&\*(L"An open protocol to allow secure \s-1API\s0 authentication in a simple and standard method from desktop and web applications.\*(R"
.PP
In practical terms, OAuth is a mechanism for a Consumer to request protected resources from a Service Provider on behalf of a user.
.PP
Please refer to the OAuth spec: <http://oauth.net/documentation/spec>
.PP
Net::OAuth provides:
.IP "\(bu" 4
classes that encapsulate OAuth messages (requests and responses).
.IP "\(bu" 4
message signing
.IP "\(bu" 4
message serialization and parsing.
.IP "\(bu" 4
2\-legged requests (aka. tokenless requests, aka. consumer requests), see \*(L"\s-1CONSUMER\s0 \s-1REQUESTS\s0\*(R"
.PP
Net::OAuth does not provide:
.IP "\(bu" 4
Consumer or Service Provider encapsulation
.IP "\(bu" 4
token/nonce/key storage/management
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1OAUTH\s0 \s-1MESSAGES\s0"
.IX Subsection "OAUTH MESSAGES"
An OAuth message is a set of key-value pairs.  The following message types are supported:
.PP
Requests
.IP "\(bu" 4
Request Token (Net::OAuth::RequestTokenRequest)
.IP "\(bu" 4
Access Token (Net::OAuth::AccessTokenRequest)
.IP "\(bu" 4
User Authentication (Net::OAuth::UserAuthRequest)
.IP "\(bu" 4
Protected Resource (Net::OAuth::ProtectedResourceRequest)
.IP "\(bu" 4
Consumer Request (Net::OAuth::ConsumerRequest) (2\-legged / token-less request)
.PP
Responses
.IP "\(bu" 4
Request Token (Net::OAuth::RequestTokenResponse)
.IP "\(bu" 4
Access Token (Net::OAuth:AccessTokenResponse)
.IP "\(bu" 4
User Authentication (Net::OAuth::UserAuthResponse)
.PP
Each OAuth message type has one or more required parameters, zero or more optional parameters, and most allow arbitrary parameters.
.PP
All OAuth requests must be signed by the Consumer.  Responses from the Service Provider, however, are not signed.
.PP
To create a message, the easiest way is to use the factory methods (Net::OAuth\->request, Net::OAuth\->response, Net::OAuth\->message).  The following method invocations are all equivalent:
.PP
.Vb 4
\& $request = Net::OAuth\->request(\*(Aquser authentication\*(Aq)\->new(%params);
\& $request = Net::OAuth\->request(\*(Aquser_auth\*(Aq)\->new(%params);
\& $request = Net::OAuth\->request(\*(AqUserAuth\*(Aq)\->new(%params);
\& $request = Net::OAuth\->message(\*(AqUserAuthRequest\*(Aq)\->new(%params);
.Ve
.PP
The more verbose way is to use the class directly:
.PP
.Vb 2
\& use Net::OAuth::UserAuthRequest; 
\& $request = Net::OAuth::UserAuthRequest\->new(%params);
.Ve
.PP
You can also create a message by deserializing it from a Authorization header, \s-1URL\s0, query hash, or \s-1POST\s0 body
.PP
.Vb 5
\& $request = Net::OAuth\->request(\*(Aqprotected resource\*(Aq)\->from_authorization_header($ENV{HTTP_AUTHORIZATION}, %api_params);
\& $request = Net::OAuth\->request(\*(Aqprotected resource\*(Aq)\->from_url($url, %api_params);
\& $request = Net::OAuth\->request(\*(Aqprotected resource\*(Aq)\->from_hash({$q\->Vars}, %api_params); # CGI
\& $request = Net::OAuth\->request(\*(Aqprotected resource\*(Aq)\->from_hash($c\->request\->params, %api_params); # Catalyst
\& $response = Net::OAuth\->response(\*(Aqrequest token\*(Aq)\->from_post_body($response_content, %api_params);
.Ve
.PP
Note that the deserialization methods (as opposed to \fInew()\fR) expect OAuth protocol parameters to be prefixed with 'oauth_', as you would expect in a valid OAuth message.
.PP
Before sending a request, the Consumer must first sign it:
.PP
.Vb 1
\& $request\->sign;
.Ve
.PP
When receiving a request, the Service Provider should first verify the signature:
.PP
.Vb 1
\& die "Signature verification failed" unless $request\->verify;
.Ve
.PP
When sending a message the last step is to serialize it and send it to wherever it needs to go.  The following serialization methods are available:
.PP
.Vb 1
\& $response\->to_post_body # a application/x\-www\-form\-urlencoded POST body
\&
\& $request\->to_url # the query string of a URL
\&
\& $request\->to_authorization_header # the value of an HTTP Authorization header
\&
\& $request\->to_hash # a hash that could be used for some other serialization
.Ve
.SS "\s-1API\s0 \s-1PARAMETERS\s0 vs \s-1MESSAGE\s0 \s-1PARAMETERS\s0"
.IX Subsection "API PARAMETERS vs MESSAGE PARAMETERS"
Net::OAuth defines 'message parameters' as parameters that are part of the transmitted OAuth message.  These include any protocol parameter (prefixed with 'oauth_' in the message), and any additional message parameters (the extra_params hash).
.PP
\&'\s-1API\s0 parameters' are parameters required to build a message object that are not transmitted with the message, e.g. consumer_secret, token_secret, request_url, request_method.
.PP
There are various methods to inspect a message class to see what parameters are defined:
.PP
.Vb 7
\& $request\->required_message_params;
\& $request\->optional_message_params;
\& $request\->all_message_params;
\& $request\->required_api_params;
\& $request\->optional_api_params;
\& $request\->all_api_params;
\& $request\->all_params;
.Ve
.PP
E.g.
.PP
.Vb 3
\& use Net::OAuth;
\& use Data::Dumper;
\& print Dumper(Net::OAuth\->request("protected resource")\->required_message_params);
\&
\& $VAR1 = [
\&          \*(Aqconsumer_key\*(Aq,
\&          \*(Aqsignature_method\*(Aq,
\&          \*(Aqtimestamp\*(Aq,
\&          \*(Aqnonce\*(Aq,
\&          \*(Aqtoken\*(Aq
\&        ];
.Ve
.SS "\s-1ACCESSING\s0 \s-1PARAMETERS\s0"
.IX Subsection "ACCESSING PARAMETERS"
All parameters can be get/set using accessor methods. E.g.
.PP
.Vb 2
\& my $consumer_key = $request\->consumer_key;
\& $request\->request_method(\*(AqPOST\*(Aq);
.Ve
.SS "\s-1THE\s0 \s-1REQUEST_URL\s0 \s-1PARAMETER\s0"
.IX Subsection "THE REQUEST_URL PARAMETER"
Any query parameters in the request_url are removed and added to the extra_params hash when generating the signature.
.PP
E.g. the following requests are pretty much equivalent:
.PP
.Vb 7
\& my $request = Net::OAuth\->request(\*(AqRequest Token\*(Aq)\->new(
\&  %params,
\&  request_url => \*(Aqhttps://photos.example.net/request_token\*(Aq,
\&  extra_params => {
\&   foo => \*(Aqbar\*(Aq
\&  },
\&);
\&
\& my $request = Net::OAuth\->request(\*(AqRequest Token\*(Aq)\->new(
\&  %params,
\&  request_url => \*(Aqhttps://photos.example.net/request_token?foo=bar\*(Aq,
\& );
.Ve
.PP
Calling \f(CW$request\fR\->request_url will still return whatever you set it to originally. If you want to get the request_url with the query parameters removed, you can do:
.PP
.Vb 1
\&    my $url = $request\->normalized_request_url;
.Ve
.SS "\s-1SIGNATURE\s0 \s-1METHODS\s0"
.IX Subsection "SIGNATURE METHODS"
The following signature methods are supported:
.IP "\(bu" 4
\&\s-1PLAINTEXT\s0
.IP "\(bu" 4
\&\s-1HMAC\-SHA1\s0
.IP "\(bu" 4
\&\s-1HMAC\-SHA256\s0
.IP "\(bu" 4
\&\s-1RSA\-SHA1\s0
.PP
The signature method is determined by the value of the signature_method parameter that is passed to the message constructor.
.PP
If an unknown signature method is specified, the signing/verification will throw an exception.
.PP
\fI\s-1PLAINTEXT\s0 \s-1SIGNATURES\s0\fR
.IX Subsection "PLAINTEXT SIGNATURES"
.PP
This method is a trivial signature which adds no security.  Not recommended.
.PP
\fI\s-1HMAC\-SHA1\s0 \s-1SIGNATURES\s0\fR
.IX Subsection "HMAC-SHA1 SIGNATURES"
.PP
This method is available if you have Digest::HMAC_SHA1 installed.  This is by far the most commonly used method.
.PP
\fI\s-1HMAC\-SHA256\s0 \s-1SIGNATURES\s0\fR
.IX Subsection "HMAC-SHA256 SIGNATURES"
.PP
This method is available if you have Digest::SHA installed.
.PP
\fI\s-1RSA\-SHA1\s0 \s-1SIGNATURES\s0\fR
.IX Subsection "RSA-SHA1 SIGNATURES"
.PP
To use \s-1RSA\-SHA1\s0 signatures, pass in a Crypt::OpenSSL::RSA object (or any object that can do \f(CW$o\fR\->sign($str) and/or \f(CW$o\fR\->verify($str, \f(CW$sig\fR))
.PP
E.g.
.PP
Consumer:
.PP
.Vb 6
\& use Crypt::OpenSSL::RSA;
\& use File::Slurp;
\& $keystring = read_file(\*(Aqprivate_key.pem\*(Aq);
\& $private_key = Crypt::OpenSSL::RSA\->new_private_key($keystring);
\& $request = Net::OAuth\->request(\*(Aqrequest token\*(Aq)\->new(%params);
\& $request\->sign($private_key);
.Ve
.PP
Service Provider:
.PP
.Vb 8
\& use Crypt::OpenSSL::RSA;
\& use File::Slurp;
\& $keystring = read_file(\*(Aqpublic_key.pem\*(Aq);
\& $public_key = Crypt::OpenSSL::RSA\->new_public_key($keystring);
\& $request = Net::OAuth\->request(\*(Aqrequest token\*(Aq)\->new(%params);
\& if (!$request\->verify($public_key)) {
\&        die "Signature verification failed";
\& }
.Ve
.PP
Note that you can pass the key in as a parameter called 'signature_key' to the message constructor, rather than passing it to the sign/verify method, if you like.
.SS "\s-1CONSUMER\s0 \s-1REQUESTS\s0"
.IX Subsection "CONSUMER REQUESTS"
To send a request without including a token, use a Consumer Request:
.PP
.Vb 9
\&    my $request = Net::OAuth\->request(\*(Aqconsumer\*(Aq)\->new(
\&            consumer_key => \*(Aqdpf43f3p2l4k3l03\*(Aq,
\&            consumer_secret => \*(Aqkd94hf93k423kf44\*(Aq,
\&            request_url => \*(Aqhttp://provider.example.net/profile\*(Aq,
\&            request_method => \*(AqGET\*(Aq,
\&            signature_method => \*(AqHMAC\-SHA1\*(Aq,
\&            timestamp => \*(Aq1191242096\*(Aq,
\&            nonce => \*(Aqkllo9940pd9333jh\*(Aq,
\&    );
\&
\&    $request\->sign;
.Ve
.PP
See Net::OAuth::ConsumerRequest
.SS "I18N"
.IX Subsection "I18N"
Per the OAuth spec, when making the signature Net::OAuth first encodes parameters to \s-1UTF\-8\s0. This means that any parameters you pass to Net::OAuth, if they might be outside of \s-1ASCII\s0 character set, should be run through \fIEncode::decode()\fR (or an equivalent PerlIO layer) first to decode them to Perl's internal character sructure.
.SS "\s-1OAUTH\s0 1.0A"
.IX Subsection "OAUTH 1.0A"
Background:
.PP
http://mojodna.net/2009/05/20/an\-idiots\-guide\-to\-oauth\-10a.html <http://mojodna.net/2009/05/20/an-idiots-guide-to-oauth-10a.html>
.PP
http://oauth.googlecode.com/svn/spec/core/1.0a/drafts/3/oauth\-core\-1_0a.html <http://oauth.googlecode.com/svn/spec/core/1.0a/drafts/3/oauth-core-1_0a.html>
.PP
Net::OAuth defaults to OAuth 1.0 spec compliance, and supports OAuth 1.0 Rev A with an optional switch:
.PP
.Vb 2
\& use Net::OAuth
\& $Net::OAuth::PROTOCOL_VERSION = Net::OAuth::PROTOCOL_VERSION_1_0A;
.Ve
.PP
It is recommended that any new projects use this switch if possible, and existing projects move to supporting this switch as soon as possible.  Probably the easiest way for existing projects to do this is to turn on the switch and run your test suite.  The Net::OAuth constructor will throw an exception where the new protocol parameters (callback, callback_confirmed, verifier) are missing.
.PP
Internally, the Net::OAuth::Message constructor checks \f(CW$Net::OAuth::PROTOCOL_VERSION\fR and attempts to load the equivalent subclass in the Net::OAuth::V1_0A:: namespace.  So if you instantiate a Net::OAuth::RequestTokenRequest object, you will end up with a Net::OAuth::V1_0A::RequestTokenRequest (a subclass of Net::OAuth::RequestTokenRequest) if the protocol version is set to \s-1PROTOCOL_VERSION_1_0A\s0.  You can also select a 1.0a subclass on a per-message basis by passing
.PP
.Vb 1
\&    protocol_version => Net::OAuth::PROTOCOL_VERSION_1_0A
.Ve
.PP
in the \s-1API\s0 parameters hash.
.PP
If you are not sure whether the entity you are communicating with is 1.0A compliant, you can try instantiating a 1.0A message first and then fall back to 1.0 if that fails:
.PP
.Vb 10
\&    use Net::OAuth
\&    $Net::OAuth::PROTOCOL_VERSION = Net::OAuth::PROTOCOL_VERSION_1_0A;
\&    my $is_oauth_1_0 = 0;
\&    my $response = eval{Net::OAuth\->response(\*(Aqrequest token\*(Aq)\->from_post_body($res\->content)};
\&    if ($@) {
\&        if ($@ =~ /Missing required parameter \*(Aqcallback_confirmed\*(Aq/) {
\&            # fall back to OAuth 1.0
\&            $response = Net::OAuth\->response(\*(Aqrequest token\*(Aq)\->from_post_body(
\&                $res\->content, 
\&                protocol_version => Net::OAuth::PROTOCOL_VERSION_1_0
\&            );
\&            $is_oauth_1_0 = 1; # from now on treat the server as OAuth 1.0 compliant
\&        }
\&        else {
\&            die $@;
\&        }
\&    }
.Ve
.PP
At some point in the future, Net::OAuth will default to Net::OAuth::PROTOCOL_VERSION_1_0A.
.SH "DEMO"
.IX Header "DEMO"
There is a demo Consumer \s-1CGI\s0 in this package, also available online at <http://oauth.kg23.com/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://oauth.net>
.PP
Check out Net::OAuth::Simple \- it has a simpler \s-1API\s0 that may be more to your liking
.PP
Check out Net::Twitter::OAuth for a Twitter-specific OAuth \s-1API\s0
.PP
Check out WWW::Netflix::API for a Netflix-specific OAuth \s-1API\s0
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Support for repeating/multivalued parameters
.IP "\(bu" 4
Add convenience methods for SPs
.Sp
Something like:
.Sp
.Vb 2
\&    # direct from CGI.pm object
\&    $request = Net::OAuth\->request(\*(AqRequest Token\*(Aq)\->from_cgi_query($cgi, %api_params);
\&    
\&    # direct from Catalyst::Request object
\&    $request = Net::OAuth\->request(\*(AqRequest Token\*(Aq)\->from_catalyst_request($c\->req, %api_params); 
\&    
\&    # from Auth header and GET and POST params in one
\&    local $/;
\&    my $post_body = <STDIN>;
\&    $request = Net::OAuth\->request(\*(AqRequest Token\*(Aq)\->from_auth_get_and_post(
\&        $ENV{HTTP_AUTHORIZATION}, 
\&        $ENV{QUERY_STRING},
\&        $post_body,
\&        %api_params
\&    );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Keith Grennan, \f(CW\*(C`<kgrennan at cpan.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Keith Grennan, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
