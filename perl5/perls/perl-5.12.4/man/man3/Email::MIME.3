.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Email::MIME 3"
.TH Email::MIME 3 "2011-09-13" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::MIME \- Easy MIME message parsing.
.SH "VERSION"
.IX Header "VERSION"
version 1.910
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Email::MIME;
\&  my $parsed = Email::MIME\->new($message);
\&
\&  my @parts = $parsed\->parts; # These will be Email::MIME objects, too.
\&  my $decoded = $parsed\->body;
\&  my $non_decoded = $parsed\->body_raw;
\&
\&  my $content_type = $parsed\->content_type;
.Ve
.PP
\&...or...
.PP
.Vb 2
\&  use Email::MIME::Creator;
\&  use IO::All;
\&
\&  # multipart message
\&  my @parts = (
\&      Email::MIME\->create(
\&          attributes => {
\&              filename     => "report.pdf",
\&              content_type => "application/pdf",
\&              encoding     => "quoted\-printable",
\&              name         => "2004\-financials.pdf",
\&          },
\&          body => io( "2004\-financials.pdf" )\->all,
\&      ),
\&      Email::MIME\->create(
\&          attributes => {
\&              content_type => "text/plain",
\&              disposition  => "attachment",
\&              charset      => "US\-ASCII",
\&          },
\&          body_str => "Hello there!",
\&      ),
\&  );
\&
\&  my $email = Email::MIME\->create(
\&      header_str => [ From => \*(Aqcasey@geeknest.com\*(Aq ],
\&      parts      => [ @parts ],
\&  );
\&
\&  # nesting parts
\&  $email\->parts_set(
\&      [
\&        $email\->parts,
\&        Email::MIME\->create( parts => [ @parts ] ),
\&      ],
\&  );
\&  
\&  # standard modifications
\&  $email\->header_str_set( \*(AqX\-PoweredBy\*(Aq => \*(AqRT v3.0\*(Aq      );
\&  $email\->header_str_set( To            => rcpts()        );
\&  $email\->header_str_set( Cc            => aux_rcpts()    );
\&  $email\->header_str_set( Bcc           => sekrit_rcpts() );
\&
\&  # more advanced
\&  $_\->encoding_set( \*(Aqbase64\*(Aq ) for $email\->parts;
\&  
\&  # Quick multipart creation
\&  my $quicky = Email::MIME\->create(
\&      header_str => [
\&          From => \*(Aqmy@address\*(Aq,
\&          To   => \*(Aqyour@address\*(Aq,
\&      ],
\&      parts => [
\&          q[This is part one],
\&          q[This is part two],
\&          q[These could be binary too],
\&      ],
\&  );
\&  
\&  print $email\->as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an extension of the Email::Simple module, to handle \s-1MIME\s0
encoded messages. It takes a message as a string, splits it up into its
constituent parts, and allows you access to various parts of the
message. Headers are decoded from \s-1MIME\s0 encoding.
.SH "METHODS"
.IX Header "METHODS"
Please see Email::Simple for the base set of methods. It won't take
very long. Added to that, you have:
.SS "create"
.IX Subsection "create"
.Vb 5
\&  my $single = Email::MIME\->create(
\&    header_str => [ ... ],
\&    body_str   => \*(Aq...\*(Aq,
\&    attributes => { ... },
\&  );
\&  
\&  my $multi = Email::MIME\->create(
\&    header_str => [ ... ],
\&    parts      => [ ... ],
\&    attributes => { ... },
\&  );
.Ve
.PP
This method creates a new \s-1MIME\s0 part. The \f(CW\*(C`header_str\*(C'\fR parameter is a list of
headers pairs to include in the message. The value for each pair is expected to
be a text string that will be MIME-encoded as needed.  A similar \f(CW\*(C`header\*(C'\fR
parameter can be provided in addition to or instead of \f(CW\*(C`header_str\*(C'\fR.  Its
values will be used verbatim.
.PP
\&\f(CW\*(C`attributes\*(C'\fR is a hash of \s-1MIME\s0 attributes to assign to the part, and may
override portions of the header set in the \f(CW\*(C`header\*(C'\fR parameter.
.PP
The \f(CW\*(C`parts\*(C'\fR parameter is a list reference containing \f(CW\*(C`Email::MIME\*(C'\fR
objects. Elements of the \f(CW\*(C`parts\*(C'\fR list can also be a non-reference
string of data. In that case, an \f(CW\*(C`Email::MIME\*(C'\fR object will be created
for you. Simple checks will determine if the part is binary or not, and
all parts created in this fashion are encoded with \f(CW\*(C`base64\*(C'\fR, just in case.
.PP
If \f(CW\*(C`body\*(C'\fR is given instead of \f(CW\*(C`parts\*(C'\fR, it specifies the body to be used for a
flat (subpart-less) \s-1MIME\s0 message.  It is assumed to be a sequence of octets.
.PP
If \f(CW\*(C`body_str\*(C'\fR is given instead of \f(CW\*(C`body\*(C'\fR or \f(CW\*(C`parts\*(C'\fR, it is assumed to be a
character string to be used as the body.  If you provide a \f(CW\*(C`body_str\*(C'\fR
parameter, you \fBmust\fR provide \f(CW\*(C`charset\*(C'\fR and \f(CW\*(C`encoding\*(C'\fR attributes.
.PP
Back to \f(CW\*(C`attributes\*(C'\fR. The hash keys correspond directly to methods or
modifying a message from \f(CW\*(C`Email::MIME::Modifier\*(C'\fR. The allowed keys are:
content_type, charset, name, format, boundary, encoding, disposition,
and filename. They will be mapped to \f(CW"$attr\e_set"\fR for message
modification.
.SS "content_type_set"
.IX Subsection "content_type_set"
.Vb 1
\&  $email\->content_type_set( \*(Aqtext/html\*(Aq );
.Ve
.PP
Change the content type. All \f(CW\*(C`Content\-Type\*(C'\fR header attributes
will remain intact.
.SS "charset_set"
.IX Subsection "charset_set"
.SS "name_set"
.IX Subsection "name_set"
.SS "format_set"
.IX Subsection "format_set"
.SS "boundary_set"
.IX Subsection "boundary_set"
.Vb 4
\&  $email\->charset_set( \*(Aqutf8\*(Aq );
\&  $email\->name_set( \*(Aqsome_filename.txt\*(Aq );
\&  $email\->format_set( \*(Aqflowed\*(Aq );
\&  $email\->boundary_set( undef ); # remove the boundary
.Ve
.PP
These four methods modify common \f(CW\*(C`Content\-Type\*(C'\fR attributes. If set to
\&\f(CW\*(C`undef\*(C'\fR, the attribute is removed. All other \f(CW\*(C`Content\-Type\*(C'\fR header
information is preserved when modifying an attribute.
.SS "encoding_set"
.IX Subsection "encoding_set"
.Vb 3
\&  $email\->encoding_set( \*(Aqbase64\*(Aq );
\&  $email\->encoding_set( \*(Aqquoted\-printable\*(Aq );
\&  $email\->encoding_set( \*(Aq8bit\*(Aq );
.Ve
.PP
Convert the message body and alter the \f(CW\*(C`Content\-Transfer\-Encoding\*(C'\fR
header using this method. Your message body, the output of the \f(CW\*(C`body()\*(C'\fR
method, will remain the same. The raw body, output with the \f(CW\*(C`body_raw()\*(C'\fR
method, will be changed to reflect the new encoding.
.SS "body_set"
.IX Subsection "body_set"
.Vb 1
\&  $email\->body_set( $unencoded_body_string );
.Ve
.PP
This method will encode the new body you send using the encoding
specified in the \f(CW\*(C`Content\-Transfer\-Encoding\*(C'\fR header, then set
the body to the new encoded body.
.PP
This method overrides the default \f(CW\*(C`body_set()\*(C'\fR method.
.SS "body_str_set"
.IX Subsection "body_str_set"
.Vb 1
\&  $email\->body_str_set($unicode_str);
.Ve
.PP
This method behaves like \f(CW\*(C`body_set\*(C'\fR, but assumes that the given value is a
Unicode string that should be encoded into the message's charset before being
set.  If the charset can't be determined, an exception is thrown.
.SS "disposition_set"
.IX Subsection "disposition_set"
.Vb 1
\&  $email\->disposition_set( \*(Aqattachment\*(Aq );
.Ve
.PP
Alter the \f(CW\*(C`Content\-Disposition\*(C'\fR of a message. All header attributes
will remain intact.
.SS "filename_set"
.IX Subsection "filename_set"
.Vb 1
\&  $email\->filename_set( \*(Aqboo.pdf\*(Aq );
.Ve
.PP
Sets the filename attribute in the \f(CW\*(C`Content\-Disposition\*(C'\fR header. All other
header information is preserved when setting this attribute.
.SS "parts_set"
.IX Subsection "parts_set"
.Vb 1
\&  $email\->parts_set( \e@new_parts );
.Ve
.PP
Replaces the parts for an object. Accepts a reference to a list of
\&\f(CW\*(C`Email::MIME\*(C'\fR objects, representing the new parts. If this message was
originally a single part, the \f(CW\*(C`Content\-Type\*(C'\fR header will be changed to
\&\f(CW\*(C`multipart/mixed\*(C'\fR, and given a new boundary attribute.
.SS "parts_add"
.IX Subsection "parts_add"
.Vb 1
\&  $email\->parts_add( \e@more_parts );
.Ve
.PP
Adds \s-1MIME\s0 parts onto the current \s-1MIME\s0 part. This is a simple extension
of \f(CW\*(C`parts_set\*(C'\fR to make our lives easier. It accepts an array reference
of additional parts.
.SS "walk_parts"
.IX Subsection "walk_parts"
.Vb 3
\&  $email\->walk_parts(sub {
\&      my ($part) = @_;
\&      return if $part\->subparts; # multipart
\&      
\&      if ( $part\->content_type =~ m[text/html]i ) {
\&          my $body = $part\->body;
\&          $body =~ s/<link [^>]+>//; # simple filter example
\&          $part\->body_set( $body );
\&      }
\&  });
.Ve
.PP
Walks through all the \s-1MIME\s0 parts in a message and applies a callback to
each. Accepts a code reference as its only argument. The code reference
will be passed a single argument, the current \s-1MIME\s0 part within the
top-level \s-1MIME\s0 object. All changes will be applied in place.
.SS "header_str_set"
.IX Subsection "header_str_set"
.Vb 1
\&  $email\->header_str_set($header_name => @value_strings);
.Ve
.PP
This behaves like \f(CW\*(C`header_set\*(C'\fR, but expects Unicode (character) strings as the
values to set, rather than pre-encoded byte strings.  It will encode them as
\&\s-1MIME\s0 encoded-words if they contain any control or 8\-bit characters.
.SS "parts"
.IX Subsection "parts"
This returns a list of \f(CW\*(C`Email::MIME\*(C'\fR objects reflecting the parts of the
message. If it's a single-part message, you get the original object back.
.PP
In scalar context, this method returns the number of parts.
.SS "subparts"
.IX Subsection "subparts"
This returns a list of \f(CW\*(C`Email::MIME\*(C'\fR objects reflecting the parts of the
message.  If it's a single-part message, this method returns an empty list.
.PP
In scalar context, this method returns the number of subparts.
.SS "body"
.IX Subsection "body"
This decodes and returns the body of the object \fIas a byte string\fR. For
top-level objects in multi-part messages, this is highly likely to be something
like \*(L"This is a multi-part message in \s-1MIME\s0 format.\*(R"
.SS "body_str"
.IX Subsection "body_str"
This decodes both the Content-Transfer-Encoding layer of the body (like the
\&\f(CW\*(C`body\*(C'\fR method) as well as the charset encoding of the body (unlike the \f(CW\*(C`body\*(C'\fR
method), returning a Unicode string.
.PP
If the charset is known, it is used.  If there is no charset but the content
type is either \f(CW\*(C`text/plain\*(C'\fR or \f(CW\*(C`text/html\*(C'\fR, us-ascii is assumed.  Otherwise,
an exception is thrown.
.SS "body_raw"
.IX Subsection "body_raw"
This returns the body of the object, but doesn't decode the transfer encoding.
.SS "decode_hook"
.IX Subsection "decode_hook"
This method is called before the Email::MIME::Encodings \f(CW\*(C`decode\*(C'\fR method, to
decode the body of non-binary messages (or binary messages, if the
\&\f(CW\*(C`force_decode_hook\*(C'\fR method returns true).  By default, this method does
nothing, but subclasses may define behavior.
.PP
This method could be used to implement the decryption of content in secure
email, for example.
.SS "content_type"
.IX Subsection "content_type"
This is a shortcut for access to the content type header.
.SS "filename"
.IX Subsection "filename"
This provides the suggested filename for the attachment part. Normally
it will return the filename from the headers, but if \f(CW\*(C`filename\*(C'\fR is
passed a true parameter, it will generate an appropriate \*(L"stable\*(R"
filename if one is not found in the \s-1MIME\s0 headers.
.SS "invent_filename"
.IX Subsection "invent_filename"
.Vb 1
\&  my $filename = Email::MIME\->invent_filename($content_type);
.Ve
.PP
This routine is used by \f(CW\*(C`filename\*(C'\fR to generate filenames for attached files.
It will attempt to choose a reasonable extension, falling back to \fIdat\fR.
.SS "debug_structure"
.IX Subsection "debug_structure"
.Vb 1
\&  my $description = $email\->debug_structure;
.Ve
.PP
This method returns a string that describes the structure of the \s-1MIME\s0 entity.
For example:
.PP
.Vb 3
\&  + multipart/alternative; boundary="=_NextPart_2"; charset="BIG\-5"
\&    + text/plain
\&    + text/html
.Ve
.SH "TODO"
.IX Header "TODO"
All of the Email::MIME\-specific guts should move to a single entry on the
object's guts.  This will require changes to both Email::MIME and
Email::MIME::Modifier, sadly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Email::Simple, Email::MIME::Modifier, Email::MIME::Creator.
.SH "PERL EMAIL PROJECT"
.IX Header "PERL EMAIL PROJECT"
This module is maintained by the Perl Email Project
.PP
<http://emailproject.perl.org/wiki/Email::MIME>
.SH "AUTHOR"
.IX Header "AUTHOR"
Casey West, \f(CW\*(C`casey@geeknest.com\*(C'\fR
.PP
Simon Cozens, \f(CW\*(C`simon@cpan.org\*(C'\fR (retired)
.PP
This software is copyright (c) 2004 by Simon Cozens.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as perl itself.
.SH "THANKS"
.IX Header "THANKS"
This module was generously sponsored by Best Practical
(http://www.bestpractical.com/) and Pete Sergeant.
