.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::FormValidator 3"
.TH Data::FormValidator 3 "2012-02-08" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::FormValidator \- Validates user input (usually from an HTML form) based
on input profile.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Data::FormValidator;
\&
\& my $results = Data::FormValidator\->check(\e%input_hash, \e%dfv_profile);
\&
\& if ($results\->has_invalid or $results\->has_missing) {
\&     # do something with $results\->invalid, $results\->missing
\&     # or  $results\->msgs
\& }
\& else {
\&     # do something with $results\->valid
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::FormValidator's main aim is to make input validation expressible in a
simple format.
.PP
Data::FormValidator lets you define profiles which declare the
required and optional fields and any constraints they might have.
.PP
The results are provided as an object which makes it easy to handle
missing and invalid results, return error messages about which constraints
failed, or process the resulting valid data.
.SH "VALIDATING INPUT"
.IX Header "VALIDATING INPUT"
.SS "\fIcheck()\fP"
.IX Subsection "check()"
.Vb 1
\& my $results = Data::FormValidator\->check(\e%input_hash, \e%dfv_profile);
.Ve
.PP
\&\f(CW\*(C`check\*(C'\fR is the recommended method to use to validate forms. It returns its results as a
Data::FormValidator::Results object.  A
deprecated method \f(CW\*(C`validate\*(C'\fR is also available, returning its results as an
array described below.
.PP
.Vb 2
\& use Data::FormValidator;
\& my $results = Data::FormValidator\->check(\e%input_hash, \e%dfv_profile);
.Ve
.PP
Here, \f(CW\*(C`check()\*(C'\fR is used as a class method, and takes two required parameters.
.PP
The first a reference to the data to be be validated. This can either be a hash
reference, or a \s-1CGI\s0.pm\-like object. In particular, the object must have a \fIparam()\fR
method that works like the one in \s-1CGI\s0.pm does. CGI::Simple and Apache::Request
objects are known to work in particular. Note that if you use a hash reference,
multiple values for a single key should be presented as an array reference.
.PP
The second argument is a reference to the profile you are validating.
.SS "\fIvalidate()\fP"
.IX Subsection "validate()"
.Vb 2
\&    my( $valids, $missings, $invalids, $unknowns ) =
\&        Data::FormValidator\->validate( \e%input_hash, \e%dfv_profile);
.Ve
.PP
\&\f(CW\*(C`validate()\*(C'\fR provides a deprecated alternative to \f(CW\*(C`check()\*(C'\fR. It has the same input
syntax, but returns a four element array, described as follows
.IP "valids" 4
.IX Item "valids"
This is a hash reference to the valid fields which were submitted in
the data. The data may have been modified by the various filters specified.
.IP "missings" 4
.IX Item "missings"
This is a reference to an array which contains the name of the missing
fields. Those are the fields that the user forget to fill or filled
with spaces. These fields may comes from the \fIrequired\fR list or the
\&\fIdependencies\fR list.
.IP "invalids" 4
.IX Item "invalids"
This is a reference to an array which contains the name of the fields which
failed one or more of their constraint checks. If there are no invalid fields,
an empty arrayref will be returned.
.Sp
Fields defined with multiple constraints will have an array ref returned in the
\&\f(CW@invalids\fR array instead of a string. The first element in this array is the
name of the field, and the remaining fields are the names of the failed
constraints.
.IP "unknowns" 4
.IX Item "unknowns"
This is a list of fields which are unknown to the profile. Whether or
not this indicates an error in the user input is application
dependent.
.SS "\fInew()\fP"
.IX Subsection "new()"
Using \f(CW\*(C`new()\*(C'\fR is only needed for advanced usage, including these cases:
.IP "o" 4
.IX Item "o"
Loading more than one profile at a time. Then you can select the profile you
want by name later with \f(CW\*(C`check()\*(C'\fR. Here's an example:
.Sp
.Vb 4
\& my $dfv = Data::FormValidator\->new({
\&    profile_1 => { # usual profile definition here },
\&    profile_2 => { # another profile definition },
\& });
.Ve
.Sp
As illustrated, multiple profiles are defined through a hash ref whose keys point
to profile definitions.
.Sp
You can also load several profiles from a file, by defining several profiles as shown above
in an external file. Then just pass in the name of the file:
.Sp
.Vb 1
\& my $dfv = Data::FormValidator\->new(\*(Aq/path/to/profiles.pl\*(Aq);
.Ve
.Sp
If the input profile is specified as a file name, the profiles will be reread
each time that the disk copy is modified.
.Sp
Now when calling \f(CW\*(C`check()\*(C'\fR, you just need to supply the profile name:
.Sp
.Vb 1
\& my $results = $dfv\->check(\e%input_hash,\*(Aqprofile_1\*(Aq);
.Ve
.IP "o" 4
.IX Item "o"
Applying defaults to more than one input profile. There are some parts
of the validation profile that you might like to re-use for many form
validations.
.Sp
To facilitate this, \f(CW\*(C`new()\*(C'\fR takes a second argument, a hash reference. Here
the usual input profile definitions can be made. These will act as defaults for
any subsequent calls to \f(CW\*(C`check()\*(C'\fR on this object.
.Sp
Currently the logic for this is very simple. Any definition of a key in your
validation profile will completely overwrite your default value.
.Sp
This means you can't define two keys for \f(CW\*(C`constraint_regexp_map\*(C'\fR and expect
they will always be there. This kind of feature may be added in the future.
.Sp
The exception here is definitions for your \f(CW\*(C`msgs\*(C'\fR key. You will safely  be
able to define some defaults for the top level keys within \f(CW\*(C`msgs\*(C'\fR and not have
them clobbered just because \f(CW\*(C`msgs\*(C'\fR was defined in a validation profile.
.Sp
One way to use this feature is to create your own sub-class that always provides
your defaults to \f(CW\*(C`new()\*(C'\fR.
.Sp
Another option is to create your own wrapper routine which provides these defaults to
\&\f(CW\*(C`new()\*(C'\fR.  Here's an example of a routine you might put in a
CGI::Application super-class to make use of this feature:
.Sp
.Vb 6
\& # Always use the built\-in CGI object as the form data
\& # and provide some defaults to new constructor
\& sub check_form {
\&     my $self = shift;
\&     my $profile = shift
\&        || die \*(Aqcheck_form: missing required profile\*(Aq;
\&
\&     require Data::FormValidator;
\&     my $dfv = Data::FormValidator\->new({},{
\&        # your defaults here
\&     });
\&     return $dfv\->check($self\->query,$profile);
\& }
.Ve
.SH "INPUT PROFILE SPECIFICATION"
.IX Header "INPUT PROFILE SPECIFICATION"
An input profile is a hash reference containing one or more of the following
keys.
.PP
Here is a very simple input profile. Examples of more advanced options are
described below.
.PP
.Vb 1
\&    use Data::FormValidator::Constraints qw(:closures);
\&
\&    my $profile = {
\&        optional => [qw( company
\&                         fax
\&                         country )],
\&
\&        required => [qw( fullname
\&                         phone
\&                         email
\&                         address )],
\&
\&        constraint_methods => {
\&            email => email(),
\&        }
\&    };
.Ve
.PP
That defines some fields as optional, some as required, and defines that the
field named 'email' must pass the constraint named 'email'.
.PP
Here is a complete list of the keys available in the input profile, with
examples of each.
.SS "required"
.IX Subsection "required"
This is an array reference which contains the name of the fields which are
required. Any fields in this list which are not present or contain only
spaces will be reported as missing.
.SS "required_regexp"
.IX Subsection "required_regexp"
.Vb 1
\& required_regexp => qr/city|state|zipcode/,
.Ve
.PP
This is a regular expression used to specify additional field names for which values
will be required.
.SS "require_some"
.IX Subsection "require_some"
.Vb 4
\& require_some => {
\&    # require any two fields from this group
\&    city_or_state_or_zipcode => [ 2, qw/city state zipcode/ ],
\& }
.Ve
.PP
This is a reference to a hash which defines groups of fields where 1 or more
fields from the group should be required, but exactly which fields doesn't
matter. The keys in the hash are the group names.  These are returned as
\&\*(L"missing\*(R" unless the required number of fields from the group has been filled
in. The values in this hash are array references. The first element in this
array should be the number of fields in the group that is required. If the
first field in the array is not an a digit, a default of \*(L"1\*(R" will be used.
.SS "optional"
.IX Subsection "optional"
.Vb 1
\& optional => [qw/meat coffee chocolate/],
.Ve
.PP
This is an array reference which contains the name of optional fields.
These are fields which \s-1MAY\s0 be present and if they are, they will be
checked for valid input. Any fields not in optional or required list
will be reported as unknown.
.SS "optional_regexp"
.IX Subsection "optional_regexp"
.Vb 1
\& optional_regexp => qr/_province$/,
.Ve
.PP
This is a regular expression used to specify additional fields which are
optional. For example, if you wanted all fields names that begin with \fIuser_\fR
to be optional, you could use the regular expression, /^user_/
.SS "dependencies"
.IX Subsection "dependencies"
.Vb 1
\& dependencies   => {
\&
\&    # If cc_no is entered, make cc_type and cc_exp required
\&    "cc_no" => [ qw( cc_type cc_exp ) ],
\&
\&    # if pay_type eq \*(Aqcheck\*(Aq, require check_no
\&    "pay_type" => {
\&        check => [ qw( check_no ) ],
\&     }
\&
\&    # if cc_type is VISA or MASTERCARD require CVV
\&    "cc_type" => sub {
\&        my $dfv  = shift;
\&        my $type = shift;
\&
\&        return [ \*(Aqcc_cvv\*(Aq ] if ($type eq "VISA" || $type eq "MASTERCARD");
\&        return [ ];
\&    },
\& },
.Ve
.PP
This is for the case where an optional field has other requirements.  The
dependent fields can be specified with an array reference.
.PP
If the dependencies are specified with a hash reference then the additional
constraint is added that the optional field must equal a key for the
dependencies to be added.
.PP
If the dependencies are specified as a code reference then the code will be
executed to determine the dependent fields.  It is passed two parameters,
the object and the value of the field, and it should return an array reference
containing the list of dependent fields.
.PP
Any fields in the dependencies list that are missing when the target is present
will be reported as missing.
.SS "dependency_groups"
.IX Subsection "dependency_groups"
.Vb 4
\& dependency_groups  => {
\&     # if either field is filled in, they all become required
\&     password_group => [qw/password password_confirmation/],
\& }
.Ve
.PP
This is a hash reference which contains information about groups of
interdependent fields. The keys are arbitrary names that you create and
the values are references to arrays of the field names in each group.
.SS "defaults"
.IX Subsection "defaults"
.Vb 3
\& defaults => {
\&     country => "USA",
\& },
.Ve
.PP
This is a hash reference where keys are field names and
values are defaults to use if input for the field is missing.
.PP
The values can be code refs which will be used to calculate the
value if needed. These code refs will be passed in the DFV::Results
object as the only parameter.
.PP
The defaults are set shortly before the constraints are applied, and
will be returned with the other valid data.
.SS "defaults_regexp_map"
.IX Subsection "defaults_regexp_map"
.Vb 3
\&  defaults_regexp_map => {
\&      qr/^opt_/ => 1,
\&  },
.Ve
.PP
This is a hash reference that maps  regular expressions to default values to
use for matching optional or required fields.
.PP
It's useful if you have generated many checkbox fields with the similar names.
Since checkbox fields submit nothing at all when they are not checked, it's
useful to set defaults for them.
.PP
Note that it doesn't make sense to use a default for a field handled by
\&\f(CW\*(C`optional_regexp\*(C'\fR or \f(CW\*(C`required_regexp\*(C'\fR.  When the field is not submitted,
there is no way to know that it should be optional or required, and thus there's
no way to know that a default should be set for it.
.SS "filters"
.IX Subsection "filters"
.Vb 2
\& # trim leading and trailing whitespace on all fields
\& filters       => [\*(Aqtrim\*(Aq],
.Ve
.PP
This is a reference to an array of filters that will be applied to \s-1ALL\s0 optional
and required fields, \fBbefore\fR any constraints are applied.
.PP
This can be the name of a built-in filter
(trim,digit,etc) or an anonymous subroutine which should take one parameter,
the field value and return the (possibly) modified value.
.PP
Filters modify the data returned through the results object, so use them carefully.
.PP
See Data::FormValidator::Filters for details on the built-in filters.
.SS "field_filters"
.IX Subsection "field_filters"
.Vb 3
\& field_filters => {
\&     cc_no => [\*(Aqdigit\*(Aq],
\& },
.Ve
.PP
A hash ref with field names as keys. Values are array references of built-in
filters to apply (trim,digit,etc) or an anonymous subroutine which should take
one parameter, the field value and return the (possibly) modified value.
.PP
Filters are applied \fBbefore\fR any constraints are applied.
.PP
See Data::FormValidator::Filters for details on the built-in filters.
.SS "field_filter_regexp_map"
.IX Subsection "field_filter_regexp_map"
.Vb 4
\& field_filter_regexp_map => {
\&     # Upper\-case the first letter of all fields that end in "_name"
\&     qr/_name$/    => [\*(Aqucfirst\*(Aq],
\& },
.Ve
.PP
\&'field_filter_regexp_map' is used to apply filters to fields that match a
regular expression.  This is a hash reference where the keys are the regular
expressions to use and the values are references to arrays of filters which
will be applied to specific input fields. Just as with 'field_filters', you
can you use a built-in filter or use a coderef to supply your own.
.SS "constraint_methods"
.IX Subsection "constraint_methods"
.Vb 1
\& use Data::FormValidator::Constraints qw(:closures);
\&
\& constraint_methods => {
\&    cc_no      => cc_number({fields => [\*(Aqcc_type\*(Aq]}),
\&    cc_type    => cc_type(),
\&    cc_exp     => cc_exp(),
\&  },
.Ve
.PP
A hash ref which contains the constraints that will be used to check whether or
not the field contains valid data.
.PP
\&\fBNote:\fR To use the built-in constraints, they need to first be loaded into your
name space using the syntax above. (Unless you are using the old \f(CW\*(C`constraints\*(C'\fR key,
documented in \*(L"\s-1BACKWARDS\s0 \s-1COMPATIBILITY\s0\*(R").
.PP
The keys in this hash are field names. The values can be any of the following:
.IP "o" 4
.IX Item "o"
A named constraint.
.Sp
\&\fBExample\fR:
.Sp
.Vb 1
\& my_zipcode_field     => zip(),
.Ve
.Sp
See Data::FormValidator::Constraints for the details of which
built-in constraints that are available.
.IP "o" 4
.IX Item "o"
A perl regular expression
.Sp
\&\fBExample\fR:
.Sp
.Vb 1
\& my_zipcode_field   => qr/^\ed{5}$/, # match exactly 5 digits
.Ve
.Sp
If this field is named in \f(CW\*(C`untaint_constraint_fields\*(C'\fR or \f(CW\*(C`untaint_regexp_map\*(C'\fR,
or \f(CW\*(C`untaint_all_constraints\*(C'\fR is effective, be aware of the following: If you
write your own regular expressions and only match part of the string then
you'll only get part of the string in the valid hash. It is a good idea to
write you own constraints like /^regex$/. That way you match the whole string.
.IP "o" 4
.IX Item "o"
a subroutine reference, to supply custom code
.Sp
This will check the input and return true or false depending on the input's validity.
By default, the constraint function receives a Data::FormValidator::Results
object as its first argument, and the value to be validated as the second.  To
validate a field based on more inputs than just the field itself, see
\&\*(L"\s-1VALIDATING\s0 \s-1INPUT\s0 \s-1BASED\s0 \s-1ON\s0 \s-1MULTIPLE\s0 \s-1FIELDS\s0\*(R".
.Sp
\&\fBExamples\fR:
.Sp
.Vb 4
\& # Notice the use of \*(Aqpop\*(Aq\-\-
\& # the object is the first arg passed to the method
\& # while the value is the second, and last arg.
\& my_zipcode_field => sub { my $val = pop;  return $val =~ \*(Aq/^\ed{5}$/\*(Aq },
\&
\& # OR you can reference a subroutine, which should work like the one above
\& my_zipcode_field => \e&my_validation_routine,
\&
\& # An example of setting the constraint name.
\& my_zipcode_field => sub {
\&    my ($dfv, $val) = @_;
\&    $dfv\->set_current_constraint_name(\*(Aqmy_constraint_name\*(Aq);
\&    return $val =~ \*(Aq/^\ed{5}$/\*(Aq
\& },
.Ve
.IP "o" 4
.IX Item "o"
an array reference
.Sp
An array reference is used to apply multiple constraints to a single
field. Any of the above options are valid entries the array.
See \*(L"\s-1MULTIPLE\s0 \s-1CONSTRAINTS\s0\*(R" below.
.Sp
For more details see \*(L"\s-1VALIDATING\s0 \s-1INPUT\s0 \s-1BASED\s0 \s-1ON\s0 \s-1MULTIPLE\s0 \s-1FIELDS\s0\*(R".
.SS "constraint_method_regexp_map"
.IX Subsection "constraint_method_regexp_map"
.Vb 1
\& use Data::FormValidator::Constraints qw(:closures);
\&
\& # In your profile.
\& constraint_method_regexp_map => {
\&     # All fields that end in _postcode have the \*(Aqpostcode\*(Aq constraint applied.
\&     qr/_postcode$/    => postcode(),
\& },
.Ve
.PP
A hash ref where the keys are the regular expressions to
use and the values are the constraints to apply.
.PP
If one or more constraints have already been defined for a given field using
\&\f(CW\*(C`constraint_methods\*(C'\fR, \f(CW\*(C`constraint_method_regexp_map\*(C'\fR will add an additional
constraint for that field for each regular expression that matches.
.SS "untaint_all_constraints"
.IX Subsection "untaint_all_constraints"
.Vb 1
\& untaint_all_constraints => 1,
.Ve
.PP
If this field is set, all form data that passes a constraint will be untainted.
The untainted data will be returned in the valid hash.  Untainting is based on
the pattern match used by the constraint.  Note that some constraint routines
may not provide untainting.
.PP
See Writing your own constraint routines for more information.
.PP
This is overridden by \f(CW\*(C`untaint_constraint_fields\*(C'\fR and \f(CW\*(C`untaint_regexp_map\*(C'\fR.
.SS "untaint_constraint_fields"
.IX Subsection "untaint_constraint_fields"
.Vb 1
\& untaint_constraint_fields => [qw(zipcode state)],
.Ve
.PP
Specifies that one or more fields will be untainted if they pass their
constraint(s). This can be set to a single field name or an array reference of
field names. The untainted data will be returned in the valid hash.
.PP
This overrides the untaint_all_constraints flag.
.SS "untaint_regexp_map"
.IX Subsection "untaint_regexp_map"
.Vb 1
\& untaint_regexp_map => [qr/some_field_\ed/],
.Ve
.PP
Specifies that certain fields will be untainted if they pass their constraints
and match one of the regular expressions supplied. This can be set to a single
regex, or an array reference of regexes. The untainted data will be returned
in the valid hash.
.PP
The above example would untaint the fields named \f(CW\*(C`some_field_1\*(C'\fR, and \f(CW\*(C`some_field_2\*(C'\fR
but not \f(CW\*(C`some_field\*(C'\fR.
.PP
This overrides the untaint_all_constraints flag.
.SS "missing_optional_valid"
.IX Subsection "missing_optional_valid"
.Vb 1
\& missing_optional_valid => 1
.Ve
.PP
This can be set to a true value to cause optional fields with empty values to
be included in the valid hash. By default they are not included\*(-- this is the
historical behavior.
.PP
This is an important flag if you are using the contents of an \*(L"update\*(R" form to
update a record in a database. Without using the option, fields that have been
set back to \*(L"blank\*(R" may fail to get updated.
.SS "validator_packages"
.IX Subsection "validator_packages"
.Vb 2
\& # load all the constraints and filters from these modules
\& validator_packages => [qw(Data::FormValidator::Constraints::Upload)],
.Ve
.PP
This key is used to define other packages which contain constraint routines or
filters.  Set this key to a single package name, or an arrayref of several. All
of its constraint and filter routines  beginning with 'match_', 'valid_' and
\&'filter_' will be imported into Data::FormValidator.  This lets you reference
them in a constraint with just their name, just like built-in routines.  You
can even override the provided validators.
.PP
See Writing your own constraint routines
documentation for more information
.SS "msgs"
.IX Subsection "msgs"
This key is used to define parameters related to formatting error messages
returned to the user.
.PP
By default, invalid fields have the message \*(L"Invalid\*(R" associated with them
while missing fields have the message \*(L"Missing\*(R" associated with them.
.PP
In the simplest case, nothing needs to be defined here, and the default values
will be used.
.PP
The default formatting applied is designed for display in an \s-1XHTML\s0 web page.
That formatting is as followings:
.PP
.Vb 1
\&    <span style="color:red;font\-weight:bold" class="dfv_errors">* %s</span>
.Ve
.PP
The \f(CW%s\fR will be replaced with the message. The effect is that the message
will appear in bold red with an asterisk before it. This style can be overridden by simply
defining \*(L"dfv_errors\*(R" appropriately in a style sheet, or by providing a new format string.
.PP
Here's a more complex example that shows how to provide your own default message strings, as well
as providing custom messages per field, and handling multiple constraints:
.PP
.Vb 1
\& msgs => {
\&
\&     # set a custom error prefix, defaults to none
\&     prefix=> \*(Aqerror_\*(Aq,
\&
\&     # Set your own "Missing" message, defaults to "Missing"
\&     missing => \*(AqNot Here!\*(Aq,
\&
\&     # Default invalid message, default\*(Aqs to "Invalid"
\&     invalid => \*(AqProblematic!\*(Aq,
\&
\&     # message separator for multiple messages
\&     # Defaults to \*(Aq \*(Aq
\&     invalid_separator => \*(Aq <br /> \*(Aq,
\&
\&     # formatting string, default given above.
\&     format => \*(AqERROR: %s\*(Aq,
\&
\&     # Error messages, keyed by constraint name
\&     # Your constraints must be named to use this.
\&     constraints => {
\&                     \*(Aqdate_and_time\*(Aq => \*(AqNot a valid time format\*(Aq,
\&                     # ...
\&     },
\&
\&     # This token will be included in the hash if there are
\&     # any errors returned. This can be useful with templating
\&     # systems like HTML::Template
\&     # The \*(Aqprefix\*(Aq setting does not apply here.
\&     # defaults to undefined
\&     any_errors => \*(Aqsome_errors\*(Aq,
\& }
.Ve
.PP
The hash that's prepared can be retrieved through the \f(CW\*(C`msgs\*(C'\fR method
described in the Data::FormValidator::Results documentation.
.SS "msgs \- callback"
.IX Subsection "msgs - callback"
\&\fIThis is a new feature. While it expected to be forward-compatible, it hasn't
yet received the testing the rest of the \s-1API\s0 has.\fR
.PP
If the built-in message generation doesn't suit you, it is also possible to
provide your own by specifying a code reference:
.PP
.Vb 1
\& msgs  =>  \e&my_msgs_callback
.Ve
.PP
This will be called as a Data::FormValidator::Results method.  It may
receive as arguments an additional hash reference of control parameters,
corresponding to the key names usually used in the \f(CW\*(C`msgs\*(C'\fR area of the
profile. You can ignore this information if you'd like.
.PP
If you have an alternative error message handler you'd like to share, stick in
the \f(CW\*(C`Data::FormValidator::ErrMsgs\*(C'\fR name space and upload it to \s-1CPAN\s0.
.SS "debug"
.IX Subsection "debug"
This method is used to print details about what is going on to \s-1STDERR\s0.
.PP
Currently only level '1' is used. It provides information about which
fields matched constraint_regexp_map.
.SS "A shortcut for array refs"
.IX Subsection "A shortcut for array refs"
A number of parts of the input profile specification include array references
as their values.  In any of these places, you can simply use a string if you
only need to specify one value. For example, instead of
.PP
.Vb 1
\& filters => [ \*(Aqtrim\*(Aq ]
.Ve
.PP
you can simply say
.PP
.Vb 1
\& filters => \*(Aqtrim\*(Aq
.Ve
.SS "A note on regular expression formats"
.IX Subsection "A note on regular expression formats"
In addition to using the preferred method of defining regular expressions
using \f(CW\*(C`qr\*(C'\fR, a deprecated style of defining them as strings is also supported.
.PP
Preferred:
.PP
.Vb 1
\& qr/this is great/
.Ve
.PP
Deprecated, but supported
.PP
.Vb 1
\& \*(Aqm/this still works/\*(Aq
.Ve
.SH "VALIDATING INPUT BASED ON MULTIPLE FIELDS"
.IX Header "VALIDATING INPUT BASED ON MULTIPLE FIELDS"
You can pass more than one value into a constraint routine.  For that, the
value of the constraint should be a hash reference. If you are creating your
own routines, be sure to read the section labeled
\&\*(L"\s-1WRITING\s0 \s-1YOUR\s0 \s-1OWN\s0 \s-1CONSTRAINT\s0 \s-1ROUTINES\s0\*(R",
in the Data::FormValidator::Constraints documentation.  It describes
a newer and more flexible syntax.
.PP
Using the original syntax, one key should be named \f(CW\*(C`constraint\*(C'\fR and should
have a value set to the reference of the subroutine or the name of a built-in
validator.  Another required key is \f(CW\*(C`params\*(C'\fR. The value of the \f(CW\*(C`params\*(C'\fR key
is a reference to an array of the other elements to use in the validation. If
the element is a scalar, it is assumed to be a field name. The field is known
to Data::FormValidator, the value will be filtered through any defined filters
before it is passed in.  If the value is a reference, the reference is passed
directly to the routine.  Don't forget to include the name of the field to
check in that list, if you are using this syntax.
.PP
\&\fBExample\fR:
.PP
.Vb 4
\& cc_no  => {
\&     constraint  => "cc_number",
\&     params         => [ qw( cc_no cc_type ) ],
\& },
.Ve
.SH "MULTIPLE CONSTRAINTS"
.IX Header "MULTIPLE CONSTRAINTS"
Multiple constraints can be applied to a single field by defining the value of
the constraint to be an array reference. Each of the values in this array can
be any of the constraint types defined above.
.PP
When using multiple constraints it is important to return the name of the
constraint that failed so you can distinguish between them. To do that,
either use a named constraint, or use the hash ref method of defining a
constraint and include a \f(CW\*(C`name\*(C'\fR key with a value set to the name of your
constraint.  Here's an example:
.PP
.Vb 7
\& my_zipcode_field => [
\&     \*(Aqzip\*(Aq,
\&     {
\&       constraint =>  \*(Aq/^406/\*(Aq,
\&       name        =>  \*(Aqstarts_with_406\*(Aq,
\&     }
\& ],
.Ve
.PP
You can use an array reference with a single constraint in it if you just want
to have the name of your failed constraint returned in the above fashion.
.PP
Read about the \f(CW\*(C`validate()\*(C'\fR function above to see how multiple constraints
are returned differently with that method.
.SH "ADVANCED VALIDATION"
.IX Header "ADVANCED VALIDATION"
For even more advanced validation, you will likely want to read the
documentation for other modules in this distribution, linked below. Also keep
in mind that the  Data::FormValidator profile structure is just another data
structure. There is no reason why it needs to be defined statically. The
profile could also be built on the fly with custom Perl code.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
.SS "\fIvalidate()\fP"
.IX Subsection "validate()"
.Vb 2
\&    my( $valids, $missings, $invalids, $unknowns ) =
\&        Data::FormValidator\->validate( \e%input_hash, \e%dfv_profile);
.Ve
.PP
\&\f(CW\*(C`validate()\*(C'\fR provides a deprecated alternative to \f(CW\*(C`check()\*(C'\fR. It has the same input
syntax, but returns a four element array, described as follows
.IP "valids" 4
.IX Item "valids"
This is a hash reference to the valid fields which were submitted in
the data. The data may have been modified by the various filters specified.
.IP "missings" 4
.IX Item "missings"
This is a reference to an array which contains the name of the missing
fields. Those are the fields that the user forget to fill or filled
with spaces. These fields may comes from the \fIrequired\fR list or the
\&\fIdependencies\fR list.
.IP "invalids" 4
.IX Item "invalids"
This is a reference to an array which contains the name of the fields
which failed one or more of their constraint checks.
.Sp
Fields defined with multiple constraints will have an array ref returned in the
\&\f(CW@invalids\fR array instead of a string. The first element in this array is the
name of the field, and the remaining fields are the names of the failed
constraints.
.IP "unknowns" 4
.IX Item "unknowns"
This is a list of fields which are unknown to the profile. Whether or
not this indicates an error in the user input is application
dependent.
.SS "constraints (profile key)"
.IX Subsection "constraints (profile key)"
This is a supported but deprecated profile key. Using \f(CW\*(C`constraint_methods\*(C'\fR is
recommended instead, which provides a simpler, more versatile interface.
.PP
.Vb 8
\& constraints => {
\&    cc_no      => {
\&        constraint  => "cc_number",
\&        params        => [ qw( cc_no cc_type ) ],
\&    },
\&    cc_type    => "cc_type",
\&    cc_exp    => "cc_exp",
\&  },
.Ve
.PP
A hash ref which contains the constraints that
will be used to check whether or not the field contains valid data.
.PP
The keys in this hash are field names. The values can be any of the following:
.IP "o" 4
.IX Item "o"
A named constraint.
.Sp
\&\fBExample\fR:
.Sp
.Vb 1
\& my_zipcode_field     => \*(Aqzip\*(Aq,
.Ve
.Sp
See Data::FormValidator::Constraints for the details of which
built-in constraints that are available.
.SS "hashref style of specifying constraints"
.IX Subsection "hashref style of specifying constraints"
Using a hash reference to specify a constraint is an older technique
used to name a constraint or supply multiple parameters.
.PP
Both of these interface issues are now better addressed with \f(CW\*(C`constraint_methods\*(C'\fR
and \f(CW\*(C`$self\-\e\*(C'\fRname_this('foo')>.
.PP
.Vb 5
\& # supply multiple parameters
\& cc_no  => {
\&     constraint  => "cc_number",
\&     params      => [ qw( cc_no cc_type ) ],
\& },
\&
\& # name a constraint, useful for returning error messages
\& last_name => {
\&     name => "ends_in_name",
\&     constraint => qr/_name$/,
\& },
.Ve
.PP
Using a hash reference for a constraint permits the passing of multiple
arguments. Required arguments are \f(CW\*(C`constraint\*(C'\fR or \f(CW\*(C`constraint_method\*(C'\fR.
Optional arguments are \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`params\*(C'\fR.
.PP
A \f(CW\*(C`name\*(C'\fR on a constraints 'glues' the constraint to its error message
in the validator profile (refer \f(CW\*(C`msgs\*(C'\fR section below). If no \f(CW\*(C`name\*(C'\fR is
given then it will default to the value of \f(CW\*(C`constraint\*(C'\fR or
\&\f(CW\*(C`constraint_method\*(C'\fR \s-1IF\s0 they are \s-1NOT\s0 a \s-1CODE\s0 ref or a RegExp ref.
.PP
The \f(CW\*(C`params\*(C'\fR value is a reference to an array of the parameters to pass
to the constraint method.
If an element of the \f(CW\*(C`params\*(C'\fR list is a scalar, it is assumed to be naming
a key of the \f(CW%input_hash\fR and that value is passed to the routine.
If the parameter is a reference, then it is treated literally and passed
unchanged to the routine.
.PP
If you are using the older \f(CW\*(C`constraint\*(C'\fR over
the new \f(CW\*(C`constraint_method\*(C'\fR then don't forget to include the name of the
field to check in the \f(CW\*(C`params\*(C'\fR list. \f(CW\*(C`constraint_method\*(C'\fR provides access
to this value via the \f(CW\*(C`get_current_*\*(C'\fR methods
(refer Data::FormValidator::Constraints)
.PP
For more details see \*(L"\s-1VALIDATING\s0 \s-1INPUT\s0 \s-1BASED\s0 \s-1ON\s0 \s-1MULTIPLE\s0 \s-1FIELDS\s0\*(R".
.SS "constraint_regexp_map (profile key)"
.IX Subsection "constraint_regexp_map (profile key)"
This is a supported by deprecated profile key. Using
\&\f(CW\*(C`constraint_methods_regexp_map\*(C'\fR is recommended instead.
.PP
.Vb 4
\& constraint_regexp_map => {
\&     # All fields that end in _postcode have the \*(Aqpostcode\*(Aq constraint applied.
\&     qr/_postcode$/    => \*(Aqpostcode\*(Aq,
\& },
.Ve
.PP
A hash ref where the keys are the regular expressions to
use and the values are the constraints to apply.
.PP
If one or more constraints have already been defined for a given field using
\&\*(L"constraints\*(R", constraint_regexp_map will add an additional constraint for that
field for each regular expression that matches.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBOther modules in this distribution:\fR
.PP
Data::FormValidator::Constraints
.PP
Data::FormValidator::Constraints::Dates
.PP
Data::FormValidator::Constraints::Upload
.PP
Data::FormValidator::ConstraintsFactory
.PP
Data::FormValidator::Filters
.PP
Data::FormValidator::Results
.PP
\&\fBA sample application by the maintainer:\fR
.PP
Validating Web Forms with Perl, http://mark.stosberg.com/Tech/perl/form\-validation/ <http://mark.stosberg.com/Tech/perl/form-validation/>
.PP
\&\fBRelated modules:\fR
.PP
Data::FormValidator::Tutorial
.PP
Data::FormValidator::Util::HTML
.PP
CGI::Application::ValidateRM, a
CGI::Application & Data::FormValidator glue module
.PP
HTML::Template::Associate::FormValidator is designed
to make some kinds of integration with HTML::Template easier.
.PP
Params::Validate is useful for validating function parameters.
.PP
Regexp::Common,
Data::Types,
Data::Verify,
Email::Valid,
String::Checker,
CGI::ArgChecker,
CGI::FormMagick::Validator,
CGI::Validate
.PP
\&\fBDocument Translations:\fR
.PP
Japanese: <http://perldoc.jp/docs/modules/>
.PP
\&\fBDistributions which include Data::FormValidator\fR
.PP
FreeBSD includes a port named \fBp5\-Data\-FormValidator\fR
.PP
Debian GNU/Linux includes a port named \fBlibdata-formvalidator-perl\fR
.SH "CREDITS"
.IX Header "CREDITS"
Some of those input validation functions have been taken from MiniVend
by Michael J. Heins.
.PP
The credit card checksum validation was taken from contribution by Bruce
Albrecht to the MiniVend program.
.SH "BUGS"
.IX Header "BUGS"
Bug reports and patches are welcome. Reports which include a failing Test::More
style test are helpful will receive priority.
.PP
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data\-FormValidator <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data-FormValidator>
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
This project is managed using the darcs source control system (
http://www.darcs.net/ ). My darcs archive is here:
http://mark.stosberg.com/darcs_hive/dfv/
.PP
\&\fBSupport Mailing List\fR
.PP
If you have any questions, comments, or feature suggestions, post them to the
support mailing list!  To join the mailing list, visit
.PP
http://lists.sourceforge.net/lists/listinfo/cascade\-dataform <http://lists.sourceforge.net/lists/listinfo/cascade-dataform>
.PP
Messages about \s-1DFV\s0 sent directly to the maintainer may be redirected here.
.SH "AUTHOR"
.IX Header "AUTHOR"
Parts Copyright 2001\-2006 by Mark Stosberg <mark at summersault.com>, (Current Maintainer)
.PP
Copyright (c) 1999 Francis J. Lacoste and iNsu Innovations Inc.  All rights reserved.
(Original Author)
.PP
Parts Copyright 1996\-1999 by Michael J. Heins <mike@heins.net>
.PP
Parts Copyright 1996\-1999 by Bruce Albrecht  <bruce.albrecht@seag.fingerhut.com>
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify
it under the terms as perl itself.
