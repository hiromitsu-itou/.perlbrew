.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst 3"
.TH Catalyst 3 "2011-11-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst \- The Elegant MVC Web Application Framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See the Catalyst::Manual distribution for comprehensive
documentation and tutorials.
.PP
.Vb 3
\&    # Install Catalyst::Devel for helpers and other development tools
\&    # use the helper to create a new application
\&    catalyst.pl MyApp
\&
\&    # add models, views, controllers
\&    script/myapp_create.pl model MyDatabase DBIC::Schema create=static dbi:SQLite:/path/to/db
\&    script/myapp_create.pl view MyTemplate TT
\&    script/myapp_create.pl controller Search
\&
\&    # built in testserver \-\- use \-r to restart automatically on changes
\&    # \-\-help to see all available options
\&    script/myapp_server.pl
\&
\&    # command line testing interface
\&    script/myapp_test.pl /yada
\&
\&    ### in lib/MyApp.pm
\&    use Catalyst qw/\-Debug/; # include plugins here as well
\&
\&    ### In lib/MyApp/Controller/Root.pm (autocreated)
\&    sub foo : Chained(\*(Aq/\*(Aq) Args() { # called for /foo, /foo/1, /foo/1/2, etc.
\&        my ( $self, $c, @args ) = @_; # args are qw/1 2/ for /foo/1/2
\&        $c\->stash\->{template} = \*(Aqfoo.tt\*(Aq; # set the template
\&        # lookup something from db \-\- stash vars are passed to TT
\&        $c\->stash\->{data} =
\&          $c\->model(\*(AqDatabase::Foo\*(Aq)\->search( { country => $args[0] } );
\&        if ( $c\->req\->params\->{bar} ) { # access GET or POST parameters
\&            $c\->forward( \*(Aqbar\*(Aq ); # process another action
\&            # do something else after forward returns
\&        }
\&    }
\&
\&    # The foo.tt TT template can use the stash data from the database
\&    [% WHILE (item = data.next) %]
\&        [% item.foo %]
\&    [% END %]
\&
\&    # called for /bar/of/soap, /bar/of/soap/10, etc.
\&    sub bar : Chained(\*(Aq/\*(Aq) PathPart(\*(Aq/bar/of/soap\*(Aq) Args() { ... }
\&
\&    # called after all actions are finished
\&    sub end : Action {
\&        my ( $self, $c ) = @_;
\&        if ( scalar @{ $c\->error } ) { ... } # handle errors
\&        return if $c\->res\->body; # already have a response
\&        $c\->forward( \*(AqMyApp::View::TT\*(Aq ); # render template
\&    }
.Ve
.PP
See Catalyst::Manual::Intro for additional information.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Catalyst is a modern framework for making web applications without the
pain usually associated with this process. This document is a reference
to the main Catalyst application. If you are a new user, we suggest you
start with Catalyst::Manual::Tutorial or Catalyst::Manual::Intro.
.PP
See Catalyst::Manual for more documentation.
.PP
Catalyst plugins can be loaded by naming them as arguments to the \*(L"use
Catalyst\*(R" statement. Omit the \f(CW\*(C`Catalyst::Plugin::\*(C'\fR prefix from the
plugin name, i.e., \f(CW\*(C`Catalyst::Plugin::My::Module\*(C'\fR becomes
\&\f(CW\*(C`My::Module\*(C'\fR.
.PP
.Vb 1
\&    use Catalyst qw/My::Module/;
.Ve
.PP
If your plugin starts with a name other than \f(CW\*(C`Catalyst::Plugin::\*(C'\fR, you can
fully qualify the name by using a unary plus:
.PP
.Vb 4
\&    use Catalyst qw/
\&        My::Module
\&        +Fully::Qualified::Plugin::Name
\&    /;
.Ve
.PP
Special flags like \f(CW\*(C`\-Debug\*(C'\fR can also be specified as
arguments when Catalyst is loaded:
.PP
.Vb 1
\&    use Catalyst qw/\-Debug My::Module/;
.Ve
.PP
The position of plugins and flags in the chain is important, because
they are loaded in the order in which they appear.
.PP
The following flags are supported:
.SS "\-Debug"
.IX Subsection "-Debug"
Enables debug output. You can also force this setting from the system
environment with \s-1CATALYST_DEBUG\s0 or <\s-1MYAPP\s0>_DEBUG. The environment
settings override the application, with <\s-1MYAPP\s0>_DEBUG having the highest
priority.
.PP
This sets the log level to 'debug' and enables full debug output on the
error screen. If you only want the latter, see \f(CW$c\fR\->debug.
.SS "\-Home"
.IX Subsection "-Home"
Forces Catalyst to use a specific home directory, e.g.:
.PP
.Vb 1
\&    use Catalyst qw[\-Home=/usr/mst];
.Ve
.PP
This can also be done in the shell environment by setting either the
\&\f(CW\*(C`CATALYST_HOME\*(C'\fR environment variable or \f(CW\*(C`MYAPP_HOME\*(C'\fR; where \f(CW\*(C`MYAPP\*(C'\fR
is replaced with the uppercased name of your application, any \*(L"::\*(R" in
the name will be replaced with underscores, e.g. MyApp::Web should use
\&\s-1MYAPP_WEB_HOME\s0. If both variables are set, the \s-1MYAPP_HOME\s0 one will be used.
.PP
If none of these are set, Catalyst will attempt to automatically detect the
home directory. If you are working in a development environment, Catalyst
will try and find the directory containing either Makefile.PL, Build.PL or
dist.ini. If the application has been installed into the system (i.e.
you have done \f(CW\*(C`make install\*(C'\fR), then Catalyst will use the path to your
application module, without the .pm extension (e.g., /foo/MyApp if your
application was installed at /foo/MyApp.pm)
.SS "\-Log"
.IX Subsection "-Log"
.Vb 1
\&    use Catalyst \*(Aq\-Log=warn,fatal,error\*(Aq;
.Ve
.PP
Specifies a comma-delimited list of log levels.
.SS "\-Stats"
.IX Subsection "-Stats"
Enables statistics collection and reporting.
.PP
.Vb 1
\&   use Catalyst qw/\-Stats=1/;
.Ve
.PP
You can also force this setting from the system environment with \s-1CATALYST_STATS\s0
or <\s-1MYAPP\s0>_STATS. The environment settings override the application, with
<\s-1MYAPP\s0>_STATS having the highest priority.
.PP
Stats are also enabled if debugging  is enabled.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1INFORMATION\s0 \s-1ABOUT\s0 \s-1THE\s0 \s-1CURRENT\s0 \s-1REQUEST\s0"
.IX Subsection "INFORMATION ABOUT THE CURRENT REQUEST"
.ie n .SS "$c\->action"
.el .SS "\f(CW$c\fP\->action"
.IX Subsection "$c->action"
Returns a Catalyst::Action object for the current action, which
stringifies to the action name. See Catalyst::Action.
.ie n .SS "$c\->namespace"
.el .SS "\f(CW$c\fP\->namespace"
.IX Subsection "$c->namespace"
Returns the namespace of the current action, i.e., the \s-1URI\s0 prefix
corresponding to the controller of the current action. For example:
.PP
.Vb 2
\&    # in Controller::Foo::Bar
\&    $c\->namespace; # returns \*(Aqfoo/bar\*(Aq;
.Ve
.ie n .SS "$c\->request"
.el .SS "\f(CW$c\fP\->request"
.IX Subsection "$c->request"
.ie n .SS "$c\->req"
.el .SS "\f(CW$c\fP\->req"
.IX Subsection "$c->req"
Returns the current Catalyst::Request object, giving access to
information about the current client request (including parameters,
cookies, \s-1HTTP\s0 headers, etc.). See Catalyst::Request.
.SS "\s-1REQUEST\s0 \s-1FLOW\s0 \s-1HANDLING\s0"
.IX Subsection "REQUEST FLOW HANDLING"
.ie n .SS "$c\->forward( $action [, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->forward( \f(CW$action\fP [, \e@arguments ] )"
.IX Subsection "$c->forward( $action [, @arguments ] )"
.ie n .SS "$c\->forward( $class, $method, [, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->forward( \f(CW$class\fP, \f(CW$method\fP, [, \e@arguments ] )"
.IX Subsection "$c->forward( $class, $method, [, @arguments ] )"
Forwards processing to another action, by its private name. If you give a
class name but no method, \f(CW\*(C`process()\*(C'\fR is called. You may also optionally
pass arguments in an arrayref. The action will receive the arguments in
\&\f(CW@_\fR and \f(CW\*(C`$c\->req\->args\*(C'\fR. Upon returning from the function,
\&\f(CW\*(C`$c\->req\->args\*(C'\fR will be restored to the previous values.
.PP
Any data \f(CW\*(C`return\*(C'\fRed from the action forwarded to, will be returned by the
call to forward.
.PP
.Vb 4
\&    my $foodata = $c\->forward(\*(Aq/foo\*(Aq);
\&    $c\->forward(\*(Aqindex\*(Aq);
\&    $c\->forward(qw/Model::DBIC::Foo do_stuff/);
\&    $c\->forward(\*(AqView::TT\*(Aq);
.Ve
.PP
Note that forward implies
an \f(CW\*(C`eval { }\*(C'\fR around the call (actually
execute does), thus rendering all
exceptions thrown by the called action non-fatal and pushing them onto
\&\f(CW$c\fR\->error instead. If you want \f(CW\*(C`die\*(C'\fR to propagate you need to do something
like:
.PP
.Vb 2
\&    $c\->forward(\*(Aqfoo\*(Aq);
\&    die join "\en", @{ $c\->error } if @{ $c\->error };
.Ve
.PP
Or make sure to always return true values from your actions and write
your code like this:
.PP
.Vb 1
\&    $c\->forward(\*(Aqfoo\*(Aq) || return;
.Ve
.PP
Another note is that \f(CW\*(C`$c\->forward\*(C'\fR always returns a scalar because it
actually returns \f(CW$c\fR\->state which operates in a scalar context.
Thus, something like:
.PP
.Vb 1
\&    return @array;
.Ve
.PP
in an action that is forwarded to is going to return a scalar,
i.e. how many items are in that array, which is probably not what you want.
If you need to return an array then return a reference to it,
or stash it like so:
.PP
.Vb 1
\&    $c\->stash\->{array} = \e@array;
.Ve
.PP
and access it from the stash.
.PP
Keep in mind that the \f(CW\*(C`end\*(C'\fR method used is that of the caller action. So a \f(CW\*(C`$c\->detach\*(C'\fR inside a forwarded action would run the \f(CW\*(C`end\*(C'\fR method from the original action requested.
.ie n .SS "$c\->detach( $action [, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->detach( \f(CW$action\fP [, \e@arguments ] )"
.IX Subsection "$c->detach( $action [, @arguments ] )"
.ie n .SS "$c\->detach( $class, $method, [, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->detach( \f(CW$class\fP, \f(CW$method\fP, [, \e@arguments ] )"
.IX Subsection "$c->detach( $class, $method, [, @arguments ] )"
.ie n .SS "$c\->\fIdetach()\fP"
.el .SS "\f(CW$c\fP\->\fIdetach()\fP"
.IX Subsection "$c->detach()"
The same as forward, but
doesn't return to the previous action when processing is finished.
.PP
When called with no arguments it escapes the processing chain entirely.
.ie n .SS "$c\->visit( $action [, \e@captures, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->visit( \f(CW$action\fP [, \e@captures, \e@arguments ] )"
.IX Subsection "$c->visit( $action [, @captures, @arguments ] )"
.ie n .SS "$c\->visit( $class, $method, [, \e@captures, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->visit( \f(CW$class\fP, \f(CW$method\fP, [, \e@captures, \e@arguments ] )"
.IX Subsection "$c->visit( $class, $method, [, @captures, @arguments ] )"
Almost the same as forward,
but does a full dispatch, instead of just calling the new \f(CW$action\fR /
\&\f(CW\*(C`$class\->$method\*(C'\fR. This means that \f(CW\*(C`begin\*(C'\fR, \f(CW\*(C`auto\*(C'\fR and the method
you go to are called, just like a new request.
.PP
In addition both \f(CW\*(C`$c\->action\*(C'\fR and \f(CW\*(C`$c\->namespace\*(C'\fR are localized.
This means, for example, that \f(CW\*(C`$c\->action\*(C'\fR methods such as
name, class and
reverse return information for the visited action
when they are invoked within the visited action.  This is different from the
behavior of forward, which
continues to use the \f(CW$c\fR\->action object from the caller action even when
invoked from the called action.
.PP
\&\f(CW\*(C`$c\->stash\*(C'\fR is kept unchanged.
.PP
In effect, visit
allows you to \*(L"wrap\*(R" another action, just as it would have been called by
dispatching from a \s-1URL\s0, while the analogous
go allows you to
transfer control to another action as if it had been reached directly from a \s-1URL\s0.
.ie n .SS "$c\->go( $action [, \e@captures, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->go( \f(CW$action\fP [, \e@captures, \e@arguments ] )"
.IX Subsection "$c->go( $action [, @captures, @arguments ] )"
.ie n .SS "$c\->go( $class, $method, [, \e@captures, \e@arguments ] )"
.el .SS "\f(CW$c\fP\->go( \f(CW$class\fP, \f(CW$method\fP, [, \e@captures, \e@arguments ] )"
.IX Subsection "$c->go( $class, $method, [, @captures, @arguments ] )"
The relationship between \f(CW\*(C`go\*(C'\fR and
visit is the same as
the relationship between
forward and
detach. Like \f(CW\*(C`$c\->visit\*(C'\fR,
\&\f(CW\*(C`$c\->go\*(C'\fR will perform a full dispatch on the specified action or method,
with localized \f(CW\*(C`$c\->action\*(C'\fR and \f(CW\*(C`$c\->namespace\*(C'\fR. Like \f(CW\*(C`detach\*(C'\fR,
\&\f(CW\*(C`go\*(C'\fR escapes the processing of the current request chain on completion, and
does not return to its caller.
.PP
\&\f(CW@arguments\fR are arguments to the final destination of \f(CW$action\fR. \f(CW@captures\fR are
arguments to the intermediate steps, if any, on the way to the final sub of
\&\f(CW$action\fR.
.ie n .SS "$c\->response"
.el .SS "\f(CW$c\fP\->response"
.IX Subsection "$c->response"
.ie n .SS "$c\->res"
.el .SS "\f(CW$c\fP\->res"
.IX Subsection "$c->res"
Returns the current Catalyst::Response object, see there for details.
.ie n .SS "$c\->stash"
.el .SS "\f(CW$c\fP\->stash"
.IX Subsection "$c->stash"
Returns a hashref to the stash, which may be used to store data and pass
it between components during a request. You can also set hash keys by
passing arguments. The stash is automatically sent to the view. The
stash is cleared at the end of a request; it cannot be used for
persistent storage (for this you must use a session; see
Catalyst::Plugin::Session for a complete system integrated with
Catalyst).
.PP
.Vb 3
\&    $c\->stash\->{foo} = $bar;
\&    $c\->stash( { moose => \*(Aqmajestic\*(Aq, qux => 0 } );
\&    $c\->stash( bar => 1, gorch => 2 ); # equivalent to passing a hashref
\&
\&    # stash is automatically passed to the view for use in a template
\&    $c\->forward( \*(AqMyApp::View::TT\*(Aq );
.Ve
.ie n .SS "$c\->error"
.el .SS "\f(CW$c\fP\->error"
.IX Subsection "$c->error"
.ie n .SS "$c\->error($error, ...)"
.el .SS "\f(CW$c\fP\->error($error, ...)"
.IX Subsection "$c->error($error, ...)"
.ie n .SS "$c\->error($arrayref)"
.el .SS "\f(CW$c\fP\->error($arrayref)"
.IX Subsection "$c->error($arrayref)"
Returns an arrayref containing error messages.  If Catalyst encounters an
error while processing a request, it stores the error in \f(CW$c\fR\->error.  This
method should only be used to store fatal error messages.
.PP
.Vb 1
\&    my @error = @{ $c\->error };
.Ve
.PP
Add a new error.
.PP
.Vb 1
\&    $c\->error(\*(AqSomething bad happened\*(Aq);
.Ve
.ie n .SS "$c\->state"
.el .SS "\f(CW$c\fP\->state"
.IX Subsection "$c->state"
Contains the return value of the last executed action.
Note that << \f(CW$c\fR\->state >> operates in a scalar context which means that all
values it returns are scalar.
.ie n .SS "$c\->clear_errors"
.el .SS "\f(CW$c\fP\->clear_errors"
.IX Subsection "$c->clear_errors"
Clear errors.  You probably don't want to clear the errors unless you are
implementing a custom error screen.
.PP
This is equivalent to running
.PP
.Vb 1
\&    $c\->error(0);
.Ve
.SS "\s-1COMPONENT\s0 \s-1ACCESSORS\s0"
.IX Subsection "COMPONENT ACCESSORS"
.ie n .SS "$c\->controller($name)"
.el .SS "\f(CW$c\fP\->controller($name)"
.IX Subsection "$c->controller($name)"
Gets a Catalyst::Controller instance by name.
.PP
.Vb 1
\&    $c\->controller(\*(AqFoo\*(Aq)\->do_stuff;
.Ve
.PP
If the name is omitted, will return the controller for the dispatched
action.
.PP
If you want to search for controllers, pass in a regexp as the argument.
.PP
.Vb 2
\&    # find all controllers that start with Foo
\&    my @foo_controllers = $c\->controller(qr{^Foo});
.Ve
.ie n .SS "$c\->model($name)"
.el .SS "\f(CW$c\fP\->model($name)"
.IX Subsection "$c->model($name)"
Gets a Catalyst::Model instance by name.
.PP
.Vb 1
\&    $c\->model(\*(AqFoo\*(Aq)\->do_stuff;
.Ve
.PP
Any extra arguments are directly passed to \s-1ACCEPT_CONTEXT\s0.
.PP
If the name is omitted, it will look for
 \- a model object in \f(CW$c\fR\->stash\->{current_model_instance}, then
 \- a model name in \f(CW$c\fR\->stash\->{current_model}, then
 \- a config setting 'default_model', or
 \- check if there is only one model, and return it if that's the case.
.PP
If you want to search for models, pass in a regexp as the argument.
.PP
.Vb 2
\&    # find all models that start with Foo
\&    my @foo_models = $c\->model(qr{^Foo});
.Ve
.ie n .SS "$c\->view($name)"
.el .SS "\f(CW$c\fP\->view($name)"
.IX Subsection "$c->view($name)"
Gets a Catalyst::View instance by name.
.PP
.Vb 1
\&    $c\->view(\*(AqFoo\*(Aq)\->do_stuff;
.Ve
.PP
Any extra arguments are directly passed to \s-1ACCEPT_CONTEXT\s0.
.PP
If the name is omitted, it will look for
 \- a view object in \f(CW$c\fR\->stash\->{current_view_instance}, then
 \- a view name in \f(CW$c\fR\->stash\->{current_view}, then
 \- a config setting 'default_view', or
 \- check if there is only one view, and return it if that's the case.
.PP
If you want to search for views, pass in a regexp as the argument.
.PP
.Vb 2
\&    # find all views that start with Foo
\&    my @foo_views = $c\->view(qr{^Foo});
.Ve
.ie n .SS "$c\->controllers"
.el .SS "\f(CW$c\fP\->controllers"
.IX Subsection "$c->controllers"
Returns the available names which can be passed to \f(CW$c\fR\->controller
.ie n .SS "$c\->models"
.el .SS "\f(CW$c\fP\->models"
.IX Subsection "$c->models"
Returns the available names which can be passed to \f(CW$c\fR\->model
.ie n .SS "$c\->views"
.el .SS "\f(CW$c\fP\->views"
.IX Subsection "$c->views"
Returns the available names which can be passed to \f(CW$c\fR\->view
.ie n .SS "$c\->comp($name)"
.el .SS "\f(CW$c\fP\->comp($name)"
.IX Subsection "$c->comp($name)"
.ie n .SS "$c\->component($name)"
.el .SS "\f(CW$c\fP\->component($name)"
.IX Subsection "$c->component($name)"
Gets a component object by name. This method is not recommended,
unless you want to get a specific component by full
class. \f(CW\*(C`$c\->controller\*(C'\fR, \f(CW\*(C`$c\->model\*(C'\fR, and \f(CW\*(C`$c\->view\*(C'\fR
should be used instead.
.PP
If \f(CW$name\fR is a regexp, a list of components matched against the full
component name will be returned.
.PP
If Catalyst can't find a component by name, it will fallback to regex
matching by default. To disable this behaviour set
disable_component_resolution_regex_fallback to a true value.
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->config( disable_component_resolution_regex_fallback => 1 );
.Ve
.SS "\s-1CLASS\s0 \s-1DATA\s0 \s-1AND\s0 \s-1HELPER\s0 \s-1CLASSES\s0"
.IX Subsection "CLASS DATA AND HELPER CLASSES"
.ie n .SS "$c\->config"
.el .SS "\f(CW$c\fP\->config"
.IX Subsection "$c->config"
Returns or takes a hashref containing the application's configuration.
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->config( { db => \*(Aqdsn:SQLite:foo.db\*(Aq } );
.Ve
.PP
You can also use a \f(CW\*(C`YAML\*(C'\fR, \f(CW\*(C`XML\*(C'\fR or Config::General config file
like \f(CW\*(C`myapp.conf\*(C'\fR in your applications home directory. See
Catalyst::Plugin::ConfigLoader.
.PP
\fICascading configuration\fR
.IX Subsection "Cascading configuration"
.PP
The config method is present on all Catalyst components, and configuration
will be merged when an application is started. Configuration loaded with
Catalyst::Plugin::ConfigLoader takes precedence over other configuration,
followed by configuration in your top level \f(CW\*(C`MyApp\*(C'\fR class. These two
configurations are merged, and then configuration data whose hash key matches a
component name is merged with configuration for that component.
.PP
The configuration for a component is then passed to the \f(CW\*(C`new\*(C'\fR method when a
component is constructed.
.PP
For example:
.PP
.Vb 2
\&    MyApp\->config({ \*(AqModel::Foo\*(Aq => { bar => \*(Aqbaz\*(Aq, overrides => \*(Aqme\*(Aq } });
\&    MyApp::Model::Foo\->config({ quux => \*(Aqfrob\*(Aq, overrides => \*(Aqthis\*(Aq });
.Ve
.PP
will mean that \f(CW\*(C`MyApp::Model::Foo\*(C'\fR receives the following data when
constructed:
.PP
.Vb 5
\&    MyApp::Model::Foo\->new({
\&        bar => \*(Aqbaz\*(Aq,
\&        quux => \*(Aqfrob\*(Aq,
\&        overrides => \*(Aqme\*(Aq,
\&    });
.Ve
.PP
It's common practice to use a Moose attribute
on the receiving component to access the config value.
.PP
.Vb 1
\&    package MyApp::Model::Foo;
\&
\&    use Moose;
\&
\&    # this attr will receive \*(Aqbaz\*(Aq at construction time
\&    has \*(Aqbar\*(Aq => (
\&        is  => \*(Aqrw\*(Aq,
\&        isa => \*(AqStr\*(Aq,
\&    );
.Ve
.PP
You can then get the value 'baz' by calling \f(CW$c\fR\->model('Foo')\->bar
(or \f(CW$self\fR\->bar inside code in the model).
.PP
\&\fB\s-1NOTE:\s0\fR you \s-1MUST\s0 \s-1NOT\s0 call \f(CW\*(C`$self\->config\*(C'\fR or \f(CW\*(C`_\|_PACKAGE_\|_\->config\*(C'\fR
as a way of reading config within your code, as this \fBwill not\fR give you the
correctly merged config back. You \fB\s-1MUST\s0\fR take the config values supplied to
the constructor and use those instead.
.ie n .SS "$c\->log"
.el .SS "\f(CW$c\fP\->log"
.IX Subsection "$c->log"
Returns the logging object instance. Unless it is already set, Catalyst
sets this up with a Catalyst::Log object. To use your own log class,
set the logger with the \f(CW\*(C`_\|_PACKAGE_\|_\->log\*(C'\fR method prior to calling
\&\f(CW\*(C`_\|_PACKAGE_\|_\->setup\*(C'\fR.
.PP
.Vb 2
\& _\|_PACKAGE_\|_\->log( MyLogger\->new );
\& _\|_PACKAGE_\|_\->setup;
.Ve
.PP
And later:
.PP
.Vb 1
\&    $c\->log\->info( \*(AqNow logging with my own logger!\*(Aq );
.Ve
.PP
Your log class should implement the methods described in
Catalyst::Log.
.ie n .SS "$c\->debug"
.el .SS "\f(CW$c\fP\->debug"
.IX Subsection "$c->debug"
Returns 1 if debug mode is enabled, 0 otherwise.
.PP
You can enable debug mode in several ways:
.IP "By calling myapp_server.pl with the \-d flag" 4
.IX Item "By calling myapp_server.pl with the -d flag"
.PD 0
.IP "With the environment variables \s-1MYAPP_DEBUG\s0, or \s-1CATALYST_DEBUG\s0" 4
.IX Item "With the environment variables MYAPP_DEBUG, or CATALYST_DEBUG"
.IP "The \-Debug option in your MyApp.pm" 4
.IX Item "The -Debug option in your MyApp.pm"
.ie n .IP "By declaring ""sub debug { 1 }"" in your MyApp.pm." 4
.el .IP "By declaring \f(CWsub debug { 1 }\fR in your MyApp.pm." 4
.IX Item "By declaring sub debug { 1 } in your MyApp.pm."
.PD
.PP
The first three also set the log level to 'debug'.
.PP
Calling \f(CW\*(C`$c\->debug(1)\*(C'\fR has no effect.
.ie n .SS "$c\->dispatcher"
.el .SS "\f(CW$c\fP\->dispatcher"
.IX Subsection "$c->dispatcher"
Returns the dispatcher instance. See Catalyst::Dispatcher.
.ie n .SS "$c\->engine"
.el .SS "\f(CW$c\fP\->engine"
.IX Subsection "$c->engine"
Returns the engine instance. See Catalyst::Engine.
.SS "\s-1UTILITY\s0 \s-1METHODS\s0"
.IX Subsection "UTILITY METHODS"
.ie n .SS "$c\->path_to(@path)"
.el .SS "\f(CW$c\fP\->path_to(@path)"
.IX Subsection "$c->path_to(@path)"
Merges \f(CW@path\fR with \f(CW\*(C`$c\->config\->{home}\*(C'\fR and returns a
Path::Class::Dir object. Note you can usually use this object as
a filename, but sometimes you will have to explicitly stringify it
yourself by calling the \f(CW\*(C`\->stringify\*(C'\fR method.
.PP
For example:
.PP
.Vb 1
\&    $c\->path_to( \*(Aqdb\*(Aq, \*(Aqsqlite.db\*(Aq );
.Ve
.SS "MyApp\->setup"
.IX Subsection "MyApp->setup"
Initializes the dispatcher and engine, loads any plugins, and loads the
model, view, and controller components. You may also specify an array
of plugins to load here, if you choose to not load them in the \f(CW\*(C`use
Catalyst\*(C'\fR line.
.PP
.Vb 2
\&    MyApp\->setup;
\&    MyApp\->setup( qw/\-Debug/ );
.Ve
.PP
\&\fBNote:\fR You \fBshould not\fR wrap this method with method modifiers
or bad things will happen \- wrap the \f(CW\*(C`setup_finalize\*(C'\fR method instead.
.ie n .SS "$app\->setup_finalize"
.el .SS "\f(CW$app\fP\->setup_finalize"
.IX Subsection "$app->setup_finalize"
A hook to attach modifiers to. This method does not do anything except set the
\&\f(CW\*(C`setup_finished\*(C'\fR accessor.
.PP
Applying method modifiers to the \f(CW\*(C`setup\*(C'\fR method doesn't work, because of quirky things done for plugin setup.
.PP
Example:
.PP
.Vb 2
\&    after setup_finalize => sub {
\&        my $app = shift;
\&
\&        ## do stuff here..
\&    };
.Ve
.ie n .SS "$c\->uri_for( $path?, @args?, \e%query_values? )"
.el .SS "\f(CW$c\fP\->uri_for( \f(CW$path\fP?, \f(CW@args\fP?, \e%query_values? )"
.IX Subsection "$c->uri_for( $path?, @args?, %query_values? )"
.ie n .SS "$c\->uri_for( $action, \e@captures?, @args?, \e%query_values? )"
.el .SS "\f(CW$c\fP\->uri_for( \f(CW$action\fP, \e@captures?, \f(CW@args\fP?, \e%query_values? )"
.IX Subsection "$c->uri_for( $action, @captures?, @args?, %query_values? )"
Constructs an absolute \s-1URI\s0 object based on the application root, the
provided path, and the additional arguments and query parameters provided.
When used as a string, provides a textual \s-1URI\s0.  If you need more flexibility
than this (i.e. the option to provide relative URIs etc.) see
Catalyst::Plugin::SmartURI.
.PP
If no arguments are provided, the \s-1URI\s0 for the current action is returned.
To return the current action and also provide \f(CW@args\fR, use
\&\f(CW\*(C`$c\->uri_for( $c\->action, @args )\*(C'\fR.
.PP
If the first argument is a string, it is taken as a public \s-1URI\s0 path relative
to \f(CW\*(C`$c\->namespace\*(C'\fR (if it doesn't begin with a forward slash) or
relative to the application root (if it does). It is then merged with
\&\f(CW\*(C`$c\->request\->base\*(C'\fR; any \f(CW@args\fR are appended as additional path
components; and any \f(CW%query_values\fR are appended as \f(CW\*(C`?foo=bar\*(C'\fR parameters.
.PP
If the first argument is a Catalyst::Action it represents an action which
will have its path resolved using \f(CW\*(C`$c\->dispatcher\->uri_for_action\*(C'\fR. The
optional \f(CW\*(C`\e@captures\*(C'\fR argument (an arrayref) allows passing the captured
variables that are needed to fill in the paths of Chained and Regex actions;
once the path is resolved, \f(CW\*(C`uri_for\*(C'\fR continues as though a path was
provided, appending any arguments or parameters and creating an absolute
\&\s-1URI\s0.
.PP
The captures for the current request can be found in
\&\f(CW\*(C`$c\->request\->captures\*(C'\fR, and actions can be resolved using
\&\f(CW\*(C`Catalyst::Controller\->action_for($name)\*(C'\fR. If you have a private action
path, use \f(CW\*(C`$c\->uri_for_action\*(C'\fR instead.
.PP
.Vb 3
\&  # Equivalent to $c\->req\->uri
\&  $c\->uri_for($c\->action, $c\->req\->captures,
\&      @{ $c\->req\->args }, $c\->req\->params);
\&
\&  # For the Foo action in the Bar controller
\&  $c\->uri_for($c\->controller(\*(AqBar\*(Aq)\->action_for(\*(AqFoo\*(Aq));
\&
\&  # Path to a static resource
\&  $c\->uri_for(\*(Aq/static/images/logo.png\*(Aq);
.Ve
.ie n .SS "$c\->uri_for_action( $path, \e@captures_and_args?, @args?, \e%query_values? )"
.el .SS "\f(CW$c\fP\->uri_for_action( \f(CW$path\fP, \e@captures_and_args?, \f(CW@args\fP?, \e%query_values? )"
.IX Subsection "$c->uri_for_action( $path, @captures_and_args?, @args?, %query_values? )"
.ie n .SS "$c\->uri_for_action( $action, \e@captures_and_args?, @args?, \e%query_values? )"
.el .SS "\f(CW$c\fP\->uri_for_action( \f(CW$action\fP, \e@captures_and_args?, \f(CW@args\fP?, \e%query_values? )"
.IX Subsection "$c->uri_for_action( $action, @captures_and_args?, @args?, %query_values? )"
.ie n .IP "$path" 4
.el .IP "\f(CW$path\fR" 4
.IX Item "$path"
A private path to the Catalyst action you want to create a \s-1URI\s0 for.
.Sp
This is a shortcut for calling \f(CW\*(C`$c\->dispatcher\->get_action_by_path($path)\*(C'\fR and passing the resulting \f(CW$action\fR and the remaining arguments to \f(CW\*(C`$c\->uri_for\*(C'\fR.
.Sp
You can also pass in a Catalyst::Action object, in which case it is passed to
\&\f(CW\*(C`$c\->uri_for\*(C'\fR.
.Sp
Note that although the path looks like a \s-1URI\s0 that dispatches to the wanted action, it is not a \s-1URI\s0, but an internal path to that action.
.Sp
For example, if the action looks like:
.Sp
.Vb 1
\& package MyApp::Controller::Users;
\&
\& sub lst : Path(\*(Aqthe\-list\*(Aq) {}
.Ve
.Sp
You can use:
.Sp
.Vb 1
\& $c\->uri_for_action(\*(Aq/users/lst\*(Aq)
.Ve
.Sp
and it will create the \s-1URI\s0 /users/the\-list.
.IP "\e@captures_and_args?" 4
.IX Item "@captures_and_args?"
Optional array reference of Captures (i.e. \f(CW\*(C`<CaptureArgs or $c\-\*(C'\fRreq\->captures>)
and arguments to the request. Usually used with Catalyst::DispatchType::Chained
to interpolate all the parameters in the \s-1URI\s0.
.ie n .IP "@args?" 4
.el .IP "\f(CW@args\fR?" 4
.IX Item "@args?"
Optional list of extra arguments \- can be supplied in the
\&\f(CW\*(C`\e@captures_and_args?\*(C'\fR array ref, or here \- whichever is easier for your
code.
.Sp
Your action can have zero, a fixed or a variable number of args (e.g.
\&\f(CWArgs(1)\fR for a fixed number or \f(CW\*(C`Args()\*(C'\fR for a variable number)..
.IP "\e%query_values?" 4
.IX Item "%query_values?"
Optional array reference of query parameters to append. E.g.
.Sp
.Vb 1
\&  { foo => \*(Aqbar\*(Aq }
.Ve
.Sp
will generate
.Sp
.Vb 1
\&  /rest/of/your/uri?foo=bar
.Ve
.ie n .SS "$c\->welcome_message"
.el .SS "\f(CW$c\fP\->welcome_message"
.IX Subsection "$c->welcome_message"
Returns the Catalyst welcome \s-1HTML\s0 page.
.SS "run_options"
.IX Subsection "run_options"
Contains a hash of options passed from the application script, including
the original \s-1ARGV\s0 the script received, the processed values from that
\&\s-1ARGV\s0 and any extra arguments to the script which were not processed.
.PP
This can be used to add custom options to your application's scripts
and setup your application differently depending on the values of these
options.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These methods are not meant to be used by end users.
.ie n .SS "$c\->components"
.el .SS "\f(CW$c\fP\->components"
.IX Subsection "$c->components"
Returns a hash of components.
.ie n .SS "$c\->context_class"
.el .SS "\f(CW$c\fP\->context_class"
.IX Subsection "$c->context_class"
Returns or sets the context class.
.ie n .SS "$c\->counter"
.el .SS "\f(CW$c\fP\->counter"
.IX Subsection "$c->counter"
Returns a hashref containing coderefs and execution counts (needed for
deep recursion detection).
.ie n .SS "$c\->depth"
.el .SS "\f(CW$c\fP\->depth"
.IX Subsection "$c->depth"
Returns the number of actions on the current internal execution stack.
.ie n .SS "$c\->dispatch"
.el .SS "\f(CW$c\fP\->dispatch"
.IX Subsection "$c->dispatch"
Dispatches a request to actions.
.ie n .SS "$c\->dispatcher_class"
.el .SS "\f(CW$c\fP\->dispatcher_class"
.IX Subsection "$c->dispatcher_class"
Returns or sets the dispatcher class.
.ie n .SS "$c\->dump_these"
.el .SS "\f(CW$c\fP\->dump_these"
.IX Subsection "$c->dump_these"
Returns a list of 2\-element array references (name, structure) pairs
that will be dumped on the error page in debug mode.
.ie n .SS "$c\->engine_class"
.el .SS "\f(CW$c\fP\->engine_class"
.IX Subsection "$c->engine_class"
Returns or sets the engine class.
.ie n .SS "$c\->execute( $class, $coderef )"
.el .SS "\f(CW$c\fP\->execute( \f(CW$class\fP, \f(CW$coderef\fP )"
.IX Subsection "$c->execute( $class, $coderef )"
Execute a coderef in given class and catch exceptions. Errors are available
via \f(CW$c\fR\->error.
.ie n .SS "$c\->finalize"
.el .SS "\f(CW$c\fP\->finalize"
.IX Subsection "$c->finalize"
Finalizes the request.
.ie n .SS "$c\->finalize_body"
.el .SS "\f(CW$c\fP\->finalize_body"
.IX Subsection "$c->finalize_body"
Finalizes body.
.ie n .SS "$c\->finalize_cookies"
.el .SS "\f(CW$c\fP\->finalize_cookies"
.IX Subsection "$c->finalize_cookies"
Finalizes cookies.
.ie n .SS "$c\->finalize_error"
.el .SS "\f(CW$c\fP\->finalize_error"
.IX Subsection "$c->finalize_error"
Finalizes error.
.ie n .SS "$c\->finalize_headers"
.el .SS "\f(CW$c\fP\->finalize_headers"
.IX Subsection "$c->finalize_headers"
Finalizes headers.
.ie n .SS "$c\->finalize_output"
.el .SS "\f(CW$c\fP\->finalize_output"
.IX Subsection "$c->finalize_output"
An alias for finalize_body.
.ie n .SS "$c\->finalize_read"
.el .SS "\f(CW$c\fP\->finalize_read"
.IX Subsection "$c->finalize_read"
Finalizes the input after reading is complete.
.ie n .SS "$c\->finalize_uploads"
.el .SS "\f(CW$c\fP\->finalize_uploads"
.IX Subsection "$c->finalize_uploads"
Finalizes uploads. Cleans up any temporary files.
.ie n .SS "$c\->get_action( $action, $namespace )"
.el .SS "\f(CW$c\fP\->get_action( \f(CW$action\fP, \f(CW$namespace\fP )"
.IX Subsection "$c->get_action( $action, $namespace )"
Gets an action in a given namespace.
.ie n .SS "$c\->get_actions( $action, $namespace )"
.el .SS "\f(CW$c\fP\->get_actions( \f(CW$action\fP, \f(CW$namespace\fP )"
.IX Subsection "$c->get_actions( $action, $namespace )"
Gets all actions of a given name in a namespace and all parent
namespaces.
.ie n .SS "$app\->handle_request( @arguments )"
.el .SS "\f(CW$app\fP\->handle_request( \f(CW@arguments\fP )"
.IX Subsection "$app->handle_request( @arguments )"
Called to handle each \s-1HTTP\s0 request.
.ie n .SS "$class\->prepare( @arguments )"
.el .SS "\f(CW$class\fP\->prepare( \f(CW@arguments\fP )"
.IX Subsection "$class->prepare( @arguments )"
Creates a Catalyst context from an engine-specific request (Apache, \s-1CGI\s0,
etc.).
.ie n .SS "$c\->prepare_action"
.el .SS "\f(CW$c\fP\->prepare_action"
.IX Subsection "$c->prepare_action"
Prepares action. See Catalyst::Dispatcher.
.ie n .SS "$c\->prepare_body"
.el .SS "\f(CW$c\fP\->prepare_body"
.IX Subsection "$c->prepare_body"
Prepares message body.
.ie n .SS "$c\->prepare_body_chunk( $chunk )"
.el .SS "\f(CW$c\fP\->prepare_body_chunk( \f(CW$chunk\fP )"
.IX Subsection "$c->prepare_body_chunk( $chunk )"
Prepares a chunk of data before sending it to HTTP::Body.
.PP
See Catalyst::Engine.
.ie n .SS "$c\->prepare_body_parameters"
.el .SS "\f(CW$c\fP\->prepare_body_parameters"
.IX Subsection "$c->prepare_body_parameters"
Prepares body parameters.
.ie n .SS "$c\->prepare_connection"
.el .SS "\f(CW$c\fP\->prepare_connection"
.IX Subsection "$c->prepare_connection"
Prepares connection.
.ie n .SS "$c\->prepare_cookies"
.el .SS "\f(CW$c\fP\->prepare_cookies"
.IX Subsection "$c->prepare_cookies"
Prepares cookies.
.ie n .SS "$c\->prepare_headers"
.el .SS "\f(CW$c\fP\->prepare_headers"
.IX Subsection "$c->prepare_headers"
Prepares headers.
.ie n .SS "$c\->prepare_parameters"
.el .SS "\f(CW$c\fP\->prepare_parameters"
.IX Subsection "$c->prepare_parameters"
Prepares parameters.
.ie n .SS "$c\->prepare_path"
.el .SS "\f(CW$c\fP\->prepare_path"
.IX Subsection "$c->prepare_path"
Prepares path and base.
.ie n .SS "$c\->prepare_query_parameters"
.el .SS "\f(CW$c\fP\->prepare_query_parameters"
.IX Subsection "$c->prepare_query_parameters"
Prepares query parameters.
.ie n .SS "$c\->log_request"
.el .SS "\f(CW$c\fP\->log_request"
.IX Subsection "$c->log_request"
Writes information about the request to the debug logs.  This includes:
.IP "\(bu" 4
Request method, path, and remote \s-1IP\s0 address
.IP "\(bu" 4
Query keywords (see \*(L"query_keywords\*(R" in Catalyst::Request)
.IP "\(bu" 4
Request parameters
.IP "\(bu" 4
File uploads
.ie n .SS "$c\->log_response"
.el .SS "\f(CW$c\fP\->log_response"
.IX Subsection "$c->log_response"
Writes information about the response to the debug logs by calling
\&\f(CW\*(C`$c\->log_response_status_line\*(C'\fR and \f(CW\*(C`$c\->log_response_headers\*(C'\fR.
.ie n .SS "$c\->log_response_status_line($response)"
.el .SS "\f(CW$c\fP\->log_response_status_line($response)"
.IX Subsection "$c->log_response_status_line($response)"
Writes one line of information about the response to the debug logs.  This includes:
.IP "\(bu" 4
Response status code
.IP "\(bu" 4
Content-Type header (if present)
.IP "\(bu" 4
Content-Length header (if present)
.ie n .SS "$c\->log_response_headers($headers);"
.el .SS "\f(CW$c\fP\->log_response_headers($headers);"
.IX Subsection "$c->log_response_headers($headers);"
Hook method which can be wrapped by plugins to log the response headers.
No-op in the default implementation.
.ie n .SS "$c\->log_request_parameters( query => {}, body => {} )"
.el .SS "\f(CW$c\fP\->log_request_parameters( query => {}, body => {} )"
.IX Subsection "$c->log_request_parameters( query => {}, body => {} )"
Logs request parameters to debug logs
.ie n .SS "$c\->log_request_uploads"
.el .SS "\f(CW$c\fP\->log_request_uploads"
.IX Subsection "$c->log_request_uploads"
Logs file uploads included in the request to the debug logs.
The parameter name, filename, file type, and file size are all included in
the debug logs.
.ie n .SS "$c\->log_request_headers($headers);"
.el .SS "\f(CW$c\fP\->log_request_headers($headers);"
.IX Subsection "$c->log_request_headers($headers);"
Hook method which can be wrapped by plugins to log the request headers.
No-op in the default implementation.
.ie n .SS "$c\->log_headers($type => $headers)"
.el .SS "\f(CW$c\fP\->log_headers($type => \f(CW$headers\fP)"
.IX Subsection "$c->log_headers($type => $headers)"
Logs HTTP::Headers (either request or response) to the debug logs.
.ie n .SS "$c\->prepare_read"
.el .SS "\f(CW$c\fP\->prepare_read"
.IX Subsection "$c->prepare_read"
Prepares the input for reading.
.ie n .SS "$c\->prepare_request"
.el .SS "\f(CW$c\fP\->prepare_request"
.IX Subsection "$c->prepare_request"
Prepares the engine request.
.ie n .SS "$c\->prepare_uploads"
.el .SS "\f(CW$c\fP\->prepare_uploads"
.IX Subsection "$c->prepare_uploads"
Prepares uploads.
.ie n .SS "$c\->prepare_write"
.el .SS "\f(CW$c\fP\->prepare_write"
.IX Subsection "$c->prepare_write"
Prepares the output for writing.
.ie n .SS "$c\->request_class"
.el .SS "\f(CW$c\fP\->request_class"
.IX Subsection "$c->request_class"
Returns or sets the request class. Defaults to Catalyst::Request.
.ie n .SS "$c\->response_class"
.el .SS "\f(CW$c\fP\->response_class"
.IX Subsection "$c->response_class"
Returns or sets the response class. Defaults to Catalyst::Response.
.ie n .SS "$c\->read( [$maxlength] )"
.el .SS "\f(CW$c\fP\->read( [$maxlength] )"
.IX Subsection "$c->read( [$maxlength] )"
Reads a chunk of data from the request body. This method is designed to
be used in a while loop, reading \f(CW$maxlength\fR bytes on every call.
\&\f(CW$maxlength\fR defaults to the size of the request if not specified.
.PP
You have to set \f(CW\*(C`MyApp\->config(parse_on_demand => 1)\*(C'\fR to use this
directly.
.PP
Warning: If you use \fIread()\fR, Catalyst will not process the body,
so you will not be able to access \s-1POST\s0 parameters or file uploads via
\&\f(CW$c\fR\->request.  You must handle all body parsing yourself.
.ie n .SS "$c\->run"
.el .SS "\f(CW$c\fP\->run"
.IX Subsection "$c->run"
Starts the engine.
.ie n .SS "$c\->set_action( $action, $code, $namespace, $attrs )"
.el .SS "\f(CW$c\fP\->set_action( \f(CW$action\fP, \f(CW$code\fP, \f(CW$namespace\fP, \f(CW$attrs\fP )"
.IX Subsection "$c->set_action( $action, $code, $namespace, $attrs )"
Sets an action in a given namespace.
.ie n .SS "$c\->setup_actions($component)"
.el .SS "\f(CW$c\fP\->setup_actions($component)"
.IX Subsection "$c->setup_actions($component)"
Sets up actions for a component.
.ie n .SS "$c\->setup_components"
.el .SS "\f(CW$c\fP\->setup_components"
.IX Subsection "$c->setup_components"
This method is called internally to set up the application's components.
.PP
It finds modules by calling the locate_components method, expands them to
package names with the expand_component_module method, and then installs
each component into the application.
.PP
The \f(CW\*(C`setup_components\*(C'\fR config option is passed to both of the above methods.
.PP
Installation of each component is performed by the setup_component method,
below.
.ie n .SS "$c\->locate_components( $setup_component_config )"
.el .SS "\f(CW$c\fP\->locate_components( \f(CW$setup_component_config\fP )"
.IX Subsection "$c->locate_components( $setup_component_config )"
This method is meant to provide a list of component modules that should be
setup for the application.  By default, it will use Module::Pluggable.
.PP
Specify a \f(CW\*(C`setup_components\*(C'\fR config option to pass additional options directly
to Module::Pluggable. To add additional search paths, specify a key named
\&\f(CW\*(C`search_extra\*(C'\fR as an array reference. Items in the array beginning with \f(CW\*(C`::\*(C'\fR
will have the application class name prepended to them.
.ie n .SS "$c\->expand_component_module( $component, $setup_component_config )"
.el .SS "\f(CW$c\fP\->expand_component_module( \f(CW$component\fP, \f(CW$setup_component_config\fP )"
.IX Subsection "$c->expand_component_module( $component, $setup_component_config )"
Components found by \f(CW\*(C`locate_components\*(C'\fR will be passed to this method, which
is expected to return a list of component (package) names to be set up.
.ie n .SS "$c\->setup_component"
.el .SS "\f(CW$c\fP\->setup_component"
.IX Subsection "$c->setup_component"
.ie n .SS "$c\->setup_dispatcher"
.el .SS "\f(CW$c\fP\->setup_dispatcher"
.IX Subsection "$c->setup_dispatcher"
Sets up dispatcher.
.ie n .SS "$c\->setup_engine"
.el .SS "\f(CW$c\fP\->setup_engine"
.IX Subsection "$c->setup_engine"
Sets up engine.
.ie n .SS "$c\->apply_default_middlewares"
.el .SS "\f(CW$c\fP\->apply_default_middlewares"
.IX Subsection "$c->apply_default_middlewares"
Adds the following Plack middlewares to your application, since they are
useful and commonly needed:
.PP
Plack::Middleware::ReverseProxy, (conditionally added based on the status
of your \f(CW$ENV\fR{\s-1REMOTE_ADDR\s0}, and can be forced on with \f(CW\*(C`using_frontend_proxy\*(C'\fR
or forced off with \f(CW\*(C`ignore_frontend_proxy\*(C'\fR), Plack::Middleware::LighttpdScriptNameFix
(if you are using Lighttpd), Plack::Middleware::IIS6ScriptNameFix (always
applied since this middleware is smart enough to conditionally apply itself).
.PP
Additionally if we detect we are using Nginx, we add a bit of custom middleware
to solve some problems with the way that server handles \f(CW$ENV\fR{\s-1PATH_INFO\s0} and
\&\f(CW$ENV\fR{\s-1SCRIPT_NAME\s0}
.ie n .SS "$c\->psgi_app"
.el .SS "\f(CW$c\fP\->psgi_app"
.IX Subsection "$c->psgi_app"
Returns a \s-1PSGI\s0 application code reference for the catalyst application
\&\f(CW$c\fR. This is the bare application without any middlewares
applied. \f(CW\*(C`${myapp}.psgi\*(C'\fR is not taken into account.
.PP
This is what you want to be using to retrieve the \s-1PSGI\s0 application code
reference of your Catalyst application for use in \fI.psgi\fR files.
.ie n .SS "$c\->setup_home"
.el .SS "\f(CW$c\fP\->setup_home"
.IX Subsection "$c->setup_home"
Sets up the home directory.
.ie n .SS "$c\->setup_log"
.el .SS "\f(CW$c\fP\->setup_log"
.IX Subsection "$c->setup_log"
Sets up log by instantiating a Catalyst::Log object and
passing it to \f(CW\*(C`log()\*(C'\fR. Pass in a comma-delimited list of levels to set the
log to.
.PP
This method also installs a \f(CW\*(C`debug\*(C'\fR method that returns a true value into the
catalyst subclass if the \*(L"debug\*(R" level is passed in the comma-delimited list,
or if the \f(CW$CATALYST_DEBUG\fR environment variable is set to a true value.
.PP
Note that if the log has already been setup, by either a previous call to
\&\f(CW\*(C`setup_log\*(C'\fR or by a call such as \f(CW\*(C`_\|_PACKAGE_\|_\->log( MyLogger\->new )\*(C'\fR,
that this method won't actually set up the log object.
.ie n .SS "$c\->setup_plugins"
.el .SS "\f(CW$c\fP\->setup_plugins"
.IX Subsection "$c->setup_plugins"
Sets up plugins.
.ie n .SS "$c\->setup_stats"
.el .SS "\f(CW$c\fP\->setup_stats"
.IX Subsection "$c->setup_stats"
Sets up timing statistics class.
.ie n .SS "$c\->registered_plugins"
.el .SS "\f(CW$c\fP\->registered_plugins"
.IX Subsection "$c->registered_plugins"
Returns a sorted list of the plugins which have either been stated in the
import list.
.PP
If passed a given plugin name, it will report a boolean value indicating
whether or not that plugin is loaded.  A fully qualified name is required if
the plugin name does not begin with \f(CW\*(C`Catalyst::Plugin::\*(C'\fR.
.PP
.Vb 3
\& if ($c\->registered_plugins(\*(AqSome::Plugin\*(Aq)) {
\&     ...
\& }
.Ve
.ie n .SS "$c\->stack"
.el .SS "\f(CW$c\fP\->stack"
.IX Subsection "$c->stack"
Returns an arrayref of the internal execution stack (actions that are
currently executing).
.ie n .SS "$c\->stats"
.el .SS "\f(CW$c\fP\->stats"
.IX Subsection "$c->stats"
Returns the current timing statistics object. By default Catalyst uses
Catalyst::Stats, but can be set otherwise with
stats_class.
.PP
Even if \-Stats is not enabled, the stats object is still
available. By enabling it with \f(CW\*(C` $c\-\*(C'\fRstats\->\fIenabled\fR\|(1) >, it can be used to
profile explicitly, although MyApp.pm still won't profile nor output anything
by itself.
.ie n .SS "$c\->stats_class"
.el .SS "\f(CW$c\fP\->stats_class"
.IX Subsection "$c->stats_class"
Returns or sets the stats (timing statistics) class. Catalyst::Stats is used by default.
.ie n .SS "$c\->use_stats"
.el .SS "\f(CW$c\fP\->use_stats"
.IX Subsection "$c->use_stats"
Returns 1 when stats collection is enabled.
.PP
Note that this is a static method, not an accessor and should be overridden
by declaring \f(CW\*(C`sub use_stats { 1 }\*(C'\fR in your MyApp.pm, not by calling \f(CW\*(C`$c\->use_stats(1)\*(C'\fR.
.ie n .SS "$c\->write( $data )"
.el .SS "\f(CW$c\fP\->write( \f(CW$data\fP )"
.IX Subsection "$c->write( $data )"
Writes \f(CW$data\fR to the output stream. When using this method directly, you
will need to manually set the \f(CW\*(C`Content\-Length\*(C'\fR header to the length of
your output data, if known.
.SS "version"
.IX Subsection "version"
Returns the Catalyst version number. Mostly useful for \*(L"powered by\*(R"
messages in template systems.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
There are a number of 'base' config variables which can be set:
.IP "\(bu" 4
\&\f(CW\*(C`default_model\*(C'\fR \- The default model picked if you say \f(CW\*(C`$c\->model\*(C'\fR. See \*(L"$c\->model($name)\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`default_view\*(C'\fR \- The default view to be rendered or returned when \f(CW\*(C`$c\->view\*(C'\fR is called. See \*(L"$c\->view($name)\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`disable_component_resolution_regex_fallback\*(C'\fR \- Turns
off the deprecated component resolution functionality so
that if any of the component methods (e.g. \f(CW\*(C`$c\->controller(\*(AqFoo\*(Aq)\*(C'\fR)
are called then regex search will not be attempted on string values and
instead \f(CW\*(C`undef\*(C'\fR will be returned.
.IP "\(bu" 4
\&\f(CW\*(C`home\*(C'\fR \- The application home directory. In an uninstalled application,
this is the top level application directory. In an installed application,
this will be the directory containing \f(CW\*(C`MyApp.pm\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ignore_frontend_proxy\*(C'\fR \- See \*(L"\s-1PROXY\s0 \s-1SUPPORT\s0\*(R"
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR \- The name of the application in debug messages and the debug and
welcome screens
.IP "\(bu" 4
\&\f(CW\*(C`parse_on_demand\*(C'\fR \- The request body (for example file uploads) will not be parsed
until it is accessed. This allows you to (for example) check authentication (and reject
the upload) before actually receiving all the data. See \*(L"ON-DEMAND \s-1PARSER\s0\*(R"
.IP "\(bu" 4
\&\f(CW\*(C`root\*(C'\fR \- The root directory for templates. Usually this is just a
subdirectory of the home directory, but you can set it to change the
templates to a different directory.
.IP "\(bu" 4
\&\f(CW\*(C`search_extra\*(C'\fR \- Array reference passed to Module::Pluggable to for additional
namespaces from which components will be loaded (and constructed and stored in
\&\f(CW\*(C`$c\->components\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`show_internal_actions\*(C'\fR \- If true, causes internal actions such as \f(CW\*(C`_DISPATCH\*(C'\fR
to be shown in hit debug tables in the test server.
.IP "\(bu" 4
\&\f(CW\*(C`use_request_uri_for_path\*(C'\fR \- Controls if the \f(CW\*(C`REQUEST_URI\*(C'\fR or \f(CW\*(C`PATH_INFO\*(C'\fR environment
variable should be used for determining the request path.
.Sp
Most web server environments pass the requested path to the application using environment variables,
from which Catalyst has to reconstruct the request base (i.e. the top level path to / in the application,
exposed as \f(CW\*(C`$c\->request\->base\*(C'\fR) and the request path below that base.
.Sp
There are two methods of doing this, both of which have advantages and disadvantages. Which method is used
is determined by the \f(CW\*(C`$c\->config(use_request_uri_for_path)\*(C'\fR setting (which can either be true or false).
.RS 4
.IP "use_request_uri_for_path => 0" 4
.IX Item "use_request_uri_for_path => 0"
This is the default (and the) traditional method that Catalyst has used for determining the path information.
The path is generated from a combination of the \f(CW\*(C`PATH_INFO\*(C'\fR and \f(CW\*(C`SCRIPT_NAME\*(C'\fR environment variables.
The allows the application to behave correctly when \f(CW\*(C`mod_rewrite\*(C'\fR is being used to redirect requests
into the application, as these variables are adjusted by mod_rewrite to take account for the redirect.
.Sp
However this method has the major disadvantage that it is impossible to correctly decode some elements
of the path, as \s-1RFC\s0 3875 says: "\f(CW\*(C`Unlike a URI path, the PATH_INFO is not URL\-encoded, and cannot
contain path\-segment parameters.\*(C'\fR" This means \s-1PATH_INFO\s0 is \fBalways\fR decoded, and therefore Catalyst
can't distinguish / vs \f(CW%2F\fR in paths (in addition to other encoded values).
.IP "use_request_uri_for_path => 1" 4
.IX Item "use_request_uri_for_path => 1"
This method uses the \f(CW\*(C`REQUEST_URI\*(C'\fR and \f(CW\*(C`SCRIPT_NAME\*(C'\fR environment variables. As \f(CW\*(C`REQUEST_URI\*(C'\fR is never
decoded, this means that applications using this mode can correctly handle URIs including the \f(CW%2F\fR character
(i.e. with \f(CW\*(C`AllowEncodedSlashes\*(C'\fR set to \f(CW\*(C`On\*(C'\fR in Apache).
.Sp
Given that this method of path resolution is provably more correct, it is recommended that you use
this unless you have a specific need to deploy your application in a non-standard environment, and you are
aware of the implications of not being able to handle encoded \s-1URI\s0 paths correctly.
.Sp
However it also means that in a number of cases when the app isn't installed directly at a path, but instead
is having paths rewritten into it (e.g. as a .cgi/fcgi in a public_html directory, with mod_rewrite in a
\&.htaccess file, or when \s-1SSI\s0 is used to rewrite pages into the app, or when sub-paths of the app are exposed
at other URIs than that which the app is 'normally' based at with \f(CW\*(C`mod_rewrite\*(C'\fR), the resolution of
\&\f(CW\*(C`$c\->request\->base\*(C'\fR will be incorrect.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`using_frontend_proxy\*(C'\fR \- See \*(L"\s-1PROXY\s0 \s-1SUPPORT\s0\*(R".
.SH "INTERNAL ACTIONS"
.IX Header "INTERNAL ACTIONS"
Catalyst uses internal actions like \f(CW\*(C`_DISPATCH\*(C'\fR, \f(CW\*(C`_BEGIN\*(C'\fR, \f(CW\*(C`_AUTO\*(C'\fR,
\&\f(CW\*(C`_ACTION\*(C'\fR, and \f(CW\*(C`_END\*(C'\fR. These are by default not shown in the private
action table, but you can make them visible with a config parameter.
.PP
.Vb 1
\&    MyApp\->config(show_internal_actions => 1);
.Ve
.SH "ON-DEMAND PARSER"
.IX Header "ON-DEMAND PARSER"
The request body is usually parsed at the beginning of a request,
but if you want to handle input yourself, you can enable on-demand
parsing with a config parameter.
.PP
.Vb 1
\&    MyApp\->config(parse_on_demand => 1);
.Ve
.SH "PROXY SUPPORT"
.IX Header "PROXY SUPPORT"
Many production servers operate using the common double-server approach,
with a lightweight frontend web server passing requests to a larger
backend server. An application running on the backend server must deal
with two problems: the remote user always appears to be \f(CW127.0.0.1\fR and
the server's hostname will appear to be \f(CW\*(C`localhost\*(C'\fR regardless of the
virtual host that the user connected through.
.PP
Catalyst will automatically detect this situation when you are running
the frontend and backend servers on the same machine. The following
changes are made to the request.
.PP
.Vb 2
\&    $c\->req\->address is set to the user\*(Aqs real IP address, as read from
\&    the HTTP X\-Forwarded\-For header.
\&
\&    The host value for $c\->req\->base and $c\->req\->uri is set to the real
\&    host, as read from the HTTP X\-Forwarded\-Host header.
.Ve
.PP
Additionally, you may be running your backend application on an insecure
connection (port 80) while your frontend proxy is running under \s-1SSL\s0.  If there
is a discrepancy in the ports, use the \s-1HTTP\s0 header \f(CW\*(C`X\-Forwarded\-Port\*(C'\fR to
tell Catalyst what port the frontend listens on.  This will allow all URIs to
be created properly.
.PP
In the case of passing in:
.PP
.Vb 1
\&    X\-Forwarded\-Port: 443
.Ve
.PP
All calls to \f(CW\*(C`uri_for\*(C'\fR will result in an https link, as is expected.
.PP
Obviously, your web server must support these headers for this to work.
.PP
In a more complex server farm environment where you may have your
frontend proxy server(s) on different machines, you will need to set a
configuration option to tell Catalyst to read the proxied data from the
headers.
.PP
.Vb 1
\&    MyApp\->config(using_frontend_proxy => 1);
.Ve
.PP
If you do not wish to use the proxy support at all, you may set:
.PP
.Vb 1
\&    MyApp\->config(ignore_frontend_proxy => 0);
.Ve
.SS "Note about psgi files"
.IX Subsection "Note about psgi files"
Note that if you supply your own .psgi file, calling
\&\f(CW\*(C`MyApp\->psgi_app(@_);\*(C'\fR, then \fBthis will not happen automatically\fR.
.PP
You either need to apply Plack::Middleware::ReverseProxy yourself
in your psgi, for example:
.PP
.Vb 4
\&    builder {
\&        enable "Plack::Middleware::ReverseProxy";
\&        MyApp\->psgi_app
\&    };
.Ve
.PP
This will unconditionally add the ReverseProxy support, or you need to call
\&\f(CW\*(C`$app = MyApp\->apply_default_middlewares($app)\*(C'\fR (to conditionally
apply the support depending upon your config).
.PP
See Catalyst::PSGI for more information.
.SH "THREAD SAFETY"
.IX Header "THREAD SAFETY"
Catalyst has been tested under Apache 2's threading \f(CW\*(C`mpm_worker\*(C'\fR,
\&\f(CW\*(C`mpm_winnt\*(C'\fR, and the standalone forking \s-1HTTP\s0 server on Windows. We
believe the Catalyst core to be thread-safe.
.PP
If you plan to operate in a threaded environment, remember that all other
modules you are using must also be thread-safe. Some modules, most notably
DBD::SQLite, are not thread-safe.
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\s-1IRC:\s0
.PP
.Vb 1
\&    Join #catalyst on irc.perl.org.
.Ve
.PP
Mailing Lists:
.PP
.Vb 2
\&    http://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/catalyst
\&    http://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/catalyst\-dev
.Ve
.PP
Web:
.PP
.Vb 1
\&    http://catalyst.perl.org
.Ve
.PP
Wiki:
.PP
.Vb 1
\&    http://dev.catalyst.perl.org
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Task::Catalyst \- All you need to start with Catalyst"
.IX Subsection "Task::Catalyst - All you need to start with Catalyst"
.SS "Catalyst::Manual \- The Catalyst Manual"
.IX Subsection "Catalyst::Manual - The Catalyst Manual"
.SS "Catalyst::Component, Catalyst::Controller \- Base classes for components"
.IX Subsection "Catalyst::Component, Catalyst::Controller - Base classes for components"
.SS "Catalyst::Engine \- Core engine"
.IX Subsection "Catalyst::Engine - Core engine"
.SS "Catalyst::Log \- Log class."
.IX Subsection "Catalyst::Log - Log class."
.SS "Catalyst::Request \- Request object"
.IX Subsection "Catalyst::Request - Request object"
.SS "Catalyst::Response \- Response object"
.IX Subsection "Catalyst::Response - Response object"
.SS "Catalyst::Test \- The test suite."
.IX Subsection "Catalyst::Test - The test suite."
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005, the above named \s-1PROJECT\s0 \s-1FOUNDER\s0 and \s-1CONTRIBUTORS\s0.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
