.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Utility::ArraySplicer 3"
.TH MakeMethods::Utility::ArraySplicer 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Utility::ArraySplicer \- Common array ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Class::MakeMethods::Utility::ArraySplicer;
\&  
\&  # Get one or more values
\&  $value = array_splicer( $array_ref, $index );
\&  @values = array_splicer( $array_ref, $index_array_ref );
\&  
\&  # Set one or more values
\&  array_splicer( $array_ref, $index => $new_value, ... );
\&  
\&  # Splice selected values in or out
\&  array_splicer( $array_ref, [ $start_index, $end_index], [ @values ]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a utility function and several associated constants which support a general purpose array-splicer interface, used by several of the Standard and Composite method generators.
.SS "array_splicer"
.IX Subsection "array_splicer"
This is a general-purpose array accessor function. Depending on the arguments passed to it, it will get, set, slice, splice, or otherwise modify your array.
.IP "\(bu" 4
If called without any arguments, returns the contents of the array in list context, or an array reference in scalar context (or undef).
.Sp
.Vb 3
\&  # Get all values
\&  $value_ref = array_splicer( $array_ref );
\&  @values = array_splicer( $array_ref );
.Ve
.IP "\(bu" 4
If called with a single numeric argument, uses that argument as an index to retrieve from the referenced array, and returns that value (or undef).
.Sp
.Vb 2
\&  # Get one value
\&  $value = array_splicer( $array_ref, $index );
.Ve
.IP "\(bu" 4
If called with a single array ref argument, sets the contents of the array to match the contents of the provided one.
.Sp
.Vb 2
\&  # Set contents of array
\&  array_splicer( $array_ref, [ $value1, $value2, ... ] );
\&
\&  # Reset the array contents to empty
\&  array_splicer( $array_ref, [] );
.Ve
.IP "\(bu" 4
If called with a two arguments, the first undefined and the second an array ref argument, uses that array's contents as a list of indexes to return a slice of the referenced array.
.Sp
.Vb 2
\&  # Get slice of values
\&  @values = array_splicer( $array_ref, undef, [ $index1, $index2, ... ] );
.Ve
.IP "\(bu" 4
If called with a list of argument pairs, each with a numeric index and an associated value, stores the value at the given index in the referenced array. The current value in each position will be overwritten, and later arguments with the same index will override earlier ones. Returns the current array-ref value.
.Sp
.Vb 2
\&  # Set one or more values by index
\&  array_splicer( $array_ref, $index1 => $value1, $index2 => $value2, ... );
.Ve
.IP "\(bu" 4
If called with a list of argument pairs, each with the first item being a reference to an array of up to two numbers, loops over each pair and uses those numbers to splice the value array.
.Sp
.Vb 2
\&  # Splice selected values in or out
\&  array_splicer( $array_ref, [ $start_index, $count], [ @values ]);
.Ve
.Sp
The first controlling number is the position at which the splice will begin. Zero will start before the first item in the list. Negative numbers count backwards from the end of the array.
.Sp
The second number is the number of items to be removed from the list. If it is omitted, or undefined, or zero, no items are removed. If it is a positive integer, that many items will be returned.
.Sp
If both numbers are omitted, or are both undefined, they default to containing the entire value array.
.Sp
If the second argument is undef, no values will be inserted; if it is a non-reference value, that one value will be inserted; if it is an array-ref, its values will be copied.
.Sp
The method returns the items that removed from the array, if any.
.Sp
Here are some examples of common splicing operations.
.Sp
.Vb 2
\&  # Insert an item at position in the array
\&  $obj\->bar([3], \*(AqPotatoes\*(Aq );  
\&  
\&  # Remove 1 item from position 3 in the array
\&  $obj\->bar([3, 1], undef );  
\&  
\&  # Set a new value at position 2, and return the old value 
\&  print $obj\->bar([2, 1], \*(AqFroth\*(Aq );
\&
\&  # Unshift an item onto the front of the list
\&  array_splicer( $array_ref, [0], \*(AqBubbles\*(Aq );
\&
\&  # Shift the first item off of the front of the list
\&  print array_splicer( $array_ref, [0, 1], undef );
\&
\&  # Push an item onto the end of the list
\&  array_splicer( $array_ref, [undef], \*(AqBubbles\*(Aq );
\&
\&  # Pop the last item off of the end of the list
\&  print array_splicer( $array_ref, [undef, 1], undef );
.Ve
.SS "Constants"
.IX Subsection "Constants"
There are also constants symbols to facilitate some common combinations of splicing arguments:
.PP
.Vb 2
\&  # Reset the array contents to empty
\&  array_splicer( $array_ref, array_clear );
\&  
\&  # Set the array contents to provided values
\&  array_splicer( $array_ref, array_splice, [ 2, 3 ] );
\&  
\&  # Unshift an item onto the front of the list
\&  array_splicer( $array_ref, array_unshift, \*(AqBubbles\*(Aq );
\&  
\&  # Shift it back off again
\&  print array_splicer( $array_ref, array_shift );
\&  
\&  # Push an item onto the end of the list
\&  array_splicer( $array_ref, array_push, \*(AqBubbles\*(Aq );
\&  
\&  # Pop it back off again
\&  print array_splicer( $array_ref, array_pop );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.PP
See Class::MakeMethods::Standard::Hash and numerous other classes for
examples of usage.
