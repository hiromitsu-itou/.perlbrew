.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::CSV 3"
.TH Text::CSV 3 "2010-12-27" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::CSV \- comma\-separated values manipulator (using XS or PurePerl)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Text::CSV;
\&
\& my @rows;
\& my $csv = Text::CSV\->new ( { binary => 1 } )  # should set binary attribute.
\&                 or die "Cannot use CSV: ".Text::CSV\->error_diag ();
\& 
\& open my $fh, "<:encoding(utf8)", "test.csv" or die "test.csv: $!";
\& while ( my $row = $csv\->getline( $fh ) ) {
\&     $row\->[2] =~ m/pattern/ or next; # 3rd field should match
\&     push @rows, $row;
\& }
\& $csv\->eof or $csv\->error_diag();
\& close $fh;
\&
\& $csv\->eol ("\er\en");
\& 
\& open $fh, ">:encoding(utf8)", "new.csv" or die "new.csv: $!";
\& $csv\->print ($fh, $_) for @rows;
\& close $fh or die "new.csv: $!";
\& 
\& #
\& # parse and combine style
\& #
\& 
\& $status = $csv\->combine(@columns);    # combine columns into a string
\& $line   = $csv\->string();             # get the combined string
\& 
\& $status  = $csv\->parse($line);        # parse a CSV string into fields
\& @columns = $csv\->fields();            # get the parsed fields
\& 
\& $status       = $csv\->status ();      # get the most recent status
\& $bad_argument = $csv\->error_input (); # get the most recent bad argument
\& $diag         = $csv\->error_diag ();  # if an error occured, explains WHY
\& 
\& $status = $csv\->print ($io, $colref); # Write an array of fields
\&                                       # immediately to a file $io
\& $colref = $csv\->getline ($io);        # Read a line from file $io,
\&                                       # parse it and return an array
\&                                       # ref of fields
\& $csv\->column_names (@names);          # Set column names for getline_hr ()
\& $ref = $csv\->getline_hr ($io);        # getline (), but returns a hashref
\& $eof = $csv\->eof ();                  # Indicate if last parse or
\&                                       # getline () hit End Of File
\& 
\& $csv\->types(\e@t_array);               # Set column types
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::CSV provides facilities for the composition and decomposition of
comma-separated values using Text::CSV_XS or its pure Perl version.
.PP
An instance of the Text::CSV class can combine fields into a \s-1CSV\s0 string
and parse a \s-1CSV\s0 string into fields.
.PP
The module accepts either strings or files as input and can utilize any
user-specified characters as delimiters, separators, and escapes so it is
perhaps better called \s-1ASV\s0 (anything separated values) rather than just \s-1CSV\s0.
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    1.21
.Ve
.PP
This module is compatible with Text::CSV_XS \fB0.80\fR and later.
.SS "Embedded newlines"
.IX Subsection "Embedded newlines"
\&\fBImportant Note\fR: The default behavior is to only accept \s-1ASCII\s0 characters.
This means that fields can not contain newlines. If your data contains
newlines embedded in fields, or characters above 0x7e (tilde), or binary data,
you *must* set \f(CW\*(C`binary => 1\*(C'\fR in the call to \f(CW\*(C`new ()\*(C'\fR.  To cover the widest
range of parsing options, you will always want to set binary.
.PP
But you still have the problem that you have to pass a correct line to the
\&\f(CW\*(C`parse ()\*(C'\fR method, which is more complicated from the usual point of
usage:
.PP
.Vb 4
\& my $csv = Text::CSV\->new ({ binary => 1, eol => $/ });
\& while (<>) {           #  WRONG!
\&     $csv\->parse ($_);
\&     my @fields = $csv\->fields ();
.Ve
.PP
will break, as the while might read broken lines, as that does not care
about the quoting. If you need to support embedded newlines, the way to go
is either
.PP
.Vb 3
\& my $csv = Text::CSV\->new ({ binary => 1, eol => $/ });
\& while (my $row = $csv\->getline (*ARGV)) {
\&     my @fields = @$row;
.Ve
.PP
or, more safely in perl 5.6 and up
.PP
.Vb 4
\& my $csv = Text::CSV\->new ({ binary => 1, eol => $/ });
\& open my $io, "<", $file or die "$file: $!";
\& while (my $row = $csv\->getline ($io)) {
\&     my @fields = @$row;
.Ve
.SS "Unicode (\s-1UTF8\s0)"
.IX Subsection "Unicode (UTF8)"
On parsing (both for \f(CW\*(C`getline ()\*(C'\fR and \f(CW\*(C`parse ()\*(C'\fR), if the source is
marked being \s-1UTF8\s0, then all fields that are marked binary will also be
be marked \s-1UTF8\s0.
.PP
For complete control over encoding, please use Text::CSV::Encoded:
.PP
.Vb 5
\&    use Text::CSV::Encoded;
\&    my $csv = Text::CSV::Encoded\->new ({
\&        encoding_in  => "iso\-8859\-1", # the encoding comes into   Perl
\&        encoding_out => "cp1252",     # the encoding comes out of Perl
\&    });
\&
\&    $csv = Text::CSV::Encoded\->new ({ encoding  => "utf8" });
\&    # combine () and print () accept *literally* utf8 encoded data
\&    # parse () and getline () return *literally* utf8 encoded data
\&
\&    $csv = Text::CSV::Encoded\->new ({ encoding  => undef }); # default
\&    # combine () and print () accept UTF8 marked data
\&    # parse () and getline () return UTF8 marked data
.Ve
.PP
On combining (\f(CW\*(C`print ()\*(C'\fR and \f(CW\*(C`combine ()\*(C'\fR), if any of the combining
fields was marked \s-1UTF8\s0, the resulting string will be marked \s-1UTF8\s0.
.PP
Note however if the backend module is Text::CSV_XS,
that all fields \f(CW\*(C`before\*(C'\fR the first field that was marked \s-1UTF8\s0
and contained 8\-bit characters that were not upgraded to \s-1UTF8\s0, these
will be bytes in the resulting string too, causing errors. If you pass
data of different encoding, or you don't know if there is different
encoding, force it to be upgraded before you pass them on:
.PP
.Vb 2
\&    # backend = Text::CSV_XS
\&    $csv\->print ($fh, [ map { utf8::upgrade (my $x = $_); $x } @data ]);
.Ve
.SH "SPECIFICATION"
.IX Header "SPECIFICATION"
See to \*(L"\s-1SPECIFICATION\s0\*(R" in Text::CSV_XS.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These methods are common between \s-1XS\s0 and puer Perl version.
Most of the document was shamelessly copied and replaced from Text::CSV_XS.
.SS "version ()"
.IX Subsection "version ()"
(Class method) Returns the current backend module version.
If you want the module version, you can use the \f(CW\*(C`VERSION\*(C'\fR method,
.PP
.Vb 3
\& print Text::CSV\->VERSION;      # This module version
\& print Text::CSV\->version;      # The version of the worker module
\&                                # same as Text::CSV\->backend\->version
.Ve
.SS "new (\e%attr)"
.IX Subsection "new (%attr)"
(Class method) Returns a new instance of Text::CSV_XS. The objects
attributes are described by the (optional) hash ref \f(CW\*(C`\e%attr\*(C'\fR.
Currently the following attributes are available:
.IP "eol" 4
.IX Item "eol"
An end-of-line string to add to rows. \f(CW\*(C`undef\*(C'\fR is replaced with an
empty string. The default is \f(CW\*(C`$\e\*(C'\fR. Common values for \f(CW\*(C`eol\*(C'\fR are
\&\f(CW"\e012"\fR (Line Feed) or \f(CW"\e015\e012"\fR (Carriage Return, Line Feed).
Cannot be longer than 7 (\s-1ASCII\s0) characters.
.Sp
If both \f(CW$/\fR and \f(CW\*(C`eol\*(C'\fR equal \f(CW"\e015"\fR, parsing lines that end on
only a Carriage Return without Line Feed, will be \f(CW\*(C`parse\*(C'\fRd correct.
Line endings, whether in \f(CW$/\fR or \f(CW\*(C`eol\*(C'\fR, other than \f(CW\*(C`undef\*(C'\fR,
\&\f(CW"\en"\fR, \f(CW"\er\en"\fR, or \f(CW"\er"\fR are not (yet) supported for parsing.
.IP "sep_char" 4
.IX Item "sep_char"
The char used for separating fields, by default a comma. (\f(CW\*(C`,\*(C'\fR).
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The separation character can not be equal to the quote character.
The separation character can not be equal to the escape character.
.Sp
See also \*(L"\s-1CAVEATS\s0\*(R" in Text::CSV_XS
.IP "allow_whitespace" 4
.IX Item "allow_whitespace"
When this option is set to true, whitespace (\s-1TAB\s0's and \s-1SPACE\s0's)
surrounding the separation character is removed when parsing. If
either \s-1TAB\s0 or \s-1SPACE\s0 is one of the three major characters \f(CW\*(C`sep_char\*(C'\fR,
\&\f(CW\*(C`quote_char\*(C'\fR, or \f(CW\*(C`escape_char\*(C'\fR it will not be considered whitespace.
.Sp
So lines like:
.Sp
.Vb 1
\&  1 , "foo" , bar , 3 , zapp
.Ve
.Sp
are now correctly parsed, even though it violates the \s-1CSV\s0 specs.
.Sp
Note that \fBall\fR whitespace is stripped from start and end of each
field. That would make it more a \fIfeature\fR than a way to be able
to parse bad \s-1CSV\s0 lines, as
.Sp
.Vb 1
\& 1,   2.0,  3,   ape  , monkey
.Ve
.Sp
will now be parsed as
.Sp
.Vb 1
\& ("1", "2.0", "3", "ape", "monkey")
.Ve
.Sp
even if the original line was perfectly sane \s-1CSV\s0.
.IP "blank_is_undef" 4
.IX Item "blank_is_undef"
Under normal circumstances, \s-1CSV\s0 data makes no distinction between
quoted\- and unquoted empty fields. They both end up in an empty
string field once read, so
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& ("1", "", "", " ", "2")
.Ve
.Sp
When \fIwriting\fR \s-1CSV\s0 files with \f(CW\*(C`always_quote\*(C'\fR set, the unquoted empty
field is the result of an undefined value. To make it possible to also
make this distinction when reading \s-1CSV\s0 data, the \f(CW\*(C`blank_is_undef\*(C'\fR option
will cause unquoted empty fields to be set to undef, causing the above to
be parsed as
.Sp
.Vb 1
\& ("1", "", undef, " ", "2")
.Ve
.IP "empty_is_undef" 4
.IX Item "empty_is_undef"
Going one step further than \f(CW\*(C`blank_is_undef\*(C'\fR, this attribute converts
all empty fields to undef, so
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& (1, undef, undef, " ", 2)
.Ve
.Sp
Note that this only effects fields that are \fIreally\fR empty, not fields
that are empty after stripping allowed whitespace. \s-1YMMV\s0.
.IP "quote_char" 4
.IX Item "quote_char"
The char used for quoting fields containing blanks, by default the
double quote character (\f(CW\*(C`"\*(C'\fR). A value of undef suppresses
quote chars. (For simple cases only).
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The quote character can not be equal to the separation character.
.IP "allow_loose_quotes" 4
.IX Item "allow_loose_quotes"
By default, parsing fields that have \f(CW\*(C`quote_char\*(C'\fR characters inside
an unquoted field, like
.Sp
.Vb 1
\& 1,foo "bar" baz,42
.Ve
.Sp
would result in a parse error. Though it is still bad practice to
allow this format, we cannot help there are some vendors that make
their applications spit out lines styled like this.
.Sp
In case there is \fBreally\fR bad \s-1CSV\s0 data, like
.Sp
.Vb 1
\& 1,"foo "bar" baz",42
.Ve
.Sp
or
.Sp
.Vb 1
\& 1,""foo bar baz"",42
.Ve
.Sp
there is a way to get that parsed, and leave the quotes inside the quoted
field as-is. This can be achieved by setting \f(CW\*(C`allow_loose_quotes\*(C'\fR \fB\s-1AND\s0\fR
making sure that the \f(CW\*(C`escape_char\*(C'\fR is \fInot\fR equal to \f(CW\*(C`quote_char\*(C'\fR.
.IP "escape_char" 4
.IX Item "escape_char"
The character used for escaping certain characters inside quoted fields.
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The \f(CW\*(C`escape_char\*(C'\fR defaults to being the literal double-quote mark (\f(CW\*(C`"\*(C'\fR)
in other words, the same as the default \f(CW\*(C`quote_char\*(C'\fR. This means that
doubling the quote mark in a field escapes it:
.Sp
.Vb 1
\&  "foo","bar","Escape ""quote mark"" with two ""quote marks""","baz"
.Ve
.Sp
If you change the default quote_char without changing the default
escape_char, the escape_char will still be the quote mark.  If instead
you want to escape the quote_char by doubling it, you will need to change
the escape_char to be the same as what you changed the quote_char to.
.Sp
The escape character can not be equal to the separation character.
.IP "allow_loose_escapes" 4
.IX Item "allow_loose_escapes"
By default, parsing fields that have \f(CW\*(C`escape_char\*(C'\fR characters that
escape characters that do not need to be escaped, like:
.Sp
.Vb 2
\& my $csv = Text::CSV\->new ({ escape_char => "\e\e" });
\& $csv\->parse (qq{1,"my bar\e\*(Aqs",baz,42});
.Ve
.Sp
would result in a parse error. Though it is still bad practice to
allow this format, this option enables you to treat all escape character
sequences equal.
.IP "binary" 4
.IX Item "binary"
If this attribute is \s-1TRUE\s0, you may use binary characters in quoted fields,
including line feeds, carriage returns and \s-1NULL\s0 bytes. (The latter must
be escaped as \f(CW\*(C`"0\*(C'\fR.) By default this feature is off.
.Sp
If a string is marked \s-1UTF8\s0, binary will be turned on automatically when
binary characters other than \s-1CR\s0 or \s-1NL\s0 are encountered. Note that a simple
string like \f(CW"\ex{00a0}"\fR might still be binary, but not marked \s-1UTF8\s0, so
setting \f(CW\*(C`{ binary => 1 }\*(C'\fR is still a wise option.
.IP "types" 4
.IX Item "types"
A set of column types; this attribute is immediately passed to the
\&\fItypes\fR method below. You must not set this attribute otherwise,
except for using the \fItypes\fR method. For details see the description
of the \fItypes\fR method below.
.IP "always_quote" 4
.IX Item "always_quote"
By default the generated fields are quoted only, if they need to, for
example, if they contain the separator. If you set this attribute to
a \s-1TRUE\s0 value, then all defined fields will be quoted. This is typically
easier to handle in external applications.
.IP "quote_space" 4
.IX Item "quote_space"
By default, a space in a field would trigger quotation. As no rule
exists this to be forced in \s-1CSV\s0, nor any for the opposite, the default
is true for safety. You can exclude the space from this trigger by
setting this option to 0.
.IP "quote_null" 4
.IX Item "quote_null"
By default, a \s-1NULL\s0 byte in a field would be escaped. This attribute
enables you to treat the \s-1NULL\s0 byte as a simple binary character in
binary mode (the \f(CW\*(C`{ binary => 1 }\*(C'\fR is set). The default is true.
You can prevent \s-1NULL\s0 escapes by setting this attribute to 0.
.IP "keep_meta_info" 4
.IX Item "keep_meta_info"
By default, the parsing of input lines is as simple and fast as
possible. However, some parsing information \- like quotation of
the original field \- is lost in that process. Set this flag to
true to be able to retrieve that information after parsing with
the methods \f(CW\*(C`meta_info ()\*(C'\fR, \f(CW\*(C`is_quoted ()\*(C'\fR, and \f(CW\*(C`is_binary ()\*(C'\fR
described below.  Default is false.
.IP "verbatim" 4
.IX Item "verbatim"
This is a quite controversial attribute to set, but it makes hard
things possible.
.Sp
The basic thought behind this is to tell the parser that the normally
special characters newline (\s-1NL\s0) and Carriage Return (\s-1CR\s0) will not be
special when this flag is set, and be dealt with as being ordinary
binary characters. This will ease working with data with embedded
newlines.
.Sp
When \f(CW\*(C`verbatim\*(C'\fR is used with \f(CW\*(C`getline ()\*(C'\fR, \f(CW\*(C`getline ()\*(C'\fR
auto-chomp's every line.
.Sp
Imagine a file format like
.Sp
.Vb 1
\&  M^^Hans^Janssen^Klas 2\en2A^Ja^11\-06\-2007#\er\en
.Ve
.Sp
where, the line ending is a very specific \*(L"#\er\en\*(R", and the sep_char
is a ^ (caret). None of the fields is quoted, but embedded binary
data is likely to be present. With the specific line ending, that
shouldn not be too hard to detect.
.Sp
By default, Text::CSV' parse function however is instructed to only
know about \*(L"\en\*(R" and \*(L"\er\*(R" to be legal line endings, and so has to deal
with the embedded newline as a real end-of-line, so it can scan the next
line if binary is true, and the newline is inside a quoted field.
With this attribute however, we can tell parse () to parse the line
as if \en is just nothing more than a binary character.
.Sp
For parse () this means that the parser has no idea about line ending
anymore, and getline () chomps line endings on reading.
.IP "auto_diag" 4
.IX Item "auto_diag"
Set to true will cause \f(CW\*(C`error_diag ()\*(C'\fR to be automatically be called
in void context upon errors.
.Sp
If set to a value greater than 1, it will die on errors instead of
warn.
.Sp
To check future plans and a difference in \s-1XS\s0 version,
please see to \*(L"auto_diag\*(R" in Text::CSV_XS.
.PP
To sum it up,
.PP
.Vb 1
\& $csv = Text::CSV\->new ();
.Ve
.PP
is equivalent to
.PP
.Vb 10
\& $csv = Text::CSV\->new ({
\&     quote_char          => \*(Aq"\*(Aq,
\&     escape_char         => \*(Aq"\*(Aq,
\&     sep_char            => \*(Aq,\*(Aq,
\&     eol                 => $\e,
\&     always_quote        => 0,
\&     quote_space         => 1,
\&     quote_null          => 1,
\&     binary              => 0,
\&     keep_meta_info      => 0,
\&     allow_loose_quotes  => 0,
\&     allow_loose_escapes => 0,
\&     allow_whitespace    => 0,
\&     blank_is_undef      => 0,
\&     empty_is_undef      => 0,
\&     verbatim            => 0,
\&     auto_diag           => 0,
\&     });
.Ve
.PP
For all of the above mentioned flags, there is an accessor method
available where you can inquire for the current value, or change
the value
.PP
.Vb 2
\& my $quote = $csv\->quote_char;
\& $csv\->binary (1);
.Ve
.PP
It is unwise to change these settings halfway through writing \s-1CSV\s0
data to a stream. If however, you want to create a new stream using
the available \s-1CSV\s0 object, there is no harm in changing them.
.PP
If the \f(CW\*(C`new ()\*(C'\fR constructor call fails, it returns \f(CW\*(C`undef\*(C'\fR, and makes
the fail reason available through the \f(CW\*(C`error_diag ()\*(C'\fR method.
.PP
.Vb 2
\& $csv = Text::CSV\->new ({ ecs_char => 1 }) or
\&     die "" . Text::CSV\->error_diag ();
.Ve
.PP
\&\f(CW\*(C`error_diag ()\*(C'\fR will return a string like
.PP
.Vb 1
\& "INI \- Unknown attribute \*(Aqecs_char\*(Aq"
.Ve
.SS "print"
.IX Subsection "print"
.Vb 1
\& $status = $csv\->print ($io, $colref);
.Ve
.PP
Similar to \f(CW\*(C`combine () + string () + print\*(C'\fR, but more efficient. It
expects an array ref as input (not an array!) and the resulting string is
not really created (\s-1XS\s0 version), but immediately written to the \fI\f(CI$io\fI\fR object, typically
an \s-1IO\s0 handle or any other object that offers a \fIprint\fR method. Note, this
implies that the following is wrong in perl 5.005_xx and older:
.PP
.Vb 2
\& open FILE, ">", "whatever";
\& $status = $csv\->print (\e*FILE, $colref);
.Ve
.PP
as in perl 5.005 and older, the glob \f(CW\*(C`\e*FILE\*(C'\fR is not an object, thus it
does not have a print method. The solution is to use an IO::File object or
to hide the glob behind an IO::Wrap object. See IO::File and IO::Wrap
for details.
.PP
For performance reasons the print method doesn't create a result string.
(If its backend is \s-1PP\s0 version, result strings are created internally.)
In particular the \fI\f(CI$csv\fI\->string ()\fR, \fI\f(CI$csv\fI\->status ()\fR,
\&\fI\f(CI$csv\fI\-\fRfields ()> and \fI\f(CI$csv\fI\->error_input ()\fR methods are meaningless
after executing this method.
.SS "combine"
.IX Subsection "combine"
.Vb 1
\& $status = $csv\->combine (@columns);
.Ve
.PP
This object function constructs a \s-1CSV\s0 string from the arguments, returning
success or failure.  Failure can result from lack of arguments or an argument
containing an invalid character.  Upon success, \f(CW\*(C`string ()\*(C'\fR can be called to
retrieve the resultant \s-1CSV\s0 string.  Upon failure, the value returned by
\&\f(CW\*(C`string ()\*(C'\fR is undefined and \f(CW\*(C`error_input ()\*(C'\fR can be called to retrieve an
invalid argument.
.SS "string"
.IX Subsection "string"
.Vb 1
\& $line = $csv\->string ();
.Ve
.PP
This object function returns the input to \f(CW\*(C`parse ()\*(C'\fR or the resultant \s-1CSV\s0
string of \f(CW\*(C`combine ()\*(C'\fR, whichever was called more recently.
.SS "getline"
.IX Subsection "getline"
.Vb 1
\& $colref = $csv\->getline ($io);
.Ve
.PP
This is the counterpart to print, like parse is the counterpart to
combine: It reads a row from the \s-1IO\s0 object \f(CW$io\fR using \f(CW$io\fR\->getline ()
and parses this row into an array ref. This array ref is returned
by the function or undef for failure.
.PP
When fields are bound with \f(CW\*(C`bind_columns ()\*(C'\fR, the return value is a
reference to an empty list.
.PP
The \fI\f(CI$csv\fI\->string ()\fR, \fI\f(CI$csv\fI\->fields ()\fR and \fI\f(CI$csv\fI\->status ()\fR
methods are meaningless, again.
.SS "getline_all"
.IX Subsection "getline_all"
.Vb 3
\& $arrayref = $csv\->getline_all ($io);
\& $arrayref = $csv\->getline_all ($io, $offset);
\& $arrayref = $csv\->getline_all ($io, $offset, $length);
.Ve
.PP
This will return a reference to a list of \f(CW\*(C`getline ($io)\*(C'\fR results.
In this call, \f(CW\*(C`keep_meta_info\*(C'\fR is disabled. If \f(CW$offset\fR is negative,
as with \f(CW\*(C`splice ()\*(C'\fR, only the last \f(CW\*(C`abs ($offset)\*(C'\fR records of \f(CW$io\fR
are taken into consideration.
.PP
Given a \s-1CSV\s0 file with 10 lines:
.PP
.Vb 10
\& lines call
\& \-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0..9  $csv\->getline_all ($io)         # all
\& 0..9  $csv\->getline_all ($io,  0)     # all
\& 8..9  $csv\->getline_all ($io,  8)     # start at 8
\& \-     $csv\->getline_all ($io,  0,  0) # start at 0 first 0 rows
\& 0..4  $csv\->getline_all ($io,  0,  5) # start at 0 first 5 rows
\& 4..5  $csv\->getline_all ($io,  4,  2) # start at 4 first 2 rows
\& 8..9  $csv\->getline_all ($io, \-2)     # last 2 rows
\& 6..7  $csv\->getline_all ($io, \-4,  2) # first 2 of last  4 rows
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 1
\& $status = $csv\->parse ($line);
.Ve
.PP
This object function decomposes a \s-1CSV\s0 string into fields, returning
success or failure.  Failure can result from a lack of argument or the
given \s-1CSV\s0 string is improperly formatted.  Upon success, \f(CW\*(C`fields ()\*(C'\fR can
be called to retrieve the decomposed fields .  Upon failure, the value
returned by \f(CW\*(C`fields ()\*(C'\fR is undefined and \f(CW\*(C`error_input ()\*(C'\fR can be called
to retrieve the invalid argument.
.PP
You may use the \fItypes ()\fR method for setting column types. See the
description below.
.SS "getline_hr"
.IX Subsection "getline_hr"
The \f(CW\*(C`getline_hr ()\*(C'\fR and \f(CW\*(C`column_names ()\*(C'\fR methods work together to allow
you to have rows returned as hashrefs. You must call \f(CW\*(C`column_names ()\*(C'\fR
first to declare your column names.
.PP
.Vb 3
\& $csv\->column_names (qw( code name price description ));
\& $hr = $csv\->getline_hr ($io);
\& print "Price for $hr\->{name} is $hr\->{price} EUR\en";
.Ve
.PP
\&\f(CW\*(C`getline_hr ()\*(C'\fR will croak if called before \f(CW\*(C`column_names ()\*(C'\fR.
.SS "getline_hr_all"
.IX Subsection "getline_hr_all"
.Vb 3
\& $arrayref = $csv\->getline_hr_all ($io);
\& $arrayref = $csv\->getline_hr_all ($io, $offset);
\& $arrayref = $csv\->getline_hr_all ($io, $offset, $length);
.Ve
.PP
This will return a reference to a list of \f(CW\*(C`getline_hr ($io)\*(C'\fR results.
In this call, \f(CW\*(C`keep_meta_info\*(C'\fR is disabled.
.SS "column_names"
.IX Subsection "column_names"
Set the keys that will be used in the \f(CW\*(C`getline_hr ()\*(C'\fR calls. If no keys
(column names) are passed, it'll return the current setting.
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR accepts a list of scalars (the column names) or a
single array_ref, so you can pass \f(CW\*(C`getline ()\*(C'\fR
.PP
.Vb 1
\&  $csv\->column_names ($csv\->getline ($io));
.Ve
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR does \fBno\fR checking on duplicates at all, which might
lead to unwanted results. Undefined entries will be replaced with the
string \f(CW"\ecAUNDEF\ecA"\fR, so
.PP
.Vb 2
\&  $csv\->column_names (undef, "", "name", "name");
\&  $hr = $csv\->getline_hr ($io);
.Ve
.PP
Will set \f(CW\*(C`$hr\-\*(C'\fR{\*(L"\ecAUNDEF\ecA\*(R"}> to the 1st field, \f(CW\*(C`$hr\-\*(C'\fR{""}> to the
2nd field, and \f(CW\*(C`$hr\-\*(C'\fR{name}> to the 4th field, discarding the 3rd field.
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR croaks on invalid arguments.
.SS "bind_columns"
.IX Subsection "bind_columns"
Takes a list of references to scalars to store the fields fetched
\&\f(CW\*(C`getline ()\*(C'\fR in. When you don't pass enough references to store the
fetched fields in, \f(CW\*(C`getline ()\*(C'\fR will fail. If you pass more than there are
fields to return, the remaining references are left untouched.
.PP
.Vb 4
\&  $csv\->bind_columns (\e$code, \e$name, \e$price, \e$description);
\&  while ($csv\->getline ($io)) {
\&      print "The price of a $name is \ex{20ac} $price\en";
\&      }
.Ve
.SS "eof"
.IX Subsection "eof"
.Vb 1
\& $eof = $csv\->eof ();
.Ve
.PP
If \f(CW\*(C`parse ()\*(C'\fR or \f(CW\*(C`getline ()\*(C'\fR was used with an \s-1IO\s0 stream, this
method will return true (1) if the last call hit end of file, otherwise
it will return false (''). This is useful to see the difference between
a failure and end of file.
.SS "types"
.IX Subsection "types"
.Vb 1
\& $csv\->types (\e@tref);
.Ve
.PP
This method is used to force that columns are of a given type. For
example, if you have an integer column, two double columns and a
string column, then you might do a
.PP
.Vb 4
\& $csv\->types ([Text::CSV::IV (),
\&               Text::CSV::NV (),
\&               Text::CSV::NV (),
\&               Text::CSV::PV ()]);
.Ve
.PP
Column types are used only for decoding columns, in other words
by the \fIparse ()\fR and \fIgetline ()\fR methods.
.PP
You can unset column types by doing a
.PP
.Vb 1
\& $csv\->types (undef);
.Ve
.PP
or fetch the current type settings with
.PP
.Vb 1
\& $types = $csv\->types ();
.Ve
.IP "\s-1IV\s0" 4
.IX Item "IV"
Set field type to integer.
.IP "\s-1NV\s0" 4
.IX Item "NV"
Set field type to numeric/float.
.IP "\s-1PV\s0" 4
.IX Item "PV"
Set field type to string.
.SS "fields"
.IX Subsection "fields"
.Vb 1
\& @columns = $csv\->fields ();
.Ve
.PP
This object function returns the input to \f(CW\*(C`combine ()\*(C'\fR or the resultant
decomposed fields of C successful <parse ()>, whichever was called more
recently.
.PP
Note that the return value is undefined after using \f(CW\*(C`getline ()\*(C'\fR, which
does not fill the data structures returned by \f(CW\*(C`parse ()\*(C'\fR.
.SS "meta_info"
.IX Subsection "meta_info"
.Vb 1
\& @flags = $csv\->meta_info ();
.Ve
.PP
This object function returns the flags of the input to \f(CW\*(C`combine ()\*(C'\fR or
the flags of the resultant decomposed fields of \f(CW\*(C`parse ()\*(C'\fR, whichever
was called more recently.
.PP
For each field, a meta_info field will hold flags that tell something about
the field returned by the \f(CW\*(C`fields ()\*(C'\fR method or passed to the \f(CW\*(C`combine ()\*(C'\fR
method. The flags are bit-wise-or'd like:
.IP "0x0001" 4
.IX Item "0x0001"
The field was quoted.
.IP "0x0002" 4
.IX Item "0x0002"
The field was binary.
.PP
See the \f(CW\*(C`is_*** ()\*(C'\fR methods below.
.SS "is_quoted"
.IX Subsection "is_quoted"
.Vb 1
\&  my $quoted = $csv\->is_quoted ($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the
last result of \f(CW\*(C`parse ()\*(C'\fR.
.PP
This returns a true value if the data in the indicated column was
enclosed in \f(CW\*(C`quote_char\*(C'\fR quotes. This might be important for data
where \f(CW\*(C`,20070108,\*(C'\fR is to be treated as a numeric value, and where
\&\f(CW\*(C`,"20070108",\*(C'\fR is explicitly marked as character string data.
.SS "is_binary"
.IX Subsection "is_binary"
.Vb 1
\&  my $binary = $csv\->is_binary ($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the
last result of \f(CW\*(C`parse ()\*(C'\fR.
.PP
This returns a true value if the data in the indicated column
contained any byte in the range [\ex00\-\ex08,\ex10\-\ex1F,\ex7F\-\exFF]
.SS "status"
.IX Subsection "status"
.Vb 1
\& $status = $csv\->status ();
.Ve
.PP
This object function returns success (or failure) of \f(CW\*(C`combine ()\*(C'\fR or
\&\f(CW\*(C`parse ()\*(C'\fR, whichever was called more recently.
.SS "error_input"
.IX Subsection "error_input"
.Vb 1
\& $bad_argument = $csv\->error_input ();
.Ve
.PP
This object function returns the erroneous argument (if it exists) of
\&\f(CW\*(C`combine ()\*(C'\fR or \f(CW\*(C`parse ()\*(C'\fR, whichever was called more recently.
.SS "error_diag"
.IX Subsection "error_diag"
.Vb 5
\& Text::CSV\->error_diag ();
\& $csv\->error_diag ();
\& $error_code   = 0  + $csv\->error_diag ();
\& $error_str    = "" . $csv\->error_diag ();
\& ($cde, $str, $pos) = $csv\->error_diag ();
.Ve
.PP
If (and only if) an error occured, this function returns the diagnostics
of that error.
.PP
If called in void context, it will print the internal error code and the
associated error message to \s-1STDERR\s0.
.PP
If called in list context, it will return the error code and the error
message in that order. If the last error was from parsing, the third
value returned is the best guess at the location within the line that was
being parsed. It's value is 1\-based.
.PP
Note: \f(CW$pos\fR returned by the backend Text::CSV_PP does not show
the error point in many cases (see to the below line).
It is for conscience's sake in using Text::CSV_PP.
.PP
If called in scalar context, it will return the diagnostics in a single
scalar, a\-la $!. It will contain the error code in numeric context, and
the diagnostics message in string context.
.PP
Depending on the used worker module, returned diagnostics is diffferent.
.PP
Text::CSV_XS parses csv strings by dividing one character while Text::CSV_PP
by using the regular expressions. That difference makes the different cause
of the failure.
.PP
When called as a class method or a direct function call, the error diag
is that of the last \f(CW\*(C`new ()\*(C'\fR call.
.SS "SetDiag"
.IX Subsection "SetDiag"
.Vb 1
\& $csv\->SetDiag (0);
.Ve
.PP
Use to reset the diagnostics if you are dealing with errors.
.SS "Some methods are Text::CSV only."
.IX Subsection "Some methods are Text::CSV only."
.IP "backend" 4
.IX Item "backend"
Returns the backend module name called by Text::CSV.
\&\f(CW\*(C`module\*(C'\fR is an alias.
.IP "is_xs" 4
.IX Item "is_xs"
Returns true value if Text::CSV or the object uses \s-1XS\s0 module as worker.
.IP "is_pp" 4
.IX Item "is_pp"
Returns true value if Text::CSV or the object uses pure-Perl module as worker.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
If an error occured, \f(CW$csv\fR\->error_diag () can be used to get more information
on the cause of the failure. Note that for speed reasons, the internal value
is never cleared on success, so using the value returned by error_diag () in
normal cases \- when no error occured \- may cause unexpected results.
.PP
This function changes depending on the used module (\s-1XS\s0 or PurePerl).
.PP
See to \*(L"\s-1DIAGNOSTICS\s0\*(R" in Text::CSV_XS and \*(L"\s-1DIAGNOSTICS\s0\*(R" in Text::CSV_PP.
.SS "\s-1HISTORY\s0 \s-1AND\s0 \s-1WORKER\s0 \s-1MODULES\s0"
.IX Subsection "HISTORY AND WORKER MODULES"
This module, Text::CSV was firstly written by Alan Citterman which could deal with
\&\fBonly ascii characters\fR. Then, Jochen Wiedmann wrote Text::CSV_XS which has
the \fBbinary mode\fR. This \s-1XS\s0 version is maintained by H.Merijn Brand and Text::CSV_PP
written by Makamaka was pure-Perl version of Text::CSV_XS.
.PP
Now, Text::CSV was rewritten by Makamaka and become a wrapper to Text::CSV_XS or Text::CSV_PP.
Text::CSV_PP will be bundled in this distribution.
.PP
When you use Text::CSV, it calls a backend worker module \- Text::CSV_XS or Text::CSV_PP.
By default, Text::CSV tries to use Text::CSV_XS which must be complied and installed properly.
If this call is fail, Text::CSV uses Text::CSV_PP.
.PP
The required Text::CSV_XS version is \fI0.41\fR in Text::CSV version 1.03.
.PP
If you set an enviornment variable \f(CW\*(C`PERL_TEXT_CSV\*(C'\fR, The calling action will be changed.
.IP "\s-1PERL_TEXT_CSV\s0 = 0" 4
.IX Item "PERL_TEXT_CSV = 0"
.PD 0
.IP "\s-1PERL_TEXT_CSV\s0 = 'Text::CSV_PP'" 4
.IX Item "PERL_TEXT_CSV = 'Text::CSV_PP'"
.PD
Always use Text::CSV_PP
.IP "\s-1PERL_TEXT_CSV\s0 = 1" 4
.IX Item "PERL_TEXT_CSV = 1"
.PD 0
.IP "\s-1PERL_TEXT_CSV\s0 = 'Text::CSV_XS,Text::CSV_PP'" 4
.IX Item "PERL_TEXT_CSV = 'Text::CSV_XS,Text::CSV_PP'"
.PD
(The default) Use compiled Text::CSV_XS if it is properly compiled & installed,
otherwise use Text::CSV_PP
.IP "\s-1PERL_TEXT_CSV\s0 = 2" 4
.IX Item "PERL_TEXT_CSV = 2"
.PD 0
.IP "\s-1PERL_TEXT_CSV\s0 = 'Text::CSV_XS'" 4
.IX Item "PERL_TEXT_CSV = 'Text::CSV_XS'"
.PD
Always use compiled Text::CSV_XS, die if it isn't properly compiled & installed.
.PP
These ideas come from DBI::PurePerl mechanism.
.PP
example:
.PP
.Vb 2
\&  BEGIN { $ENV{PERL_TEXT_CSV} = 0 }
\&  use Text::CSV; # always uses Text::CSV_PP
.Ve
.PP
In future, it may be able to specify another module.
.SH "TODO"
.IX Header "TODO"
.IP "Wrapper mechanism" 4
.IX Item "Wrapper mechanism"
Currently the wrapper mechanism is to change symbolic table for speed.
.Sp
.Vb 3
\& for my $method (@PublicMethods) {
\&     *{"Text::CSV::$method"} = \e&{"$class\e::$method"};
\& }
.Ve
.Sp
But how about it \- calling worker module object?
.Sp
.Vb 4
\& sub parse {
\&     my $self = shift;
\&     $self\->{_WORKER_OBJECT}\->parse(@_); # XS or PP CSV object
\& }
.Ve
.PP
See to \*(L"\s-1TODO\s0\*(R" in Text::CSV_XS and \*(L"\s-1TODO\s0\*(R" in Text::CSV_PP.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::CSV_PP, Text::CSV_XS and Text::CSV::Encoded.
.SH "AUTHORS and MAINTAINERS"
.IX Header "AUTHORS and MAINTAINERS"
Alan Citterman \fI<alan[at]mfgrtl.com>\fR wrote the original Perl
module. Please don't send mail concerning Text::CSV to Alan, as
he's not a present maintainer.
.PP
Jochen Wiedmann \fI<joe[at]ispsoft.de>\fR rewrote the encoding and
decoding in C by implementing a simple finite-state machine and added
the variable quote, escape and separator characters, the binary mode
and the print and getline methods. See ChangeLog releases 0.10 through
0.23.
.PP
H.Merijn Brand \fI<h.m.brand[at]xs4all.nl>\fR cleaned up the code,
added the field flags methods, wrote the major part of the test suite,
completed the documentation, fixed some \s-1RT\s0 bugs. See ChangeLog releases
0.25 and on.
.PP
Makamaka Hannyaharamitu, <makamaka[at]cpan.org> wrote Text::CSV_PP
which is the pure-Perl version of Text::CSV_XS.
.PP
New Text::CSV (since 0.99) is maintained by Makamaka.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Text::CSV
.PP
Copyright (C) 1997 Alan Citterman. All rights reserved.
Copyright (C) 2007\-2009 Makamaka Hannyaharamitu.
.PP
Text::CSV_PP:
.PP
Copyright (C) 2005\-2010 Makamaka Hannyaharamitu.
.PP
Text:CSV_XS:
.PP
Copyright (C) 2007\-2010 H.Merijn Brand for \s-1PROCURA\s0 B.V.
Copyright (C) 1998\-2001 Jochen Wiedmann. All rights reserved.
Portions Copyright (C) 1997 Alan Citterman. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
