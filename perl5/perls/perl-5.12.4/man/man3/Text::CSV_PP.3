.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::CSV_PP 3"
.TH Text::CSV_PP 3 "2010-12-27" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::CSV_PP \- Text::CSV_XS compatible pure\-Perl module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Text::CSV_PP;
\& 
\& $csv = Text::CSV_PP\->new();     # create a new object
\& # If you want to handle non\-ascii char.
\& $csv = Text::CSV_PP\->new({binary => 1});
\& 
\& $status = $csv\->combine(@columns);    # combine columns into a string
\& $line   = $csv\->string();             # get the combined string
\& 
\& $status  = $csv\->parse($line);        # parse a CSV string into fields
\& @columns = $csv\->fields();            # get the parsed fields
\& 
\& $status       = $csv\->status ();      # get the most recent status
\& $bad_argument = $csv\->error_input (); # get the most recent bad argument
\& $diag         = $csv\->error_diag ();  # if an error occured, explains WHY
\& 
\& $status = $csv\->print ($io, $colref); # Write an array of fields
\&                                       # immediately to a file $io
\& $colref = $csv\->getline ($io);        # Read a line from file $io,
\&                                       # parse it and return an array
\&                                       # ref of fields
\& $csv\->column_names (@names);          # Set column names for getline_hr ()
\& $ref = $csv\->getline_hr ($io);        # getline (), but returns a hashref
\& $eof = $csv\->eof ();                  # Indicate if last parse or
\&                                       # getline () hit End Of File
\& 
\& $csv\->types(\e@t_array);               # Set column types
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::CSV_PP has almost same functions of Text::CSV_XS which 
provides facilities for the composition and decomposition of
comma-separated values. As its name suggests, Text::CSV_XS
is a \s-1XS\s0 module and Text::CSV_PP is a Puer Perl one.
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    1.29
.Ve
.PP
This module is compatible with Text::CSV_XS \fB0.80\fR and later.
.SS "Unicode (\s-1UTF8\s0)"
.IX Subsection "Unicode (UTF8)"
On parsing (both for \f(CW\*(C`getline ()\*(C'\fR and \f(CW\*(C`parse ()\*(C'\fR), if the source is
marked being \s-1UTF8\s0, then parsing that source will mark all fields that
are marked binary will also be marked \s-1UTF8\s0.
.PP
On combining (\f(CW\*(C`print ()\*(C'\fR and \f(CW\*(C`combine ()\*(C'\fR), if any of the combining
fields was marked \s-1UTF8\s0, the resulting string will be marked \s-1UTF8\s0.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These methods are almost same as Text::CSV_XS.
Most of the documentation was shamelessly copied and replaced from Text::CSV_XS.
.PP
See to Text::CSV_XS.
.SS "version ()"
.IX Subsection "version ()"
(Class method) Returns the current backend module version.
If you want the module version, you can use the \f(CW\*(C`VERSION\*(C'\fR method,
.PP
.Vb 3
\& print Text::CSV\->VERSION;      # This module version
\& print Text::CSV\->version;      # The version of the worker module
\&                                # same as Text::CSV\->backend\->version
.Ve
.SS "new (\e%attr)"
.IX Subsection "new (%attr)"
(Class method) Returns a new instance of Text::CSV_XS. The objects
attributes are described by the (optional) hash ref \f(CW\*(C`\e%attr\*(C'\fR.
Currently the following attributes are available:
.IP "eol" 4
.IX Item "eol"
An end-of-line string to add to rows. \f(CW\*(C`undef\*(C'\fR is replaced with an
empty string. The default is \f(CW\*(C`$\e\*(C'\fR. Common values for \f(CW\*(C`eol\*(C'\fR are
\&\f(CW"\e012"\fR (Line Feed) or \f(CW"\e015\e012"\fR (Carriage Return, Line Feed).
Cannot be longer than 7 (\s-1ASCII\s0) characters.
.Sp
If both \f(CW$/\fR and \f(CW\*(C`eol\*(C'\fR equal \f(CW"\e015"\fR, parsing lines that end on
only a Carriage Return without Line Feed, will be \f(CW\*(C`parse\*(C'\fRd correct.
Line endings, whether in \f(CW$/\fR or \f(CW\*(C`eol\*(C'\fR, other than \f(CW\*(C`undef\*(C'\fR,
\&\f(CW"\en"\fR, \f(CW"\er\en"\fR, or \f(CW"\er"\fR are not (yet) supported for parsing.
.IP "sep_char" 4
.IX Item "sep_char"
The char used for separating fields, by default a comma. (\f(CW\*(C`,\*(C'\fR).
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The separation character can not be equal to the quote character.
The separation character can not be equal to the escape character.
.Sp
See also \*(L"\s-1CAVEATS\s0\*(R" in Text::CSV_XS
.IP "allow_whitespace" 4
.IX Item "allow_whitespace"
When this option is set to true, whitespace (\s-1TAB\s0's and \s-1SPACE\s0's)
surrounding the separation character is removed when parsing. If
either \s-1TAB\s0 or \s-1SPACE\s0 is one of the three major characters \f(CW\*(C`sep_char\*(C'\fR,
\&\f(CW\*(C`quote_char\*(C'\fR, or \f(CW\*(C`escape_char\*(C'\fR it will not be considered whitespace.
.Sp
So lines like:
.Sp
.Vb 1
\&  1 , "foo" , bar , 3 , zapp
.Ve
.Sp
are now correctly parsed, even though it violates the \s-1CSV\s0 specs.
.Sp
Note that \fBall\fR whitespace is stripped from start and end of each
field. That would make it more a \fIfeature\fR than a way to be able
to parse bad \s-1CSV\s0 lines, as
.Sp
.Vb 1
\& 1,   2.0,  3,   ape  , monkey
.Ve
.Sp
will now be parsed as
.Sp
.Vb 1
\& ("1", "2.0", "3", "ape", "monkey")
.Ve
.Sp
even if the original line was perfectly sane \s-1CSV\s0.
.IP "blank_is_undef" 4
.IX Item "blank_is_undef"
Under normal circumstances, \s-1CSV\s0 data makes no distinction between
quoted\- and unquoted empty fields. They both end up in an empty
string field once read, so
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& ("1", "", "", " ", "2")
.Ve
.Sp
When \fIwriting\fR \s-1CSV\s0 files with \f(CW\*(C`always_quote\*(C'\fR set, the unquoted empty
field is the result of an undefined value. To make it possible to also
make this distinction when reading \s-1CSV\s0 data, the \f(CW\*(C`blank_is_undef\*(C'\fR option
will cause unquoted empty fields to be set to undef, causing the above to
be parsed as
.Sp
.Vb 1
\& ("1", "", undef, " ", "2")
.Ve
.IP "empty_is_undef" 4
.IX Item "empty_is_undef"
Going one step further than \f(CW\*(C`blank_is_undef\*(C'\fR, this attribute converts
all empty fields to undef, so
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& (1, undef, undef, " ", 2)
.Ve
.Sp
Note that this only effects fields that are \fIrealy\fR empty, not fields
that are empty after stripping allowed whitespace. \s-1YMMV\s0.
.IP "quote_char" 4
.IX Item "quote_char"
The char used for quoting fields containing blanks, by default the
double quote character (\f(CW\*(C`"\*(C'\fR). A value of undef suppresses
quote chars. (For simple cases only).
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The quote character can not be equal to the separation character.
.IP "allow_loose_quotes" 4
.IX Item "allow_loose_quotes"
By default, parsing fields that have \f(CW\*(C`quote_char\*(C'\fR characters inside
an unquoted field, like
.Sp
.Vb 1
\& 1,foo "bar" baz,42
.Ve
.Sp
would result in a parse error. Though it is still bad practice to
allow this format, we cannot help there are some vendors that make
their applications spit out lines styled like this.
.Sp
In case there is \fBreally\fR bad \s-1CSV\s0 data, like
.Sp
.Vb 1
\& 1,"foo "bar" baz",42
.Ve
.Sp
or
.Sp
.Vb 1
\& 1,""foo bar baz"",42
.Ve
.Sp
there is a way to get that parsed, and leave the quotes inside the quoted
field as-is. This can be achieved by setting \f(CW\*(C`allow_loose_quotes\*(C'\fR \fB\s-1AND\s0\fR
making sure that the \f(CW\*(C`escape_char\*(C'\fR is \fInot\fR equal to \f(CW\*(C`quote_char\*(C'\fR.
.IP "escape_char" 4
.IX Item "escape_char"
The character used for escaping certain characters inside quoted fields.
Limited to a single-byte character, usually in the range from 0x20
(space) to 0x7e (tilde).
.Sp
The \f(CW\*(C`escape_char\*(C'\fR defaults to being the literal double-quote mark (\f(CW\*(C`"\*(C'\fR)
in other words, the same as the default \f(CW\*(C`quote_char\*(C'\fR. This means that
doubling the quote mark in a field escapes it:
.Sp
.Vb 1
\&  "foo","bar","Escape ""quote mark"" with two ""quote marks""","baz"
.Ve
.Sp
If you change the default quote_char without changing the default
escape_char, the escape_char will still be the quote mark.  If instead
you want to escape the quote_char by doubling it, you will need to change
the escape_char to be the same as what you changed the quote_char to.
.Sp
The escape character can not be equal to the separation character.
.IP "allow_loose_escapes" 4
.IX Item "allow_loose_escapes"
By default, parsing fields that have \f(CW\*(C`escape_char\*(C'\fR characters that
escape characters that do not need to be escaped, like:
.Sp
.Vb 2
\& my $csv = Text::CSV\->new ({ escape_char => "\e\e" });
\& $csv\->parse (qq{1,"my bar\e\*(Aqs",baz,42});
.Ve
.Sp
would result in a parse error. Though it is still bad practice to
allow this format, this option enables you to treat all escape character
sequences equal.
.IP "binary" 4
.IX Item "binary"
If this attribute is \s-1TRUE\s0, you may use binary characters in quoted fields,
including line feeds, carriage returns and \s-1NULL\s0 bytes. (The latter must
be escaped as \f(CW\*(C`"0\*(C'\fR.) By default this feature is off.
.Sp
If a string is marked \s-1UTF8\s0, binary will be turned on automatically when
binary characters other than \s-1CR\s0 or \s-1NL\s0 are encountered. Note that a simple
string like \f(CW"\ex{00a0}"\fR might still be binary, but not marked \s-1UTF8\s0, so
setting \f(CW\*(C`{ binary => 1 }\*(C'\fR is still a wise option.
.IP "types" 4
.IX Item "types"
A set of column types; this attribute is immediately passed to the
\&\fItypes\fR method below. You must not set this attribute otherwise,
except for using the \fItypes\fR method. For details see the description
of the \fItypes\fR method below.
.IP "always_quote" 4
.IX Item "always_quote"
By default the generated fields are quoted only, if they need to, for
example, if they contain the separator. If you set this attribute to
a \s-1TRUE\s0 value, then all defined fields will be quoted. This is typically
easier to handle in external applications.
.IP "quote_space" 4
.IX Item "quote_space"
By default, a space in a field would trigger quotation. As no rule
exists this to be forced in \s-1CSV\s0, nor any for the opposite, the default
is true for safety. You can exclude the space from this trigger by
setting this option to 0.
.IP "quote_null" 4
.IX Item "quote_null"
By default, a \s-1NULL\s0 byte in a field would be escaped. This attribute
enables you to treat the \s-1NULL\s0 byte as a simple binary character in
binary mode (the \f(CW\*(C`{ binary => 1 }\*(C'\fR is set). The default is true.
You can prevent \s-1NULL\s0 escapes by setting this attribute to 0.
.IP "keep_meta_info" 4
.IX Item "keep_meta_info"
By default, the parsing of input lines is as simple and fast as
possible. However, some parsing information \- like quotation of
the original field \- is lost in that process. Set this flag to
true to be able to retrieve that information after parsing with
the methods \f(CW\*(C`meta_info ()\*(C'\fR, \f(CW\*(C`is_quoted ()\*(C'\fR, and \f(CW\*(C`is_binary ()\*(C'\fR
described below.  Default is false.
.IP "verbatim" 4
.IX Item "verbatim"
This is a quite controversial attribute to set, but it makes hard
things possible.
.Sp
The basic thought behind this is to tell the parser that the normally
special characters newline (\s-1NL\s0) and Carriage Return (\s-1CR\s0) will not be
special when this flag is set, and be dealt with as being ordinary
binary characters. This will ease working with data with embedded
newlines.
.Sp
When \f(CW\*(C`verbatim\*(C'\fR is used with \f(CW\*(C`getline ()\*(C'\fR, \f(CW\*(C`getline ()\*(C'\fR
auto-chomp's every line.
.Sp
Imagine a file format like
.Sp
.Vb 1
\&  M^^Hans^Janssen^Klas 2\en2A^Ja^11\-06\-2007#\er\en
.Ve
.Sp
where, the line ending is a very specific \*(L"#\er\en\*(R", and the sep_char
is a ^ (caret). None of the fields is quoted, but embedded binary
data is likely to be present. With the specific line ending, that
shouldn't be too hard to detect.
.Sp
By default, Text::CSV' parse function however is instructed to only
know about \*(L"\en\*(R" and \*(L"\er\*(R" to be legal line endings, and so has to deal
with the embedded newline as a real end-of-line, so it can scan the next
line if binary is true, and the newline is inside a quoted field.
With this attribute however, we can tell parse () to parse the line
as if \en is just nothing more than a binary character.
.Sp
For parse () this means that the parser has no idea about line ending
anymore, and getline () chomps line endings on reading.
.IP "auto_diag" 4
.IX Item "auto_diag"
Set to true will cause \f(CW\*(C`error_diag ()\*(C'\fR to be automatically be called
in void context upon errors.
.Sp
If set to a value greater than 1, it will die on errors instead of
warn.
.Sp
To check future plans and a difference in \s-1XS\s0 version,
please see to \*(L"auto_diag\*(R" in Text::CSV_XS.
.PP
To sum it up,
.PP
.Vb 1
\& $csv = Text::CSV_PP\->new ();
.Ve
.PP
is equivalent to
.PP
.Vb 10
\& $csv = Text::CSV_PP\->new ({
\&     quote_char          => \*(Aq"\*(Aq,
\&     escape_char         => \*(Aq"\*(Aq,
\&     sep_char            => \*(Aq,\*(Aq,
\&     eol                 => $\e,
\&     always_quote        => 0,
\&     quote_space         => 1,
\&     quote_null          => 1,
\&     binary              => 0,
\&     keep_meta_info      => 0,
\&     allow_loose_quotes  => 0,
\&     allow_loose_escapes => 0,
\&     allow_whitespace    => 0,
\&     blank_is_undef      => 0,
\&     empty_is_undef      => 0,
\&     verbatim            => 0,
\&     auto_diag           => 0,
\&     });
.Ve
.PP
For all of the above mentioned flags, there is an accessor method
available where you can inquire for the current value, or change
the value
.PP
.Vb 2
\& my $quote = $csv\->quote_char;
\& $csv\->binary (1);
.Ve
.PP
It is unwise to change these settings halfway through writing \s-1CSV\s0
data to a stream. If however, you want to create a new stream using
the available \s-1CSV\s0 object, there is no harm in changing them.
.PP
If the \f(CW\*(C`new ()\*(C'\fR constructor call fails, it returns \f(CW\*(C`undef\*(C'\fR, and makes
the fail reason available through the \f(CW\*(C`error_diag ()\*(C'\fR method.
.PP
.Vb 2
\& $csv = Text::CSV\->new ({ ecs_char => 1 }) or
\&     die "" . Text::CSV\->error_diag ();
.Ve
.PP
\&\f(CW\*(C`error_diag ()\*(C'\fR will return a string like
.PP
.Vb 1
\& "INI \- Unknown attribute \*(Aqecs_char\*(Aq"
.Ve
.SS "print"
.IX Subsection "print"
.Vb 1
\& $status = $csv\->print ($io, $colref);
.Ve
.PP
Similar to \f(CW\*(C`combine () + string () + print\*(C'\fR, but more efficient. It
expects an array ref as input (not an array!) and the resulting string is
not really created (\s-1XS\s0 version), but immediately written to the \fI\f(CI$io\fI\fR object, typically
an \s-1IO\s0 handle or any other object that offers a \fIprint\fR method. Note, this
implies that the following is wrong in perl 5.005_xx and older:
.PP
.Vb 2
\& open FILE, ">", "whatever";
\& $status = $csv\->print (\e*FILE, $colref);
.Ve
.PP
as in perl 5.005 and older, the glob \f(CW\*(C`\e*FILE\*(C'\fR is not an object, thus it
doesn't have a print method. The solution is to use an IO::File object or
to hide the glob behind an IO::Wrap object. See IO::File and IO::Wrap
for details.
.PP
For performance reasons the print method doesn't create a result string.
(If its backend is \s-1PP\s0 version, result strings are created internally.)
In particular the \fI\f(CI$csv\fI\->string ()\fR, \fI\f(CI$csv\fI\->status ()\fR,
\&\fI\f(CI$csv\fI\-\fRfields ()> and \fI\f(CI$csv\fI\->error_input ()\fR methods are meaningless
after executing this method.
.SS "combine"
.IX Subsection "combine"
.Vb 1
\& $status = $csv\->combine (@columns);
.Ve
.PP
This object function constructs a \s-1CSV\s0 string from the arguments, returning
success or failure.  Failure can result from lack of arguments or an argument
containing an invalid character.  Upon success, \f(CW\*(C`string ()\*(C'\fR can be called to
retrieve the resultant \s-1CSV\s0 string.  Upon failure, the value returned by
\&\f(CW\*(C`string ()\*(C'\fR is undefined and \f(CW\*(C`error_input ()\*(C'\fR can be called to retrieve an
invalid argument.
.SS "string"
.IX Subsection "string"
.Vb 1
\& $line = $csv\->string ();
.Ve
.PP
This object function returns the input to \f(CW\*(C`parse ()\*(C'\fR or the resultant \s-1CSV\s0
string of \f(CW\*(C`combine ()\*(C'\fR, whichever was called more recently.
.SS "getline"
.IX Subsection "getline"
.Vb 1
\& $colref = $csv\->getline ($io);
.Ve
.PP
This is the counterpart to print, like parse is the counterpart to
combine: It reads a row from the \s-1IO\s0 object \f(CW$io\fR using \f(CW$io\fR\->getline ()
and parses this row into an array ref. This array ref is returned
by the function or undef for failure.
.PP
When fields are bound with \f(CW\*(C`bind_columns ()\*(C'\fR, the return value is a
reference to an empty list.
.PP
The \fI\f(CI$csv\fI\->string ()\fR, \fI\f(CI$csv\fI\->fields ()\fR and \fI\f(CI$csv\fI\->status ()\fR
methods are meaningless, again.
.SS "getline_all"
.IX Subsection "getline_all"
.Vb 3
\& $arrayref = $csv\->getline_all ($io);
\& $arrayref = $csv\->getline_all ($io, $offset);
\& $arrayref = $csv\->getline_all ($io, $offset, $length);
.Ve
.PP
This will return a reference to a list of \f(CW\*(C`getline ($io)\*(C'\fR results.
In this call, \f(CW\*(C`keep_meta_info\*(C'\fR is disabled. If \f(CW$offset\fR is negative,
as with \f(CW\*(C`splice ()\*(C'\fR, only the last \f(CW\*(C`abs ($offset)\*(C'\fR records of \f(CW$io\fR
are taken into consideration.
.PP
Given a \s-1CSV\s0 file with 10 lines:
.PP
.Vb 10
\& lines call
\& \-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0..9  $csv\->getline_all ($io)         # all
\& 0..9  $csv\->getline_all ($io,  0)     # all
\& 8..9  $csv\->getline_all ($io,  8)     # start at 8
\& \-     $csv\->getline_all ($io,  0,  0) # start at 0 first 0 rows
\& 0..4  $csv\->getline_all ($io,  0,  5) # start at 0 first 5 rows
\& 4..5  $csv\->getline_all ($io,  4,  2) # start at 4 first 2 rows
\& 8..9  $csv\->getline_all ($io, \-2)     # last 2 rows
\& 6..7  $csv\->getline_all ($io, \-4,  2) # first 2 of last  4 rows
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 1
\& $status = $csv\->parse ($line);
.Ve
.PP
This object function decomposes a \s-1CSV\s0 string into fields, returning
success or failure.  Failure can result from a lack of argument or the
given \s-1CSV\s0 string is improperly formatted.  Upon success, \f(CW\*(C`fields ()\*(C'\fR can
be called to retrieve the decomposed fields .  Upon failure, the value
returned by \f(CW\*(C`fields ()\*(C'\fR is undefined and \f(CW\*(C`error_input ()\*(C'\fR can be called
to retrieve the invalid argument.
.PP
You may use the \fItypes ()\fR method for setting column types. See the
description below.
.SS "getline_hr"
.IX Subsection "getline_hr"
The \f(CW\*(C`getline_hr ()\*(C'\fR and \f(CW\*(C`column_names ()\*(C'\fR methods work together to allow
you to have rows returned as hashrefs. You must call \f(CW\*(C`column_names ()\*(C'\fR
first to declare your column names.
.PP
.Vb 3
\& $csv\->column_names (qw( code name price description ));
\& $hr = $csv\->getline_hr ($io);
\& print "Price for $hr\->{name} is $hr\->{price} EUR\en";
.Ve
.PP
\&\f(CW\*(C`getline_hr ()\*(C'\fR will croak if called before \f(CW\*(C`column_names ()\*(C'\fR.
.SS "getline_hr_all"
.IX Subsection "getline_hr_all"
.Vb 1
\& $arrayref = $csv\->getline_hr_all ($io);
.Ve
.PP
This will return a reference to a list of \f(CW\*(C`getline_hr ($io)\*(C'\fR results.
In this call, \f(CW\*(C`keep_meta_info\*(C'\fR is disabled.
.SS "column_names"
.IX Subsection "column_names"
Set the keys that will be used in the \f(CW\*(C`getline_hr ()\*(C'\fR calls. If no keys
(column names) are passed, it'll return the current setting.
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR accepts a list of scalars (the column names) or a
single array_ref, so you can pass \f(CW\*(C`getline ()\*(C'\fR
.PP
.Vb 1
\&  $csv\->column_names ($csv\->getline ($io));
.Ve
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR does \fBno\fR checking on duplicates at all, which might
lead to unwanted results. Undefined entries will be replaced with the
string \f(CW"\ecAUNDEF\ecA"\fR, so
.PP
.Vb 2
\&  $csv\->column_names (undef, "", "name", "name");
\&  $hr = $csv\->getline_hr ($io);
.Ve
.PP
Will set \f(CW\*(C`$hr\-\*(C'\fR{\*(L"\ecAUNDEF\ecA\*(R"}> to the 1st field, \f(CW\*(C`$hr\-\*(C'\fR{""}> to the
2nd field, and \f(CW\*(C`$hr\-\*(C'\fR{name}> to the 4th field, discarding the 3rd field.
.PP
\&\f(CW\*(C`column_names ()\*(C'\fR croaks on invalid arguments.
.SS "bind_columns"
.IX Subsection "bind_columns"
Takes a list of references to scalars to store the fields fetched
\&\f(CW\*(C`getline ()\*(C'\fR in. When you don't pass enough references to store the
fetched fields in, \f(CW\*(C`getline ()\*(C'\fR will fail. If you pass more than there are
fields to return, the remaining references are left untouched.
.PP
.Vb 4
\&  $csv\->bind_columns (\e$code, \e$name, \e$price, \e$description);
\&  while ($csv\->getline ($io)) {
\&      print "The price of a $name is \ex{20ac} $price\en";
\&      }
.Ve
.SS "eof"
.IX Subsection "eof"
.Vb 1
\& $eof = $csv\->eof ();
.Ve
.PP
If \f(CW\*(C`parse ()\*(C'\fR or \f(CW\*(C`getline ()\*(C'\fR was used with an \s-1IO\s0 stream, this
method will return true (1) if the last call hit end of file, otherwise
it will return false (''). This is useful to see the difference between
a failure and end of file.
.SS "types"
.IX Subsection "types"
.Vb 1
\& $csv\->types (\e@tref);
.Ve
.PP
This method is used to force that columns are of a given type. For
example, if you have an integer column, two double columns and a
string column, then you might do a
.PP
.Vb 4
\& $csv\->types ([Text::CSV_PP::IV (),
\&               Text::CSV_PP::NV (),
\&               Text::CSV_PP::NV (),
\&               Text::CSV_PP::PV ()]);
.Ve
.PP
Column types are used only for decoding columns, in other words
by the \fIparse ()\fR and \fIgetline ()\fR methods.
.PP
You can unset column types by doing a
.PP
.Vb 1
\& $csv\->types (undef);
.Ve
.PP
or fetch the current type settings with
.PP
.Vb 1
\& $types = $csv\->types ();
.Ve
.IP "\s-1IV\s0" 4
.IX Item "IV"
Set field type to integer.
.IP "\s-1NV\s0" 4
.IX Item "NV"
Set field type to numeric/float.
.IP "\s-1PV\s0" 4
.IX Item "PV"
Set field type to string.
.SS "fields"
.IX Subsection "fields"
.Vb 1
\& @columns = $csv\->fields ();
.Ve
.PP
This object function returns the input to \f(CW\*(C`combine ()\*(C'\fR or the resultant
decomposed fields of C successful <parse ()>, whichever was called more
recently.
.PP
Note that the return value is undefined after using \f(CW\*(C`getline ()\*(C'\fR, which
does not fill the data structures returned by \f(CW\*(C`parse ()\*(C'\fR.
.SS "meta_info"
.IX Subsection "meta_info"
.Vb 1
\& @flags = $csv\->meta_info ();
.Ve
.PP
This object function returns the flags of the input to \f(CW\*(C`combine ()\*(C'\fR or
the flags of the resultant decomposed fields of \f(CW\*(C`parse ()\*(C'\fR, whichever
was called more recently.
.PP
For each field, a meta_info field will hold flags that tell something about
the field returned by the \f(CW\*(C`fields ()\*(C'\fR method or passed to the \f(CW\*(C`combine ()\*(C'\fR
method. The flags are bitwise-or'd like:
.IP "0x0001" 4
.IX Item "0x0001"
The field was quoted.
.IP "0x0002" 4
.IX Item "0x0002"
The field was binary.
.PP
See the \f(CW\*(C`is_*** ()\*(C'\fR methods below.
.SS "is_quoted"
.IX Subsection "is_quoted"
.Vb 1
\&  my $quoted = $csv\->is_quoted ($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the
last result of \f(CW\*(C`parse ()\*(C'\fR.
.PP
This returns a true value if the data in the indicated column was
enclosed in \f(CW\*(C`quote_char\*(C'\fR quotes. This might be important for data
where \f(CW\*(C`,20070108,\*(C'\fR is to be treated as a numeric value, and where
\&\f(CW\*(C`,"20070108",\*(C'\fR is explicitly marked as character string data.
.SS "is_binary"
.IX Subsection "is_binary"
.Vb 1
\&  my $binary = $csv\->is_binary ($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the
last result of \f(CW\*(C`parse ()\*(C'\fR.
.PP
This returns a true value if the data in the indicated column
contained any byte in the range [\ex00\-\ex08,\ex10\-\ex1F,\ex7F\-\exFF]
.SS "status"
.IX Subsection "status"
.Vb 1
\& $status = $csv\->status ();
.Ve
.PP
This object function returns success (or failure) of \f(CW\*(C`combine ()\*(C'\fR or
\&\f(CW\*(C`parse ()\*(C'\fR, whichever was called more recently.
.SS "error_input"
.IX Subsection "error_input"
.Vb 1
\& $bad_argument = $csv\->error_input ();
.Ve
.PP
This object function returns the erroneous argument (if it exists) of
\&\f(CW\*(C`combine ()\*(C'\fR or \f(CW\*(C`parse ()\*(C'\fR, whichever was called more recently.
.SS "error_diag"
.IX Subsection "error_diag"
.Vb 5
\& Text::CSV_PP\->error_diag ();
\& $csv\->error_diag ();
\& $error_code   = 0  + $csv\->error_diag ();
\& $error_str    = "" . $csv\->error_diag ();
\& ($cde, $str, $pos) = $csv\->error_diag ();
.Ve
.PP
If (and only if) an error occured, this function returns the diagnostics
of that error.
.PP
If called in void context, it will print the internal error code and the
associated error message to \s-1STDERR\s0.
.PP
If called in list context, it will return the error code and the error
message in that order. If the last error was from parsing, the third
value returned is the best guess at the location within the line that was
being parsed. It's value is 1\-based.
.PP
Note: \f(CW$pos\fR does not show the error point in many cases.
It is for conscience's sake.
.PP
If called in scalar context, it will return the diagnostics in a single
scalar, a\-la $!. It will contain the error code in numeric context, and
the diagnostics message in string context.
.PP
To achieve this behavior with \s-1CSV_PP\s0, the returned diagnostics is blessed object.
.SS "SetDiag"
.IX Subsection "SetDiag"
.Vb 1
\& $csv\->SetDiag (0);
.Ve
.PP
Use to reset the diagnostics if you are dealing with errors.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
If an error occured, \f(CW$csv\fR\->error_diag () can be used to get more information
on the cause of the failure. Note that for speed reasons, the internal value
is never cleared on success, so using the value returned by error_diag () in
normal cases \- when no error occured \- may cause unexpected results.
.PP
Note: \s-1CSV_PP\s0's diagnostics is different from \s-1CSV_XS\s0's:
.PP
Text::CSV_XS parses csv strings by dividing one character
while Text::CSV_PP by using the regular expressions.
That difference makes the different cause of the failure.
.PP
Currently these errors are available:
.ie n .IP "1001 ""sep_char is equal to quote_char or escape_char""" 2
.el .IP "1001 ``sep_char is equal to quote_char or escape_char''" 2
.IX Item "1001 sep_char is equal to quote_char or escape_char"
The separation character cannot be equal to either the quotation character
or the escape character, as that will invalidate all parsing rules.
.ie n .IP "1002 ""\s-1INI\s0 \- allow_whitespace with escape_char or quote_char \s-1SP\s0 or \s-1TAB\s0""" 2
.el .IP "1002 ``\s-1INI\s0 \- allow_whitespace with escape_char or quote_char \s-1SP\s0 or \s-1TAB\s0''" 2
.IX Item "1002 INI - allow_whitespace with escape_char or quote_char SP or TAB"
Using \f(CW\*(C`allow_whitespace\*(C'\fR when either \f(CW\*(C`escape_char\*(C'\fR or \f(CW\*(C`quote_char\*(C'\fR is
equal to \s-1SPACE\s0 or \s-1TAB\s0 is too ambiguous to allow.
.ie n .IP "1003 ""\s-1INI\s0 \- \er or \en in main attr not allowed""" 2
.el .IP "1003 ``\s-1INI\s0 \- \er or \en in main attr not allowed''" 2
.IX Item "1003 INI - r or n in main attr not allowed"
Using default \f(CW\*(C`eol\*(C'\fR characters in either \f(CW\*(C`sep_char\*(C'\fR, \f(CW\*(C`quote_char\*(C'\fR, or
\&\f(CW\*(C`escape_char\*(C'\fR is not allowed.
.ie n .IP "2010 ""\s-1ECR\s0 \- \s-1QUO\s0 char inside quotes followed by \s-1CR\s0 not part of \s-1EOL\s0""" 2
.el .IP "2010 ``\s-1ECR\s0 \- \s-1QUO\s0 char inside quotes followed by \s-1CR\s0 not part of \s-1EOL\s0''" 2
.IX Item "2010 ECR - QUO char inside quotes followed by CR not part of EOL"
.PD 0
.ie n .IP "2011 ""\s-1ECR\s0 \- Characters after end of quoted field""" 2
.el .IP "2011 ``\s-1ECR\s0 \- Characters after end of quoted field''" 2
.IX Item "2011 ECR - Characters after end of quoted field"
.ie n .IP "2021 ""\s-1EIQ\s0 \- \s-1NL\s0 char inside quotes, binary off""" 2
.el .IP "2021 ``\s-1EIQ\s0 \- \s-1NL\s0 char inside quotes, binary off''" 2
.IX Item "2021 EIQ - NL char inside quotes, binary off"
.ie n .IP "2022 ""\s-1EIQ\s0 \- \s-1CR\s0 char inside quotes, binary off""" 2
.el .IP "2022 ``\s-1EIQ\s0 \- \s-1CR\s0 char inside quotes, binary off''" 2
.IX Item "2022 EIQ - CR char inside quotes, binary off"
.ie n .IP "2025 ""\s-1EIQ\s0 \- Loose unescaped escape""" 2
.el .IP "2025 ``\s-1EIQ\s0 \- Loose unescaped escape''" 2
.IX Item "2025 EIQ - Loose unescaped escape"
.ie n .IP "2026 ""\s-1EIQ\s0 \- Binary character inside quoted field, binary off""" 2
.el .IP "2026 ``\s-1EIQ\s0 \- Binary character inside quoted field, binary off''" 2
.IX Item "2026 EIQ - Binary character inside quoted field, binary off"
.ie n .IP "2027 ""\s-1EIQ\s0 \- Quoted field not terminated""" 2
.el .IP "2027 ``\s-1EIQ\s0 \- Quoted field not terminated''" 2
.IX Item "2027 EIQ - Quoted field not terminated"
.ie n .IP "2030 ""\s-1EIF\s0 \- \s-1NL\s0 char inside unquoted verbatim, binary off""" 2
.el .IP "2030 ``\s-1EIF\s0 \- \s-1NL\s0 char inside unquoted verbatim, binary off''" 2
.IX Item "2030 EIF - NL char inside unquoted verbatim, binary off"
.ie n .IP "2031 ""\s-1EIF\s0 \- \s-1CR\s0 char is first char of field, not part of \s-1EOL\s0""," 2
.el .IP "2031 ``\s-1EIF\s0 \- \s-1CR\s0 char is first char of field, not part of \s-1EOL\s0''," 2
.IX Item "2031 EIF - CR char is first char of field, not part of EOL,"
.ie n .IP "2032 ""\s-1EIF\s0 \- \s-1CR\s0 char inside unquoted, not part of \s-1EOL\s0""," 2
.el .IP "2032 ``\s-1EIF\s0 \- \s-1CR\s0 char inside unquoted, not part of \s-1EOL\s0''," 2
.IX Item "2032 EIF - CR char inside unquoted, not part of EOL,"
.ie n .IP "2034 ""\s-1EIF\s0 \- Loose unescaped quote""," 2
.el .IP "2034 ``\s-1EIF\s0 \- Loose unescaped quote''," 2
.IX Item "2034 EIF - Loose unescaped quote,"
.ie n .IP "2037 ""\s-1EIF\s0 \- Binary character in unquoted field, binary off""," 2
.el .IP "2037 ``\s-1EIF\s0 \- Binary character in unquoted field, binary off''," 2
.IX Item "2037 EIF - Binary character in unquoted field, binary off,"
.ie n .IP "2110 ""\s-1ECB\s0 \- Binary character in Combine, binary off""" 2
.el .IP "2110 ``\s-1ECB\s0 \- Binary character in Combine, binary off''" 2
.IX Item "2110 ECB - Binary character in Combine, binary off"
.ie n .IP "2200 ""\s-1EIO\s0 \- print to \s-1IO\s0 failed. See errno""" 2
.el .IP "2200 ``\s-1EIO\s0 \- print to \s-1IO\s0 failed. See errno''" 2
.IX Item "2200 EIO - print to IO failed. See errno"
.ie n .IP "4002 ""\s-1EIQ\s0 \- Unescaped \s-1ESC\s0 in quoted field""" 2
.el .IP "4002 ``\s-1EIQ\s0 \- Unescaped \s-1ESC\s0 in quoted field''" 2
.IX Item "4002 EIQ - Unescaped ESC in quoted field"
.ie n .IP "4003 ""\s-1EIF\s0 \- \s-1ESC\s0 \s-1CR\s0""" 2
.el .IP "4003 ``\s-1EIF\s0 \- \s-1ESC\s0 \s-1CR\s0''" 2
.IX Item "4003 EIF - ESC CR"
.ie n .IP "4004 ""\s-1EUF\s0 \- """ 2
.el .IP "4004 ``\s-1EUF\s0 \- ''" 2
.IX Item "4004 EUF - "
.ie n .IP "3001 ""\s-1EHR\s0 \- Unsupported syntax for column_names ()""" 2
.el .IP "3001 ``\s-1EHR\s0 \- Unsupported syntax for column_names ()''" 2
.IX Item "3001 EHR - Unsupported syntax for column_names ()"
.ie n .IP "3002 ""\s-1EHR\s0 \- getline_hr () called before column_names ()""" 2
.el .IP "3002 ``\s-1EHR\s0 \- getline_hr () called before column_names ()''" 2
.IX Item "3002 EHR - getline_hr () called before column_names ()"
.ie n .IP "3003 ""\s-1EHR\s0 \- bind_columns () and column_names () fields count mismatch""" 2
.el .IP "3003 ``\s-1EHR\s0 \- bind_columns () and column_names () fields count mismatch''" 2
.IX Item "3003 EHR - bind_columns () and column_names () fields count mismatch"
.ie n .IP "3004 ""\s-1EHR\s0 \- bind_columns () only accepts refs to scalars""" 2
.el .IP "3004 ``\s-1EHR\s0 \- bind_columns () only accepts refs to scalars''" 2
.IX Item "3004 EHR - bind_columns () only accepts refs to scalars"
.ie n .IP "3006 ""\s-1EHR\s0 \- bind_columns () did not pass enough refs for parsed fields""" 2
.el .IP "3006 ``\s-1EHR\s0 \- bind_columns () did not pass enough refs for parsed fields''" 2
.IX Item "3006 EHR - bind_columns () did not pass enough refs for parsed fields"
.ie n .IP "3007 ""\s-1EHR\s0 \- bind_columns needs refs to writable scalars""" 2
.el .IP "3007 ``\s-1EHR\s0 \- bind_columns needs refs to writable scalars''" 2
.IX Item "3007 EHR - bind_columns needs refs to writable scalars"
.ie n .IP "3008 ""\s-1EHR\s0 \- unexpected error in bound fields""" 2
.el .IP "3008 ``\s-1EHR\s0 \- unexpected error in bound fields''" 2
.IX Item "3008 EHR - unexpected error in bound fields"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Makamaka Hannyaharamitu, <makamaka[at]cpan.org>
.PP
Text::CSV_XS was written by <joe[at]ispsoft.de>
and maintained by <h.m.brand[at]xs4all.nl>.
.PP
Text::CSV was written by <alan[at]mfgrtl.com>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2005\-2010 by Makamaka Hannyaharamitu, <makamaka[at]cpan.org>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::CSV_XS, Text::CSV
.PP
I got many regexp bases from <http://www.din.or.jp/~ohzaki/perl.htm>
