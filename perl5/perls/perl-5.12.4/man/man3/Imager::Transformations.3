.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Transformations 3"
.TH Imager::Transformations 3 "2011-06-06" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Transformations \- Simple transformations of one image into another.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Imager;
\&
\&  $newimg = $img\->copy();
\&
\&  $newimg = $img\->scale(xpixels=>400, qtype => \*(Aqmixing\*(Aq);
\&  $newimg = $img\->scale(xpixels=>400, ypixels=>400);
\&  $newimg = $img\->scale(xpixels=>400, ypixels=>400, type=>\*(Aqmin\*(Aq);
\&  $newimg = $img\->scale(scalefactor=>0.25);
\&
\&  $newimg = $img\->scaleX(pixels=>400);
\&  $newimg = $img\->scaleX(scalefactor=>0.25);
\&  $newimg = $img\->scaleY(pixels=>400);
\&  $newimg = $img\->scaleY(scalefactor=>0.25);
\&
\&  $newimg = $img\->crop(left=>50, right=>100, top=>10, bottom=>100); 
\&  $newimg = $img\->crop(left=>50, top=>10, width=>50, height=>90);
\&
\&  $dest\->paste(left=>40,top=>20,img=>$logo);
\&
\&  $img\->rubthrough(src=>$srcimage,tx=>30, ty=>50);
\&  $img\->rubthrough(src=>$srcimage,tx=>30, ty=>50,
\&                   src_minx=>20, src_miny=>30,
\&                   src_maxx=>20, src_maxy=>30);
\&
\&  $img\->compose(src => $src, tx => 30, ty => 20, combine => \*(Aqcolor\*(Aq);
\&  $img\->compose(src => $src, tx => 30, ty => 20, combine => \*(Aqcolor\*(Aq);
\&                mask => $mask, opacity => 0.5);
\&
\&  $img\->flip(dir=>"h");       # horizontal flip
\&  $img\->flip(dir=>"vh");      # vertical and horizontal flip
\&  $newimg = $img\->copy\->flip(dir=>"v"); # make a copy and flip it vertically
\&
\&  my $rot20 = $img\->rotate(degrees=>20);
\&  my $rotpi4 = $img\->rotate(radians=>3.14159265/4);
\&
\&
\&  # Convert image to gray
\&  $new = $img\->convert(preset=>\*(Aqgrey\*(Aq);          
\&
\&  # Swap red/green channel  
\&  $new = $img\->convert(matrix=>[ [ 0, 1, 0 ],
\&                                 [ 1, 0, 0 ],
\&                                 [ 0, 0, 1 ] ]);
\&
\&  # build an image using channels from multiple input images
\&  $new = $img\->combine(src => [ $im1, $im2, $im3 ]);
\&  $new = $img\->combine(src => [ $im1, $im2, $im3 ],
\&                       channels => [ 2, 1, 0 ]);
\&
\&  # limit the range of red channel from 0..255 to 0..127
\&  @map = map { int( $_/2 } 0..255;
\&  $img\->map( red=>\e@map );
\&
\&  # Apply a Gamma of 1.4
\&  my $gamma = 1.4;
\&  my @map = map { int( 0.5 + 255*($_/255)**$gamma ) } 0..255;
\&  $img\->map(all=>\e@map);  # inplace conversion
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The methods described in Imager::Transformations fall into two categories.
Either they take an existing image and modify it in place, or they 
return a modified copy.
.PP
Functions that modify inplace are \f(CW\*(C`flip()\*(C'\fR, \f(CW\*(C`paste()\*(C'\fR,
\&\f(CW\*(C`rubthrough()\*(C'\fR and \f(CW\*(C`compose()\*(C'\fR.  If the original is to be left
intact it's possible to make a copy and alter the copy:
.PP
.Vb 1
\&  $flipped = $img\->copy()\->flip(dir=>\*(Aqh\*(Aq);
.Ve
.SS "Image copying/resizing/cropping/rotating"
.IX Subsection "Image copying/resizing/cropping/rotating"
A list of the transformations that do not alter the source image follows:
.IP "\fIcopy()\fR" 4
.IX Item "copy()"
To create a copy of an image use the \f(CW\*(C`copy()\*(C'\fR method.  This is useful
if you want to keep an original after doing something that changes the image.
.Sp
.Vb 1
\&  $newimg = $orig\->copy();
.Ve
.IP "\fIscale()\fR" 4
.IX Item "scale()"
To scale an image so proportions are maintained use the
\&\f(CW\*(C`$img\->scale()\*(C'\fR method.  if you give either a \f(CW\*(C`xpixels\*(C'\fR or
\&\f(CW\*(C`ypixels\*(C'\fR parameter they will determine the width or height
respectively.  If both are given the one resulting in a larger image
is used, unless you set the \f(CW\*(C`type\*(C'\fR parameter to \f(CW\*(Aqmin\*(Aq\fR.  example:
\&\f(CW$img\fR is 700 pixels wide and 500 pixels tall.
.IX Xref "scale"
.Sp
.Vb 2
\&  $newimg = $img\->scale(xpixels=>400); # 400x285
\&  $newimg = $img\->scale(ypixels=>400); # 560x400
\&
\&  $newimg = $img\->scale(xpixels=>400,ypixels=>400); # 560x400
\&  $newimg = $img\->scale(xpixels=>400,ypixels=>400,type=>\*(Aqmin\*(Aq); # 400x285
\&
\&  $newimg = $img\->scale(xpixels=>400, ypixels=>400),type=>\*(Aqnonprop\*(Aq); # 400x400
\&
\&  $newimg = $img\->scale(scalefactor=>0.25); 175x125 
\&  $newimg = $img\->scale(); # 350x250
.Ve
.Sp
If you want to create low quality previews of images you can pass
\&\f(CW\*(C`qtype=>\*(Aqpreview\*(Aq\*(C'\fR to scale and it will use nearest neighbor
sampling instead of filtering. It is much faster but also generates
worse looking images \- especially if the original has a lot of sharp
variations and the scaled image is by more than 3\-5 times smaller than
the original.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`xpixels\*(C'\fR, \f(CW\*(C`ypixels\*(C'\fR \- desired size of the scaled image.  The
\&\f(CW\*(C`type\*(C'\fR parameter controls whether the larger or smaller of the two
possible sizes is chosen, or if the image is scaled
non-proportionally.
.IP "\(bu" 4
\&\f(CW\*(C`constrain\*(C'\fR \- an Image::Math::Constrain object defining the way in
which the image size should be constrained.
.IP "\(bu" 4
\&\f(CW\*(C`scalefactor\*(C'\fR \- if none of \f(CW\*(C`xpixels\*(C'\fR, \f(CW\*(C`ypixels\*(C'\fR, \f(CW\*(C`xscalefactor\*(C'\fR,
\&\f(CW\*(C`yscalefactor\*(C'\fR or \f(CW\*(C`constrain\*(C'\fR is supplied then this is used as the
ratio to scale by.  Default: 0.5.
.IP "\(bu" 4
\&\f(CW\*(C`xscalefactor\*(C'\fR, \f(CW\*(C`yscalefactor\*(C'\fR \- if both are supplied then the image is
scaled as per these parameters, whether this is proportionally or not.
New in Imager 0.54.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- controls whether the larger or smaller of the two possible
sizes is chosen, possible values are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`min\*(C'\fR \- the smaller of the 2 sizes are chosen.
.IP "\(bu" 4
\&\f(CW\*(C`max\*(C'\fR \- the larger of the 2 sizes.  This is the default.
.IP "\(bu" 4
\&\f(CW\*(C`nonprop\*(C'\fR \- non-proportional scaling.  New in Imager 0.54.
.RE
.RS 4
.Sp
\&\fIscale()\fR will fail if \f(CW\*(C`type\*(C'\fR is set to some other value.
.Sp
For example, if the original image is 400 pixels wide by 200 pixels
high and \f(CW\*(C`xpixels\*(C'\fR is set to 300, and \f(CW\*(C`ypixels\*(C'\fR is set to 160.  When
\&\f(CW\*(C`type\*(C'\fR is \f(CW\*(Aqmin\*(Aq\fR the resulting image is 300 x 150, when \f(CW\*(C`type\*(C'\fR is
\&\f(CW\*(Aqmax\*(Aq\fR the resulting image is 320 x 150.
.Sp
\&\f(CW\*(C`type\*(C'\fR is only used if both \f(CW\*(C`xpixels\*(C'\fR and \f(CW\*(C`ypixels\*(C'\fR are supplied.
.RE
.IP "\(bu" 4
\&\f(CW\*(C`qtype\*(C'\fR \- defines the quality of scaling performed.  Possible values are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`normal\*(C'\fR \- high quality scaling.  This is the default.
.IP "\(bu" 4
\&\f(CW\*(C`preview\*(C'\fR \- lower quality.  When scaling down this will skip input
pixels, eg. scaling by 0.5 will skip every other pixel.  When scaling
up this will duplicate pixels.
.IP "\(bu" 4
\&\f(CW\*(C`mixing\*(C'\fR \- implements the mixing algorithm implemented by
\&\fIpnmscale\fR.  This retains more detail when scaling down than
\&\f(CW\*(C`normal\*(C'\fR.  When scaling down this proportionally accumulates sample
data from the pixels, resulting in a proportional mix of all of the
pixels.  When scaling up this will mix pixels when the sampling grid
crosses a pixel boundary but will otherwise copy pixel values.
.RE
.RS 4
.Sp
\&\fIscale()\fR will fail if \f(CW\*(C`qtype\*(C'\fR is set to some other value.
.Sp
\&\f(CW\*(C`preview\*(C'\fR is faster than \f(CW\*(C`mixing\*(C'\fR which is much faster than \f(CW\*(C`normal\*(C'\fR.
.RE
.RE
.RS 4
.Sp
To scale an image on a given axis without maintaining proportions, it
is best to call the \fIscaleX()\fR and \fIscaleY()\fR methods with the required
dimensions. eg.
.Sp
.Vb 1
\&  my $scaled = $img\->scaleX(pixels=>400)\->scaleY(pixels=>200);
.Ve
.Sp
From Imager 0.54 you can scale without maintaining proportions either
by supplying both the \f(CW\*(C`xscalefactor\*(C'\fR and \f(CW\*(C`yscalefactor\*(C'\fR arguments:
.Sp
.Vb 1
\&  my $scaled = $img\->scale(xscalefactor => 0.5, yscalefactor => 0.67);
.Ve
.Sp
or by supplying \f(CW\*(C`xpixels\*(C'\fR and \f(CW\*(C`ypixels\*(C'\fR and setting \f(CW\*(C`type\*(C'\fR to
<nonprop>:
.Sp
.Vb 1
\&  my $scaled = $im\->scale(xpixels => 200, ypixels => 200, type => \*(Aqnonprop\*(Aq);
.Ve
.Sp
Returns a new scaled image on success.  The source image is not
modified.
.Sp
Returns false on failure, check the \fIerrstr()\fR method for the reason for
failure.
.Sp
A mandatory warning is produced if \fIscale()\fR is called in void context.
.Sp
.Vb 4
\&  # setup
\&  my $image = Imager\->new;
\&  $image\->read(file => \*(Aqsomefile.jpg\*(Aq)
\&    or die $image\->errstr;
\&
\&  # all full quality unless indicated otherwise
\&  # half the size:
\&  my $half = $image\->scale;
\&
\&  # double the size
\&  my $double = $image\->scale(scalefactor => 2.0);
\&
\&  # so a 400 x 400 box fits in the resulting image:
\&  my $fit400x400inside = $image\->scale(xpixels => 400, ypixels => 400);
\&  my $fit400x400inside2 = $image\->scale(xpixels => 400, ypixels => 400,
\&                                        type=>\*(Aqmax\*(Aq);
\&
\&  # fit inside a 400 x 400 box
\&  my $inside400x400 = $image\->scale(xpixels => 400, ypixels => 400,
\&                              type=>\*(Aqmin\*(Aq);
\&
\&  # make it 400 pixels wide or high
\&  my $width400 = $image\->scale(xpixels => 400);
\&  my $height400 = $image\->scale(ypixels => 400);
\&
\&  # low quality scales:
\&  # to half size
\&  my $low = $image\->scale(qtype => \*(Aqpreview\*(Aq);
\&
\&  # mixing method scale
\&  my $mixed = $image\->scale(qtype => \*(Aqmixing\*(Aq, scalefactor => 0.1);
\&
\&  # using an Image::Math::Constrain object
\&  use Image::Math::Constrain;
\&  my $constrain = Image::Math::Constrain\->new(800, 600);
\&  my $scaled = $image\->scale(constrain => $constrain);
\&
\&  # same as Image::Math::Constrain version
\&  my $scaled2 = $image\->scale(xpixels => 800, ypixels => 600, type => \*(Aqmin\*(Aq);
.Ve
.RE
.IP "\fIscaleX()\fR" 4
.IX Item "scaleX()"
\&\fIscaleX()\fR will scale along the X dimension, return a new image with the
new width:
.Sp
.Vb 2
\&  my $newimg = $img\->scaleX(pixels=>400); # 400x500
\&  $newimg = $img\->scaleX(scalefactor=>0.25) # 175x500
.Ve
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`scalefactor\*(C'\fR \- the amount to scale the X axis.  Ignored if \f(CW\*(C`pixels\*(C'\fR is
provided.  Default: 0.5.
.IP "\(bu" 4
\&\f(CW\*(C`pixels\*(C'\fR \- the new width of the image.
.RE
.RS 4
.Sp
Returns a new scaled image on success.  The source image is not
modified.
.Sp
Returns false on failure, check the \fIerrstr()\fR method for the reason for
failure.
.Sp
A mandatory warning is produced if \fIscaleX()\fR is called in void context.
.RE
.IP "\fIscaleY()\fR" 4
.IX Item "scaleY()"
\&\fIscaleY()\fR will scale along the Y dimension, return a new image with the
new height:
.Sp
.Vb 2
\&  $newimg = $img\->scaleY(pixels=>400); # 700x400
\&  $newimg = $img\->scaleY(scalefactor=>0.25) # 700x125
.Ve
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`scalefactor\*(C'\fR \- the amount to scale the Y axis.  Ignored if \f(CW\*(C`pixels\*(C'\fR is
provided.  Default: 0.5.
.IP "\(bu" 4
\&\f(CW\*(C`pixels\*(C'\fR \- the new height of the image.
.RE
.RS 4
.Sp
Returns a new scaled image on success.  The source image is not
modified.
.Sp
Returns false on failure, check the \fIerrstr()\fR method for the reason for
failure.
.Sp
A mandatory warning is produced if \fIscaleY()\fR is called in void context.
.RE
.IP "\fIscale_calculate()\fR" 4
.IX Item "scale_calculate()"
Performs the same calculations that the \fIscale()\fR method does to
calculate the scaling factors from the parameters you pass.
.Sp
\&\fIscale_calculate()\fR can be called as an object method, or as a class
method.
.Sp
Takes the following parameters over \fIscale()\fR:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR \- the image width and height to base the scaling on.
Required if \fIscale_calculate()\fR is called as a class method.  If called
as an object method these default to the image width and height
respectively.
.RE
.RS 4
.Sp
You might use \fIscale_calculate()\fR as a class method when generating an
\&\s-1HTML\s0 \f(CW\*(C`IMG\*(C'\fR tag, for example.
.Sp
Returns an empty list on failure.
.Sp
Returns a list containing horizontal scale factor, vertical scale
factor, new width, new height, on success.
.Sp
.Vb 3
\&  my ($x_scale, $y_scale, $new_width, $new_height) =
\&        Imager\->scale_calculate(width => 1024, height => 768,
\&                                ypixels => 180, type => \*(Aqmin\*(Aq);
\&
\&  my ($x_scale, $y_scale, $new_width, $new_height) =
\&        $img\->scale_calculate(xpixels => 200, type => \*(Aqmin\*(Aq);
.Ve
.RE
.IP "\fIcrop()\fR" 4
.IX Item "crop()"
Another way to resize an image is to crop it.  The parameters to
crop are the edges of the area that you want in the returned image,
where the right and bottom edges are non-inclusive.  If a parameter is
omitted a default is used instead.
.Sp
\&\fIcrop()\fR returns the cropped image and does not modify the source image.
.Sp
The possible parameters are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`left\*(C'\fR \- the left edge of the area to be cropped.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`top\*(C'\fR \- the top edge of the area to be cropped.  Default: 0
.IP "\(bu" 4
\&\f(CW\*(C`right\*(C'\fR \- the right edge of the area to be cropped.  Default: right
edge of image.
.IP "\(bu" 4
\&\f(CW\*(C`bottom\*(C'\fR \- the bottom edge of the area to be cropped.  Default:
bottom edge of image.
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR \- width of the crop area.  Ignored if both \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR are
supplied.  Centered on the image if neither \f(CW\*(C`left\*(C'\fR nor \f(CW\*(C`right\*(C'\fR are
supplied.
.IP "\(bu" 4
\&\f(CW\*(C`height\*(C'\fR \- height of the crop area.  Ignored if both \f(CW\*(C`top\*(C'\fR and
\&\f(CW\*(C`bottom\*(C'\fR are supplied.  Centered on the image if neither \f(CW\*(C`top\*(C'\fR nor
\&\f(CW\*(C`bottom\*(C'\fR are supplied.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 4
\&  # these produce the same image
\&  $newimg = $img\->crop(left=>50, right=>100, top=>10, bottom=>100); 
\&  $newimg = $img\->crop(left=>50, top=>10, width=>50, height=>90);
\&  $newimg = $img\->crop(right=>100, bottom=>100, width=>50, height=>90);
\&
\&  # and the following produce the same image
\&  $newimg = $img\->crop(left=>50, right=>100);
\&  $newimg = $img\->crop(left=>50, right=>100, top=>0, 
\&                       bottom=>$img\->getheight);
\&
\&  # grab the top left corner of the image
\&  $newimg = $img\->crop(right=>50, bottom=>50);
.Ve
.Sp
You can also specify width and height parameters which will produce a
new image cropped from the center of the input image, with the given
width and height.
.Sp
.Vb 1
\&  $newimg = $img\->crop(width=>50, height=>50);
.Ve
.Sp
If you supply \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`right\*(C'\fR values, the \f(CW\*(C`right\*(C'\fR
value will be ignored.  If you supply \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`height\*(C'\fR and \f(CW\*(C`bottom\*(C'\fR
values, the \f(CW\*(C`bottom\*(C'\fR value will be ignored.
.Sp
The edges of the cropped area default to the edges of the source
image, for example:
.Sp
.Vb 2
\&  # a vertical bar from the middle from top to bottom
\&  $newimg = $img\->crop(width=>50);
\&
\&  # the right half
\&  $newimg = $img\->crop(left=>$img\->getwidth() / 2);
.Ve
.Sp
If the resulting image would have zero width or height then \fIcrop()\fR
returns false and \f(CW$img\fR\->errstr is an appropriate error message.
.Sp
A mandatory warning is produced if \fIcrop()\fR is called in void context.
.RE
.IP "\fIrotate()\fR" 4
.IX Item "rotate()"
Use the \fIrotate()\fR method to rotate an image.  This method will return a
new, rotated image.
.Sp
To rotate by an exact amount in degrees or radians, use the 'degrees'
or 'radians' parameter:
.Sp
.Vb 2
\&  my $rot20 = $img\->rotate(degrees=>20);
\&  my $rotpi4 = $img\->rotate(radians=>3.14159265/4);
.Ve
.Sp
Exact image rotation uses the same underlying transformation engine as
the \fImatrix_transform()\fR method (see Imager::Engines).
.Sp
You can also supply a \f(CW\*(C`back\*(C'\fR argument which acts as a background
color for the areas of the image with no samples available (outside
the rectangle of the source image.)  This can be either an
Imager::Color or Imager::Color::Float object.  This is \fBnot\fR mixed
transparent pixels in the middle of the source image, it is \fBonly\fR
used for pixels where there is no corresponding pixel in the source
image.
.Sp
To rotate in steps of 90 degrees, use the 'right' parameter:
.Sp
.Vb 1
\&  my $rotated = $img\->rotate(right=>270);
.Ve
.Sp
Rotations are clockwise for positive values.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`right\*(C'\fR \- rotate by an exact multiple of 90 degrees, specified in
degrees.
.IP "\(bu" 4
\&\f(CW\*(C`radians\*(C'\fR \- rotate by an angle specified in radians.
.IP "\(bu" 4
\&\f(CW\*(C`degrees\*(C'\fR \- rotate by an angle specified in degrees.
.IP "\(bu" 4
\&\f(CW\*(C`back\*(C'\fR \- for \f(CW\*(C`radians\*(C'\fR and \f(CW\*(C`degrees\*(C'\fR this is the color used for the
areas not covered by the original image.  For example, the corners of
an image rotated by 45 degrees.
.Sp
This can be either an Imager::Color object, an Imager::Color::Float
object or any parameter that Imager can convert to a color object, see
\&\*(L"Color Parameters\*(R" in Imager::Draw for details.
.Sp
This is \fBnot\fR mixed transparent pixels in the middle of the source
image, it is \fBonly\fR used for pixels where there is no corresponding
pixel in the source image.
.Sp
Default: transparent black.
.RE
.RS 4
.Sp
.Vb 2
\&  # rotate 45 degrees clockwise, 
\&  my $rotated = $img\->rotate(degrees => 45);
\&
\&  # rotate 10 degrees counter\-clockwise
\&  # set pixels not sourced from the original to red
\&  my $rotated = $img\->rotate(degrees => \-10, back => \*(Aqred\*(Aq);
.Ve
.RE
.SS "Image pasting/flipping"
.IX Subsection "Image pasting/flipping"
A list of the transformations that alter the source image follows:
.IP "\fIpaste()\fR" 4
.IX Item "paste()"
To copy an image to onto another image use the \f(CW\*(C`paste()\*(C'\fR
method.
.IX Xref "paste"
.Sp
.Vb 1
\&  $dest\->paste(left=>40, top=>20, src=>$logo);
.Ve
.Sp
That copies the entire \f(CW$logo\fR image onto the \f(CW$dest\fR image so that the
upper left corner of the \f(CW$logo\fR image is at (40,20).
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`src\*(C'\fR, \f(CW\*(C`img\*(C'\fR \- the source image.  \f(CW\*(C`src\*(C'\fR added for compatibility with
\&\fIrubthrough()\fR.
.IP "\(bu" 4
\&\f(CW\*(C`left\*(C'\fR, \f(CW\*(C`top\*(C'\fR \- position in output of the top left of the pasted image.
Default: (0,0)
.IP "\(bu" 4
\&\f(CW\*(C`src_minx\*(C'\fR, \f(CW\*(C`src_miny\*(C'\fR \- the top left corner in the source image to start
the paste from.  Default: (0, 0)
.IP "\(bu" 4
\&\f(CW\*(C`src_maxx\*(C'\fR, \f(CW\*(C`src_maxy\*(C'\fR \- the bottom right in the source image of the sub
image to paste.  This position is \fBnon\fR inclusive.  Default: bottom
right corner of the source image.
.IP "\(bu" 4
\&\f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR \- if the corresponding src_maxx or src_maxy is not
defined then width or height is used for the width or height of the
sub image to be pasted.
.RE
.RS 4
.Sp
.Vb 5
\&  # copy the 20x20 pixel image from (20,20) in $src_image to (10,10) in $img
\&  $img\->paste(src=>$src_image,
\&              left => 10, top => 10,
\&              src_minx => 20, src_miny => 20,
\&              src_maxx => 40, src_maxx => 40);
.Ve
.Sp
If the source image has an alpha channel and the target doesn't, then
the source is treated as if composed onto a black background.
.Sp
If the source image is color and the target is gray scale, the the
source is treated as if run through \f(CW\*(C`convert(preset=>\*(Aqgray\*(Aq)\*(C'\fR.
.RE
.IP "\fIrubthrough()\fR" 4
.IX Item "rubthrough()"
A more complicated way of blending images is where one image is
put 'over' the other with a certain amount of opaqueness.  The
method that does this is \fIrubthrough()\fR.
.Sp
.Vb 4
\&  $img\->rubthrough(src=>$overlay,
\&                   tx=>30,       ty=>50,
\&                   src_minx=>20, src_miny=>30,
\&                   src_maxx=>20, src_maxy=>30);
.Ve
.Sp
That will take the sub image defined by \fI\f(CI$overlay\fI\fR and
\&\fI[src_minx,src_maxx)[src_miny,src_maxy)\fR and overlay it on top of
\&\fI\f(CI$img\fI\fR with the upper left corner at (30,50).  You can rub 2 or 4
channel images onto a 3 channel image, or a 2 channel image onto a 1
channel image.  The last channel is used as an alpha channel.  To add
an alpha channel to an image see \fI\fIconvert()\fI\fR.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`tx\*(C'\fR, \f(CW\*(C`ty\*(C'\fR \- location in the the target image ($self) to render the
top left corner of the source.
.IP "\(bu" 4
\&\f(CW\*(C`src_minx\*(C'\fR, \f(CW\*(C`src_miny\*(C'\fR \- the top left corner in the source to transfer to
the target image.  Default: (0, 0).
.IP "\(bu" 4
\&\f(CW\*(C`src_maxx\*(C'\fR, \f(CW\*(C`src_maxy\*(C'\fR \- the bottom right in the source image of the sub
image to overlay.  This position is \fBnon\fR inclusive.  Default: bottom
right corner of the source image.
.RE
.RS 4
.Sp
.Vb 2
\&  # overlay all of $source onto $targ
\&  $targ\->rubthrough(tx => 20, ty => 25, src => $source);
\&
\&  # overlay the top left corner of $source onto $targ
\&  $targ\->rubthrough(tx => 20, ty => 25, src => $source,
\&                    src_maxx => 20, src_maxy => 20);
\&
\&  # overlay the bottom right corner of $source onto $targ
\&  $targ\->rubthrough(tx => 20, ty => 30, src => $src,
\&                    src_minx => $src\->getwidth() \- 20,
\&                    src_miny => $src\->getheight() \- 20);
.Ve
.Sp
\&\fIrubthrough()\fR returns true on success.  On failure check
\&\f(CW\*(C`$target\->errstr\*(C'\fR for the reason for failure.
.RE
.IP "\fIcompose()\fR" 4
.IX Item "compose()"
Draws the source image over the target image, with the source alpha
channel modified by the optional mask and the opacity.
.Sp
.Vb 5
\&  $img\->compose(src=>$overlay,
\&                tx=>30,       ty=>50,
\&                src_minx=>20, src_miny=>30,
\&                src_maxx=>20, src_maxy=>30,
\&                mask => $mask, opacity => 0.5);
.Ve
.Sp
That will take the sub image defined by \fI\f(CI$overlay\fI\fR and
\&\fI[src_minx,src_maxx)[src_miny,src_maxy)\fR and overlay it on top of
\&\fI\f(CI$img\fI\fR with the upper left corner at (30,50).  You can rub 2 or 4
channel images onto a 3 channel image, or a 2 channel image onto a 1
channel image.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`src\*(C'\fR \- the source image to draw onto the target.  Required.
.IP "\(bu" 4
\&\f(CW\*(C`tx\*(C'\fR, \f(CW\*(C`ty\*(C'\fR \- location in the the target image ($self) to render the top
left corner of the source.  These can also be supplied as \f(CW\*(C`left\*(C'\fR and
\&\f(CW\*(C`right\*(C'\fR.  Default: (0, 0).
.IP "\(bu" 4
\&\f(CW\*(C`src_minx\*(C'\fR, \f(CW\*(C`src_miny\*(C'\fR \- the top left corner in the source to transfer to
the target image.  Default: (0, 0).
.IP "\(bu" 4
\&\f(CW\*(C`src_maxx\*(C'\fR, \f(CW\*(C`src_maxy\*(C'\fR \- the bottom right in the source image of the sub
image to overlay.  This position is \fBnon\fR inclusive.  Default: bottom
right corner of the source image.
.IP "\(bu" 4
\&\f(CW\*(C`mask\*(C'\fR \- a mask image.  The first channel of this image is used to
modify the alpha channel of the source image.  This can be used to
mask out portions of the source image.  Where the first channel is
zero none of the source image will be used, where the first channel is
maximum the full alpha of the source image will be used, as further
modified by the opacity.
.IP "\(bu" 4
opacity \- further modifies the alpha channel of the source image, in
the range 0.0 to 1.0.  Default: 1.0.
.IP "\(bu" 4
combine \- the method to combine the source pixels with the target.
See the combine option documentation in Imager::Fill.  Default:
normal.
.RE
.RS 4
.Sp
Calling \fIcompose()\fR with no mask, combine set to \f(CW\*(C`normal\*(C'\fR, opacity set
to \f(CW1.0\fR is equivalent to calling \fIrubthrough()\fR.
.Sp
\&\fIcompose()\fR is intended to be produce similar effects to layers in
interactive paint software.
.Sp
.Vb 2
\&  # overlay all of $source onto $targ
\&  $targ\->compose(tx => 20, ty => 25, src => $source);
\&
\&  # overlay the top left corner of $source onto $targ
\&  $targ\->compose(tx => 20, ty => 25, src => $source,
\&                    src_maxx => 20, src_maxy => 20);
\&
\&  # overlay the bottom right corner of $source onto $targ
\&  $targ\->compose(tx => 20, ty => 30, src => $src,
\&                    src_minx => $src\->getwidth() \- 20,
\&                    src_miny => $src\->getheight() \- 20);
.Ve
.Sp
\&\fIcompose()\fR returns true on success.  On failure check \f(CW$target\fR\->errstr
for the reason for failure.
.RE
.IP "\fIflip()\fR" 4
.IX Item "flip()"
An inplace horizontal or vertical flip is possible by calling the
\&\f(CW\*(C`flip()\*(C'\fR method.  If the original is to be preserved it's possible to
make a copy first.  The only parameter it takes is the \f(CW\*(C`dir\*(C'\fR
parameter which can take the values \f(CW\*(C`h\*(C'\fR, \f(CW\*(C`v\*(C'\fR, \f(CW\*(C`vh\*(C'\fR and \f(CW\*(C`hv\*(C'\fR.
.Sp
.Vb 3
\&  $img\->flip(dir=>"h");       # horizontal flip
\&  $img\->flip(dir=>"vh");      # vertical and horizontal flip
\&  $nimg = $img\->copy\->flip(dir=>"v"); # make a copy and flip it vertically
.Ve
.Sp
\&\fIflip()\fR returns true on success.  On failure check \f(CW$img\fR\->errstr for the
reason for failure.
.SS "Color transformations"
.IX Subsection "Color transformations"
.IP "\fIconvert()\fR" 4
.IX Item "convert()"
You can use the convert method to transform the color space of an
image using a matrix.  For ease of use some presets are provided.
.Sp
The convert method can be used to:
.RS 4
.IP "\(bu" 4
convert an \s-1RGB\s0 or \s-1RGBA\s0 image to gray scale.
.IP "\(bu" 4
convert a gray scale image to \s-1RGB\s0.
.IP "\(bu" 4
extract a single channel from an image.
.IP "\(bu" 4
set a given channel to a particular value (or from another channel)
.RE
.RS 4
.Sp
The currently defined presets are:
.IP "\(bu" 4
\&\f(CW\*(C`gray\*(C'\fR, \f(CW\*(C`grey\*(C'\fR \- converts an \s-1RGBA\s0 image into a gray scale image with
alpha channel, or an \s-1RGB\s0 image into a gray scale image without an
alpha channel.
.Sp
This weights the \s-1RGB\s0 channels at 22.2%, 70.7% and 7.1% respectively.
.IP "\(bu" 4
\&\f(CW\*(C`noalpha\*(C'\fR \- removes the alpha channel from a 2 or 4 channel image.
An identity for other images.
.IP "\(bu" 4
\&\f(CW\*(C`red\*(C'\fR, \f(CW\*(C`channel0\*(C'\fR \- extracts the first channel of the image into a
single channel image
.IP "\(bu" 4
\&\f(CW\*(C`green\*(C'\fR, \f(CW\*(C`channel1\*(C'\fR \- extracts the second channel of the image into
a single channel image
.IP "\(bu" 4
\&\f(CW\*(C`blue\*(C'\fR, \f(CW\*(C`channel2\*(C'\fR \- extracts the third channel of the image into a
single channel image
.IP "\(bu" 4
\&\f(CW\*(C`alpha\*(C'\fR \- extracts the alpha channel of the image into a single
channel image.
.Sp
If the image has 1 or 3 channels (assumed to be gray scale or \s-1RGB\s0) then
the resulting image will be all white.
.IP "\(bu" 4
\&\f(CW\*(C`rgb\*(C'\fR
.Sp
converts a gray scale image to \s-1RGB\s0, preserving the alpha channel if any
.IP "\(bu" 4
\&\f(CW\*(C`addalpha\*(C'\fR \- adds an alpha channel to a gray scale or \s-1RGB\s0 image.
Preserves an existing alpha channel for a 2 or 4 channel image.
.RE
.RS 4
.Sp
For example, to convert an \s-1RGB\s0 image into a gray scale image:
.Sp
.Vb 1
\&  $new = $img\->convert(preset=>\*(Aqgrey\*(Aq); # or gray
.Ve
.Sp
or to convert a gray scale image to an \s-1RGB\s0 image:
.Sp
.Vb 1
\&  $new = $img\->convert(preset=>\*(Aqrgb\*(Aq);
.Ve
.Sp
The presets aren't necessary simple constants in the code, some are
generated based on the number of channels in the input image.
.Sp
If you want to perform some other color transformation, you can use
the 'matrix' parameter.
.Sp
For each output pixel the following matrix multiplication is done:
.Sp
.Vb 5
\&  | channel[0] |   | $c00, ...,  $c0k |   | inchannel[0] |
\&  |    ...     | = |       ...        | x |     ...      |
\&  | channel[k] |   | $ck0, ...,  $ckk |   | inchannel[k] |
\&                                                          1
\&Where C<k = $img\-E<gt>getchannels()\-1>.
.Ve
.Sp
So if you want to swap the red and green channels on a 3 channel image:
.Sp
.Vb 3
\&  $new = $img\->convert(matrix=>[ [ 0, 1, 0 ],
\&                                 [ 1, 0, 0 ],
\&                                 [ 0, 0, 1 ] ]);
.Ve
.Sp
or to convert a 3 channel image to gray scale using equal weightings:
.Sp
.Vb 1
\&  $new = $img\->convert(matrix=>[ [ 0.333, 0.333, 0.334 ] ])
.Ve
.Sp
Convert a 2 channel image (gray scale with alpha) to an \s-1RGBA\s0 image with
the gray converted to the specified \s-1RGB\s0 color:
.Sp
.Vb 7
\&  # set (RGB) scaled on the grey scale portion and copy the alpha
\&  # channel as is
\&  my $colored = $gray\->convert(matrix=>[ [ ($red/255),   0 ], 
\&                                         [ ($green/255), 0 ], 
\&                                         [ ($blue/255),  0 ], 
\&                                         [ 0,            1 ],
\&                                       ]);
.Ve
.Sp
To convert a 3 channel image to a 4 channel image with a 50 percent
alpha channel:
.Sp
.Vb 5
\&  my $withalpha = $rgb\->convert(matrix =>[ [ 1, 0, 0, 0 ],
\&                                           [ 0, 1, 0, 0 ],
\&                                           [ 0, 0, 1, 0 ],
\&                                           [ 0, 0, 0, 0.5 ],
\&                                         ]);
.Ve
.RE
.IP "\fIcombine()\fR" 4
.IX Xref "combine"
.IX Item "combine()"
Combine channels from one or more input images into a new image.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`src\*(C'\fR \- a reference to an array of input images.  There must be at least
one input image.  A given image may appear more than once in \f(CW\*(C`src\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- a reference to an array of channels corresponding to the
source images.  If \f(CW\*(C`channels\*(C'\fR is not supplied then the first channel
from each input image is used.  If the array referenced by \f(CW\*(C`channels\*(C'\fR
is shorter than that referenced by \f(CW\*(C`src\*(C'\fR then the first channel is
used from the extra images.
.RE
.RS 4
.Sp
.Vb 2
\&  # make an rgb image from red, green, and blue images
\&  my $rgb = Imager\->combine(src => [ $red, $green, $blue ]);
\&
\&  # convert a BGR image into RGB
\&  my $rgb = Imager\->combine(src => [ $bgr, $bgr, $bgr ],
\&                            channels => [ 2, 1, 0 ]);
\&
\&  # add an alpha channel from another image
\&  my $rgba = Imager\->combine(src => [ $rgb, $rgb, $rgb, $alpha ],
\&                     channels => [ 0, 1, 2, 0 ]);
.Ve
.RE
.SS "Color Mappings"
.IX Subsection "Color Mappings"
.IP "\fImap()\fR" 4
.IX Item "map()"
You can use the map method to map the values of each channel of an
image independently using a list of look-up tables.  It's important to
realize that the modification is made inplace.  The function simply
returns the input image again or undef on failure.
.Sp
Each channel is mapped independently through a look-up table with 256
entries.  The elements in the table should not be less than 0 and not
greater than 255.  If they are out of the 0..255 range they are
clamped to the range.  If a table does not contain 256 entries it is
silently ignored.
.Sp
Single channels can mapped by specifying their name and the mapping
table.  The channel names are \f(CW\*(C`red\*(C'\fR, \f(CW\*(C`green\*(C'\fR, \f(CW\*(C`blue\*(C'\fR, \f(CW\*(C`alpha\*(C'\fR.
.Sp
.Vb 2
\&  @map = map { int( $_/2 } 0..255;
\&  $img\->map( red=>\e@map );
.Ve
.Sp
It is also possible to specify a single map that is applied to all
channels, alpha channel included.  For example this applies a gamma
correction with a gamma of 1.4 to the input image.
.Sp
.Vb 3
\&  $gamma = 1.4;
\&  @map = map { int( 0.5 + 255*($_/255)**$gamma ) } 0..255;
\&  $img\->map(all=> \e@map);
.Ve
.Sp
The \f(CW\*(C`all\*(C'\fR map is used as a default channel, if no other map is
specified for a channel then the \f(CW\*(C`all\*(C'\fR map is used instead.  If we
had not wanted to apply gamma to the alpha channel we would have used:
.Sp
.Vb 1
\&  $img\->map(all=> \e@map, alpha=>[]);
.Ve
.Sp
Since \f(CW\*(C`[]\*(C'\fR contains fewer than 256 element the gamma channel is
unaffected.
.Sp
It is also possible to simply specify an array of maps that are
applied to the images in the \s-1RGBA\s0 order.  For example to apply
maps to the \f(CW\*(C`red\*(C'\fR and \f(CW\*(C`blue\*(C'\fR channels one would use:
.Sp
.Vb 1
\&  $img\->map(maps=>[\e@redmap, [], \e@bluemap]);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager, Imager::Engines
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>, Arnar M. Hrafnkelsson
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Revision\fR$
