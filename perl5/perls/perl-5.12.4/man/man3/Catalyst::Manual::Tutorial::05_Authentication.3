.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Tutorial::05_Authentication 3"
.TH Catalyst::Manual::Tutorial::05_Authentication 3 "2011-09-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Tutorial::05_Authentication \- Catalyst Tutorial \- Chapter 5: Authentication
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This is \fBChapter 5 of 10\fR for the Catalyst tutorial.
.PP
Tutorial Overview
.IP "1." 4
Introduction
.IP "2." 4
Catalyst Basics
.IP "3." 4
More Catalyst Basics
.IP "4." 4
Basic \s-1CRUD\s0
.IP "5." 4
\&\fB05_Authentication\fR
.IP "6." 4
Authorization
.IP "7." 4
Debugging
.IP "8." 4
Testing
.IP "9." 4
Advanced \s-1CRUD\s0
.IP "10." 4
Appendices
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Now that we finally have a simple yet functional application, we can
focus on providing authentication (with authorization coming next in
Chapter 6).
.PP
This chapter of the tutorial is divided into two main sections: 1)
basic, cleartext authentication and 2) hash-based authentication.
.PP
Source code for the tutorial in included in the \fI/home/catalyst/Final\fR directory
of the Tutorial Virtual machine (one subdirectory per chapter).  There
are also instructions for downloading the code in
Catalyst::Manual::Tutorial::01_Intro.
.SH "BASIC AUTHENTICATION"
.IX Header "BASIC AUTHENTICATION"
This section explores how to add authentication logic to a Catalyst
application.
.SS "Add Users and Roles to the Database"
.IX Subsection "Add Users and Roles to the Database"
First, we add both user and role information to the database (we will
add the role information here although it will not be used until the
authorization section, Chapter 6).  Create a new \s-1SQL\s0 script file by
opening \f(CW\*(C`myapp02.sql\*(C'\fR in your editor and insert:
.PP
.Vb 10
\&    \-\-
\&    \-\- Add users and role tables, along with a many\-to\-many join table
\&    \-\-
\&    PRAGMA foreign_keys = ON;
\&    CREATE TABLE users (
\&            id            INTEGER PRIMARY KEY,
\&            username      TEXT,
\&            password      TEXT,
\&            email_address TEXT,
\&            first_name    TEXT,
\&            last_name     TEXT,
\&            active        INTEGER
\&    );
\&    CREATE TABLE role (
\&            id   INTEGER PRIMARY KEY,
\&            role TEXT
\&    );
\&    CREATE TABLE user_role (
\&            user_id INTEGER REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            role_id INTEGER REFERENCES role(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            PRIMARY KEY (user_id, role_id)
\&    );
\&    \-\-
\&    \-\- Load up some initial test data
\&    \-\-
\&    INSERT INTO users VALUES (1, \*(Aqtest01\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt01@na.com\*(Aq, \*(AqJoe\*(Aq,  \*(AqBlow\*(Aq, 1);
\&    INSERT INTO users VALUES (2, \*(Aqtest02\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt02@na.com\*(Aq, \*(AqJane\*(Aq, \*(AqDoe\*(Aq,  1);
\&    INSERT INTO users VALUES (3, \*(Aqtest03\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt03@na.com\*(Aq, \*(AqNo\*(Aq,   \*(AqGo\*(Aq,   0);
\&    INSERT INTO role VALUES (1, \*(Aquser\*(Aq);
\&    INSERT INTO role VALUES (2, \*(Aqadmin\*(Aq);
\&    INSERT INTO user_role VALUES (1, 1);
\&    INSERT INTO user_role VALUES (1, 2);
\&    INSERT INTO user_role VALUES (2, 1);
\&    INSERT INTO user_role VALUES (3, 1);
.Ve
.PP
Then load this into the \f(CW\*(C`myapp.db\*(C'\fR database with the following command:
.PP
.Vb 1
\&    $ sqlite3 myapp.db < myapp02.sql
.Ve
.SS "Add User and Role Information to \s-1DBIC\s0 Schema"
.IX Subsection "Add User and Role Information to DBIC Schema"
Although we could manually edit the \s-1DBIC\s0 schema information to include
the new tables added in the previous step, let's use the
\&\f(CW\*(C`create=static\*(C'\fR option on the \s-1DBIC\s0 model helper to do most of the work
for us:
.PP
.Vb 11
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static components=TimeStamp dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
\&     exists "/home/catalyst/dev/MyApp/script/../lib/MyApp/Model"
\&     exists "/home/catalyst/dev/MyApp/script/../t"
\&    Dumping manual schema for MyApp::Schema to directory /home/catalyst/dev/MyApp/script/../lib ...
\&    Schema dump completed.
\&     exists "/home/catalyst/dev/MyApp/script/../lib/MyApp/Model/DB.pm"
\&    $
\&    $ ls lib/MyApp/Schema/Result
\&    Author.pm  BookAuthor.pm  Book.pm  Role.pm  User.pm  UserRole.pm
.Ve
.PP
Notice how the helper has added three new table-specific Result Source
files to the \f(CW\*(C`lib/MyApp/Schema/Result\*(C'\fR directory.  And, more
importantly, even if there were changes to the existing result source
files, those changes would have only been written above the
\&\f(CW\*(C`# DO NOT MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR comment and your hand-edited
enhancements would have been preserved.
.PP
Speaking of \*(L"hand-edited enhancements,\*(R" we should now add the
\&\f(CW\*(C`many_to_many\*(C'\fR relationship information to the User Result Source file.
As with the Book, BookAuthor, and Author files in
Chapter 3,
DBIx::Class::Schema::Loader has automatically created the \f(CW\*(C`has_many\*(C'\fR
and \f(CW\*(C`belongs_to\*(C'\fR relationships for the new User, UserRole, and Role
tables. However, as a convenience for mapping Users to their assigned
roles (see Chapter 6),
we will also manually add a \f(CW\*(C`many_to_many\*(C'\fR relationship. Edit
\&\f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR add the following information between
the \f(CW\*(C`# DO NOT MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR comment and the closing
\&\f(CW\*(C`1;\*(C'\fR:
.PP
.Vb 7
\&    # many_to_many():
\&    #   args:
\&    #     1) Name of relationship, DBIC will create accessor with this name
\&    #     2) Name of has_many() relationship this many_to_many() is shortcut for
\&    #     3) Name of belongs_to() relationship in model class of has_many() above
\&    #   You must already have the has_many() defined to use a many_to_many().
\&    _\|_PACKAGE_\|_\->many_to_many(roles => \*(Aquser_roles\*(Aq, \*(Aqrole\*(Aq);
.Ve
.PP
The code for this update is obviously very similar to the edits we made
to the \f(CW\*(C`Book\*(C'\fR and \f(CW\*(C`Author\*(C'\fR classes created in
Chapter 3 with one
exception: we only defined the \f(CW\*(C`many_to_many\*(C'\fR relationship in one
direction. Whereas we felt that we would want to map Authors to Books
\&\fB\s-1AND\s0\fR Books to Authors, here we are only adding the convenience
\&\f(CW\*(C`many_to_many\*(C'\fR in the Users to Roles direction.
.PP
Note that we do not need to make any change to the
\&\f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR schema file.  It simply tells \s-1DBIC\s0 to load all of
the Result Class and ResultSet Class files it finds below the
\&\f(CW\*(C`lib/MyApp/Schema\*(C'\fR directory, so it will automatically pick up our new
table information.
.SS "Sanity-Check of the Development Server Reload"
.IX Subsection "Sanity-Check of the Development Server Reload"
We aren't ready to try out the authentication just yet; we only want to
do a quick check to be sure our model loads correctly. Assuming that you
are following along and using the \*(L"\-r\*(R" option on \f(CW\*(C`myapp_server.pl\*(C'\fR,
then the development server should automatically reload (if not, press
\&\f(CW\*(C`Ctrl\-C\*(C'\fR to break out of the server if it's running and then enter
\&\f(CW\*(C`script/myapp_server.pl\*(C'\fR to start it). Look for the three new model
objects in the startup debug output:
.PP
.Vb 10
\&    ...
\&     .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-.
\&    | Class                                                             | Type     |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&    | MyApp::Controller::Books                                          | instance |
\&    | MyApp::Controller::Root                                           | instance |
\&    | MyApp::Model::DB                                                  | instance |
\&    | MyApp::Model::DB::Author                                          | class    |
\&    | MyApp::Model::DB::Book                                            | class    |
\&    | MyApp::Model::DB::BookAuthor                                      | class    |
\&    | MyApp::Model::DB::Role                                            | class    |
\&    | MyApp::Model::DB::User                                            | class    |
\&    | MyApp::Model::DB::UserRole                                        | class    |
\&    | MyApp::View::HTML                                                 | instance |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    ...
.Ve
.PP
Again, notice that your \*(L"Result Class\*(R" classes have been \*(L"re-loaded\*(R" by
Catalyst under \f(CW\*(C`MyApp::Model\*(C'\fR.
.SS "Include Authentication and Session Plugins"
.IX Subsection "Include Authentication and Session Plugins"
Edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and update it as follows (everything below
\&\f(CW\*(C`StackTrace\*(C'\fR is new):
.PP
.Vb 5
\&    # Load plugins
\&    use Catalyst qw/
\&        \-Debug
\&        ConfigLoader
\&        Static::Simple
\&    
\&        StackTrace
\&    
\&        Authentication
\&    
\&        Session
\&        Session::Store::File
\&        Session::State::Cookie
\&    /;
.Ve
.PP
\&\fBNote:\fR As discussed in
Chapter 3,
different versions of \f(CW\*(C`Catalyst::Devel\*(C'\fR have used a variety of methods
to load the plugins, but we are going to use the current Catalyst 5.9
practice of putting them on the \f(CW\*(C`use Catalyst\*(C'\fR line.
.PP
The \f(CW\*(C`Authentication\*(C'\fR plugin supports Authentication while the
\&\f(CW\*(C`Session\*(C'\fR plugins are required to maintain state across multiple \s-1HTTP\s0
requests.
.PP
Note that the only required Authentication class is the main one. This
is a change that occurred in version 0.09999_01 of the
Authentication plugin. You
\&\fBdo not need\fR to specify a particular
Authentication::Store or
\&\f(CW\*(C`Authentication::Credential\*(C'\fR you want to use.  Instead, indicate the
Store and Credential you want to use in your application configuration
(see below).
.PP
Make sure you include the additional plugins as new dependencies in the
Makefile.PL file something like this:
.PP
.Vb 4
\&    requires \*(AqCatalyst::Plugin::Authentication\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session::Store::File\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session::State::Cookie\*(Aq;
.Ve
.PP
Note that there are several options for
Session::Store.
Session::Store::Memcached
is generally a good choice if you are on Unix.  If you are running on
Windows Session::Store::File
is fine. Consult Session::Store and
its subclasses for additional information and options (for example to
use a database-backed session store).
.SS "Configure Authentication"
.IX Subsection "Configure Authentication"
There are a variety of ways to provide configuration information to
Catalyst::Plugin::Authentication.  Here we will use
Catalyst::Authentication::Realm::SimpleDB because it automatically
sets a reasonable set of defaults for us.  (Note: the \f(CW\*(C`SimpleDB\*(C'\fR here
has nothing to do with the SimpleDB offered in Amazon's web services
offerings \*(-- here we are only talking about a \*(L"simple\*(R" way to use your
\&\s-1DB\s0 as an authentication backend.)  Open \f(CW\*(C`lib/MyApp.pm\*(C'\fR and place the
following text above the call to \f(CW\*(C`_\|_PACKAGE_\|_\->setup();\*(C'\fR:
.PP
.Vb 10
\&    # Configure SimpleDB Authentication
\&    _\|_PACKAGE_\|_\->config(
\&        \*(AqPlugin::Authentication\*(Aq => {
\&            default => {
\&                class           => \*(AqSimpleDB\*(Aq,
\&                user_model      => \*(AqDB::User\*(Aq,
\&                password_type   => \*(Aqclear\*(Aq,
\&            },
\&        },
\&    );
.Ve
.PP
We could have placed this configuration in \f(CW\*(C`myapp.conf\*(C'\fR, but placing it
in \f(CW\*(C`lib/MyApp.pm\*(C'\fR is probably a better place since it's not likely
something that users of your application will want to change during
deployment (or you could use a mixture: leave \f(CW\*(C`class\*(C'\fR and \f(CW\*(C`user_model\*(C'\fR
defined in \f(CW\*(C`lib/MyApp.pm\*(C'\fR as we show above, but place \f(CW\*(C`password_type\*(C'\fR
in \f(CW\*(C`myapp.conf\*(C'\fR to allow the type of password to be easily modified
during deployment).  We will stick with putting all of the
authentication-related configuration in \f(CW\*(C`lib/MyApp.pm\*(C'\fR for the
tutorial, but if you wish to use \f(CW\*(C`myapp.conf\*(C'\fR, just convert to the
following code:
.PP
.Vb 7
\&    <Plugin::Authentication>
\&        <default>
\&            password_type clear
\&            user_model    DB::User
\&            class         SimpleDB
\&        </default>
\&    </Plugin::Authentication>
.Ve
.PP
\&\fB\s-1TIP:\s0\fR Here is a short script that will dump the contents of
\&\f(CW\*(C`MyApp\-\*(C'\fRconfig> to Config::General format in \f(CW\*(C`myapp.conf\*(C'\fR:
.PP
.Vb 2
\&    $ CATALYST_DEBUG=0 perl \-Ilib \-e \*(Aquse MyApp; use Config::General;
\&        Config::General\->new\->save_file("myapp.conf", MyApp\->config);\*(Aq
.Ve
.PP
\&\fB\s-1HOWEVER\s0\fR, if you try out the command above, be sure to delete the
\&\*(L"myapp.conf\*(R" command.  Otherwise, you will wind up with duplicate
configurations.
.PP
\&\fB\s-1NOTE:\s0\fR Because we are using
SimpleDB along with a
database layout that complies with its default assumptions: we don't
need to specify the names of the columns where our username and password
information is stored (hence, the \*(L"Simple\*(R" part of \*(L"SimpleDB\*(R").  That
being said, SimpleDB lets you specify that type of information if you
need to.  Take a look at \f(CW\*(C`Catalyst::Authentication::Realm::SimpleDB\*(C'\fR
for details.
.SS "Add Login and Logout Controllers"
.IX Subsection "Add Login and Logout Controllers"
Use the Catalyst create script to create two stub controller files:
.PP
.Vb 2
\&    $ script/myapp_create.pl controller Login
\&    $ script/myapp_create.pl controller Logout
.Ve
.PP
You could easily use a single controller here.  For example, you could
have a \f(CW\*(C`User\*(C'\fR controller with both \f(CW\*(C`login\*(C'\fR and \f(CW\*(C`logout\*(C'\fR actions.
Remember, Catalyst is designed to be very flexible, and leaves such
matters up to you, the designer and programmer.
.PP
Then open \f(CW\*(C`lib/MyApp/Controller/Login.pm\*(C'\fR, and update the definition of
\&\f(CW\*(C`sub index\*(C'\fR to match:
.PP
.Vb 1
\&    =head2 index
\&    
\&    Login logic
\&    
\&    =cut
\&    
\&    sub index :Path :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Get the username and password from form
\&        my $username = $c\->request\->params\->{username};
\&        my $password = $c\->request\->params\->{password};
\&    
\&        # If the username and password values were found in form
\&        if ($username && $password) {
\&            # Attempt to log the user in
\&            if ($c\->authenticate({ username => $username,
\&                                   password => $password  } )) {
\&                # If successful, then let them use the application
\&                $c\->response\->redirect($c\->uri_for(
\&                    $c\->controller(\*(AqBooks\*(Aq)\->action_for(\*(Aqlist\*(Aq)));
\&                return;
\&            } else {
\&                # Set an error message
\&                $c\->stash(error_msg => "Bad username or password.");
\&            }
\&        } else {
\&            # Set an error message
\&            $c\->stash(error_msg => "Empty username or password.")
\&                unless ($c\->user_exists);
\&        }
\&    
\&        # If either of above don\*(Aqt work out, send to the login page
\&        $c\->stash(template => \*(Aqlogin.tt2\*(Aq);
\&    }
.Ve
.PP
This controller fetches the \f(CW\*(C`username\*(C'\fR and \f(CW\*(C`password\*(C'\fR values from the
login form and attempts to authenticate the user.  If successful, it
redirects the user to the book list page.  If the login fails, the user
will stay at the login page and receive an error message.  If the
\&\f(CW\*(C`username\*(C'\fR and \f(CW\*(C`password\*(C'\fR values are not present in the form, the user
will be taken to the empty login form.
.PP
Note that we could have used something like "\f(CW\*(C`sub default :Path\*(C'\fR",
however, it is generally recommended (partly for historical reasons, and
partly for code clarity) only to use \f(CW\*(C`default\*(C'\fR in
\&\f(CW\*(C`MyApp::Controller::Root\*(C'\fR, and then mainly to generate the 404 not
found page for the application.
.PP
Instead, we are using "\f(CW\*(C`sub somename :Path :Args(0) {...}\*(C'\fR" here to
specifically match the \s-1URL\s0 \f(CW\*(C`/login\*(C'\fR. \f(CW\*(C`Path\*(C'\fR actions (aka, \*(L"literal
actions\*(R") create \s-1URI\s0 matches relative to the namespace of the controller
where they are defined.  Although \f(CW\*(C`Path\*(C'\fR supports arguments that allow
relative and absolute paths to be defined, here we use an empty \f(CW\*(C`Path\*(C'\fR
definition to match on just the name of the controller itself.  The
method name, \f(CW\*(C`index\*(C'\fR, is arbitrary. We make the match even more
specific with the \f(CW:Args(0)\fR action modifier \*(-- this forces the match
on \fIonly\fR \f(CW\*(C`/login\*(C'\fR, not \f(CW\*(C`/login/somethingelse\*(C'\fR.
.PP
Next, update the corresponding method in
\&\f(CW\*(C`lib/MyApp/Controller/Logout.pm\*(C'\fR to match:
.PP
.Vb 1
\&    =head2 index
\&    
\&    Logout logic
\&    
\&    =cut
\&    
\&    sub index :Path :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Clear the user\*(Aqs state
\&        $c\->logout;
\&    
\&        # Send the user to the starting point
\&        $c\->response\->redirect($c\->uri_for(\*(Aq/\*(Aq));
\&    }
.Ve
.SS "Add a Login Form \s-1TT\s0 Template Page"
.IX Subsection "Add a Login Form TT Template Page"
Create a login form by opening \f(CW\*(C`root/src/login.tt2\*(C'\fR and inserting:
.PP
.Vb 1
\&    [% META title = \*(AqLogin\*(Aq %]
\&    
\&    <!\-\- Login form \-\->
\&    <form method="post" action="[% c.uri_for(\*(Aq/login\*(Aq) %]">
\&      <table>
\&        <tr>
\&          <td>Username:</td>
\&          <td><input type="text" name="username" size="40" /></td>
\&        </tr>
\&        <tr>
\&          <td>Password:</td>
\&          <td><input type="password" name="password" size="40" /></td>
\&        </tr>
\&        <tr>
\&          <td colspan="2"><input type="submit" name="submit" value="Submit" /></td>
\&        </tr>
\&      </table>
\&    </form>
.Ve
.SS "Add Valid User Check"
.IX Subsection "Add Valid User Check"
We need something that provides enforcement for the authentication
mechanism \*(-- a \fIglobal\fR mechanism that prevents users who have not
passed authentication from reaching any pages except the login page.
This is generally done via an \f(CW\*(C`auto\*(C'\fR action/method in
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR.
.PP
Edit the existing \f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR class file and insert
the following method:
.PP
.Vb 1
\&    =head2 auto
\&    
\&    Check if there is a user and, if not, forward to login page
\&    
\&    =cut
\&    
\&    # Note that \*(Aqauto\*(Aq runs after \*(Aqbegin\*(Aq but before your actions and that
\&    # \*(Aqauto\*(Aqs "chain" (all from application path to most specific class are run)
\&    # See the \*(AqActions\*(Aq section of \*(AqCatalyst::Manual::Intro\*(Aq for more info.
\&    sub auto :Private {
\&        my ($self, $c) = @_;
\&    
\&        # Allow unauthenticated users to reach the login page.  This
\&        # allows unauthenticated users to reach any action in the Login
\&        # controller.  To lock it down to a single action, we could use:
\&        #   if ($c\->action eq $c\->controller(\*(AqLogin\*(Aq)\->action_for(\*(Aqindex\*(Aq))
\&        # to only allow unauthenticated access to the \*(Aqindex\*(Aq action we
\&        # added above.
\&        if ($c\->controller eq $c\->controller(\*(AqLogin\*(Aq)) {
\&            return 1;
\&        }
\&    
\&        # If a user doesn\*(Aqt exist, force login
\&        if (!$c\->user_exists) {
\&            # Dump a log message to the development server debug output
\&            $c\->log\->debug(\*(Aq***Root::auto User not found, forwarding to /login\*(Aq);
\&            # Redirect the user to the login page
\&            $c\->response\->redirect($c\->uri_for(\*(Aq/login\*(Aq));
\&            # Return 0 to cancel \*(Aqpost\-auto\*(Aq processing and prevent use of application
\&            return 0;
\&        }
\&    
\&        # User found, so return 1 to continue with processing after this \*(Aqauto\*(Aq
\&        return 1;
\&    }
.Ve
.PP
As discussed in
\&\*(L"\s-1CREATE\s0 A \s-1CATALYST\s0 \s-1CONTROLLER\s0\*(R" in Catalyst::Manual::Tutorial::03_MoreCatalystBasics,
every \f(CW\*(C`auto\*(C'\fR method from the application/root controller down to the
most specific controller will be called.  By placing the authentication
enforcement code inside the \f(CW\*(C`auto\*(C'\fR method of
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR (or \f(CW\*(C`lib/MyApp.pm\*(C'\fR), it will be called
for \fIevery\fR request that is received by the entire application.
.SS "Displaying Content Only to Authenticated Users"
.IX Subsection "Displaying Content Only to Authenticated Users"
Let's say you want to provide some information on the login page that
changes depending on whether the user has authenticated yet.  To do
this, open \f(CW\*(C`root/src/login.tt2\*(C'\fR in your editor and add the following
lines to the bottom of the file:
.PP
.Vb 10
\&    ...
\&    <p>
\&    [%
\&       # This code illustrates how certain parts of the TT
\&       # template will only be shown to users who have logged in
\&    %]
\&    [% IF c.user_exists %]
\&        Please Note: You are already logged in as \*(Aq[% c.user.username %]\*(Aq.
\&        You can <a href="[% c.uri_for(\*(Aq/logout\*(Aq) %]">logout</a> here.
\&    [% ELSE %]
\&        You need to log in to use this application.
\&    [% END %]
\&    [%#
\&       Note that this whole block is a comment because the "#" appears
\&       immediate after the "[%" (with no spaces in between).  Although it
\&       can be a handy way to temporarily "comment out" a whole block of
\&       TT code, it\*(Aqs probably a little too subtle for use in "normal"
\&       comments.
\&    %]
\&    </p>
.Ve
.PP
Although most of the code is comments, the middle few lines provide a
\&\*(L"you are already logged in\*(R" reminder if the user returns to the login
page after they have already authenticated.  For users who have not yet
authenticated, a \*(L"You need to log in...\*(R" message is displayed (note the
use of an IF-THEN-ELSE construct in \s-1TT\s0).
.SS "Try Out Authentication"
.IX Subsection "Try Out Authentication"
The development server should have reloaded each time we edited one of
the Controllers in the previous section. Now try going to
<http://localhost:3000/books/list> and you should be redirected to the
login page, hitting Shift+Reload or Ctrl+Reload if necessary (the \*(L"You
are already logged in\*(R" message should \fInot\fR appear \*(-- if it does, click
the \f(CW\*(C`logout\*(C'\fR button and try again). Note the \f(CW\*(C`***Root::auto User not
found...\*(C'\fR debug message in the development server output. Enter username
\&\f(CW\*(C`test01\*(C'\fR and password \f(CW\*(C`mypass\*(C'\fR, and you should be taken to the Book
List page.
.PP
\&\fB\s-1IMPORTANT\s0 \s-1NOTE:\s0\fR If you are having issues with authentication on
Internet Explorer (or potentially other browsers), be sure to check the
system clocks on both your server and client machines.  Internet
Explorer is very picky about timestamps for cookies.  You can use the
\&\f(CW\*(C`ntpq \-p\*(C'\fR command on the Tutorial Virtual Machine to check time sync
and/or use the following command to force a sync:
.PP
.Vb 1
\&    sudo ntpdate\-debian
.Ve
.PP
Or, depending on your firewall configuration, try it with \*(L"\-u\*(R":
.PP
.Vb 1
\&    sudo ntpdate\-debian \-u
.Ve
.PP
Note: \s-1NTP\s0 can be a little more finicky about firewalls because it uses
\&\s-1UDP\s0 vs. the more common \s-1TCP\s0 that you see with most Internet protocols.
Worse case, you might have to manually set the time on your development
box instead of using \s-1NTP\s0.
.PP
Open \f(CW\*(C`root/src/books/list.tt2\*(C'\fR and add the following lines to the
bottom (below the closing </table> tag):
.PP
.Vb 5
\&    ...
\&    <p>
\&      <a href="[% c.uri_for(\*(Aq/login\*(Aq) %]">Login</a>
\&      <a href="[% c.uri_for(c.controller.action_for(\*(Aqform_create\*(Aq)) %]">Create</a>
\&    </p>
.Ve
.PP
Reload your browser and you should now see a \*(L"Login\*(R" and \*(L"Create\*(R" links
at the bottom of the page (as mentioned earlier, you can update template
files without a development server reload).  Click the first link to
return to the login page.  This time you \fIshould\fR see the \*(L"You are
already logged in\*(R" message.
.PP
Finally, click the \f(CW\*(C`You can logout here\*(C'\fR link on the \f(CW\*(C`/login\*(C'\fR page.
You should stay at the login page, but the message should change to \*(L"You
need to log in to use this application.\*(R"
.SH "USING PASSWORD HASHES"
.IX Header "USING PASSWORD HASHES"
In this section we increase the security of our system by converting
from cleartext passwords to \s-1SHA\-1\s0 password hashes that include a random
\&\*(L"salt\*(R" value to make them extremely difficult to crack, even with
dictionary and \*(L"rainbow table\*(R" attacks.
.PP
\&\fBNote:\fR This section is optional.  You can skip it and the rest of the
tutorial will function normally.
.PP
Be aware that even with the techniques shown in this section, the
browser still transmits the passwords in cleartext to your application.
We are just avoiding the \fIstorage\fR of cleartext passwords in the
database by using a salted \s-1SHA\-1\s0 hash. If you are concerned about
cleartext passwords between the browser and your application, consider
using \s-1SSL/TLS\s0, made easy with modules such as
Catalyst::Plugin:RequireSSL and Catalyst::ActionRole::RequireSSL.
.SS "Re-Run the DBIC::Schema Model Helper to Include DBIx::Class::PassphraseColumn"
.IX Subsection "Re-Run the DBIC::Schema Model Helper to Include DBIx::Class::PassphraseColumn"
Let's re-run the model helper to have it include
DBIx::Class::PassphraseColumn in all of the Result Classes it
generates for us.  Simply use the same command we saw in Chapters 3 and
4, but add \f(CW\*(C`,PassphraseColumn\*(C'\fR to the \f(CW\*(C`components\*(C'\fR argument:
.PP
.Vb 3
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static components=TimeStamp,PassphraseColumn dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
.Ve
.PP
If you then open one of the Result Classes, you will see that it
includes PassphraseColumn in the \f(CW\*(C`load_components\*(C'\fR line.  Take a look
at \f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR since that's the main class where
we want to use hashed and salted passwords:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->load_components("InflateColumn::DateTime", "TimeStamp", "PassphraseColumn");
.Ve
.ie n .SS "Modify the ""password"" Column to Use PassphraseColumn"
.el .SS "Modify the ``password'' Column to Use PassphraseColumn"
.IX Subsection "Modify the password Column to Use PassphraseColumn"
Open the file \f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR and enter the following
text below the \*(L"# \s-1DO\s0 \s-1NOT\s0 \s-1MODIFY\s0 \s-1THIS\s0 \s-1OR\s0 \s-1ANYTHING\s0 \s-1ABOVE\s0!\*(R" line but above
the closing \*(L"1;\*(R":
.PP
.Vb 10
\&    # Have the \*(Aqpassword\*(Aq column use a SHA\-1 hash and 20\-byte salt
\&    # with RFC 2307 encoding; Generate the \*(Aqcheck_password" method
\&    _\|_PACKAGE_\|_\->add_columns(
\&        \*(Aqpassword\*(Aq => {
\&            passphrase       => \*(Aqrfc2307\*(Aq,
\&            passphrase_class => \*(AqSaltedDigest\*(Aq,
\&            passphrase_args  => {
\&                algorithm   => \*(AqSHA\-1\*(Aq,
\&                salt_random => 20.
\&            },
\&            passphrase_check_method => \*(Aqcheck_password\*(Aq,
\&        },
\&    );
.Ve
.PP
This redefines the automatically generated definition for the password
fields at the top of the Result Class file to now use PassphraseColumn
logic, storing passwords in \s-1RFC\s0 2307 format (\f(CW\*(C`passphrase\*(C'\fR is set to
\&\f(CW\*(C`rfc2307\*(C'\fR).  \f(CW\*(C`passphrase_class\*(C'\fR can be set to the name of any
\&\f(CW\*(C`Authen::Passphrase::*\*(C'\fR class, such as \f(CW\*(C`SaltedDigest\*(C'\fR to use
Authen::Passphrase::SaltedDigest, or \f(CW\*(C`BlowfishCrypt\*(C'\fR to use
Authen::Passphrase::BlowfishCrypt.  \f(CW\*(C`passphrase_args\*(C'\fR is then used
to customize the passphrase class you selected. Here we specified the
digest algorithm to use as \f(CW\*(C`SHA\-1\*(C'\fR and the size of the salt to use, but
we could have also specified any other option the selected passphrase
class supports.
.SS "Load Hashed Passwords in the Database"
.IX Subsection "Load Hashed Passwords in the Database"
Next, let's create a quick script to load some hashed and salted
passwords into the \f(CW\*(C`password\*(C'\fR column of our \f(CW\*(C`users\*(C'\fR table.  Open the
file \f(CW\*(C`set_hashed_passwords.pl\*(C'\fR in your editor and enter the following
text:
.PP
.Vb 1
\&    #!/usr/bin/perl
\&    
\&    use strict;
\&    use warnings;
\&    
\&    use MyApp::Schema;
\&    
\&    my $schema = MyApp::Schema\->connect(\*(Aqdbi:SQLite:myapp.db\*(Aq);
\&    
\&    my @users = $schema\->resultset(\*(AqUser\*(Aq)\->all;
\&    
\&    foreach my $user (@users) {
\&        $user\->password(\*(Aqmypass\*(Aq);
\&        $user\->update;
\&    }
.Ve
.PP
PassphraseColumn lets us simply call \f(CW\*(C`$user\-\*(C'\fRcheck_password($password)>
to see if the user has supplied the correct password, or, as we show
above, call \f(CW\*(C`$user\-\*(C'\fRupdate($new_password)> to update the hashed
password stored for this user.
.PP
Then run the following command:
.PP
.Vb 1
\&    $ DBIC_TRACE=1 perl \-Ilib set_hashed_passwords.pl
.Ve
.PP
We had to use the \f(CW\*(C`\-Ilib\*(C'\fR argument to tell Perl to look under the
\&\f(CW\*(C`lib\*(C'\fR directory for our \f(CW\*(C`MyApp::Schema\*(C'\fR model.
.PP
The \s-1DBIC_TRACE\s0 output should show that the update worked:
.PP
.Vb 9
\&    $ DBIC_TRACE=1 perl \-Ilib set_hashed_passwords.pl
\&    SELECT me.id, me.username, me.password, me.email_address,
\&    me.first_name, me.last_name, me.active FROM users me:
\&    UPDATE users SET password = ? WHERE ( id = ? ):
\&    \*(Aq{SSHA}esgz64CpHMo8pMfgIIszP13ft23z/zio04aCwNdm0wc6MDeloMUH4g==\*(Aq, \*(Aq1\*(Aq
\&    UPDATE users SET password = ? WHERE ( id = ? ):
\&    \*(Aq{SSHA}FpGhpCJus+Ea9ne4ww8404HH+hJKW/fW+bAv1v6FuRUy2G7I2aoTRQ==\*(Aq, \*(Aq2\*(Aq
\&    UPDATE users SET password = ? WHERE ( id = ? ):
\&    \*(Aq{SSHA}ZyGlpiHls8qFBSbHr3r5t/iqcZE602XLMbkSVRRNl6rF8imv1abQVg==\*(Aq, \*(Aq3\*(Aq
.Ve
.PP
But we can further confirm our actions by dumping the users table:
.PP
.Vb 4
\&    $ sqlite3 myapp.db "select * from users"
\&    1|test01|{SSHA}esgz64CpHMo8pMfgIIszP13ft23z/zio04aCwNdm0wc6MDeloMUH4g==|t01@na.com|Joe|Blow|1
\&    2|test02|{SSHA}FpGhpCJus+Ea9ne4ww8404HH+hJKW/fW+bAv1v6FuRUy2G7I2aoTRQ==|t02@na.com|Jane|Doe|1
\&    3|test03|{SSHA}ZyGlpiHls8qFBSbHr3r5t/iqcZE602XLMbkSVRRNl6rF8imv1abQVg==|t03@na.com|No|Go|0
.Ve
.PP
As you can see, the passwords are much harder to steal from the database
(not only are the hashes stored, but every hash is different even though
the passwords are the same because of the added \*(L"salt\*(R" value).  Also
note that this demonstrates how to use a DBIx::Class model outside of
your web application \*(-- a very useful feature in many situations.
.SS "Enable Hashed and Salted Passwords"
.IX Subsection "Enable Hashed and Salted Passwords"
Edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and update the \fIconfig()\fR section for
\&\f(CW\*(C`Plugin::Authentication\*(C'\fR it to match the following text (the only
change is to the \f(CW\*(C`password_type\*(C'\fR field):
.PP
.Vb 10
\&    # Configure SimpleDB Authentication
\&    _\|_PACKAGE_\|_\->config(
\&        \*(AqPlugin::Authentication\*(Aq => {
\&            default => {
\&                class           => \*(AqSimpleDB\*(Aq,
\&                user_model      => \*(AqDB::User\*(Aq,
\&                password_type   => \*(Aqself_check\*(Aq,
\&            },
\&        },
\&    );
.Ve
.PP
The use of \f(CW\*(C`self_check\*(C'\fR will cause
Catalyst::Plugin::Authentication::Store::DBIC to call the
\&\f(CW\*(C`check_password\*(C'\fR method we enabled on our \f(CW\*(C`password\*(C'\fR columns.
.SS "Try Out the Hashed Passwords"
.IX Subsection "Try Out the Hashed Passwords"
The development server should restart as soon as your save the
\&\f(CW\*(C`lib/MyApp.pm\*(C'\fR file in the previous section. You should now be able to
go to <http://localhost:3000/books/list> and login as before. When
done, click the \*(L"logout\*(R" link on the login page (or point your browser
at <http://localhost:3000/logout>).
.SH "USING THE SESSION FOR FLASH"
.IX Header "USING THE SESSION FOR FLASH"
As discussed in the previous chapter of the tutorial, \f(CW\*(C`flash\*(C'\fR allows
you to set variables in a way that is very similar to \f(CW\*(C`stash\*(C'\fR, but it
will remain set across multiple requests.  Once the value is read, it is
cleared (unless reset).  Although \f(CW\*(C`flash\*(C'\fR has nothing to do with
authentication, it does leverage the same session plugins.  Now that
those plugins are enabled, let's go back and update the \*(L"delete and
redirect with query parameters\*(R" code seen at the end of the
Basic \s-1CRUD\s0 chapter of the
tutorial to take advantage of \f(CW\*(C`flash\*(C'\fR.
.PP
First, open \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and modify \f(CW\*(C`sub delete\*(C'\fR to
match the following (everything after the model search line of code has
changed):
.PP
.Vb 1
\&    =head2 delete
\&    
\&    Delete a book
\&    
\&    =cut
\&    
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_authors\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Use \*(Aqflash\*(Aq to save information across requests until it\*(Aqs read
\&        $c\->flash\->{status_msg} = "Book deleted";
\&    
\&        # Redirect the user back to the list page
\&        $c\->response\->redirect($c\->uri_for($self\->action_for(\*(Aqlist\*(Aq)));
\&    }
.Ve
.PP
Next, open \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR and update the \s-1TT\s0 code to pull from
flash vs. the \f(CW\*(C`status_msg\*(C'\fR query parameter:
.PP
.Vb 9
\&    ...
\&    <div id="content">
\&        [%# Status and error messages %]
\&        <span class="message">[% status_msg || c.flash.status_msg %]</span>
\&        <span class="error">[% error_msg %]</span>
\&        [%# This is where TT will stick all of your template\*(Aqs contents. \-%]
\&        [% content %]
\&    </div><!\-\- end content \-\->
\&    ...
.Ve
.PP
Although the sample above only shows the \f(CW\*(C`content\*(C'\fR div, leave the rest
of the file intact \*(-- the only change we made to replace \*(L"||
c.request.params.status_msg\*(R" with \*(L"c.flash.status_msg\*(R" in the
\&\f(CW\*(C`<span class="message">\*(C'\fR line.
.SS "Try Out Flash"
.IX Subsection "Try Out Flash"
Authenticate using the login screen and then point your browser to
<http://localhost:3000/books/url_create/Test/1/4> to create an extra
several books.  Click the \*(L"Return to list\*(R" link and delete one of the
\&\*(L"Test\*(R" books you just added.  The \f(CW\*(C`flash\*(C'\fR mechanism should retain our
\&\*(L"Book deleted\*(R" status message across the redirect.
.PP
\&\fB\s-1NOTE:\s0\fR While \f(CW\*(C`flash\*(C'\fR will save information across multiple requests,
\&\fIit does get cleared the first time it is read\fR.  In general, this is
exactly what you want \*(-- the \f(CW\*(C`flash\*(C'\fR message will get displayed on the
next screen where it's appropriate, but it won't \*(L"keep showing up\*(R" after
that first time (unless you reset it).  Please refer to
Catalyst::Plugin::Session for additional information.
.PP
\&\fBNote:\fR There is also a \f(CW\*(C`flash\-to\-stash\*(C'\fR feature that will
automatically load the contents the contents of flash into stash,
allowing us to use the more typical \f(CW\*(C`c.flash.status_msg\*(C'\fR in our \s-1TT\s0
template in lieu of the more verbose \f(CW\*(C`status_msg || c.flash.status_msg\*(C'\fR
we used above.  Consult Catalyst::Plugin::Session for additional
information.
.SS "Switch To Catalyst::Plugin::StatusMessages"
.IX Subsection "Switch To Catalyst::Plugin::StatusMessages"
Although the query parameter technique we used in
Chapter 4 and the \f(CW\*(C`flash\*(C'\fR
approach we used above will work in most cases, they both have their
drawbacks.  The query parameters can leave the status message on the
screen longer than it should (for example, if the user hits refresh).
And \f(CW\*(C`flash\*(C'\fR can display the wrong message on the wrong screen (flash
just shows the message on the next page for that user... if the user
has multiple windows or tabs open, then the wrong one can get the
status message).
.PP
Catalyst::Plugin::StatusMessage is designed to address these
shortcomings.  It stores the messages in the user's session (so they are
available across multiple requests), but ties each status message to a
random token.  By passing this token across the redirect, we are no
longer relying on a potentially ambiguous \*(L"next request\*(R" like we do with
flash.  And, because the message is deleted the first time it's
displayed, the user can hit refresh and still only see the message a
single time (even though the \s-1URL\s0 may continue to reference the token,
it's only displayed the first time).  The use of \f(CW\*(C`StatusMessage\*(C'\fR
or a similar mechanism is recommended for all Catalyst applications.
.PP
To enable \f(CW\*(C`StatusMessage\*(C'\fR, first edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and add
\&\f(CW\*(C`StatusMessage\*(C'\fR to the list of plugins:
.PP
.Vb 4
\&    use Catalyst qw/
\&        \-Debug
\&        ConfigLoader
\&        Static::Simple
\&    
\&        StackTrace
\&    
\&        Authentication
\&    
\&        Session
\&        Session::Store::File
\&        Session::State::Cookie
\&    
\&        StatusMessage
\&    /;
.Ve
.PP
Then edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and modify the \f(CW\*(C`delete\*(C'\fR
action to match the following:
.PP
.Vb 2
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Saved the PK id for status_msg below
\&        my $id = $c\->stash\->{object}\->id;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_authors\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Redirect the user back to the list page
\&        $c\->response\->redirect($c\->uri_for($self\->action_for(\*(Aqlist\*(Aq),
\&            {mid => $c\->set_status_msg("Deleted book $id")}));
\&    }
.Ve
.PP
This uses the \f(CW\*(C`set_status_msg\*(C'\fR that the plugin added to \f(CW$c\fR to save
the message under a random token.  (If we wanted to save an error
message, we could have used \f(CW\*(C`set_error_msg\*(C'\fR.)  Because
\&\f(CW\*(C`set_status_msg\*(C'\fR and \f(CW\*(C`set_error_msg\*(C'\fR both return the random token, we
can assign that value to the "\f(CW\*(C`mid\*(C'\fR" query parameter via \f(CW\*(C`uri_for\*(C'\fR as
shown above.
.PP
Next, we need to make sure that the list page will load display the
message.  The easiest way to do this is to take advantage of the chained
dispatch we implemented in
Chapter 4.  Edit
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR again and update the \f(CW\*(C`base\*(C'\fR action to
match:
.PP
.Vb 2
\&    sub base :Chained(\*(Aq/\*(Aq) :PathPart(\*(Aqbooks\*(Aq) :CaptureArgs(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Store the ResultSet in stash so it\*(Aqs available for other methods
\&        $c\->stash(resultset => $c\->model(\*(AqDB::Book\*(Aq));
\&    
\&        # Print a message to the debug log
\&        $c\->log\->debug(\*(Aq*** INSIDE BASE METHOD ***\*(Aq);
\&    
\&        # Load status messages
\&        $c\->load_status_msgs;
\&    }
.Ve
.PP
That way, anything that chains off \f(CW\*(C`base\*(C'\fR will automatically get any
status or error messages loaded into the stash.  Let's convert the
\&\f(CW\*(C`list\*(C'\fR action to take advantage of this.  Modify the method signature
for \f(CW\*(C`list\*(C'\fR from:
.PP
.Vb 1
\&    sub list :Local {
.Ve
.PP
to:
.PP
.Vb 1
\&    sub list :Chained(\*(Aqbase\*(Aq) :PathParth(\*(Aqlist\*(Aq) :Args(0) {
.Ve
.PP
Finally, let's clean up the status/error message code in our wrapper
template.  Edit \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR and change the \*(L"content\*(R" div
to match the following:
.PP
.Vb 7
\&    <div id="content">
\&        [%# Status and error messages %]
\&        <span class="message">[% status_msg %]</span>
\&        <span class="error">[% error_msg %]</span>
\&        [%# This is where TT will stick all of your template\*(Aqs contents. \-%]
\&        [% content %]
\&    </div><!\-\- end content \-\->
.Ve
.PP
Now go to <http://localhost:3000/books/list> in your browser. Delete
another of the \*(L"Test\*(R" books you added in the previous step.  You should
get redirection from the \f(CW\*(C`delete\*(C'\fR action back to the \f(CW\*(C`list\*(C'\fR action,
but with a \*(L"mid=########\*(R" message \s-1ID\s0 query parameter.  The screen should
say \*(L"Deleted book #\*(R" (where # is the \s-1PK\s0 id of the book you removed).
However, if you hit refresh in your browser, the status message is no
longer displayed  (even though the \s-1URL\s0 does still contain the message \s-1ID\s0
token, it is ignored \*(-- thereby keeping the state of our status/error
messages in sync with the users actions).
.PP
You can jump to the next chapter of the tutorial here:
Authorization
.SH "AUTHOR"
.IX Header "AUTHOR"
Kennedy Clark, \f(CW\*(C`hkclark@gmail.com\*(C'\fR
.PP
Feel free to contact the author for any errors or suggestions, but the
best way to report issues is via the \s-1CPAN\s0 \s-1RT\s0 Bug system at
https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst\-Manual <https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst-Manual>.
.PP
Copyright 2006\-2011, Kennedy Clark, under the
Creative Commons Attribution Share-Alike License Version 3.0
(http://creativecommons.org/licenses/by\-sa/3.0/us/ <http://creativecommons.org/licenses/by-sa/3.0/us/>).
