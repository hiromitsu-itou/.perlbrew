.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager 3"
.TH Imager 3 "2012-01-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager \- Perl extension for Generating 24 bit Images
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Thumbnail example
\&
\&  #!/usr/bin/perl \-w
\&  use strict;
\&  use Imager;
\&
\&  die "Usage: thumbmake.pl filename\en" if !\-f $ARGV[0];
\&  my $file = shift;
\&
\&  my $format;
\&
\&  # see Imager::Files for information on the read() method
\&  my $img = Imager\->new(file=>$file)
\&    or die Imager\->errstr();
\&
\&  $file =~ s/\e.[^.]*$//;
\&
\&  # Create smaller version
\&  # documented in Imager::Transformations
\&  my $thumb = $img\->scale(scalefactor=>.3);
\&
\&  # Autostretch individual channels
\&  $thumb\->filter(type=>\*(Aqautolevels\*(Aq);
\&
\&  # try to save in one of these formats
\&  SAVE:
\&
\&  for $format ( qw( png gif jpeg tiff ppm ) ) {
\&    # Check if given format is supported
\&    if ($Imager::formats{$format}) {
\&      $file.="_low.$format";
\&      print "Storing image as: $file\en";
\&      # documented in Imager::Files
\&      $thumb\->write(file=>$file) or
\&        die $thumb\->errstr;
\&      last SAVE;
\&    }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imager is a module for creating and altering images.  It can read and
write various image formats, draw primitive shapes like lines,and
polygons, blend multiple images together in various ways, scale, crop,
render text and more.
.SS "Overview of documentation"
.IX Subsection "Overview of documentation"
.IP "\(bu" 4
Imager \- This document \- Synopsis, Example, Table of Contents and
Overview.
.IP "\(bu" 4
Imager::Tutorial \- a brief introduction to Imager.
.IP "\(bu" 4
Imager::Cookbook \- how to do various things with Imager.
.IP "\(bu" 4
Imager::ImageTypes \- Basics of constructing image objects with
\&\f(CW\*(C`new()\*(C'\fR: Direct type/virtual images, \s-1RGB\s0(A)/paletted images,
8/16/double bits/channel, color maps, channel masks, image tags, color
quantization.  Also discusses basic image information methods.
.IP "\(bu" 4
Imager::Files \- \s-1IO\s0 interaction, reading/writing images, format
specific tags.
.IP "\(bu" 4
Imager::Draw \- Drawing Primitives, lines, boxes, circles, arcs,
flood fill.
.IP "\(bu" 4
Imager::Color \- Color specification.
.IP "\(bu" 4
Imager::Fill \- Fill pattern specification.
.IP "\(bu" 4
Imager::Font \- General font rendering, bounding boxes and font
metrics.
.IP "\(bu" 4
Imager::Transformations \- Copying, scaling, cropping, flipping,
blending, pasting, convert and map.
.IP "\(bu" 4
Imager::Engines \- Programmable transformations through
\&\f(CW\*(C`transform()\*(C'\fR, \f(CW\*(C`transform2()\*(C'\fR and \f(CW\*(C`matrix_transform()\*(C'\fR.
.IP "\(bu" 4
Imager::Filters \- Filters, sharpen, blur, noise, convolve etc. and
filter plug-ins.
.IP "\(bu" 4
Imager::Expr \- Expressions for evaluation engine used by
\&\fItransform2()\fR.
.IP "\(bu" 4
Imager::Matrix2d \- Helper class for affine transformations.
.IP "\(bu" 4
Imager::Fountain \- Helper for making gradient profiles.
.IP "\(bu" 4
Imager::API \- using Imager's C \s-1API\s0
.IP "\(bu" 4
Imager::APIRef \- \s-1API\s0 function reference
.IP "\(bu" 4
Imager::Inline \- using Imager's C \s-1API\s0 from Inline::C
.IP "\(bu" 4
Imager::ExtUtils \- tools to get access to Imager's C \s-1API\s0.
.SS "Basic Overview"
.IX Subsection "Basic Overview"
An Image object is created with \f(CW\*(C`$img = Imager\->new()\*(C'\fR.
Examples:
.PP
.Vb 4
\&  $img=Imager\->new();                         # create empty image
\&  $img\->read(file=>\*(Aqlena.png\*(Aq,type=>\*(Aqpng\*(Aq) or # read image from file
\&     die $img\->errstr();                      # give an explanation
\&                                              # if something failed
.Ve
.PP
or if you want to create an empty image:
.PP
.Vb 1
\&  $img=Imager\->new(xsize=>400,ysize=>300,channels=>4);
.Ve
.PP
This example creates a completely black image of width 400 and height
300 and 4 channels.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
In general a method will return false when it fails, if it does use
the \f(CW\*(C`errstr()\*(C'\fR method to find out why:
.IP "\fIerrstr()\fR" 4
.IX Item "errstr()"
Returns the last error message in that context.
.Sp
If the last error you received was from calling an object method, such
as read, call \fIerrstr()\fR as an object method to find out why:
.Sp
.Vb 3
\&  my $image = Imager\->new;
\&  $image\->read(file => \*(Aqsomefile.gif\*(Aq)
\&     or die $image\->errstr;
.Ve
.Sp
If it was a class method then call \fIerrstr()\fR as a class method:
.Sp
.Vb 2
\&  my @imgs = Imager\->read_multi(file => \*(Aqsomefile.gif\*(Aq)
\&    or die Imager\->errstr;
.Ve
.Sp
Note that in some cases object methods are implemented in terms of
class methods so a failing object method may set both.
.PP
The \f(CW\*(C`Imager\->new\*(C'\fR method is described in detail in
Imager::ImageTypes.
.SH "METHOD INDEX"
.IX Header "METHOD INDEX"
Where to find information on methods for Imager class objects.
.PP
\&\fIaddcolors()\fR \- \*(L"\fIaddcolors()\fR\*(R" in Imager::ImageTypes \- add colors to a
paletted image
.PP
\&\fIaddtag()\fR \-  \*(L"\fIaddtag()\fR\*(R" in Imager::ImageTypes \- add image tags
.PP
\&\fIalign_string()\fR \- \*(L"\fIalign_string()\fR\*(R" in Imager::Draw \- draw text aligned on a
point
.PP
\&\fIarc()\fR \- \*(L"\fIarc()\fR\*(R" in Imager::Draw \- draw a filled arc
.PP
\&\fIbits()\fR \- \*(L"\fIbits()\fR\*(R" in Imager::ImageTypes \- number of bits per sample for the
image
.PP
\&\fIbox()\fR \- \*(L"\fIbox()\fR\*(R" in Imager::Draw \- draw a filled or outline box.
.PP
\&\fIcircle()\fR \- \*(L"\fIcircle()\fR\*(R" in Imager::Draw \- draw a filled circle
.PP
\&\fIclose_log()\fR \- \*(L"\fIclose_log()\fR\*(R" in Imager::ImageTypes \- close the Imager
debugging log.
.PP
\&\fIcolorcount()\fR \- \*(L"\fIcolorcount()\fR\*(R" in Imager::ImageTypes \- the number of
colors in an image's palette (paletted images only)
.PP
\&\fIcombine()\fR \- \*(L"\fIcombine()\fR\*(R" in Imager::Transformations \- combine channels
from one or more images.
.PP
\&\fIcombines()\fR \- \*(L"\fIcombines()\fR\*(R" in Imager::Draw \- return a list of the
different combine type keywords
.PP
\&\fIcompose()\fR \- \*(L"\fIcompose()\fR\*(R" in Imager::Transformations \- compose one image
over another.
.PP
\&\fIconvert()\fR \- \*(L"\fIconvert()\fR\*(R" in Imager::Transformations \- transform the color
space
.PP
\&\fIcopy()\fR \- \*(L"\fIcopy()\fR\*(R" in Imager::Transformations \- make a duplicate of an
image
.PP
\&\fIcrop()\fR \- \*(L"\fIcrop()\fR\*(R" in Imager::Transformations \- extract part of an image
.PP
\&\fIdef_guess_type()\fR \- \*(L"\fIdef_guess_type()\fR\*(R" in Imager::Files \- default function
used to guess the output file format based on the output file name
.PP
\&\fIdeltag()\fR \-  \*(L"\fIdeltag()\fR\*(R" in Imager::ImageTypes \- delete image tags
.PP
\&\fIdifference()\fR \- \*(L"\fIdifference()\fR\*(R" in Imager::Filters \- produce a difference
images from two input images.
.PP
\&\fIerrstr()\fR \- \*(L"\fIerrstr()\fR\*(R" \- the error from the last failed operation.
.PP
\&\fIfilter()\fR \- \*(L"\fIfilter()\fR\*(R" in Imager::Filters \- image filtering
.PP
\&\fIfindcolor()\fR \- \*(L"\fIfindcolor()\fR\*(R" in Imager::ImageTypes \- search the image
palette, if it has one
.PP
\&\fIflip()\fR \- \*(L"\fIflip()\fR\*(R" in Imager::Transformations \- flip an image, vertically,
horizontally
.PP
\&\fIflood_fill()\fR \- \*(L"\fIflood_fill()\fR\*(R" in Imager::Draw \- fill an enclosed or same
color area
.PP
\&\fIgetchannels()\fR \- \*(L"\fIgetchannels()\fR\*(R" in Imager::ImageTypes \- the number of
samples per pixel for an image
.PP
\&\fIgetcolorcount()\fR \- \*(L"\fIgetcolorcount()\fR\*(R" in Imager::ImageTypes \- the number of
different colors used by an image (works for direct color images)
.PP
\&\fIgetcolors()\fR \- \*(L"\fIgetcolors()\fR\*(R" in Imager::ImageTypes \- get colors from the image
palette, if it has one
.PP
\&\fIgetcolorusage()\fR \- \*(L"\fIgetcolorusage()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIgetcolorusagehash()\fR \- \*(L"\fIgetcolorusagehash()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIget_file_limits()\fR \- \*(L"Limiting the sizes of images you read\*(R" in Imager::Files
.PP
\&\fIgetheight()\fR \- \*(L"\fIgetheight()\fR\*(R" in Imager::ImageTypes \- height of the image in
pixels
.PP
\&\fIgetmask()\fR \- \*(L"\fIgetmask()\fR\*(R" in Imager::ImageTypes \- write mask for the image
.PP
\&\fIgetpixel()\fR \- \*(L"\fIgetpixel()\fR\*(R" in Imager::Draw \- retrieve one or more pixel
colors
.PP
\&\fIgetsamples()\fR \- \*(L"\fIgetsamples()\fR\*(R" in Imager::Draw \- retrieve samples from a
row or partial row of pixels.
.PP
\&\fIgetscanline()\fR \- \*(L"\fIgetscanline()\fR\*(R" in Imager::Draw \- retrieve colors for a
row or partial row of pixels.
.PP
\&\fIgetwidth()\fR \- \*(L"\fIgetwidth()\fR\*(R" in Imager::ImageTypes \- width of the image in
pixels.
.PP
\&\fIimg_set()\fR \- \*(L"\fIimg_set()\fR\*(R" in Imager::ImageTypes \- re-use an Imager object
for a new image.
.PP
\&\fIinit()\fR \- \*(L"\fIinit()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIis_bilevel()\fR \- \*(L"\fIis_bilevel()\fR\*(R" in Imager::ImageTypes \- returns whether
image write functions should write the image in their bilevel (blank
and white, no gray levels) format
.PP
\&\fIis_logging()\fR \*(L"\fIis_logging()\fR\*(R" in Imager::ImageTypes \- test if the debug
log is active.
.PP
\&\fIline()\fR \- \*(L"\fIline()\fR\*(R" in Imager::Draw \- draw an interval
.PP
\&\fIload_plugin()\fR \- \*(L"\fIload_plugin()\fR\*(R" in Imager::Filters
.PP
\&\fIlog()\fR \- \*(L"\fIlog()\fR\*(R" in Imager::ImageTypes \- send a message to the debugging
log.
.PP
\&\fImake_palette()\fR \- \*(L"\fImake_palette()\fR\*(R" in Imager::ImageTypes \- produce a
color palette from one or more input images.
.PP
\&\fImap()\fR \- \*(L"Color Mappings\*(R" in Imager::Transformations \- remap color
channel values
.PP
\&\fImasked()\fR \-  \*(L"\fImasked()\fR\*(R" in Imager::ImageTypes \- make a masked image
.PP
\&\fImatrix_transform()\fR \- \*(L"\fImatrix_transform()\fR\*(R" in Imager::Engines
.PP
\&\fImaxcolors()\fR \- \*(L"\fImaxcolors()\fR\*(R" in Imager::ImageTypes
.PP
\&\s-1\fINC\s0()\fR \- \*(L"\s-1\fINC\s0()\fR\*(R" in Imager::Handy
.PP
\&\s-1\fINCF\s0()\fR \- \*(L"\s-1\fINCF\s0()\fR\*(R" in Imager::Handy
.PP
\&\fInew()\fR \- \*(L"\fInew()\fR\*(R" in Imager::ImageTypes
.PP
\&\fInewcolor()\fR \- \*(L"\fInewcolor()\fR\*(R" in Imager::Handy
.PP
\&\fInewcolour()\fR \- \*(L"\fInewcolour()\fR\*(R" in Imager::Handy
.PP
\&\fInewfont()\fR \- \*(L"\fInewfont()\fR\*(R" in Imager::Handy
.PP
\&\s-1\fINF\s0()\fR \- \*(L"\s-1\fINF\s0()\fR\*(R" in Imager::Handy
.PP
\&\fIopen()\fR \- Imager::Files \- an alias for \fIread()\fR
.PP
\&\fIopen_log()\fR \- \*(L"\fIopen_log()\fR\*(R" in Imager::ImageTypes \- open the debug log.
.PP
\&\fIparseiptc()\fR \- \*(L"\fIparseiptc()\fR\*(R" in Imager::Files \- parse \s-1IPTC\s0 data from a \s-1JPEG\s0
image
.PP
\&\fIpaste()\fR \- \*(L"\fIpaste()\fR\*(R" in Imager::Transformations \- draw an image onto an
image
.PP
\&\fIpolygon()\fR \- \*(L"\fIpolygon()\fR\*(R" in Imager::Draw
.PP
\&\fIpolyline()\fR \- \*(L"\fIpolyline()\fR\*(R" in Imager::Draw
.PP
\&\fIpreload()\fR \- \*(L"\fIpreload()\fR\*(R" in Imager::Files
.PP
\&\fIread()\fR \- \*(L"\fIread()\fR\*(R" in Imager::Files \- read a single image from an image file
.PP
\&\fIread_multi()\fR \- \*(L"\fIread_multi()\fR\*(R" in Imager::Files \- read multiple images from an image
file
.PP
\&\fIread_types()\fR \- \*(L"\fIread_types()\fR\*(R" in Imager::Files \- list image types Imager
can read.
.PP
\&\fIregister_filter()\fR \- \*(L"\fIregister_filter()\fR\*(R" in Imager::Filters
.PP
\&\fIregister_reader()\fR \- \*(L"\fIregister_reader()\fR\*(R" in Imager::Files
.PP
\&\fIregister_writer()\fR \- \*(L"\fIregister_writer()\fR\*(R" in Imager::Files
.PP
\&\fIrotate()\fR \- \*(L"\fIrotate()\fR\*(R" in Imager::Transformations
.PP
\&\fIrubthrough()\fR \- \*(L"\fIrubthrough()\fR\*(R" in Imager::Transformations \- draw an image
onto an image and use the alpha channel
.PP
\&\fIscale()\fR \- \*(L"\fIscale()\fR\*(R" in Imager::Transformations
.PP
\&\fIscale_calculate()\fR \- \*(L"\fIscale_calculate()\fR\*(R" in Imager::Transformations
.PP
\&\fIscaleX()\fR \- \*(L"\fIscaleX()\fR\*(R" in Imager::Transformations
.PP
\&\fIscaleY()\fR \- \*(L"\fIscaleY()\fR\*(R" in Imager::Transformations
.PP
\&\fIsetcolors()\fR \- \*(L"\fIsetcolors()\fR\*(R" in Imager::ImageTypes \- set palette colors
in a paletted image
.PP
\&\fIset_file_limits()\fR \- \*(L"Limiting the sizes of images you read\*(R" in Imager::Files
.PP
\&\fIsetmask()\fR \- \*(L"\fIsetmask()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIsetpixel()\fR \- \*(L"\fIsetpixel()\fR\*(R" in Imager::Draw
.PP
\&\fIsetsamples()\fR \- \*(L"\fIsetsamples()\fR\*(R" in Imager::Draw
.PP
\&\fIsetscanline()\fR \- \*(L"\fIsetscanline()\fR\*(R" in Imager::Draw
.PP
\&\fIsettag()\fR \- \*(L"\fIsettag()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIstring()\fR \- \*(L"\fIstring()\fR\*(R" in Imager::Draw \- draw text on an image
.PP
\&\fItags()\fR \-  \*(L"\fItags()\fR\*(R" in Imager::ImageTypes \- fetch image tags
.PP
\&\fIto_paletted()\fR \-  \*(L"\fIto_paletted()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIto_rgb16()\fR \- \*(L"\fIto_rgb16()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIto_rgb8()\fR \- \*(L"\fIto_rgb8()\fR\*(R" in Imager::ImageTypes
.PP
\&\fIto_rgb_double()\fR \- \*(L"\fIto_rgb_double()\fR\*(R" in Imager::ImageTypes \- convert to
double per sample image.
.PP
\&\fItransform()\fR \- \*(L"\fItransform()\fR\*(R" in Imager::Engines
.PP
\&\fItransform2()\fR \- \*(L"\fItransform2()\fR\*(R" in Imager::Engines
.PP
\&\fItype()\fR \-  \*(L"\fItype()\fR\*(R" in Imager::ImageTypes \- type of image (direct vs paletted)
.PP
\&\fIunload_plugin()\fR \- \*(L"\fIunload_plugin()\fR\*(R" in Imager::Filters
.PP
\&\fIvirtual()\fR \- \*(L"\fIvirtual()\fR\*(R" in Imager::ImageTypes \- whether the image has it's own
data
.PP
\&\fIwrite()\fR \- \*(L"\fIwrite()\fR\*(R" in Imager::Files \- write an image to a file
.PP
\&\fIwrite_multi()\fR \- \*(L"\fIwrite_multi()\fR\*(R" in Imager::Files \- write multiple image to an image
file.
.PP
\&\fIwrite_types()\fR \- \*(L"\fIread_types()\fR\*(R" in Imager::Files \- list image types Imager
can write.
.SH "CONCEPT INDEX"
.IX Header "CONCEPT INDEX"
animated \s-1GIF\s0 \- \*(L"Writing an animated \s-1GIF\s0\*(R" in Imager::Files
.PP
aspect ratio \- \f(CW\*(C`i_xres\*(C'\fR, \f(CW\*(C`i_yres\*(C'\fR, \f(CW\*(C`i_aspect_only\*(C'\fR in
\&\*(L"Common Tags\*(R" in Imager::ImageTypes.
.PP
blend \- alpha blending one image onto another
\&\*(L"\fIrubthrough()\fR\*(R" in Imager::Transformations
.PP
blur \- \*(L"gaussian\*(R" in Imager::Filters, \*(L"conv\*(R" in Imager::Filters
.PP
boxes, drawing \- \*(L"\fIbox()\fR\*(R" in Imager::Draw
.PP
changes between image \- \*(L"Image Difference\*(R" in Imager::Filters
.PP
channels, combine into one image \- \*(L"\fIcombine()\fR\*(R" in Imager::Transformations
.PP
color \- Imager::Color
.PP
color names \- Imager::Color, Imager::Color::Table
.PP
combine modes \- \*(L"Combine Types\*(R" in Imager::Draw
.PP
compare images \- \*(L"Image Difference\*(R" in Imager::Filters
.PP
contrast \- \*(L"contrast\*(R" in Imager::Filters, \*(L"autolevels\*(R" in Imager::Filters
.PP
convolution \- \*(L"conv\*(R" in Imager::Filters
.PP
cropping \- \*(L"\fIcrop()\fR\*(R" in Imager::Transformations
.PP
\&\s-1CUR\s0 files \- \*(L"\s-1ICO\s0 (Microsoft Windows Icon) and \s-1CUR\s0 (Microsoft Windows Cursor)\*(R" in Imager::Files
.PP
\&\f(CW\*(C`diff\*(C'\fR images \- \*(L"Image Difference\*(R" in Imager::Filters
.PP
dpi \- \f(CW\*(C`i_xres\*(C'\fR, \f(CW\*(C`i_yres\*(C'\fR in \*(L"Common Tags\*(R" in Imager::ImageTypes,
\&\*(L"Image spatial resolution\*(R" in Imager::Cookbook
.PP
drawing boxes \- \*(L"\fIbox()\fR\*(R" in Imager::Draw
.PP
drawing lines \- \*(L"\fIline()\fR\*(R" in Imager::Draw
.PP
drawing text \- \*(L"\fIstring()\fR\*(R" in Imager::Draw, \*(L"\fIalign_string()\fR\*(R" in Imager::Draw
.PP
error message \- \*(L"\s-1ERROR\s0 \s-1HANDLING\s0\*(R"
.PP
files, font \- Imager::Font
.PP
files, image \- Imager::Files
.PP
filling, types of fill \- Imager::Fill
.PP
filling, boxes \- \*(L"\fIbox()\fR\*(R" in Imager::Draw
.PP
filling, flood fill \- \*(L"\fIflood_fill()\fR\*(R" in Imager::Draw
.PP
flood fill \- \*(L"\fIflood_fill()\fR\*(R" in Imager::Draw
.PP
fonts \- Imager::Font
.PP
fonts, drawing with \- \*(L"\fIstring()\fR\*(R" in Imager::Draw,
\&\*(L"\fIalign_string()\fR\*(R" in Imager::Draw, Imager::Font::Wrap
.PP
fonts, metrics \- \*(L"\fIbounding_box()\fR\*(R" in Imager::Font, Imager::Font::BBox
.PP
fonts, multiple master \- \*(L"\s-1MULTIPLE\s0 \s-1MASTER\s0 \s-1FONTS\s0\*(R" in Imager::Font
.PP
fountain fill \- \*(L"Fountain fills\*(R" in Imager::Fill,
\&\*(L"fountain\*(R" in Imager::Filters, Imager::Fountain,
\&\*(L"gradgen\*(R" in Imager::Filters
.PP
\&\s-1GIF\s0 files \- \*(L"\s-1GIF\s0\*(R" in Imager::Files
.PP
\&\s-1GIF\s0 files, animated \- \*(L"Writing an animated \s-1GIF\s0\*(R" in Imager::Files
.PP
gradient fill \- \*(L"Fountain fills\*(R" in Imager::Fill,
\&\*(L"fountain\*(R" in Imager::Filters, Imager::Fountain,
\&\*(L"gradgen\*(R" in Imager::Filters
.PP
gray scale, convert image to \- \*(L"\fIconvert()\fR\*(R" in Imager::Transformations
.PP
gaussian blur \- \*(L"gaussian\*(R" in Imager::Filters
.PP
hatch fills \- \*(L"Hatched fills\*(R" in Imager::Fill
.PP
\&\s-1ICO\s0 files \- \*(L"\s-1ICO\s0 (Microsoft Windows Icon) and \s-1CUR\s0 (Microsoft Windows Cursor)\*(R" in Imager::Files
.PP
invert image \- \*(L"hardinvert\*(R" in Imager::Filters,
\&\*(L"hardinvertall\*(R" in Imager::Filters
.PP
\&\s-1JPEG\s0 \- \*(L"\s-1JPEG\s0\*(R" in Imager::Files
.PP
limiting image sizes \- \*(L"Limiting the sizes of images you read\*(R" in Imager::Files
.PP
lines, drawing \- \*(L"\fIline()\fR\*(R" in Imager::Draw
.PP
matrix \- Imager::Matrix2d, 
\&\*(L"Matrix Transformations\*(R" in Imager::Engines,
\&\*(L"\fItransform()\fR\*(R" in Imager::Font
.PP
metadata, image \- \*(L"Tags\*(R" in Imager::ImageTypes
.PP
mosaic \- \*(L"mosaic\*(R" in Imager::Filters
.PP
noise, filter \- \*(L"noise\*(R" in Imager::Filters
.PP
noise, rendered \- \*(L"turbnoise\*(R" in Imager::Filters,
\&\*(L"radnoise\*(R" in Imager::Filters
.PP
paste \- \*(L"\fIpaste()\fR\*(R" in Imager::Transformations,
\&\*(L"\fIrubthrough()\fR\*(R" in Imager::Transformations
.PP
pseudo-color image \- \*(L"\fIto_paletted()\fR\*(R" in Imager::ImageTypes,
\&\*(L"\fInew()\fR\*(R" in Imager::ImageTypes
.PP
posterize \- \*(L"postlevels\*(R" in Imager::Filters
.PP
\&\s-1PNG\s0 files \- Imager::Files, \*(L"\s-1PNG\s0\*(R" in Imager::Files
.PP
\&\s-1PNM\s0 \- \*(L"\s-1PNM\s0 (Portable aNy Map)\*(R" in Imager::Files
.PP
rectangles, drawing \- \*(L"\fIbox()\fR\*(R" in Imager::Draw
.PP
resizing an image \- \*(L"\fIscale()\fR\*(R" in Imager::Transformations, 
\&\*(L"\fIcrop()\fR\*(R" in Imager::Transformations
.PP
\&\s-1RGB\s0 (\s-1SGI\s0) files \- \*(L"\s-1SGI\s0 (\s-1RGB\s0, \s-1BW\s0)\*(R" in Imager::Files
.PP
saving an image \- Imager::Files
.PP
scaling \- \*(L"\fIscale()\fR\*(R" in Imager::Transformations
.PP
\&\s-1SGI\s0 files \- \*(L"\s-1SGI\s0 (\s-1RGB\s0, \s-1BW\s0)\*(R" in Imager::Files
.PP
sharpen \- \*(L"unsharpmask\*(R" in Imager::Filters, \*(L"conv\*(R" in Imager::Filters
.PP
size, image \- \*(L"\fIgetwidth()\fR\*(R" in Imager::ImageTypes,
\&\*(L"\fIgetheight()\fR\*(R" in Imager::ImageTypes
.PP
size, text \- \*(L"\fIbounding_box()\fR\*(R" in Imager::Font
.PP
tags, image metadata \- \*(L"Tags\*(R" in Imager::ImageTypes
.PP
text, drawing \- \*(L"\fIstring()\fR\*(R" in Imager::Draw, \*(L"\fIalign_string()\fR\*(R" in Imager::Draw,
Imager::Font::Wrap
.PP
text, wrapping text in an area \- Imager::Font::Wrap
.PP
text, measuring \- \*(L"\fIbounding_box()\fR\*(R" in Imager::Font, Imager::Font::BBox
.PP
tiles, color \- \*(L"mosaic\*(R" in Imager::Filters
.PP
transparent images \- Imager::ImageTypes,
\&\*(L"Transparent \s-1PNG\s0\*(R" in Imager::Cookbook
.PP
unsharp mask \- \*(L"unsharpmask\*(R" in Imager::Filters
.PP
watermark \- \*(L"watermark\*(R" in Imager::Filters
.PP
writing an image to a file \- Imager::Files
.SH "THREADS"
.IX Header "THREADS"
Imager doesn't support perl threads.
.PP
Imager has limited code to prevent double frees if you create images,
colors etc, and then create a thread, but has no code to prevent two
threads entering Imager's error handling code, and none is likely to
be added.
.SH "SUPPORT"
.IX Header "SUPPORT"
The best place to get help with Imager is the mailing list.
.PP
To subscribe send a message with \f(CW\*(C`subscribe\*(C'\fR in the body to:
.PP
.Vb 1
\&   imager\-devel+request@molar.is
.Ve
.PP
or use the form at:
.Sp
.RS 4
http://www.molar.is/en/lists/imager\-devel/ <http://www.molar.is/en/lists/imager-devel/>
.RE
.PP
where you can also find the mailing list archive.
.PP
You can report bugs by pointing your browser at:
.Sp
.RS 4
<https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Imager>
.RE
.PP
or by sending an email to:
.Sp
.RS 4
bug\-Imager@rt.cpan.org
.RE
.PP
Please remember to include the versions of Imager, perl, supporting
libraries, and any relevant code.  If you have specific images that
cause the problems, please include those too.
.PP
If you don't want to publish your email address on a mailing list you
can use CPAN::Forum:
.PP
.Vb 1
\&  http://www.cpanforum.com/dist/Imager
.Ve
.PP
You will need to register to post.
.SH "CONTRIBUTING TO IMAGER"
.IX Header "CONTRIBUTING TO IMAGER"
.SS "Feedback"
.IX Subsection "Feedback"
I like feedback.
.PP
If you like or dislike Imager, you can add a public review of Imager
at \s-1CPAN\s0 Ratings:
.PP
.Vb 1
\&  http://cpanratings.perl.org/dist/Imager
.Ve
.PP
This requires a Bitcard account (http://www.bitcard.org).
.PP
You can also send email to the maintainer below.
.PP
If you send me a bug report via email, it will be copied to Request
Tracker.
.SS "Patches"
.IX Subsection "Patches"
I accept patches, preferably against the master branch in git.  Please
include an explanation of the reason for why the patch is needed or
useful.
.PP
Your patch should include regression tests where possible, otherwise
it will be delayed until I get a chance to write them.
.PP
To browse Imager's git repository:
.PP
.Vb 1
\&  http://git.imager.perl.org/imager.git
.Ve
.PP
or:
.PP
.Vb 1
\&  https://github.com/tonycoz/imager
.Ve
.PP
To clone:
.PP
.Vb 1
\&  git clone git://git.imager.perl.org/imager.git
.Ve
.PP
or:
.PP
.Vb 1
\&  git clone git://github.com/tonycoz/imager.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org> is the current maintainer for Imager.
.PP
Arnar M. Hrafnkelsson is the original author of Imager.
.PP
Many others have contributed to Imager, please see the \f(CW\*(C`README\*(C'\fR for a
complete list.
.SH "LICENSE"
.IX Header "LICENSE"
Imager is licensed under the same terms as perl itself.
.PP
A test font, FT2/fontfiles/MMOne.pfb, contains a Postscript operator
definition copyrighted by Adobe.  See \fIadobe.txt\fR in the source for
license information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl(1), Imager::ImageTypes(3), Imager::Files(3),
Imager::Draw(3), Imager::Color(3), Imager::Fill(3),
Imager::Font(3), Imager::Transformations(3),
Imager::Engines(3), Imager::Filters(3), Imager::Expr(3),
Imager::Matrix2d(3), Imager::Fountain(3)
.PP
<http://imager.perl.org/>
.PP
Affix::Infix2Postfix(3), Parse::RecDescent(3)
.PP
Other perl imaging modules include:
.PP
\&\s-1GD\s0(3), Image::Magick(3), Graphics::Magick(3).
