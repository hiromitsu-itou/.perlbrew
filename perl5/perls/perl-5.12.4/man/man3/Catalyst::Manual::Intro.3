.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Intro 3"
.TH Catalyst::Manual::Intro 3 "2011-08-29" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Intro \- Introduction to Catalyst
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a brief introduction to Catalyst. It explains the most important
features of how Catalyst works and shows how to get a simple application
up and running quickly. For an introduction (without code) to Catalyst
itself, and why you should be using it, see Catalyst::Manual::About.
For a systematic step-by-step introduction to writing an application
with Catalyst, see Catalyst::Manual::Tutorial.
.SS "What is Catalyst?"
.IX Subsection "What is Catalyst?"
Catalyst is an elegant web application framework, extremely flexible
yet extremely simple. It's similar to Ruby on Rails, Spring (Java), and
Maypole, upon which it was originally based. Its most
important design philosphy is to provide easy access to all the tools
you need to develop web applications, with few restrictions on how you
need to use these tools. However, this does mean that it is always
possible to do things in a different way. Other web frameworks are
\&\fIinitially\fR simpler to use, but achieve this by locking the programmer
into a single set of tools. Catalyst's emphasis on flexibility means
that you have to think more to use it. We view this as a feature.  For
example, this leads to Catalyst being more suited to system integration
tasks than other web frameworks.
.PP
\fI\s-1MVC\s0\fR
.IX Subsection "MVC"
.PP
Catalyst follows the Model-View-Controller (\s-1MVC\s0) design pattern,
allowing you to easily separate concerns, like content, presentation,
and flow control, into separate modules. This separation allows you to
modify code that handles one concern without affecting code that handles
the others. Catalyst promotes the re-use of existing Perl modules that
already handle common web application concerns well.
.PP
Here's how the Model, View, and Controller map to those concerns, with
examples of well-known Perl modules you may want to use for each.
.IP "\(bu" 4
\&\fBModel\fR
.Sp
Access and modify content (data). DBIx::Class, Class::DBI,
Xapian, Net::LDAP...
.IP "\(bu" 4
\&\fBView\fR
.Sp
Present content to the user. Template Toolkit,
Mason, HTML::Template...
.IP "\(bu" 4
\&\fBController\fR
.Sp
Control the whole request phase, check parameters, dispatch actions, flow
control. Catalyst itself!
.PP
If you're unfamiliar with \s-1MVC\s0 and design patterns, you may want to
check out the original book on the subject, \fIDesign Patterns\fR, by
Gamma, Helm, Johnson, and Vlissides, also known as the Gang of Four
(GoF).  Many, many web application frameworks are based on \s-1MVC\s0, which
is becoming a popular design paradigm for the world wide web.
.PP
\fIFlexibility\fR
.IX Subsection "Flexibility"
.PP
Catalyst is much more flexible than many other frameworks. Rest assured
you can use your favorite Perl modules with Catalyst.
.IP "\(bu" 4
\&\fBMultiple Models, Views, and Controllers\fR
.Sp
To build a Catalyst application, you handle each type of concern inside
special modules called \*(L"Components\*(R". Often this code will be very
simple, just calling out to Perl modules like those listed above under
\&\*(L"\s-1MVC\s0\*(R". Catalyst handles these components in a very flexible way. Use
as many Models, Views, and Controllers as you like, using as many
different Perl modules as you like, all in the same application. Want to
manipulate multiple databases, and retrieve some data via \s-1LDAP\s0? No
problem. Want to present data from the same Model using Template
Toolkit and PDF::Template? Easy.
.IP "\(bu" 4
\&\fBReuseable Components\fR
.Sp
Not only does Catalyst promote the re-use of already existing Perl
modules, it also allows you to re-use your Catalyst components in
multiple Catalyst applications.
.IP "\(bu" 4
\&\fBUnrestrained URL-to-Action Dispatching\fR
.Sp
Catalyst allows you to dispatch any URLs to any application \*(L"Actions\*(R",
even through regular expressions! Unlike most other frameworks, it
doesn't require mod_rewrite or class and method names in URLs.
.Sp
With Catalyst you register your actions and address them directly. For
example:
.Sp
.Vb 4
\&    sub hello : Local {
\&        my ( $self, $context ) = @_;
\&        $context\->response\->body(\*(AqHello World!\*(Aq);
\&    }
.Ve
.Sp
Now http://localhost:3000/hello prints \*(L"Hello World!\*(R".
.Sp
Note that actions with the \f(CW\*(C` :Local \*(C'\fR attribute are equivalent to
using a \f(CW\*(C`:Path(\*(Aqaction_name\*(Aq) \*(C'\fR attribute, so our action could be
equivalently:
.Sp
.Vb 4
\&    sub hi : Path(\*(Aqhello\*(Aq) {
\&        my ( $self, $context ) = @_;
\&        $context\->response\->body(\*(AqHello World!\*(Aq);
\&    }
.Ve
.IP "\(bu" 4
\&\fBSupport for \s-1CGI\s0, mod_perl, Apache::Request, FastCGI\fR
.Sp
Use Catalyst::Engine::Apache or Catalyst::Engine::CGI. Another
interesting engine is Catalyst::Engine::HTTP::Prefork \- available from \s-1CPAN\s0
separately \- which will turn the built server into a fully fledged production
ready server (although you'll probably want to run it behind a front end proxy
if you end up using it).
.PP
\fISimplicity\fR
.IX Subsection "Simplicity"
.PP
The best part is that Catalyst implements all this flexibility in a very
simple way.
.IP "\(bu" 4
\&\fBBuilding Block Interface\fR
.Sp
Components interoperate very smoothly. For example, Catalyst
automatically makes a \*(L"Context\*(R" object available to every
component. Via the context, you can access the request object, share
data between components, and control the flow of your
application. Building a Catalyst application feels a lot like snapping
together toy building blocks, and everything just works.
.IP "\(bu" 4
\&\fBComponent Auto-Discovery\fR
.Sp
No need to \f(CW\*(C`use\*(C'\fR all of your components. Catalyst automatically finds
and loads them.
.IP "\(bu" 4
\&\fBPre-Built Components for Popular Modules\fR
.Sp
See Catalyst::Model::DBIC::Schema for DBIx::Class, or
Catalyst::View::TT for Template Toolkit.
.IP "\(bu" 4
\&\fBBuilt-in Test Framework\fR
.Sp
Catalyst comes with a built-in, lightweight http server and test
framework, making it easy to test applications from the web browser,
and the command line.
.IP "\(bu" 4
\&\fBHelper Scripts\fR
.Sp
Catalyst provides helper scripts to quickly generate running starter
code for components and unit tests. Install Catalyst::Devel and see
Catalyst::Helper.
.SS "Quickstart"
.IX Subsection "Quickstart"
Here's how to install Catalyst and get a simple application up and
running, using the helper scripts described above.
.PP
\fIInstall\fR
.IX Subsection "Install"
.PP
Installation of Catalyst should be straightforward:
.PP
.Vb 2
\&    # perl \-MCPAN \-e \*(Aqinstall Catalyst::Runtime\*(Aq
\&    # perl \-MCPAN \-e \*(Aqinstall Catalyst::Devel\*(Aq
.Ve
.PP
\fISetup\fR
.IX Subsection "Setup"
.PP
.Vb 4
\&    $ catalyst.pl MyApp
\&    # output omitted
\&    $ cd MyApp
\&    $ script/myapp_create.pl controller Library::Login
.Ve
.PP
Frank Speiser's Amazon \s-1EC2\s0 Catalyst \s-1SDK\s0
.IX Subsection "Frank Speiser's Amazon EC2 Catalyst SDK"
.PP
There are currently two flavors of publicly available Amazon Machine
Images (\s-1AMI\s0) that include all the elements you'd need to begin
developing in a fully functional Catalyst environment within
minutes. See
Catalyst::Manual::Installation for
more details.
.PP
\fIRun\fR
.IX Subsection "Run"
.PP
.Vb 1
\&    $ script/myapp_server.pl
.Ve
.PP
Now visit these locations with your favorite browser or user agent to see
Catalyst in action:
.PP
(\s-1NOTE:\s0 Although we create a controller here, we don't actually use it.
Both of these URLs should take you to the welcome page.)
.IP "http://localhost:3000/" 4
.IX Item "http://localhost:3000/"
.PD 0
.IP "http://localhost:3000/library/login/" 4
.IX Item "http://localhost:3000/library/login/"
.PD
.SS "How It Works"
.IX Subsection "How It Works"
Let's see how Catalyst works, by taking a closer look at the components
and other parts of a Catalyst application.
.PP
\fIComponents\fR
.IX Subsection "Components"
.PP
Catalyst has an uncommonly flexible component system. You can define as
many \*(L"Models\*(R", \*(L"Views\*(R", and \*(L"Controllers\*(R" as you like. As discussed
previously, the general idea is that the View is responsible for the
output of data to the user (typically via a web browser, but a View can
also generate PDFs or e\-mails, for example); the Model is responsible
for providing data (typically from a relational database); and the
Controller is responsible for interacting with the user and deciding
how user input determines what actions the application takes.
.PP
In the world of \s-1MVC\s0, there are frequent discussions and disagreements
about the nature of each element \- whether certain types of logic
belong in the Model or the Controller, etc. Catalyst's flexibility
means that this decision is entirely up to you, the programmer;
Catalyst doesn't enforce anything. See Catalyst::Manual::About for
a general discussion of these issues.
.PP
Model, View and Controller components must inherit from Catalyst::Model,
Catalyst::View and Catalyst::Controller, respectively. These, in turn, inherit
from Catalyst::Component which provides a simple class structure and some
common class methods like \f(CW\*(C`config\*(C'\fR and \f(CW\*(C`new\*(C'\fR (constructor).
.PP
.Vb 3
\&    package MyApp::Controller::Catalog;
\&    use Moose;
\&    use namespace::autoclean;
\&
\&    BEGIN { extends \*(AqCatalyst::Controller\*(Aq }
\&
\&    _\|_PACKAGE_\|_\->config( foo => \*(Aqbar\*(Aq );
\&
\&    1;
.Ve
.PP
You don't have to \f(CW\*(C`use\*(C'\fR or otherwise register Models, Views, and
Controllers.  Catalyst automatically discovers and instantiates them
when you call \f(CW\*(C`setup\*(C'\fR in the main application. All you need to do is
put them in directories named for each Component type. You can use a
short alias for each one.
.IP "\(bu" 4
\&\fBMyApp/Model/\fR
.IP "\(bu" 4
\&\fBMyApp/M/\fR
.IP "\(bu" 4
\&\fBMyApp/View/\fR
.IP "\(bu" 4
\&\fBMyApp/V/\fR
.IP "\(bu" 4
\&\fBMyApp/Controller/\fR
.IP "\(bu" 4
\&\fBMyApp/C/\fR
.PP
In older versions of Catalyst, the recommended practice (and the one
automatically created by helper scripts) was to name the directories
\&\f(CW\*(C`M/\*(C'\fR, \f(CW\*(C`V/\*(C'\fR, and \f(CW\*(C`C/\*(C'\fR. Though these still work, they are deprecated
and we now recommend the use of the full names.
.PP
Views
.IX Subsection "Views"
.PP
To show how to define views, we'll use an already-existing base class for the
Template Toolkit, Catalyst::View::TT. All we need to do is
inherit from this class:
.PP
.Vb 1
\&    package MyApp::View::TT;
\&
\&    use strict;
\&    use base \*(AqCatalyst::View::TT\*(Aq;
\&
\&    1;
.Ve
.PP
(You can also generate this automatically by using the helper script:
.PP
.Vb 1
\&    script/myapp_create.pl view TT TT
.Ve
.PP
where the first \f(CW\*(C`TT\*(C'\fR tells the script that the name of the view should
be \f(CW\*(C`TT\*(C'\fR, and the second that it should be a Template Toolkit view.)
.PP
This gives us a \fIprocess()\fR method and we can now just do
\&\f(CW$c\fR\->forward('MyApp::View::TT') to render our templates. The base class
makes \fIprocess()\fR implicit, so we don't have to say
\&\f(CW\*(C`$c\->forward(qw/MyApp::View::TT process/)\*(C'\fR.
.PP
.Vb 4
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{template} = \*(Aqhello.tt\*(Aq;
\&    }
\&
\&    sub end : Private {
\&        my ( $self, $c ) = @_;
\&        $c\->forward( $c\->view(\*(AqTT\*(Aq) );
\&    }
.Ve
.PP
You normally render templates at the end of a request, so it's a perfect
use for the global \f(CW\*(C`end\*(C'\fR action.
.PP
In practice, however, you would use a default \f(CW\*(C`end\*(C'\fR action as supplied
by Catalyst::Action::RenderView.
.PP
Also, be sure to put the template under the directory specified in
\&\f(CW\*(C`$c\->config\->{root}\*(C'\fR, or you'll end up looking at the debug
screen.
.PP
Models
.IX Subsection "Models"
.PP
Models are providers of data. This data could come from anywhere \- a
search engine index, a spreadsheet, the file system \- but typically a
Model represents a database table. The data source does not
intrinsically have much to do with web applications or Catalyst \- it
could just as easily be used to write an offline report generator or a
command-line tool.
.PP
To show how to define models, again we'll use an already-existing base
class, this time for DBIx::Class: Catalyst::Model::DBIC::Schema.
We'll also need DBIx::Class::Schema::Loader.
.PP
But first, we need a database.
.PP
.Vb 5
\&    \-\- myapp.sql
\&    CREATE TABLE foo (
\&        id INTEGER PRIMARY KEY,
\&        data TEXT
\&    );
\&
\&    CREATE TABLE bar (
\&        id INTEGER PRIMARY KEY,
\&        foo INTEGER REFERENCES foo,
\&        data TEXT
\&    );
\&
\&    INSERT INTO foo (data) VALUES (\*(AqTEST!\*(Aq);
\&
\&    % sqlite3 /tmp/myapp.db < myapp.sql
.Ve
.PP
Now we can create a DBIC::Schema model for this database.
.PP
.Vb 1
\&    script/myapp_create.pl model MyModel DBIC::Schema MySchema create=static \*(Aqdbi:SQLite:/tmp/myapp.db\*(Aq
.Ve
.PP
DBIx::Class::Schema::Loader can automatically load table layouts and
relationships, and convert them into a static schema definition
\&\f(CW\*(C`MySchema\*(C'\fR, which you can edit later.
.PP
Use the stash to pass data to your templates.
.PP
We add the following to MyApp/Controller/Root.pm
.PP
.Vb 2
\&    sub view : Global {
\&        my ( $self, $c, $id ) = @_;
\&
\&        $c\->stash\->{item} = $c\->model(\*(AqMyModel::Foo\*(Aq)\->find($id);
\&    }
\&
\&    1;
\&
\&    sub end : Private {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->stash\->{template} ||= \*(Aqindex.tt\*(Aq;
\&        $c\->forward( $c\->view(\*(AqTT\*(Aq) );
\&    }
.Ve
.PP
We then create a new template file \*(L"root/index.tt\*(R" containing:
.PP
.Vb 1
\&    The Id\*(Aqs data is [% item.data %]
.Ve
.PP
Models do not have to be part of your Catalyst application; you
can always call an outside module that serves as your Model:
.PP
.Vb 3
\&    # in a Controller
\&    sub list : Local {
\&      my ( $self, $c ) = @_;
\&
\&      $c\->stash\->{template} = \*(Aqlist.tt\*(Aq;
\&
\&      use Some::Outside::Database::Module;
\&      my @records = Some::Outside::Database::Module\->search({
\&        artist => \*(AqLed Zeppelin\*(Aq,
\&        });
\&
\&      $c\->stash\->{records} = \e@records;
\&    }
.Ve
.PP
But by using a Model that is part of your Catalyst application, you
gain several things: you don't have to \f(CW\*(C`use\*(C'\fR each component, Catalyst
will find and load it automatically at compile-time; you can
\&\f(CW\*(C`forward\*(C'\fR to the module, which can only be done to Catalyst
components.  Only Catalyst components can be fetched with
\&\f(CW\*(C`$c\->model(\*(AqSomeModel\*(Aq)\*(C'\fR.
.PP
Happily, since many people have existing Model classes that they
would like to use with Catalyst (or, conversely, they want to
write Catalyst models that can be used outside of Catalyst, e.g.
in a cron job), it's trivial to write a simple component in
Catalyst that slurps in an outside Model:
.PP
.Vb 7
\&    package MyApp::Model::DB;
\&    use base qw/Catalyst::Model::DBIC::Schema/;
\&    _\|_PACKAGE_\|_\->config(
\&        schema_class => \*(AqSome::DBIC::Schema\*(Aq,
\&        connect_info => [\*(Aqdbi:SQLite:foo.db\*(Aq, \*(Aq\*(Aq, \*(Aq\*(Aq, {AutoCommit=>1}]
\&    );
\&    1;
.Ve
.PP
and that's it! Now \f(CW\*(C`Some::DBIC::Schema\*(C'\fR is part of your
Cat app as \f(CW\*(C`MyApp::Model::DB\*(C'\fR.
.PP
Within Catalyst, the common approach to writing a model for your
application is wrapping a generic model (e.g. DBIx::Class::Schema, a
bunch of XMLs, or anything really) with an object that contains
configuration data, convenience methods, and so forth. Thus you
will in effect have two models \- a wrapper model that knows something
about Catalyst and your web application, and a generic model that is
totally independent of these needs.
.PP
Technically, within Catalyst a model is a \fBcomponent\fR \- an instance of
the model's class belonging to the application. It is important to
stress that the lifetime of these objects is per application, not per
request.
.PP
While the model base class (Catalyst::Model) provides things like
\&\f(CW\*(C`config\*(C'\fR to better integrate the model into the application, sometimes
this is not enough, and the model requires access to \f(CW$c\fR itself.
.PP
Situations where this need might arise include:
.IP "\(bu" 4
Interacting with another model
.IP "\(bu" 4
Using per-request data to control behavior
.IP "\(bu" 4
Using plugins from a Model (for example Catalyst::Plugin::Cache).
.PP
From a style perspective it's usually considered bad form to make your
model \*(L"too smart\*(R" about things \- it should worry about business logic
and leave the integration details to the controllers. If, however, you
find that it does not make sense at all to use an auxillary controller
around the model, and the model's need to access \f(CW$c\fR cannot be
sidestepped, there exists a power tool called \*(L"\s-1ACCEPT_CONTEXT\s0\*(R".
.PP
Controllers
.IX Subsection "Controllers"
.PP
Multiple controllers are a good way to separate logical domains of your
application.
.PP
.Vb 1
\&    package MyApp::Controller::Login;
\&
\&    use base qw/Catalyst::Controller/;
\&
\&    sub login : Path("login") { }
\&    sub new_password : Path("new\-password") { }
\&    sub logout : Path("logout") { }
\&
\&    package MyApp::Controller::Catalog;
\&
\&    use base qw/Catalyst::Controller/;
\&
\&    sub view : Local { }
\&    sub list : Local { }
\&
\&    package MyApp::Controller::Cart;
\&
\&    use base qw/Catalyst::Controller/;
\&
\&    sub add : Local { }
\&    sub update : Local { }
\&    sub order : Local { }
.Ve
.PP
Note that you can also supply attributes via the Controller's config so
long as you have at least one attribute on a subref to be exported
(:Action is commonly used for this) \- for example the following is
equivalent to the same controller above:
.PP
.Vb 1
\&    package MyApp::Controller::Login;
\&
\&    use base qw/Catalyst::Controller/;
\&
\&    _\|_PACKAGE_\|_\->config(
\&      actions => {
\&        \*(Aqsign_in\*(Aq => { Path => \*(Aqsign\-in\*(Aq },
\&        \*(Aqnew_password\*(Aq => { Path => \*(Aqnew\-password\*(Aq },
\&        \*(Aqsign_out\*(Aq => { Path => \*(Aqsign\-out\*(Aq },
\&      },
\&    );
\&
\&    sub sign_in : Action { }
\&    sub new_password : Action { }
\&    sub sign_out : Action { }
.Ve
.PP
\fI\s-1ACCEPT_CONTEXT\s0\fR
.IX Subsection "ACCEPT_CONTEXT"
.PP
Whenever you call \f(CW$c\fR\->component(\*(L"Foo\*(R") you get back an object \- the
instance of the model. If the component supports the \f(CW\*(C`ACCEPT_CONTEXT\*(C'\fR
method instead of returning the model itself, the return value of \f(CW\*(C`$model\->ACCEPT_CONTEXT( $c )\*(C'\fR will be used.
.PP
This means that whenever your model/view/controller needs to talk to
\&\f(CW$c\fR it gets a chance to do this when it's needed.
.PP
A typical \f(CW\*(C`ACCEPT_CONTEXT\*(C'\fR method will either clone the model and return one
with the context object set, or it will return a thin wrapper that contains
\&\f(CW$c\fR and delegates to the per-application model object.
.PP
Generally it's a bad idea to expose the context object (\f(CW$c\fR) in your
model or view code.  Instead you use the \f(CW\*(C`ACCEPT_CONTEXT\*(C'\fR subroutine
to grab the bits of the context object that you need, and provide
accessors to them in the model.  This ensures that \f(CW$c\fR is only in
scope where it is neaded which reduces maintenance and debugging
headaches.  So, if for example you needed two
Catalyst::Model::DBIC::Schema models in the same Catalyst model
code, you might do something like this:
.PP
.Vb 9
\& _\|_PACKAGE_\|_\->mk_accessors(qw(model1_schema model2_schema));
\& sub ACCEPT_CONTEXT {
\&     my ( $self, $c, @extra_arguments ) = @_;
\&     $self = bless({ %$self,
\&             model1_schema  => $c\->model(\*(AqModel1\*(Aq)\->schema,
\&             model2_schema => $c\->model(\*(AqModel2\*(Aq)\->schema
\&         }, ref($self));
\&     return $self;
\& }
.Ve
.PP
This effectively treats \f(CW$self\fR as a \fBprototype object\fR that gets a new
parameter.  \f(CW@extra_arguments\fR comes from any trailing arguments to
\&\f(CW\*(C`$c\->component( $bah, @extra_arguments )\*(C'\fR (or \f(CW\*(C`$c\->model(...)\*(C'\fR, \f(CW\*(C`$c\->view(...)\*(C'\fR etc).
.PP
In a subroutine in the  model code, we can then do this:
.PP
.Vb 6
\& sub whatever {
\&     my ($self) = @_;
\&     my $schema1 = $self\->model1_schema;
\&     my $schema2 = $self\->model2_schema;
\&     ...
\& }
.Ve
.PP
Note that we still want the Catalyst models to be a thin wrapper
around classes that will work independently of the Catalyst
application to promote reusability of code.  Here we might just want
to grab the \f(CW$c\fR\->model('\s-1DB\s0')\->schema so as to get the connection
information from the Catalyst application's configuration for example.
.PP
The life time of this value is \fBper usage\fR, and not per request. To
make this per request you can use the following technique:
.PP
Add a field to \f(CW$c\fR, like \f(CW\*(C`my_model_instance\*(C'\fR. Then write your
\&\f(CW\*(C`ACCEPT_CONTEXT\*(C'\fR method to look like this:
.PP
.Vb 2
\&    sub ACCEPT_CONTEXT {
\&      my ( $self, $c ) = @_;
\&
\&      if ( my $per_request = $c\->my_model_instance ) {
\&        return $per_request;
\&      } else {
\&        my $new_instance = bless { %$self, c => $c }, ref($self);
\&        Scalar::Util::weaken($new_instance\->{c}); # or we have a circular reference
\&        $c\->my_model_instance( $new_instance );
\&        return $new_instance;
\&      }
\&    }
.Ve
.PP
For a similar technique to grab a new component instance on each
request, see Catalyst::Component::InstancePerContext.
.PP
\fIApplication Class\fR
.IX Subsection "Application Class"
.PP
In addition to the Model, View, and Controller components, there's a
single class that represents your application itself. This is where you
configure your application, load plugins, and extend Catalyst.
.PP
.Vb 1
\&    package MyApp;
\&
\&    use strict;
\&    use parent qw/Catalyst/;
\&    use Catalyst qw/\-Debug ConfigLoader Static::Simple/;
\&    MyApp\->config(
\&        name => \*(AqMy Application\*(Aq,
\&
\&        # You can put anything else you want in here:
\&        my_configuration_variable => \*(Aqsomething\*(Aq,
\&    );
\&    1;
.Ve
.PP
In older versions of Catalyst, the application class was where you put
global actions. However, as of version 5.66, the recommended practice is
to place such actions in a special Root controller (see \*(L"Actions\*(R",
below), to avoid namespace collisions.
.IP "\(bu" 4
\&\fBname\fR
.Sp
The name of your application.
.PP
Optionally, you can specify a \fBroot\fR parameter for templates and static
data.  If omitted, Catalyst will try to auto-detect the directory's
location. You can define as many parameters as you want for plugins or
whatever you need. You can access them anywhere in your application via
\&\f(CW\*(C`$context\->config\->{$param_name}\*(C'\fR.
.PP
\fIContext\fR
.IX Subsection "Context"
.PP
Catalyst automatically blesses a Context object into your application
class and makes it available everywhere in your application. Use the
Context to directly interact with Catalyst and glue your \*(L"Components\*(R"
together. For example, if you need to use the Context from within a
Template Toolkit template, it's already there:
.PP
.Vb 1
\&    <h1>Welcome to [% c.config.name %]!</h1>
.Ve
.PP
As illustrated in our URL-to-Action dispatching example, the Context is
always the second method parameter, behind the Component object
reference or class name itself. Previously we called it \f(CW$context\fR for
clarity, but most Catalyst developers just call it \f(CW$c\fR:
.PP
.Vb 4
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->res\->body(\*(AqHello World!\*(Aq);
\&    }
.Ve
.PP
The Context contains several important objects:
.IP "\(bu" 4
Catalyst::Request
.Sp
.Vb 2
\&    $c\->request
\&    $c\->req # alias
.Ve
.Sp
The request object contains all kinds of request-specific information, like
query parameters, cookies, uploads, headers, and more.
.Sp
.Vb 5
\&    $c\->req\->params\->{foo};
\&    $c\->req\->cookies\->{sessionid};
\&    $c\->req\->headers\->content_type;
\&    $c\->req\->base;
\&    $c\->req\->uri_with( { page = $pager\->next_page } );
.Ve
.IP "\(bu" 4
Catalyst::Response
.Sp
.Vb 2
\&    $c\->response
\&    $c\->res # alias
.Ve
.Sp
The response is like the request, but contains just response-specific
information.
.Sp
.Vb 3
\&    $c\->res\->body(\*(AqHello World\*(Aq);
\&    $c\->res\->status(404);
\&    $c\->res\->redirect(\*(Aqhttp://oook.de\*(Aq);
.Ve
.IP "\(bu" 4
config
.Sp
.Vb 3
\&    $c\->config
\&    $c\->config\->{root};
\&    $c\->config\->{name};
.Ve
.IP "\(bu" 4
Catalyst::Log
.Sp
.Vb 3
\&    $c\->log
\&    $c\->log\->debug(\*(AqSomething happened\*(Aq);
\&    $c\->log\->info(\*(AqSomething you should know\*(Aq);
.Ve
.IP "\(bu" 4
\&\fBStash\fR
.Sp
.Vb 4
\&    $c\->stash
\&    $c\->stash\->{foo} = \*(Aqbar\*(Aq;
\&    $c\->stash\->{baz} = {baz => \*(Aqqox\*(Aq};
\&    $c\->stash\->{fred} = [qw/wilma pebbles/];
.Ve
.Sp
and so on.
.PP
The last of these, the stash, is a universal hash for sharing data among
application components. For an example, we return to our 'hello' action:
.PP
.Vb 5
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&        $c\->forward(\*(Aqshow_message\*(Aq);
\&    }
\&
\&    sub show_message : Private {
\&        my ( $self, $c ) = @_;
\&        $c\->res\->body( $c\->stash\->{message} );
\&    }
.Ve
.PP
Note that the stash should be used only for passing data in an
individual request cycle; it gets cleared at a new request. If you need
to maintain persistent data, use a session. See
Catalyst::Plugin::Session for a comprehensive set of
Catalyst-friendly session-handling tools.
.PP
\fIActions\fR
.IX Subsection "Actions"
.PP
You've already seen some examples of actions in this document:
subroutines with \f(CW\*(C`:Path\*(C'\fR and \f(CW\*(C`:Local\*(C'\fR attributes attached.
Here, we explain what actions are and how these attributes affect
what's happening.
.PP
When Catalyst processes a webpage request, it looks for actions to
take that will deal with the incoming request and produce a response
such as a webpage.  You create these actions for your application by
writing subroutines within your controller and marking them with
special attributes.  The attributes, the namespace, and the function
name determine when Catalyst will call the subroutine.
.PP
These action subroutines call certain functions to say what response
the webserver will give to the web request.  They can also tell
Catalyst to run other actions on the request (one example of this is
called forwarding the request; this is discussed later).
.PP
Action subroutines must have a special attribute on to show that they
are actions \- as well as marking when to call them, this shows that
they take a specific set of arguments and behave in a specific way.
At startup, Catalyst looks for all the actions in controllers,
registers them and creates Catalyst::Action objects describing
them.  When requests come in, Catalyst chooses which actions should be
called to handle the request.
.PP
(Occasionally, you might use the action objects directly, but in
general, when we talk about actions, we're talking about the
subroutines in your application that do things to process a request.)
.PP
You can choose one of several attributes for action subroutines; these
specify which requests are processed by that subroutine.  Catalyst
will look at the \s-1URL\s0 it is processing, and the actions that it has
found, and automatically call the actions it finds that match the
circumstances of the request.
.PP
The \s-1URL\s0 (for example http://localhost:3000/foo/bar) consists of two
parts, the base, describing how to connect to the server
(http://localhost:3000/ in this example) and the path, which the
server uses to decide what to return (foo/bar).  Please note that the
trailing slash after the hostname[:port] always belongs to base and
not to the path.  Catalyst uses only the path part when trying to find
actions to process.
.PP
Depending on the type of action used, the URLs may match a combination
of the controller namespace, the arguments passed to the action
attribute, and the name of the subroutine.
.IP "\(bu" 4
\&\fBController namespaces\fR
.Sp
The namespace is a modified form of the component's class (package)
name. This modified class name excludes the parts that have a
pre-defined meaning in Catalyst (\*(L"MyApp::Controller\*(R" in the above
example), replaces \*(L"::\*(R" with \*(L"/\*(R", and converts the name to lower case.
See \*(L"Components\*(R" for a full explanation of the pre-defined meaning
of Catalyst component class names.
.IP "\(bu" 4
\&\fBOverriding the namespace\fR
.Sp
Note that \fI_\|_PACKAGE_\|_\->config\->(namespace => ... )\fR can be used to override the
current namespace when matching.  So:
.Sp
.Vb 1
\&    package MyApp::Controller::Example;
.Ve
.Sp
would normally use 'example' as its namespace for matching, but if
this is specially overridden with
.Sp
.Vb 1
\&    _\|_PACKAGE_\|_\->config( namespace => \*(Aqthing\*(Aq );
.Ve
.Sp
it matches using the namespace 'thing' instead.
.IP "\(bu" 4
\&\fBApplication Wide Actions\fR
.Sp
MyApp::Controller::Root, as created by the catalyst.pl script, will
typically contain actions which are called for the top level of the
application (e.g. http://localhost:3000/ ):
.Sp
.Vb 11
\&    package MyApp::Controller::Root;
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&    # Sets the actions in this controller to be registered with no prefix
\&    # so they function identically to actions created in MyApp.pm
\&    _\|_PACKAGE_\|_\->config( namespace => \*(Aq\*(Aq);
\&    sub default : Path  {
\&        my ( $self, $context ) = @_;
\&        $context\->response\->status(404);
\&        $context\->response\->body(\*(Aq404 not found\*(Aq);
\&    }
\&    1;
.Ve
.Sp
The code
.Sp
.Vb 1
\&    _\|_PACKAGE_\|_\->config( namespace => \*(Aq\*(Aq );
.Ve
.Sp
makes the controller act as if its namespace is empty.  As you'll see
below, an empty namespace makes many of the URL-matching attributes,
such as :Path, :Local and :Global matches, match at the start of the
\&\s-1URL\s0 path.
.PP
Action types
.IX Subsection "Action types"
.PP
Catalyst supports several types of actions.  These mainly correspond
to ways of matching a \s-1URL\s0 to an action subroutine.  Internally, these
matching types are implemented by Catalyst::DispatchType\-derived
classes; the documentation there can be helpful in seeing how they
work.
.PP
They will all attempt to match the start of the path.  The remainder
of the path is passed as arguments.
.IP "\(bu" 4
Namespace-prefixed (\f(CW\*(C`:Local\*(C'\fR)
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub foo : Local { }
.Ve
.Sp
Matches any \s-1URL\s0 beginning with> http://localhost:3000/my/controller/foo. The namespace and
subroutine name together determine the path.
.IP "\(bu" 4
Root-level (\f(CW\*(C`:Global\*(C'\fR)
.Sp
.Vb 2
\&    package MyApp::Controller::Foo;
\&    sub foo : Global { }
.Ve
.Sp
Matches http://localhost:3000/foo \- that is, the action is mapped
directly to the controller namespace, ignoring the function name.
.Sp
\&\f(CW\*(C`:Global\*(C'\fR always matches from root: it is sugar for \f(CW\*(C`:Path(\*(Aq/methodname\*(Aq)\*(C'\fR.
\&\f(CW\*(C`:Local\*(C'\fR is simply sugar for \f(CW\*(C`:Path(\*(Aqmethodname\*(Aq)\*(C'\fR, which takes the package
namespace as described above.
.Sp
.Vb 3
\&    package MyApp::Controller::Root;
\&    _\|_PACKAGE_\|_\->config( namespace => \*(Aq\*(Aq);
\&    sub foo : Local { }
.Ve
.Sp
Use whichever makes the most sense for your application.
.IP "\(bu" 4
Changing handler behaviour: eating arguments (\f(CW\*(C`:Args\*(C'\fR)
.Sp
Args is not an action type per se, but an action modifier \- it adds a
match restriction to any action it's provided to, additionally
requiring as many path parts as are specified for the action to be
matched. For example, in MyApp::Controller::Foo,
.Sp
.Vb 1
\&  sub bar :Local
.Ve
.Sp
would match any \s-1URL\s0 starting /foo/bar. To restrict this you can do
.Sp
.Vb 1
\&  sub bar :Local :Args(1)
.Ve
.Sp
to only match URLs starting /foo/bar/* \- with one additional path
element required after 'bar'.
.Sp
\&\s-1NOTE\s0 that adding \f(CW:Args(0)\fR and missing out :Args completely are \fBnot\fR
the same thing.
.Sp
\&\f(CW:Args(0)\fR means that no arguments are taken.  Thus, the \s-1URL\s0 and path must
match precisely.
.Sp
No :Args at all means that \fBany number\fR of arguments are taken.  Thus, any
\&\s-1URL\s0 that \fBstarts with\fR the controller's path will match. Obviously, this means
you cannot chain from an action that does not specify args, as the next action
in the chain will be swallowed as an arg to the first!
.IP "\(bu" 4
Literal match (\f(CW\*(C`:Path\*(C'\fR)
.Sp
\&\f(CW\*(C`Path\*(C'\fR actions match things starting with a precise specified path,
and nothing else.
.Sp
\&\f(CW\*(C`Path\*(C'\fR actions without a leading forward slash match a specified path
relative to their current namespace. This example matches URLs
starting http://localhost:3000/my/controller/foo/bar :
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub bar : Path(\*(Aqfoo/bar\*(Aq) { }
.Ve
.Sp
\&\f(CW\*(C`Path\*(C'\fR actions \fBwith\fR a leading slash ignore their namespace, and
match from the start of the \s-1URL\s0 path. Example:
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub bar : Path(\*(Aq/foo/bar\*(Aq) { }
.Ve
.Sp
This matches URLs beginning http://localhost:3000/foo/bar.
.Sp
Empty \f(CW\*(C`Path\*(C'\fR definitions match on the namespace only, exactly like
\&\f(CW\*(C`:Global\*(C'\fR.
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub bar : Path { }
.Ve
.Sp
The above code matches http://localhost:3000/my/controller.
.Sp
Actions with the \f(CW\*(C`:Local\*(C'\fR attribute are similarly equivalent to
\&\f(CW\*(C`:Path(\*(Aqaction_name\*(Aq)\*(C'\fR:
.Sp
.Vb 1
\&    sub foo : Local { }
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    sub foo : Path(\*(Aqfoo\*(Aq) { }
.Ve
.IP "\(bu" 4
Pattern-match (\f(CW\*(C`:Regex\*(C'\fR and \f(CW\*(C`:LocalRegex\*(C'\fR)
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub bar : Regex(\*(Aq^item(\ed+)/order(\ed+)$\*(Aq) { }
.Ve
.Sp
This matches any \s-1URL\s0 that matches the pattern in the action key, e.g.
http://localhost:3000/item23/order42. The '' around the regexp is
optional, but perltidy likes it. :)
.Sp
\&\f(CW\*(C`:Regex\*(C'\fR matches act globally, i.e. without reference to the namespace
from which they are called.  So the above will \fBnot\fR match
http://localhost:3000/my/controller/item23/order42 \- use a
\&\f(CW\*(C`:LocalRegex\*(C'\fR action instead.
.Sp
.Vb 2
\&    package MyApp::Controller::My::Controller;
\&    sub bar : LocalRegex(\*(Aq^widget(\ed+)$\*(Aq) { }
.Ve
.Sp
\&\f(CW\*(C`:LocalRegex\*(C'\fR actions act locally, i.e. the namespace is matched
first. The above example would match urls like
http://localhost:3000/my/controller/widget23.
.Sp
If you omit the "\f(CW\*(C`^\*(C'\fR" from either sort of regex, then it will match any depth
from the base path:
.Sp
.Vb 2
\&    package MyApp::Controller::Catalog;
\&    sub bar : LocalRegex(\*(Aqwidget(\ed+)$\*(Aq) { }
.Ve
.Sp
This differs from the previous example in that it will match
http://localhost:3000/my/controller/foo/widget23 \- and a number of
other paths.
.Sp
For both \f(CW\*(C`:LocalRegex\*(C'\fR and \f(CW\*(C`:Regex\*(C'\fR actions, if you use capturing
parentheses to extract values within the matching \s-1URL\s0, those values
are available in the \f(CW\*(C`$c\->req\->captures\*(C'\fR array. In the above
example, \*(L"widget23\*(R" would capture \*(L"23\*(R" in the above example, and
\&\f(CW\*(C`$c\->req\->captures\->[0]\*(C'\fR would be \*(L"23\*(R". If you want to
pass arguments at the end of your \s-1URL\s0, you must use regex action
keys. See \*(L"\s-1URL\s0 Path Handling\*(R" below.
.IP "\(bu" 4
Chained handlers (\f(CW\*(C`:Chained\*(C'\fR)
.Sp
Catalyst also provides a method to build and dispatch chains of actions,
like
.Sp
.Vb 4
\&    sub catalog : Chained : CaptureArgs(1) {
\&        my ( $self, $c, $arg ) = @_;
\&        ...
\&    }
\&
\&    sub item : Chained(\*(Aqcatalog\*(Aq) : Args(1) {
\&        my ( $self, $c, $arg ) = @_;
\&        ...
\&    }
.Ve
.Sp
to handle a \f(CW\*(C`/catalog/*/item/*\*(C'\fR path.  Matching actions are called
one after another \- \f(CW\*(C`catalog()\*(C'\fR gets called and handed one path
element, then \f(CW\*(C`item()\*(C'\fR gets called with another one.  For further
information about this dispatch type, please see
Catalyst::DispatchType::Chained.
.IP "\(bu" 4
\&\fBPrivate\fR
.Sp
.Vb 1
\&    sub foo : Private { }
.Ve
.Sp
This will never match a \s-1URL\s0 \- it provides a private action which can
be called programmatically from within Catalyst, but is never called
automatically due to the \s-1URL\s0 being requested.
.Sp
Catalyst's \f(CW\*(C`:Private\*(C'\fR attribute is exclusive and doesn't work with other
attributes (so will not work combined with \f(CW\*(C`:Path\*(C'\fR or \f(CW\*(C`:Chained\*(C'\fR
attributes, for instance).
.Sp
Private actions can only be executed explicitly from inside a Catalyst
application.  You might do this in your controllers by calling
catalyst methods such as \f(CW\*(C`forward\*(C'\fR or \f(CW\*(C`detach\*(C'\fR to fire them:
.Sp
.Vb 3
\&    $c\->forward(\*(Aqfoo\*(Aq);
\&    # or
\&    $c\->detach(\*(Aqfoo\*(Aq);
.Ve
.Sp
See \*(L"Flow Control\*(R" for a full explanation of how you can pass
requests on to other actions. Note that, as discussed there, when
forwarding from another component, you must use the absolute path to
the method, so that a private \f(CW\*(C`bar\*(C'\fR method in your
\&\f(CW\*(C`MyApp::Controller::Catalog::Order::Process\*(C'\fR controller must, if
called from elsewhere, be reached with
\&\f(CW\*(C`$c\->forward(\*(Aq/catalog/order/process/bar\*(Aq)\*(C'\fR.
.PP
\&\fBNote:\fR After seeing these examples, you probably wonder what the
point is of defining subroutine names for regex and path
actions. However, every public action is also a private one with a
path corresponding to its namespace and subroutine name, so you have
one unified way of addressing components in your \f(CW\*(C`forward\*(C'\fRs.
.PP
Built-in special actions
.IX Subsection "Built-in special actions"
.PP
If present, the special actions \f(CW\*(C` index \*(C'\fR, \f(CW\*(C` auto \*(C'\fR, \f(CW\*(C`begin\*(C'\fR,
\&\f(CW\*(C`end\*(C'\fR and \f(CW\*(C` default \*(C'\fR are called at certain points in the request
cycle.
.PP
In response to specific application states, Catalyst will automatically
call these built-in actions in your application class:
.IP "\(bu" 4
\&\fBdefault : Path\fR
.Sp
This is called when no other action matches. It could be used, for
example, for displaying a generic frontpage for the main app, or an
error page for individual controllers. \fBNote\fR: in older Catalyst
applications you will see \f(CW\*(C`default : Private\*(C'\fR which is roughly
speaking equivalent.
.IP "\(bu" 4
\&\fBindex : Path : Args (0) \fR
.Sp
\&\f(CW\*(C`index\*(C'\fR is much like \f(CW\*(C`default\*(C'\fR except that it takes no arguments and
it is weighted slightly higher in the matching process. It is useful
as a static entry point to a controller, e.g. to have a static welcome
page. Note that it's also weighted higher than Path.  Actually the sub
name \f(CW\*(C`index\*(C'\fR can be called anything you want.  The sub attributes are
what determines the behaviour of the action.  \fBNote\fR: in older
Catalyst applications, you will see \f(CW\*(C`index : Private\*(C'\fR used, which is
roughly speaking equivalent.
.IP "\(bu" 4
\&\fBbegin : Private\fR
.Sp
Called at the beginning of a request, once the controller that will
run has been identified, but before any URL-matching actions are
called.  Catalyst will call the \f(CW\*(C`begin\*(C'\fR function in the controller
which contains the action matching the \s-1URL\s0.
.IP "\(bu" 4
\&\fBend : Private\fR
.Sp
Called at the end of a request, after all URL-matching actions are called.
Catalyst will call the \f(CW\*(C`end\*(C'\fR function in the controller
which contains the action matching the \s-1URL\s0.
.IP "\(bu" 4
\&\fBauto : Private\fR
.Sp
In addition to the normal built-in actions, you have a special action
for making chains, \f(CW\*(C`auto\*(C'\fR. \f(CW\*(C`auto\*(C'\fR actions will be run after any
\&\f(CW\*(C`begin\*(C'\fR, but before your URL-matching action is processed. Unlike the other
built-ins, multiple \f(CW\*(C`auto\*(C'\fR actions can be called; they will be
called in turn, starting with the application class and going through
to the most specific class.
.PP
Built-in actions in controllers/autochaining
.IX Subsection "Built-in actions in controllers/autochaining"
.PP
.Vb 4
\&    package MyApp::Controller::Foo;
\&    sub begin : Private { }
\&    sub default : Path  { }
\&    sub end : Path  { }
.Ve
.PP
You can define built-in actions within your controllers as well as on
your application class. In other words, for each of the three built-in
actions above, only one will be run in any request cycle. Thus, if
\&\f(CW\*(C`MyApp::Controller::Catalog::begin\*(C'\fR exists, it will be run in place
of \f(CW\*(C`MyApp::begin\*(C'\fR if you're in the \f(CW\*(C`catalog\*(C'\fR namespace, and
\&\f(CW\*(C`MyApp::Controller::Catalog::Order::begin\*(C'\fR would override this in
turn.
.PP
.Vb 1
\&    sub auto : Private { }
.Ve
.PP
\&\f(CW\*(C`auto\*(C'\fR, however, doesn't override like this: providing they exist,
\&\f(CW\*(C`MyApp::auto\*(C'\fR, \f(CW\*(C`MyApp::Controller::Catalog::auto\*(C'\fR and
\&\f(CW\*(C`MyApp::Catalog::Order::auto\*(C'\fR would be called in turn.
.PP
Here are some examples of the order in which the various built-ins
would be called:
.ie n .IP "for a request for ""/foo/foo""" 4
.el .IP "for a request for \f(CW/foo/foo\fR" 4
.IX Item "for a request for /foo/foo"
.Vb 3
\&  MyApp::Controller::Foo::auto
\&  MyApp::Controller::Foo::default # in the absence of MyApp::Controller::Foo::Foo
\&  MyApp::Controller::Foo::end
.Ve
.ie n .IP "for a request for ""/foo/bar/foo""" 4
.el .IP "for a request for \f(CW/foo/bar/foo\fR" 4
.IX Item "for a request for /foo/bar/foo"
.Vb 5
\&  MyApp::Controller::Foo::Bar::begin
\&  MyApp::Controller::Foo::auto
\&  MyApp::Controller::Foo::Bar::auto
\&  MyApp::Controller::Foo::Bar::default # for MyApp::Controller::Foo::Bar::foo
\&  MyApp::Controller::Foo::Bar::end
.Ve
.PP
The \f(CW\*(C`auto\*(C'\fR action is also distinguished by the fact that you can break
out of the processing chain by returning 0. If an \f(CW\*(C`auto\*(C'\fR action returns
0, any remaining actions will be skipped, except for \f(CW\*(C`end\*(C'\fR. So, for the
request above, if the first auto returns false, the chain would look
like this:
.ie n .IP "for a request for ""/foo/bar/foo"" where first ""auto"" returns false" 4
.el .IP "for a request for \f(CW/foo/bar/foo\fR where first \f(CWauto\fR returns false" 4
.IX Item "for a request for /foo/bar/foo where first auto returns false"
.Vb 5
\&  MyApp::Controller::Foo::Bar::begin
\&  MyApp::Controller::Foo::auto # returns false, skips some calls:
\&  # MyApp::Controller::Foo::Bar::auto \- never called
\&  # MyApp::Controller::Foo::Bar::foo \- never called
\&  MyApp::Controller::Foo::Bar::end
.Ve
.Sp
You can also \f(CW\*(C`die\*(C'\fR in the auto action; in that case, the request will
go straight to the finalize stage, without processing further
actions. So in the above example, \f(CW\*(C`MyApp::Controller::Foo::Bar::end\*(C'\fR
is skipped as well.
.PP
An example of why one might use \f(CW\*(C`auto\*(C'\fR is an authentication action:
you could set up a \f(CW\*(C`auto\*(C'\fR action to handle authentication in your
application class (which will always be called first), and if
authentication fails, returning 0 would skip any remaining methods for
that \s-1URL\s0.
.PP
\&\fBNote:\fR Looking at it another way, \f(CW\*(C`auto\*(C'\fR actions have to return a
true value to continue processing!
.PP
\s-1URL\s0 Path Handling
.IX Subsection "URL Path Handling"
.PP
You can pass arguments as part of the \s-1URL\s0 path, separated with forward
slashes (/). If the action is a Regex or LocalRegex, the '$' anchor
must be used. For example, suppose you want to handle
\&\f(CW\*(C`/foo/$bar/$baz\*(C'\fR, where \f(CW$bar\fR and \f(CW$baz\fR may vary:
.PP
.Vb 1
\&    sub foo : Regex(\*(Aq^foo$\*(Aq) { my ($self, $context, $bar, $baz) = @_; }
.Ve
.PP
But what if you also defined actions for \f(CW\*(C`/foo/boo\*(C'\fR and \f(CW\*(C`/foo/boo/hoo\*(C'\fR?
.PP
.Vb 2
\&    sub boo : Path(\*(Aqfoo/boo\*(Aq) { .. }
\&    sub hoo : Path(\*(Aqfoo/boo/hoo\*(Aq) { .. }
.Ve
.PP
Catalyst matches actions in most specific to least specific order \- that is, whatever matches the most pieces of the path wins:
.PP
.Vb 3
\&    /foo/boo/hoo
\&    /foo/boo
\&    /foo # might be /foo/bar/baz but won\*(Aqt be /foo/boo/hoo
.Ve
.PP
So Catalyst would never mistakenly dispatch the first two URLs to the
\&'^foo$' action.
.PP
If a Regex or LocalRegex action doesn't use the '$' anchor, the action will
still match a \s-1URL\s0 containing arguments; however the arguments won't be
available via \f(CW@_\fR, because the Regex will 'eat' them.
.PP
Beware!  If you write two matchers, that match the same path, with the
same specificity (that is, they match the same quantity of the path),
there's no guarantee which will actually get called.  Non-regex
matchers get tried first, followed by regex ones, but if you have, for
instance:
.PP
.Vb 1
\&   package MyApp::Controller::Root;
\&
\&   sub match1 :Path(\*(Aq/a/b\*(Aq) { }
\&
\&   package MyApp::Controller::A;
\&
\&   sub b :Local { } # Matches /a/b
.Ve
.PP
then Catalyst will call the one it finds first.  In summary, Don't Do
This.
.PP
Query Parameter Processing
.IX Subsection "Query Parameter Processing"
.PP
Parameters passed in the \s-1URL\s0 query string are handled with methods in
the Catalyst::Request class. The \f(CW\*(C`param\*(C'\fR method is functionally
equivalent to the \f(CW\*(C`param\*(C'\fR method of \f(CW\*(C`CGI.pm\*(C'\fR and can be used in
modules that require this.
.PP
.Vb 3
\&    # http://localhost:3000/catalog/view/?category=hardware&page=3
\&    my $category = $c\->req\->param(\*(Aqcategory\*(Aq);
\&    my $current_page = $c\->req\->param(\*(Aqpage\*(Aq) || 1;
\&
\&    # multiple values for single parameter name
\&    my @values = $c\->req\->param(\*(Aqscrolling_list\*(Aq);
\&
\&    # DFV requires a CGI.pm\-like input hash
\&    my $results = Data::FormValidator\->check($c\->req\->params, \e%dfv_profile);
.Ve
.PP
\fIFlow Control\fR
.IX Subsection "Flow Control"
.PP
You control the application flow with the \f(CW\*(C`forward\*(C'\fR method, which
accepts the key of an action to execute. This can be an action in the
same or another Catalyst controller, or a Class name, optionally
followed by a method name. After a \f(CW\*(C`forward\*(C'\fR, the control flow will
return to the method from which the \f(CW\*(C`forward\*(C'\fR was issued.
.PP
A \f(CW\*(C`forward\*(C'\fR is similar to a method call. The main differences are that
it wraps the call in an \f(CW\*(C`eval\*(C'\fR to allow exception handling; it
automatically passes along the context object (\f(CW$c\fR or \f(CW$context\fR);
and it allows profiling of each call (displayed in the log with
debugging enabled).
.PP
.Vb 5
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&        $c\->forward(\*(Aqcheck_message\*(Aq); # $c is automatically included
\&    }
\&
\&    sub check_message : Private {
\&        my ( $self, $c ) = @_;
\&        return unless $c\->stash\->{message};
\&        $c\->forward(\*(Aqshow_message\*(Aq);
\&    }
\&
\&    sub show_message : Private {
\&        my ( $self, $c ) = @_;
\&        $c\->res\->body( $c\->stash\->{message} );
\&    }
.Ve
.PP
A \f(CW\*(C`forward\*(C'\fR does not create a new request, so your request object
(\f(CW\*(C`$c\->req\*(C'\fR) will remain unchanged. This is a key difference between
using \f(CW\*(C`forward\*(C'\fR and issuing a redirect.
.PP
You can pass new arguments to a \f(CW\*(C`forward\*(C'\fR by adding them
in an anonymous array. In this case \f(CW\*(C`$c\->req\->args\*(C'\fR
will be changed for the duration of the \f(CW\*(C`forward\*(C'\fR only; upon
return, the original value of \f(CW\*(C`$c\->req\->args\*(C'\fR will
be reset.
.PP
.Vb 6
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&        $c\->forward(\*(Aqcheck_message\*(Aq,[qw/test1/]);
\&        # now $c\->req\->args is back to what it was before
\&    }
\&
\&    sub check_message : Action {
\&        my ( $self, $c, $first_argument ) = @_;
\&        my $also_first_argument = $c\->req\->args\->[0]; # now = \*(Aqtest1\*(Aq
\&        # do something...
\&    }
.Ve
.PP
As you can see from these examples, you can just use the method name as
long as you are referring to methods in the same controller. If you want
to forward to a method in another controller, or the main application,
you will have to refer to the method by absolute path.
.PP
.Vb 2
\&  $c\->forward(\*(Aq/my/controller/action\*(Aq);
\&  $c\->forward(\*(Aq/default\*(Aq); # calls default in main application
.Ve
.PP
You can also forward to classes and methods.
.PP
.Vb 4
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->forward(qw/MyApp::View:Hello say_hello/);
\&    }
\&
\&    sub bye : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->forward(\*(AqMyApp::Model::Hello\*(Aq); # no method: will try \*(Aqprocess\*(Aq
\&    }
\&
\&    package MyApp::View::Hello;
\&
\&    sub say_hello {
\&        my ( $self, $c ) = @_;
\&        $c\->res\->body(\*(AqHello World!\*(Aq);
\&    }
\&
\&    sub process {
\&        my ( $self, $c ) = @_;
\&        $c\->res\->body(\*(AqGoodbye World!\*(Aq);
\&    }
.Ve
.PP
This mechanism is used by Catalyst::Action::RenderView to forward
to the \f(CW\*(C`process\*(C'\fR method in a view class.
.PP
It should be noted that whilst forward is useful, it is not the only way
of calling other code in Catalyst. Forward just gives you stats in the debug
screen, wraps the code you're calling in an exception handler and localises
\&\f(CW\*(C`$c\->request\->args\*(C'\fR.
.PP
If you don't want or need these features then it's perfectly acceptable
(and faster) to do something like this:
.PP
.Vb 5
\&    sub hello : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&        $self\->check_message( $c, \*(Aqtest1\*(Aq );
\&    }
\&    
\&    sub check_message {
\&        my ( $self, $c, $first_argument ) = @_;
\&        # do something...
\&    }
.Ve
.PP
Note that \f(CW\*(C`forward\*(C'\fR returns to the calling action and continues
processing after the action finishes. If you want all further processing
in the calling action to stop, use \f(CW\*(C`detach\*(C'\fR instead, which will execute
the \f(CW\*(C`detach\*(C'\fRed action and not return to the calling sub. In both cases,
Catalyst will automatically try to call \fIprocess()\fR if you omit the
method.
.PP
\fITesting\fR
.IX Subsection "Testing"
.PP
Catalyst has a built-in http server for testing or local
deployment. (Later, you can easily use a more powerful server, for
example Apache/mod_perl or FastCGI, in a production environment.)
.PP
Start your application on the command line...
.PP
.Vb 1
\&    script/myapp_server.pl
.Ve
.PP
\&...then visit http://localhost:3000/ in a browser to view the output.
.PP
You can also do it all from the command line:
.PP
.Vb 1
\&    script/myapp_test.pl http://localhost/
.Ve
.PP
Catalyst has a number of tools for actual regression testing of
applications. The helper scripts will automatically generate basic tests
that can be extended as you develop your project. To write your own
comprehensive test scripts, Test::WWW::Mechanize::Catalyst is an
invaluable tool.
.PP
For more testing ideas, see Catalyst::Manual::Tutorial::Testing.
.PP
Have fun!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst::Manual::About
.IP "\(bu" 4
Catalyst::Manual::Tutorial
.IP "\(bu" 4
Catalyst
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\s-1IRC:\s0
.PP
.Vb 2
\&    Join #catalyst on irc.perl.org.
\&    Join #catalyst\-dev on irc.perl.org to help with development.
.Ve
.PP
Mailing lists:
.PP
.Vb 2
\&    http://lists.scsys.co.uk/mailman/listinfo/catalyst
\&    http://lists.scsys.co.uk/mailman/listinfo/catalyst\-dev
.Ve
.PP
Wiki:
.PP
.Vb 1
\&    http://dev.catalystframework.org/wiki
.Ve
.PP
\&\s-1FAQ:\s0
.PP
.Vb 1
\&    http://dev.catalystframework.org/wiki/faq
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
