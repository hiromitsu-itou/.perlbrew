.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Tutorial::03_MoreCatalystBasics 3"
.TH Catalyst::Manual::Tutorial::03_MoreCatalystBasics 3 "2011-09-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Tutorial::03_MoreCatalystBasics \- Catalyst Tutorial \- Chapter 3: More Catalyst Application Development Basics
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This is \fBChapter 3 of 10\fR for the Catalyst tutorial.
.PP
Tutorial Overview
.IP "1." 4
Introduction
.IP "2." 4
Catalyst Basics
.IP "3." 4
\&\fB03_More Catalyst Basics\fR
.IP "4." 4
Basic \s-1CRUD\s0
.IP "5." 4
Authentication
.IP "6." 4
Authorization
.IP "7." 4
Debugging
.IP "8." 4
Testing
.IP "9." 4
Advanced \s-1CRUD\s0
.IP "10." 4
Appendices
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This chapter of the tutorial builds on the work done in Chapter 2 to
explore some features that are more typical of \*(L"real world\*(R" web
applications. From this chapter of the tutorial onward, we will be
building a simple book database application.  Although the application
will be too limited to be of use to anyone, it should provide a basic
environment where we can explore a variety of features used in virtually
all web applications.
.PP
Source code for the tutorial in included in the \fI/home/catalyst/Final\fR
directory of the Tutorial Virtual machine (one subdirectory per
chapter).  There are also instructions for downloading the code in
Catalyst::Manual::Tutorial::01_Intro.
.PP
Please take a look at
\&\*(L"\s-1STARTING\s0 \s-1WITH\s0 \s-1THE\s0 \s-1TUTORIAL\s0 \s-1VIRTUAL\s0 \s-1MACHINE\s0\*(R" in Catalyst::Manual::Tutorial::01_Intro
before doing the rest of this tutorial.  Although the tutorial should
work correctly under most any recent version of Perl running on any
operating system, the tutorial has been written using the virtual
machine that is available for download.  The entire tutorial has been
tested to be sure it runs correctly in this environment, so it is
the most trouble-free way to get started with Catalyst.
.SH "CREATE A NEW APPLICATION"
.IX Header "CREATE A NEW APPLICATION"
The remainder of the tutorial will build an application called \f(CW\*(C`MyApp\*(C'\fR.
First use the Catalyst \f(CW\*(C`catalyst.pl\*(C'\fR script to initialize the framework
for the \f(CW\*(C`MyApp\*(C'\fR application (make sure you aren't still inside the
directory of the \f(CW\*(C`Hello\*(C'\fR application from the previous chapter of the
tutorial or in a directory that already has a \*(L"MyApp\*(R" subdirectory):
.PP
.Vb 8
\&    $ catalyst.pl MyApp
\&    created "MyApp"
\&    created "MyApp/script"
\&    created "MyApp/lib"
\&    created "MyApp/root"
\&    ...
\&    created "MyApp/script/myapp_create.pl"
\&    Change to application directory and Run "perl Makefile.PL" to make sure your install is complete
.Ve
.PP
And change the \*(L"MyApp\*(R" directory the helper created:
.PP
.Vb 1
\&    $ cd MyApp
.Ve
.PP
This creates a similar skeletal structure to what we saw in Chapter 2 of
the tutorial, except with \f(CW\*(C`MyApp\*(C'\fR and \f(CW\*(C`myapp\*(C'\fR substituted for \f(CW\*(C`Hello\*(C'\fR
and \f(CW\*(C`hello\*(C'\fR.  (As noted in Chapter 2, omit the \*(L".pl\*(R" from the command
if you are using Strawberry Perl.)
.SH "EDIT THE LIST OF CATALYST PLUGINS"
.IX Header "EDIT THE LIST OF CATALYST PLUGINS"
One of the greatest benefits of Catalyst is that it has such a large
library of bases classes and plugins available that you can use easily
add functionality to your application. Plugins are used to seamlessly
integrate existing Perl modules into the overall Catalyst framework. In
general, they do this by adding additional methods to the \f(CW\*(C`context\*(C'\fR
object (generally written as \f(CW$c\fR) that Catalyst passes to every
component throughout the framework.
.PP
Take a look at the file \f(CW\*(C`lib/MyApp.pm\*(C'\fR that the helper created above.
By default, Catalyst enables three plugins/flags:
.IP "\(bu" 4
\&\f(CW\*(C`\-Debug\*(C'\fR Flag
.Sp
Enables the Catalyst debug output you saw when we started the
\&\f(CW\*(C`script/myapp_server.pl\*(C'\fR development server earlier.  You can remove
this item when you place your application into production.
.Sp
To be technically correct, it turns out that \f(CW\*(C`\-Debug\*(C'\fR is not a plugin,
but a \fIflag\fR.  Although most of the items specified on the \f(CW\*(C`use
Catalyst\*(C'\fR line of your application class will be plugins, Catalyst
supports a limited number of flag options (of these, \f(CW\*(C`\-Debug\*(C'\fR is the
most common).  See the documentation for
\&\f(CW\*(C`https://metacpan.org/module/Catalyst|Catalyst.pm\*(C'\fR to get details on
other flags (currently \f(CW\*(C`\-Engine\*(C'\fR, \f(CW\*(C`\-Home\*(C'\fR, \f(CW\*(C`\-Log\*(C'\fR, and \f(CW\*(C`\-Stats\*(C'\fR).
.Sp
If you prefer, there are several other ways to enable debug output:
.RS 4
.IP "\(bu" 4
Use the \f(CW\*(C`$c\->debug\*(C'\fR method on the \f(CW$c\fR Catalyst context object
.IP "\(bu" 4
The \f(CW\*(C`\-d\*(C'\fR option to \f(CW\*(C`script/myapp_server.pl\*(C'\fR
.IP "\(bu" 4
The \f(CW\*(C`CATALYST_DEBUG=1\*(C'\fR environment variable (or use \f(CW\*(C`CATALYST_DEBUG=0\*(C'\fR
to temporarily disable debug output).
.RE
.RS 4
.Sp
\&\fB\s-1TIP\s0\fR: Depending on your needs, it can be helpful to permanently remove
\&\f(CW\*(C`\-Debug\*(C'\fR from \f(CW\*(C`lib/MyApp.pm\*(C'\fR and then use the \f(CW\*(C`\-d\*(C'\fR option to
\&\f(CW\*(C`script/myapp_server.pl\*(C'\fR to re-enable it when needed.  We will not be
using that approach in the tutorial, but feel free to make use of it in
your own projects.
.RE
.IP "\(bu" 4
Catalyst::Plugin::ConfigLoader
.Sp
\&\f(CW\*(C`ConfigLoader\*(C'\fR provides an automatic way to load configurable
parameters for your application from a central
Config::General file (versus having the values
hard-coded inside your Perl modules).  Config::General uses syntax very
similar to Apache configuration files.  We will see how to use this
feature of Catalyst during the authentication and authorization sections
(Chapter 5 and
Chapter 6).
.Sp
\&\fB\s-1IMPORTANT\s0 \s-1NOTE:\s0\fR If you are using a version of
Catalyst::Devel prior to version 1.06, be aware that
Catalyst changed the default format from \s-1YAML\s0 to the more
straightforward \f(CW\*(C`Config::General\*(C'\fR style.  This tutorial uses the newer
\&\f(CW\*(C`myapp.conf\*(C'\fR file for \f(CW\*(C`Config::General\*(C'\fR. However, Catalyst supports
both formats and will automatically use either \f(CW\*(C`myapp.conf\*(C'\fR or
\&\f(CW\*(C`myapp.yml\*(C'\fR (or any other format supported by
Catalyst::Plugin::ConfigLoader and
Config::Any).  If you are using a version of
Catalyst::Devel prior to 1.06, you can convert to the newer format by
simply creating the \f(CW\*(C`myapp.conf\*(C'\fR file manually and deleting
\&\f(CW\*(C`myapp.yml\*(C'\fR.  The default contents of the \f(CW\*(C`myapp.conf\*(C'\fR you create
should only consist of one line:
.Sp
.Vb 1
\&    name MyApp
.Ve
.Sp
\&\fB\s-1TIP\s0\fR: This script can be useful for converting between configuration
formats:
.Sp
.Vb 2
\&    perl \-Ilib \-e \*(Aquse MyApp; use Config::General;
\&        Config::General\->new\->save_file("myapp.conf", MyApp\->config);\*(Aq
.Ve
.IP "\(bu" 4
Catalyst::Plugin::Static::Simple
.Sp
\&\f(CW\*(C`Static::Simple\*(C'\fR provides an easy way to serve static content, such as
images and \s-1CSS\s0 files, from the development server.
.PP
For our application, we want to add one new plugin into the mix.  To do
this, edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR (this file is generally referred to as your
\&\fIapplication class\fR) and delete the lines with:
.PP
.Vb 5
\&    use Catalyst qw/
\&        \-Debug
\&        ConfigLoader
\&        Static::Simple
\&    /;
.Ve
.PP
Then replace it with:
.PP
.Vb 5
\&    # Load plugins
\&    use Catalyst qw/
\&        \-Debug
\&        ConfigLoader
\&        Static::Simple
\&    
\&        StackTrace
\&    /;
.Ve
.PP
\&\fBNote:\fR Recent versions of \f(CW\*(C`Catalyst::Devel\*(C'\fR have used a variety of
techniques to load these plugins/flags.  For example, you might see the
following:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->setup(qw/\-Debug ConfigLoader Static::Simple/);
.Ve
.PP
Don't let these variations confuse you \*(-- they all accomplish the same
result.
.PP
This tells Catalyst to start using one additional plugin,
Catalyst::Plugin::StackTrace, to add a stack trace near the top of
the standard Catalyst \*(L"debug screen\*(R" (the screen Catalyst sends to your
browser when an error occurs). Be aware that
StackTrace output appears in your
browser, not in the console window from which you're running your
application, which is where logging output usually goes.
.PP
Make sure when adding new plugins you also include them as a new
dependency within the Makefile.PL file. For example, after adding the
StackTrace plugin the Makefile.PL should include the following line:
.PP
.Vb 1
\&    requires \*(AqCatalyst::Plugin::StackTrace\*(Aq;
.Ve
.PP
\&\fBNotes:\fR
.IP "\(bu" 4
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR is just a shorthand way of referencing the name of the
package where it is used.  Therefore, in \f(CW\*(C`MyApp.pm\*(C'\fR, \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR is
equivalent to \f(CW\*(C`MyApp\*(C'\fR.
.IP "\(bu" 4
You will want to disable StackTrace
before you put your application into production, but it can be helpful
during development.
.IP "\(bu" 4
When specifying plugins, you can omit \f(CW\*(C`Catalyst::Plugin::\*(C'\fR from the
name.  Additionally, you can spread the plugin names across multiple
lines as shown here or place them all on one line.
.IP "\(bu" 4
If you want to see what the StackTrace error screen looks like, edit
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR and put a \f(CW\*(C`die "Oops";\*(C'\fR command in the
\&\f(CW\*(C`sub index :Path :Args(0)\*(C'\fR method.  Then start the development server
and open \f(CW\*(C`http://localhost:3000/\*(C'\fR in your browser.  You should get a
screen that starts with \*(L"Caught exception in
MyApp::Controller::Root\->index\*(R" with sections showing a stacktrace,
information about the Request and Response objects, the stash (something
we will learn about soon), the applications configuration configuration.
\&\fBJust don't forget to remove the die before you continue the tutorial!\fR
:\-)
.SH "CREATE A CATALYST CONTROLLER"
.IX Header "CREATE A CATALYST CONTROLLER"
As discussed earlier, controllers are where you write methods that
interact with user input.  Typically, controller methods respond to
\&\f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR requests from the user's web browser.
.PP
Use the Catalyst \f(CW\*(C`create\*(C'\fR script to add a controller for book-related
actions:
.PP
.Vb 5
\&    $ script/myapp_create.pl controller Books
\&     exists "/home/catalyst/MyApp/script/../lib/MyApp/Controller"
\&     exists "/home/catalyst/MyApp/script/../t"
\&    created "/home/catalyst/MyApp/script/../lib/MyApp/Controller/Books.pm"
\&    created "/home/catalyst/MyApp/script/../t/controller_Books.t"
.Ve
.PP
Then edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR (as discussed in
Chapter 2 of
the Tutorial, Catalyst has a separate directory under \f(CW\*(C`lib/MyApp\*(C'\fR for
each of the three parts of \s-1MVC:\s0 \f(CW\*(C`Model\*(C'\fR, \f(CW\*(C`View\*(C'\fR, and \f(CW\*(C`Controller\*(C'\fR)
and add the following method to the controller:
.PP
.Vb 1
\&    =head2 list
\&    
\&    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
\&    
\&    =cut
\&    
\&    sub list :Local {
\&        # Retrieve the usual Perl OO \*(Aq$self\*(Aq for this object. $c is the Catalyst
\&        # \*(AqContext\*(Aq that\*(Aqs used to \*(Aqglue together\*(Aq the various components
\&        # that make up the application
\&        my ($self, $c) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store in the
\&        # stash where they can be accessed by the TT template
\&        # $c\->stash(books => [$c\->model(\*(AqDB::Book\*(Aq)\->all]);
\&        # But, for now, use this code until we create the model later
\&        $c\->stash(books => \*(Aq\*(Aq);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (action methods respond to user input in
\&        # your controllers).
\&        $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
\&\fB\s-1TIP\s0\fR: See Appendix 1 for
tips on removing the leading spaces when cutting and pasting example
code from POD-based documents.
.PP
Programmers experienced with object-oriented Perl should recognize
\&\f(CW$self\fR as a reference to the object where this method was called.  On
the other hand, \f(CW$c\fR will be new to many Perl programmers who have not
used Catalyst before.  This is the \*(L"Catalyst Context object\*(R", and it is
automatically passed as the second argument to all Catalyst action
methods.  It is used to pass information between components and provide
access to Catalyst and plugin functionality.
.PP
Catalyst Controller actions are regular Perl methods, but they make use
of attributes (the "\f(CW\*(C`:Local\*(C'\fR\*(L" next to the \*(R"\f(CW\*(C`sub list\*(C'\fR" in the code
above) to provide additional information to the Catalyst dispatcher
logic (note that there can be an optional space between the colon and
the attribute name; you will see attributes written both ways).  Most
Catalyst Controllers use one of five action types:
.IP "\(bu" 4
\&\fB:Private\fR \*(-- Use \f(CW\*(C`:Private\*(C'\fR for methods that you want to make into an
action, but you do not want Catalyst to directly expose the method to
your users.  Catalyst will not map \f(CW\*(C`:Private\*(C'\fR methods to a \s-1URI\s0.  Use
them for various sorts of \*(L"special\*(R" methods (the \f(CW\*(C`begin\*(C'\fR, \f(CW\*(C`auto\*(C'\fR, etc.
discussed below) or for methods you want to be able to \f(CW\*(C`forward\*(C'\fR or
\&\f(CW\*(C`detach\*(C'\fR to.  (If the method is a \*(L"plain old method\*(R" that you
don't want to be an action at all, then just define the method without
any attribute \*(-- you can call it in your code, but the Catalyst
dispatcher will ignore it.  You will also have to manually include
\&\f(CW$c\fR if you want access to the context object in the method vs. having
Catalyst automatically include \f(CW$c\fR in the argument list for you
if it's a full-fledged action.)
.Sp
There are five types of \*(L"special\*(R" built-in \f(CW\*(C`:Private\*(C'\fR actions:
\&\f(CW\*(C`begin\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`index\*(C'\fR, and \f(CW\*(C`auto\*(C'\fR.
.RS 4
.IP "\(bu" 4
With \f(CW\*(C`begin\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`index\*(C'\fR private actions, only the
most specific action of each type will be called.  For example, if you
define a \f(CW\*(C`begin\*(C'\fR action in your controller it will \fIoverride\fR a
\&\f(CW\*(C`begin\*(C'\fR action in your application/root controller \*(-- \fIonly\fR the
action in your controller will be called.
.IP "\(bu" 4
Unlike the other actions where only a single method is called for each
request, \fIevery\fR auto action along the chain of namespaces will be
called.  Each \f(CW\*(C`auto\*(C'\fR action will be called \fIfrom the application/root
controller down through the most specific class\fR.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fB:Path\fR \*(-- \f(CW\*(C`:Path\*(C'\fR actions let you map a method to an explicit \s-1URI\s0
path.  For example, "\f(CW\*(C`:Path(\*(Aqlist\*(Aq)\*(C'\fR" in
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR would match on the \s-1URL\s0
\&\f(CW\*(C`http://localhost:3000/books/list\*(C'\fR, but "\f(CW\*(C`:Path(\*(Aq/list\*(Aq)\*(C'\fR" would match
on \f(CW\*(C`http://localhost:3000/list\*(C'\fR (because of the leading slash).  You
can use \f(CW\*(C`:Args()\*(C'\fR to specify how many arguments an action should
accept.  See \*(L"Action_types\*(R" in Catalyst::Manual::Intro for more
information and examples.
.IP "\(bu" 4
\&\fB:Local\fR \*(-- \f(CW\*(C`:Local\*(C'\fR is merely a shorthand for
"\f(CW\*(C`:Path(\*(Aq_name_of_method_\*(Aq)\*(C'\fR\*(L".  For example, these are equivalent:
\&\*(R"\f(CW\*(C`sub create_book :Local {...}\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`sub create_book :Path(\*(Aqcreate_book\*(Aq) {...}\*(C'\fR".
.IP "\(bu" 4
\&\fB:Global\fR \*(-- \f(CW\*(C`:Global\*(C'\fR is merely a shorthand for
"\f(CW\*(C`:Path(\*(Aq/_name_of_method_\*(Aq)\*(C'\fR\*(L".  For example, these are equivalent:
\&\*(R"\f(CW\*(C`sub create_book :Global {...}\*(C'\fR\*(L" and \*(R"\f(CW\*(C`sub create_book
:Path(\*(Aq/create_book\*(Aq) {...}\*(C'\fR".
.IP "\(bu" 4
\&\fB:Chained\fR \*(-- Newer Catalyst applications tend to use the Chained
dispatch form of action types because of its power and flexibility.  It
allows a series of controller methods to be automatically dispatched
when servicing a single user request.  See
Catalyst::Manual::Tutorial::04_BasicCRUD and
Catalyst::DispatchType::Chained for more information on chained
actions.
.PP
You should refer to \*(L"Action-types\*(R" in Catalyst::Manual::Intro for
additional information and for coverage of some lesser-used action types
not discussed here (\f(CW\*(C`Regex\*(C'\fR and \f(CW\*(C`LocalRegex\*(C'\fR).
.SH "CATALYST VIEWS"
.IX Header "CATALYST VIEWS"
As mentioned in Chapter 2
of the tutorial, views are where you render output, typically for
display in the user's web browser (but can generate other types of
output such as \s-1PDF\s0 or \s-1JSON\s0).  The code in \f(CW\*(C`lib/MyApp/View\*(C'\fR selects the
\&\fItype\fR of view to use, with the actual rendering template found in the
\&\f(CW\*(C`root\*(C'\fR directory.  As with virtually every aspect of Catalyst, options
abound when it comes to the specific view technology you adopt inside
your application. However, most Catalyst applications use the Template
Toolkit, known as \s-1TT\s0 (for more information on \s-1TT\s0, see
http://www.template\-toolkit.org <http://www.template-toolkit.org>). Other somewhat popular view
technologies include Mason (<http://www.masonhq.com> and
<http://www.masonbook.com>) and HTML::Template
(http://html\-template.sourceforge.net <http://html-template.sourceforge.net>).
.SS "Create a Catalyst View"
.IX Subsection "Create a Catalyst View"
When using \s-1TT\s0 for the Catalyst view, the main helper script is
Catalyst::Helper::View::TT.  You may also come across references to
Catalyst::Helper::View::TTSite, but its use is now deprecated.
.PP
For our book application, enter the following command to enable the
\&\f(CW\*(C`TT\*(C'\fR style of view rendering:
.PP
.Vb 5
\&    $ script/myapp_create.pl view HTML TT
\&     exists "/home/catalyst/MyApp/script/../lib/MyApp/View"
\&     exists "/home/catalyst/MyApp/script/../t"
\&     created "/home/catalyst/MyApp/script/../lib/MyApp/View/HTML.pm"
\&     created "/home/catalyst/MyApp/script/../t/view_HTML.t"
.Ve
.PP
This creates a view called \f(CW\*(C`HTML\*(C'\fR (the first argument) in a file called
\&\f(CW\*(C`HTML.pm\*(C'\fR that uses Catalyst::View::TT (the second argument) as the
\&\*(L"rendering engine\*(R".
.PP
It is now up to you to decide how you want to structure your view
layout.  For the tutorial, we will start with a very simple \s-1TT\s0 template
to initially demonstrate the concepts, but quickly migrate to a more
typical \*(L"wrapper page\*(R" type of configuration (where the \*(L"wrapper\*(R"
controls the overall \*(L"look and feel\*(R" of your site from a single file or
set of files).
.PP
Edit \f(CW\*(C`lib/MyApp/View/HTML.pm\*(C'\fR and you should see something similar to
the following:
.PP
.Vb 4
\&    _\|_PACKAGE_\|_\->config(
\&        TEMPLATE_EXTENSION => \*(Aq.tt\*(Aq,
\&        render_die => 1,
\&    );
.Ve
.PP
And update it to match:
.PP
.Vb 5
\&    _\|_PACKAGE_\|_\->config(
\&        # Change default TT extension
\&        TEMPLATE_EXTENSION => \*(Aq.tt2\*(Aq,
\&        render_die => 1,
\&    );
.Ve
.PP
This changes the default extension for Template Toolkit from '.tt' to
\&'.tt2'.
.PP
You can also configure components in your application class. For
example, Edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and you should see the default
configuration above the call to \f(CW\*(C`_PACKAGE_\|_\->setup\*(C'\fR (your defaults
could be different depending on the version of Catalyst you are using):
.PP
.Vb 5
\&    _\|_PACKAGE_\|_\->config(
\&        name => \*(AqMyApp\*(Aq,
\&        # Disable deprecated behavior needed by old applications
\&        disable_component_resolution_regex_fallback => 1,
\&    );
.Ve
.PP
Change this to match the following (insert a new
\&\f(CW\*(C`_\|_PACKAGE_\|_\->config\*(C'\fR below the existing statement):
.PP
.Vb 10
\&    _\|_PACKAGE_\|_\->config(
\&        name => \*(AqMyApp\*(Aq,
\&        # Disable deprecated behavior needed by old applications
\&        disable_component_resolution_regex_fallback => 1,
\&    );
\&    _\|_PACKAGE_\|_\->config(
\&        # Configure the view
\&        \*(AqView::HTML\*(Aq => {
\&            #Set the location for TT files
\&            INCLUDE_PATH => [
\&                _\|_PACKAGE_\|_\->path_to( \*(Aqroot\*(Aq, \*(Aqsrc\*(Aq ),
\&            ],
\&        },
\&    );
.Ve
.PP
This changes the base directory for your template files from \f(CW\*(C`root\*(C'\fR to
\&\f(CW\*(C`root/src\*(C'\fR.
.PP
Please stick with the settings above for the duration of the tutorial,
but feel free to use whatever options you desire in your applications
(as with most things Perl, there's more than one way to do it...).
.PP
\&\fBNote:\fR We will use \f(CW\*(C`root/src\*(C'\fR as the base directory for our template
files, with a full naming convention of
\&\f(CW\*(C`root/src/_controller_name_/_action_name_.tt2\*(C'\fR.  Another popular option
is to use \f(CW\*(C`root/\*(C'\fR as the base (with a full filename pattern of
\&\f(CW\*(C`root/_controller_name_/_action_name_.tt2\*(C'\fR).
.SS "Create a \s-1TT\s0 Template Page"
.IX Subsection "Create a TT Template Page"
First create a directory for book-related \s-1TT\s0 templates:
.PP
.Vb 1
\&    $ mkdir \-p root/src/books
.Ve
.PP
Then create \f(CW\*(C`root/src/books/list.tt2\*(C'\fR in your editor and enter:
.PP
.Vb 1
\&    [% # This is a TT comment. \-%]
\&    
\&    [%\- # Provide a title \-%]
\&    [% META title = \*(AqBook List\*(Aq \-%]
\&    
\&    [% # Note That the \*(Aq\-\*(Aq at the beginning or end of TT code  \-%]
\&    [% # "chomps" the whitespace/newline at that end of the    \-%]
\&    [% # output (use View Source in browser to see the effect) \-%]
\&    
\&    [% # Some basic HTML with a loop to display books \-%]
\&    <table>
\&    <tr><th>Title</th><th>Rating</th><th>Author(s)</th></tr>
\&    [% # Display each book in a table row %]
\&    [% FOREACH book IN books \-%]
\&      <tr>
\&        <td>[% book.title %]</td>
\&        <td>[% book.rating %]</td>
\&        <td></td>
\&      </tr>
\&    [% END \-%]
\&    </table>
.Ve
.PP
As indicated by the inline comments above, the \f(CW\*(C`META title\*(C'\fR line uses
\&\s-1TT\s0's \s-1META\s0 feature to provide a title to the \*(L"wrapper\*(R" that we will
create later (and essentially does nothing at the moment). Meanwhile,
the \f(CW\*(C`FOREACH\*(C'\fR loop iterates through each \f(CW\*(C`book\*(C'\fR model object and
prints the \f(CW\*(C`title\*(C'\fR and \f(CW\*(C`rating\*(C'\fR fields.
.PP
The \f(CW\*(C`[%\*(C'\fR and \f(CW\*(C`%]\*(C'\fR tags are used to delimit Template Toolkit code.  \s-1TT\s0
supports a wide variety of directives for \*(L"calling\*(R" other files,
looping, conditional logic, etc.  In general, \s-1TT\s0 simplifies the usual
range of Perl operators down to the single dot (\*(L".\*(R") operator.  This
applies to operations as diverse as method calls, hash lookups, and list
index values (see Template::Manual::Variables for details and
examples).  In addition to the usual Template::Toolkit module Pod
documentation, you can access the \s-1TT\s0 manual at
<https://metacpan.org/module/Template::Manual>.
.PP
\&\fB\s-1TIP:\s0\fR While you can build all sorts of complex logic into your \s-1TT\s0
templates, you should in general keep the \*(L"code\*(R" part of your templates
as simple as possible.  If you need more complex logic, create helper
methods in your model that abstract out a set of code into a single call
from your \s-1TT\s0 template.  (Note that the same is true of your controller
logic as well \*(-- complex sections of code in your controllers should
often be pulled out and placed into your model objects.)  In
Chapter 4 of the tutorial we
will explore some extremely helpful and powerful features of
DBIx::Class that allow you to pull code out of your views and
controllers and place it where it rightfully belongs in a model class.
.SS "Test Run The Application"
.IX Subsection "Test Run The Application"
To test your work so far, first start the development server:
.PP
.Vb 1
\&    $ script/myapp_server.pl \-r
.Ve
.PP
Then point your browser to <http://localhost:3000> and you should still
get the Catalyst welcome page.  Next, change the \s-1URL\s0 in your browser to
<http://localhost:3000/books/list>.  If you have everything working so
far, you should see a web page that displays nothing other than our
column headers for \*(L"Title\*(R", \*(L"Rating\*(R", and \*(L"Author(s)\*(R" \*(-- we will not see
any books until we get the database and model working below.
.PP
If you run into problems getting your application to run correctly, it
might be helpful to refer to some of the debugging techniques covered in
the Debugging chapter of the
tutorial.
.SH "CREATE A SQLITE DATABASE"
.IX Header "CREATE A SQLITE DATABASE"
In this step, we make a text file with the required \s-1SQL\s0 commands to
create a database table and load some sample data.  We will use SQLite
(<http://www.sqlite.org>), a popular database that is lightweight and
easy to use. Be sure to get at least version 3. Open \f(CW\*(C`myapp01.sql\*(C'\fR in
your editor and enter:
.PP
.Vb 10
\&    \-\-
\&    \-\- Create a very simple database to hold book and author information
\&    \-\-
\&    PRAGMA foreign_keys = ON;
\&    CREATE TABLE book (
\&            id          INTEGER PRIMARY KEY,
\&            title       TEXT ,
\&            rating      INTEGER
\&    );
\&    \-\- \*(Aqbook_author\*(Aq is a many\-to\-many join table between books & authors
\&    CREATE TABLE book_author (
\&            book_id     INTEGER REFERENCES book(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            author_id   INTEGER REFERENCES author(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            PRIMARY KEY (book_id, author_id)
\&    );
\&    CREATE TABLE author (
\&            id          INTEGER PRIMARY KEY,
\&            first_name  TEXT,
\&            last_name   TEXT
\&    );
\&    \-\-\-
\&    \-\-\- Load some sample data
\&    \-\-\-
\&    INSERT INTO book VALUES (1, \*(AqCCSP SNRS Exam Certification Guide\*(Aq, 5);
\&    INSERT INTO book VALUES (2, \*(AqTCP/IP Illustrated, Volume 1\*(Aq, 5);
\&    INSERT INTO book VALUES (3, \*(AqInternetworking with TCP/IP Vol.1\*(Aq, 4);
\&    INSERT INTO book VALUES (4, \*(AqPerl Cookbook\*(Aq, 5);
\&    INSERT INTO book VALUES (5, \*(AqDesigning with Web Standards\*(Aq, 5);
\&    INSERT INTO author VALUES (1, \*(AqGreg\*(Aq, \*(AqBastien\*(Aq);
\&    INSERT INTO author VALUES (2, \*(AqSara\*(Aq, \*(AqNasseh\*(Aq);
\&    INSERT INTO author VALUES (3, \*(AqChristian\*(Aq, \*(AqDegu\*(Aq);
\&    INSERT INTO author VALUES (4, \*(AqRichard\*(Aq, \*(AqStevens\*(Aq);
\&    INSERT INTO author VALUES (5, \*(AqDouglas\*(Aq, \*(AqComer\*(Aq);
\&    INSERT INTO author VALUES (6, \*(AqTom\*(Aq, \*(AqChristiansen\*(Aq);
\&    INSERT INTO author VALUES (7, \*(AqNathan\*(Aq, \*(AqTorkington\*(Aq);
\&    INSERT INTO author VALUES (8, \*(AqJeffrey\*(Aq, \*(AqZeldman\*(Aq);
\&    INSERT INTO book_author VALUES (1, 1);
\&    INSERT INTO book_author VALUES (1, 2);
\&    INSERT INTO book_author VALUES (1, 3);
\&    INSERT INTO book_author VALUES (2, 4);
\&    INSERT INTO book_author VALUES (3, 5);
\&    INSERT INTO book_author VALUES (4, 6);
\&    INSERT INTO book_author VALUES (4, 7);
\&    INSERT INTO book_author VALUES (5, 8);
.Ve
.PP
Then use the following command to build a \f(CW\*(C`myapp.db\*(C'\fR SQLite database:
.PP
.Vb 1
\&    $ sqlite3 myapp.db < myapp01.sql
.Ve
.PP
If you need to create the database more than once, you probably want to
issue the \f(CW\*(C`rm myapp.db\*(C'\fR command to delete the database before you use
the \f(CW\*(C`sqlite3 myapp.db < myapp01.sql\*(C'\fR command.
.PP
Once the \f(CW\*(C`myapp.db\*(C'\fR database file has been created and initialized, you
can use the SQLite command line environment to do a quick dump of the
database contents:
.PP
.Vb 12
\&    $ sqlite3 myapp.db
\&    SQLite version 3.7.3
\&    Enter ".help" for instructions
\&    Enter SQL statements terminated with a ";"
\&    sqlite> select * from book;
\&    1|CCSP SNRS Exam Certification Guide|5
\&    2|TCP/IP Illustrated, Volume 1|5
\&    3|Internetworking with TCP/IP Vol.1|4
\&    4|Perl Cookbook|5
\&    5|Designing with Web Standards|5
\&    sqlite> .q
\&    $
.Ve
.PP
Or:
.PP
.Vb 6
\&    $ sqlite3 myapp.db "select * from book"
\&    1|CCSP SNRS Exam Certification Guide|5
\&    2|TCP/IP Illustrated, Volume 1|5
\&    3|Internetworking with TCP/IP Vol.1|4
\&    4|Perl Cookbook|5
\&    5|Designing with Web Standards|5
.Ve
.PP
As with most other \s-1SQL\s0 tools, if you are using the full \*(L"interactive\*(R"
environment you need to terminate your \s-1SQL\s0 commands with a \*(L";\*(R" (it's not
required if you do a single \s-1SQL\s0 statement on the command line).  Use
\&\*(L".q\*(R" to exit from SQLite from the SQLite interactive mode and return to
your \s-1OS\s0 command prompt.
.PP
Please note that here we have chosen to use 'singular' table names. This
is because the default inflection code for older versions of
DBIx::Class::Schema::Loader does \s-1NOT\s0 handle plurals. There has been
much philosophical discussion on whether table names should be plural or
singular.  There is no one correct answer, as long as one makes a choice
and remains consistent with it. If you prefer plural table names (e.g.
you think that they are easier to read) then see the documentation in
\&\*(L"naming\*(R" in DBIx::Class::Schema::Loader::Base (version 0.05 or greater).
.PP
For using other databases, such as PostgreSQL or MySQL, see
Appendix 2.
.SH "DATABASE ACCESS WITH DBIx::Class"
.IX Header "DATABASE ACCESS WITH DBIx::Class"
Catalyst can be used with virtually any form of datastore available via
Perl.  For example, Catalyst::Model::DBI can be used to access
databases through the traditional Perl \s-1DBI\s0 interface or you can use a
model to access files of any type on the filesystem.  However, most
Catalyst applications use some form of object-relational mapping (\s-1ORM\s0)
technology to create objects associated with tables in a relational
database, and Matt Trout's DBIx::Class (abbreviated as \*(L"\s-1DBIC\s0\*(R") is the
usual choice (this tutorial will use DBIx::Class).
.PP
Although DBIx::Class has included support for a \f(CW\*(C`create=dynamic\*(C'\fR mode
to automatically read the database structure every time the application
starts, its use is no longer recommended.  While it can make for
\&\*(L"flashy\*(R" demos, the use of the \f(CW\*(C`create=static\*(C'\fR mode we use below can be
implemented just as quickly and provides many advantages (such as the
ability to add your own methods to the overall \s-1DBIC\s0 framework, a
technique that we see in
Chapter 4).
.SS "Create Static DBIx::Class Schema Files"
.IX Subsection "Create Static DBIx::Class Schema Files"
\&\fBNote:\fR If you are not following along in the Tutorial Virtual Machine,
please be sure that you have version 1.27 or higher of DBD::SQLite and
version 0.39 or higher of Catalyst::Model::DBIC::Schema.  (The Tutorial
\&\s-1VM\s0 already has versions that are known to work.)  You can get your
currently installed version numbers with the following commands.
.PP
.Vb 2
\&    $ perl \-MCatalyst::Model::DBIC::Schema\e 999
\&    $ perl \-MDBD::SQLite\e 999
.Ve
.PP
Before you continue, make sure your \f(CW\*(C`myapp.db\*(C'\fR database file is in the
application's topmost directory. Now use the model helper with the
\&\f(CW\*(C`create=static\*(C'\fR option to read the database with
DBIx::Class::Schema::Loader and
automatically build the required files for us:
.PP
.Vb 9
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
\&     exists "/home/catalyst/MyApp/script/../lib/MyApp/Model"
\&     exists "/home/catalyst/MyApp/script/../t"
\&    Dumping manual schema for MyApp::Schema to directory /home/catalyst/MyApp/script/../lib ...
\&    Schema dump completed.
\&    created "/home/catalyst/MyApp/script/../lib/MyApp/Model/DB.pm"
\&    created "/home/catalyst/MyApp/script/../t/model_DB.t"
.Ve
.PP
Please note the '\e' above.  Depending on your environment, you might be
able to cut and paste the text as shown or need to remove the '\e'
character to that the command is all on a single line.
.PP
The \f(CW\*(C`script/myapp_create.pl\*(C'\fR command breaks down like this:
.IP "\(bu" 4
\&\f(CW\*(C`DB\*(C'\fR is the name of the model class to be created by the helper in
the \f(CW\*(C`lib/MyApp/Model\*(C'\fR directory.
.IP "\(bu" 4
\&\f(CW\*(C`DBIC::Schema\*(C'\fR is the type of the model to create.  This equates to
Catalyst::Model::DBIC::Schema, the standard way to use a DBIC-based
model inside of Catalyst.
.IP "\(bu" 4
\&\f(CW\*(C`MyApp::Schema\*(C'\fR is the name of the \s-1DBIC\s0 schema file written to
\&\f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`create=static\*(C'\fR causes DBIx::Class::Schema::Loader to load the
schema as it runs and then write that information out into
\&\f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR and files under the \f(CW\*(C`lib/MyApp/Schema\*(C'\fR
directory.
.IP "\(bu" 4
\&\f(CW\*(C`dbi:SQLite:myapp.db\*(C'\fR is the standard \s-1DBI\s0 connect string for use with
SQLite.
.IP "\(bu" 4
And finally, the \f(CW\*(C`on_connect_do\*(C'\fR string requests that
DBIx::Class::Schema::Loader create
foreign key relationships for us (this is not needed for databases such
as PostgreSQL and MySQL, but is required for SQLite). If you take a look
at \f(CW\*(C`lib/MyApp/Model/DB.pm\*(C'\fR, you will see that the SQLite pragma is
propagated to the Model, so that SQLite's recent (and optional) foreign
key enforcement is enabled at the start of every database connection.
.PP
If you look in the \f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR file, you will find that it
only contains a call to the \f(CW\*(C`load_namespaces\*(C'\fR method.  You will also
find that \f(CW\*(C`lib/MyApp\*(C'\fR contains a \f(CW\*(C`Schema\*(C'\fR subdirectory, which then has
a subdirectory called \*(L"Result\*(R".  This \*(L"Result\*(R" subdirectory then has
files named according to each of the tables in our simple database
(\f(CW\*(C`Author.pm\*(C'\fR, \f(CW\*(C`BookAuthor.pm\*(C'\fR, and \f(CW\*(C`Book.pm\*(C'\fR).  These three files are
called \*(L"Result Classes\*(R" (or
"ResultSource Classes") in DBIx::Class
nomenclature. Although the Result Class files are named after tables in
our database, the classes correspond to the \fIrow-level data\fR that is
returned by \s-1DBIC\s0 (more on this later, especially in
\&\*(L"\s-1EXPLORING\s0 \s-1THE\s0 \s-1POWER\s0 \s-1OF\s0 \s-1DBIC\s0\*(R" in Catalyst::Manual::Tutorial::04_BasicCRUD).
.PP
The idea with the Result Source files created under
\&\f(CW\*(C`lib/MyApp/Schema/Result\*(C'\fR by the \f(CW\*(C`create=static\*(C'\fR option is to only
edit the files below the \f(CW\*(C`# DO NOT MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR
warning. If you place all of your changes below that point in the file,
you can regenerate the automatically created information at the top of
each file should your database structure get updated.
.PP
Also note the \*(L"flow\*(R" of the model information across the various files
and directories.  Catalyst will initially load the model from
\&\f(CW\*(C`lib/MyApp/Model/DB.pm\*(C'\fR.  This file contains a reference to
\&\f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR, so that file is loaded next.  Finally, the call
to \f(CW\*(C`load_namespaces\*(C'\fR in \f(CW\*(C`Schema.pm\*(C'\fR will load each of the \*(L"Result
Class\*(R" files from the \f(CW\*(C`lib/MyApp/Schema/Result\*(C'\fR subdirectory.  The
final outcome is that Catalyst will dynamically create three
table-specific Catalyst models every time the application starts (you
can see these three model files listed in the debug output generated
when you launch the application).
.PP
Additionally, the \f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR model can easily be loaded
outside of Catalyst, for example, in command-line utilities and/or cron
jobs. \f(CW\*(C`lib/MyApp/Model/DB.pm\*(C'\fR provides a very thin \*(L"bridge\*(R" between
Catalyst this external database model.  Once you see how we can add some
powerful features to our \s-1DBIC\s0 model in
Chapter 4, the elegance
of this approach will start to become more obvious.
.PP
\&\fB\s-1NOTE:\s0\fR Older versions of
Catalyst::Model::DBIC::Schema use the
deprecated DBIx::Class \f(CW\*(C`load_classes\*(C'\fR technique instead of the newer
\&\f(CW\*(C`load_namespaces\*(C'\fR.  For new applications, please try to use
\&\f(CW\*(C`load_namespaces\*(C'\fR since it more easily supports a very useful \s-1DBIC\s0
technique called \*(L"ResultSet Classes.\*(R"  If you need to convert an
existing application from \*(L"load_classes\*(R" to \*(L"load_namespaces,\*(R" you can
use this process to automate the migration, but first make sure you have
version \f(CW0.39\fR of Catalyst::Model::DBIC::Schema and
DBIx::Class::Schema::Loader version \f(CW0.05000\fR or later.
.PP
.Vb 5
\&    $ # Re\-run the helper to upgrade for you
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static naming=current use_namespaces=1 \e
\&        dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
.Ve
.SH "ENABLE THE MODEL IN THE CONTROLLER"
.IX Header "ENABLE THE MODEL IN THE CONTROLLER"
Open \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and un-comment the model code we
left disabled earlier so that your version matches the following (un\-
comment the line containing \f(CW\*(C`[$c\->model(\*(AqDB::Book\*(Aq)\->all]\*(C'\fR and
delete the next 2 lines):
.PP
.Vb 1
\&    =head2 list
\&    
\&    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
\&    
\&    =cut
\&    
\&    sub list :Local {
\&        # Retrieve the usual Perl OO \*(Aq$self\*(Aq for this object. $c is the Catalyst
\&        # \*(AqContext\*(Aq that\*(Aqs used to \*(Aqglue together\*(Aq the various components
\&        # that make up the application
\&        my ($self, $c) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store
\&        # in the stash where they can be accessed by the TT template
\&        $c\->stash(books => [$c\->model(\*(AqDB::Book\*(Aq)\->all]);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (action methods respond to user input in
\&        # your controllers).
\&        $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
\&\fB\s-1TIP\s0\fR: You may see the \f(CW\*(C`$c\->model(\*(AqDB::Book\*(Aq)\*(C'\fR un-commented above
written as \f(CW\*(C`$c\->model(\*(AqDB\*(Aq)\->resultset(\*(AqBook\*(Aq)\*(C'\fR.  The two are
equivalent.  Either way, \f(CW\*(C`$c\->model\*(C'\fR returns a
DBIx::Class::ResultSet which handles queries
against the database and iterating over the set of results that is
returned.
.PP
We are using the \f(CW\*(C`\->all\*(C'\fR to fetch all of the books.  \s-1DBIC\s0 supports
a wide variety of more advanced operations to easily do things like
filtering and sorting the results.  For example, the following could be
used to sort the results by descending title:
.PP
.Vb 1
\&    $c\->model(\*(AqDB::Book\*(Aq)\->search({}, {order_by => \*(Aqtitle DESC\*(Aq});
.Ve
.PP
Some other examples are provided in
\&\*(L"Complex \s-1WHERE\s0 clauses\*(R" in DBIx::Class::Manual::Cookbook, with additional
information found at \*(L"search\*(R" in DBIx::Class::ResultSet,
\&\*(L"Searching\*(R" in DBIx::Class::Manual::FAQ, DBIx::Class::Manual::Intro and
Catalyst::Model::DBIC::Schema.
.SS "Test Run The Application"
.IX Subsection "Test Run The Application"
First, let's enable an environment variable that causes DBIx::Class
to dump the \s-1SQL\s0 statements used to access the database.  This is a
helpful trick when you are trying to debug your database-oriented code.
Press \f(CW\*(C`Ctrl\-C\*(C'\fR to break out of the development server and enter:
.PP
.Vb 2
\&    $ export DBIC_TRACE=1
\&    $ script/myapp_server.pl \-r
.Ve
.PP
This assumes you are using bash as your shell \*(-- adjust accordingly if
you are using a different shell (for example, under tcsh, use
\&\f(CW\*(C`setenv DBIC_TRACE 1\*(C'\fR).
.PP
\&\fB\s-1NOTE:\s0\fR You can also set this in your code using
\&\f(CW\*(C`$class\->storage\->debug(1);\*(C'\fR.  See
DBIx::Class::Manual::Troubleshooting for details (including options
to log to a file instead of displaying to the Catalyst development
server log).
.PP
Then launch the Catalyst development server.  The log output should
display something like:
.PP
.Vb 8
\&    $ script/myapp_server.pl \-r
\&    [debug] Debug messages enabled
\&    [debug] Statistics enabled
\&    [debug] Loaded plugins:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Catalyst::Plugin::ConfigLoader  0.30                                       |
\&    | Catalyst::Plugin::StackTrace  0.11                                         |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    
\&    [debug] Loaded dispatcher "Catalyst::Dispatcher"
\&    [debug] Loaded engine "Catalyst::Engine"
\&    [debug] Found home "/home/catalyst/MyApp"
\&    [debug] Loaded Config "/home/catalyst/MyApp/myapp.conf"
\&    [debug] Loaded components:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-.
\&    | Class                                                           | Type     |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&    | MyApp::Controller::Books                                        | instance |
\&    | MyApp::Controller::Root                                         | instance |
\&    | MyApp::Model::DB                                                | instance |
\&    | MyApp::Model::DB::Author                                        | class    |
\&    | MyApp::Model::DB::Book                                          | class    |
\&    | MyApp::Model::DB::BookAuthor                                    | class    |
\&    | MyApp::View::HTML                                               | instance |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    
\&    [debug] Loaded Private actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Private              | Class                                | Method       |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /default             | MyApp::Controller::Root              | default      |
\&    | /end                 | MyApp::Controller::Root              | end          |
\&    | /index               | MyApp::Controller::Root              | index        |
\&    | /books/index         | MyApp::Controller::Books             | index        |
\&    | /books/list          | MyApp::Controller::Books             | list         |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    
\&    [debug] Loaded Path actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path                                | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /                                   | /default                             |
\&    | /                                   | /index                               |
\&    | /books                              | /books/index                         |
\&    | /books/list                         | /books/list                          |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    
\&    [info] MyApp powered by Catalyst 5.80020
\&    HTTP::Server::PSGI: Accepting connections at http://0:3000
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Be sure you run the \f(CW\*(C`script/myapp_server.pl\*(C'\fR command from the
\&'base' directory of your application, not inside the \f(CW\*(C`script\*(C'\fR directory
itself or it will not be able to locate the \f(CW\*(C`myapp.db\*(C'\fR database file.
You can use a fully qualified or a relative path to locate the database
file, but we did not specify that when we ran the model helper earlier.
.PP
Some things you should note in the output above:
.IP "\(bu" 4
Catalyst::Model::DBIC::Schema dynamically created three model
classes, one to represent each of the three tables in our database
(\f(CW\*(C`MyApp::Model::DB::Author\*(C'\fR, \f(CW\*(C`MyApp::Model::DB::BookAuthor\*(C'\fR, and
\&\f(CW\*(C`MyApp::Model::DB::Book\*(C'\fR).
.IP "\(bu" 4
The \*(L"list\*(R" action in our Books controller showed up with a path of
\&\f(CW\*(C`/books/list\*(C'\fR.
.PP
Point your browser to <http://localhost:3000> and you should still get
the Catalyst welcome page.
.PP
Next, to view the book list, change the \s-1URL\s0 in your browser to
<http://localhost:3000/books/list>. You should get a list of the five
books loaded by the \f(CW\*(C`myapp01.sql\*(C'\fR script above without any formatting.
The rating for each book should appear on each row, but the \*(L"Author(s)\*(R"
column will still be blank (we will fill that in later).
.PP
Also notice in the output of the \f(CW\*(C`script/myapp_server.pl\*(C'\fR that
DBIx::Class used the following \s-1SQL\s0 to retrieve the data:
.PP
.Vb 1
\&    SELECT me.id, me.title, me.rating FROM book me
.Ve
.PP
because we enabled \s-1DBIC_TRACE\s0.
.PP
You now have the beginnings of a simple but workable web application.
Continue on to future sections and we will develop the application more
fully.
.SH "CREATE A WRAPPER FOR THE VIEW"
.IX Header "CREATE A WRAPPER FOR THE VIEW"
When using \s-1TT\s0, you can (and should) create a wrapper that will literally
wrap content around each of your templates.  This is certainly useful as
you have one main source for changing things that will appear across
your entire site/application instead of having to edit many individual
files.
.SS "Configure \s-1HTML\s0.pm For The Wrapper"
.IX Subsection "Configure HTML.pm For The Wrapper"
In order to create a wrapper, you must first edit your \s-1TT\s0 view and tell
it where to find your wrapper file.
.PP
Edit your \s-1TT\s0 view in \f(CW\*(C`lib/MyApp/View/HTML.pm\*(C'\fR and change it to match
the following:
.PP
.Vb 12
\&    _\|_PACKAGE_\|_\->config(
\&        # Change default TT extension
\&        TEMPLATE_EXTENSION => \*(Aq.tt2\*(Aq,
\&        # Set the location for TT files
\&        INCLUDE_PATH => [
\&                MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqsrc\*(Aq ),
\&            ],
\&        # Set to 1 for detailed timer stats in your HTML as comments
\&        TIMER              => 0,
\&        # This is your wrapper template located in the \*(Aqroot/src\*(Aq
\&        WRAPPER => \*(Aqwrapper.tt2\*(Aq,
\&    );
.Ve
.SS "Create the Wrapper Template File and Stylesheet"
.IX Subsection "Create the Wrapper Template File and Stylesheet"
Next you need to set up your wrapper template.  Basically, you'll want
to take the overall layout of your site and put it into this file.  For
the tutorial, open \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR and input the following:
.PP
.Vb 8
\&    <?xml version="1.0" encoding="UTF\-8"?>
\&    <!DOCTYPE html PUBLIC "\-//W3C//DTD XHTML 1.0 Strict//EN" [%#
\&        %]"http://www.w3.org/TR/xhtml1/DTD/xhtml1\-strict.dtd">
\&    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
\&    <head>
\&    <title>[% template.title or "My Catalyst App!" %]</title>
\&    <link rel="stylesheet" href="[% c.uri_for(\*(Aq/static/css/main.css\*(Aq) %]" />
\&    </head>
\&    
\&    <body>
\&    <div id="outer">
\&    <div id="header">
\&        [%# Your logo could go here \-%]
\&        <img src="[% c.uri_for(\*(Aq/static/images/btn_88x31_powered.png\*(Aq) %]" />
\&        [%# Insert the page title \-%]
\&        <h1>[% template.title or site.title %]</h1>
\&    </div>
\&    
\&    <div id="bodyblock">
\&    <div id="menu">
\&        Navigation:
\&        <ul>
\&            <li><a href="[% c.uri_for(\*(Aq/books/list\*(Aq) %]">Home</a></li>
\&            <li><a href="[% c.uri_for(\*(Aq/\*(Aq)
\&                %]" title="Catalyst Welcome Page">Welcome</a></li>
\&        </ul>
\&    </div><!\-\- end menu \-\->
\&    
\&    <div id="content">
\&        [%# Status and error messages %]
\&        <span class="message">[% status_msg %]</span>
\&        <span class="error">[% error_msg %]</span>
\&        [%# This is where TT will stick all of your template\*(Aqs contents. \-%]
\&        [% content %]
\&    </div><!\-\- end content \-\->
\&    </div><!\-\- end bodyblock \-\->
\&    
\&    <div id="footer">Copyright (c) your name goes here</div>
\&    </div><!\-\- end outer \-\->
\&    
\&    </body>
\&    </html>
.Ve
.PP
Notice the status and error message sections in the code above:
.PP
.Vb 2
\&    <span class="status">[% status_msg %]</span>
\&    <span class="error">[% error_msg %]</span>
.Ve
.PP
If we set either message in the Catalyst stash (e.g.,
\&\f(CW\*(C`$c\->stash\->{status_msg} = \*(AqRequest was successful!\*(Aq\*(C'\fR) it will
be displayed whenever any view used by that request is rendered.  The
\&\f(CW\*(C`message\*(C'\fR and \f(CW\*(C`error\*(C'\fR \s-1CSS\s0 styles can be customized to suit your needs
in the \f(CW\*(C`root/static/css/main.css\*(C'\fR file we create below.
.PP
\&\fBNotes:\fR
.IP "\(bu" 4
The Catalyst stash only lasts for a single \s-1HTTP\s0 request.  If you need to
retain information across requests you can use
Catalyst::Plugin::Session (we will use Catalyst sessions in the
Authentication chapter of the tutorial).
.IP "\(bu" 4
Although it is beyond the scope of this tutorial, you may wish to use a
JavaScript or \s-1AJAX\s0 tool such as jQuery (<http://www.jquery.com>) or
Dojo (<http://www.dojotoolkit.org>).
.PP
\fICreate A Basic Stylesheet\fR
.IX Subsection "Create A Basic Stylesheet"
.PP
First create a central location for stylesheets under the static
directory:
.PP
.Vb 1
\&    $ mkdir root/static/css
.Ve
.PP
Then open the file \f(CW\*(C`root/static/css/main.css\*(C'\fR (the file referenced in
the stylesheet href link of our wrapper above) and add the following
content:
.PP
.Vb 10
\&    #header {
\&        text\-align: center;
\&    }
\&    #header h1 {
\&        margin: 0;
\&    }
\&    #header img {
\&        float: right;
\&    }
\&    #footer {
\&        text\-align: center;
\&        font\-style: italic;
\&        padding\-top: 20px;
\&    }
\&    #menu {
\&        font\-weight: bold;
\&        background\-color: #ddd;
\&    }
\&    #menu ul {
\&        list\-style: none;
\&        float: left;
\&        margin: 0;
\&        padding: 0 0 50% 5px;
\&        font\-weight: normal;
\&        background\-color: #ddd;
\&        width: 100px;
\&    }
\&    #content {
\&        margin\-left: 120px;
\&    }
\&    .message {
\&        color: #390;
\&    }
\&    .error {
\&        color: #f00;
\&    }
.Ve
.PP
You may wish to check out a \*(L"\s-1CSS\s0 Framework\*(R" like Emastic
(<http://code.google.com/p/emastic/>) as a way to quickly provide lots
of high-quality \s-1CSS\s0 functionality.
.SS "Test Run The Application"
.IX Subsection "Test Run The Application"
Hit \*(L"Reload\*(R" in your web browser and you should now see a formatted
version of our basic book list. (Again, the development server should
have automatically restarted when you made changes to
\&\f(CW\*(C`lib/MyApp/View/HTML.pm\*(C'\fR. If you are not using the \*(L"\-r\*(R" option, you
will need to hit \f(CW\*(C`Ctrl\-C\*(C'\fR and manually restart it. Also note that the
development server does \fI\s-1NOT\s0\fR need to restart for changes to the \s-1TT\s0 and
static files we created and edited in the \f(CW\*(C`root\*(C'\fR directory \*(-- those
updates are handled on a per-request basis.)
.PP
Although our wrapper and stylesheet are obviously very simple, you
should see how it allows us to control the overall look of an entire
website from two central files. To add new pages to the site, just
provide a template that fills in the \f(CW\*(C`content\*(C'\fR section of our wrapper
template \*(-- the wrapper will provide the overall feel of the page.
.SS "Updating the Generated DBIx::Class Result Class Files"
.IX Subsection "Updating the Generated DBIx::Class Result Class Files"
If you take a look at the Schema files automatically generated by
DBIx::Class::Schema::Loader, you will see that it has already defined
\&\f(CW\*(C`has_many\*(C'\fR and \f(CW\*(C`belongs_to\*(C'\fR relationships on each side of our foreign
keys. For example, take a look at \f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR and
notice the following code:
.PP
.Vb 1
\&    =head1 RELATIONS
\&    
\&    =head2 book_authors
\&    
\&    Type: has_many
\&    
\&    Related object: L<MyApp::Schema::Result::BookAuthor>
\&    
\&    =cut
\&    
\&    _\|_PACKAGE_\|_\->has_many(
\&      "book_authors",
\&      "MyApp::Schema::Result::BookAuthor",
\&      { "foreign.book_id" => "self.id" },
\&      { cascade_copy => 0, cascade_delete => 0 },
\&    );
.Ve
.PP
Each \f(CW\*(C`Book\*(C'\fR \*(L"has_many\*(R" \f(CW\*(C`book_authors\*(C'\fR, where \f(CW\*(C`BookAuthor\*(C'\fR is the
many-to-many table that allows each Book to have multiple Authors, and
each Author to have multiple books.  The arguments to \f(CW\*(C`has_many\*(C'\fR are:
.IP "\(bu" 4
\&\f(CW\*(C`book_authors\*(C'\fR \- The name for this relationship.  \s-1DBIC\s0 will create an
accessor on the \f(CW\*(C`Books\*(C'\fR \s-1DBIC\s0 Row object with this name.
.IP "\(bu" 4
\&\f(CW\*(C`MyApp::Schema::Result::BookAuthor\*(C'\fR \- The name of the \s-1DBIC\s0 model class
referenced by this \f(CW\*(C`has_many\*(C'\fR relationship.
.IP "\(bu" 4
\&\f(CW\*(C`foreign.book_id\*(C'\fR \- \f(CW\*(C`book_id\*(C'\fR is the name of the foreign key column in
the \fIforeign\fR table that points back to this table.
.IP "\(bu" 4
\&\f(CW\*(C`self.id\*(C'\fR \- \f(CW\*(C`id\*(C'\fR is the name of the column in \fIthis\fR table that is
referenced by the foreign key.
.PP
See \*(L"has_many\*(R" in DBIx::Class::Relationship for additional information.
Note that you might see a \*(L"hand coded\*(R" version of the \f(CW\*(C`has_many\*(C'\fR
relationship above expressed as:
.PP
.Vb 5
\&    _\|_PACKAGE_\|_\->has_many(
\&      "book_authors",
\&      "MyApp::Schema::Result::BookAuthor",
\&      "book_id",
\&    );
.Ve
.PP
Where the third argument is simply the name of the column in the foreign
table.  However, the hashref syntax used by
DBIx::Class::Schema::Loader is more flexible (for example, it can
handle \*(L"multi-column foreign keys\*(R").
.PP
\&\fBNote:\fR If you are using older versions of SQLite and related \s-1DBIC\s0
tools, you will need to manually define your \f(CW\*(C`has_many\*(C'\fR and
\&\f(CW\*(C`belongs_to\*(C'\fR relationships. We recommend upgrading to the versions
specified above. :\-)
.PP
Have a look at \f(CW\*(C`lib/MyApp/Schema/Result/BookAuthor.pm\*(C'\fR and notice that
there is a \f(CW\*(C`belongs_to\*(C'\fR relationship defined that acts as the \*(L"mirror
image\*(R" to the \f(CW\*(C`has_many\*(C'\fR relationship we just looked at above:
.PP
.Vb 1
\&    =head1 RELATIONS
\&    
\&    =head2 book
\&    
\&    Type: belongs_to
\&    
\&    Related object: L<MyApp::Schema::Result::Book>
\&    
\&    =cut
\&    
\&    _\|_PACKAGE_\|_\->belongs_to(
\&      "book",
\&      "MyApp::Schema::Result::Book",
\&      { id => "book_id" },
\&      { join_type => "LEFT", on_delete => "CASCADE", on_update => "CASCADE" },
\&    );
.Ve
.PP
The arguments are similar, but see
\&\*(L"belongs_to\*(R" in DBIx::Class::Relationship for the details.
.PP
Although recent versions of SQLite and DBIx::Class::Schema::Loader
automatically handle the \f(CW\*(C`has_many\*(C'\fR and \f(CW\*(C`belongs_to\*(C'\fR relationships,
\&\f(CW\*(C`many_to_many\*(C'\fR relationship bridges (not technically a relationship)
currently need to be manually inserted.  To add a \f(CW\*(C`many_to_many\*(C'\fR
relationship bridge, first edit \f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR and
add the following text below the \f(CW\*(C`# You can replace this text...\*(C'\fR
comment:
.PP
.Vb 7
\&    # many_to_many():
\&    #   args:
\&    #     1) Name of relationship bridge, DBIC will create accessor with this name
\&    #     2) Name of has_many() relationship this many_to_many() is shortcut for
\&    #     3) Name of belongs_to() relationship in model class of has_many() above
\&    #   You must already have the has_many() defined to use a many_to_many().
\&    _\|_PACKAGE_\|_\->many_to_many(authors => \*(Aqbook_authors\*(Aq, \*(Aqauthor\*(Aq);
.Ve
.PP
\&\fBNote:\fR Be careful to put this code \fIabove\fR the \f(CW\*(C`1;\*(C'\fR at the end of
the file.  As with any Perl package, we need to end the last line with a
statement that evaluates to \f(CW\*(C`true\*(C'\fR.  This is customarily done with
\&\f(CW\*(C`1;\*(C'\fR on a line by itself.
.PP
The \f(CW\*(C`many_to_many\*(C'\fR relationship bridge is optional, but it makes it
easier to map a book to its collection of authors.  Without it, we would
have to \*(L"walk\*(R" through the \f(CW\*(C`book_author\*(C'\fR table as in
\&\f(CW\*(C`$book\->book_author\->first\->author\->last_name\*(C'\fR (we will
see examples on how to use DBIx::Class objects in your code soon, but
note that because \f(CW\*(C`$book\->book_author\*(C'\fR can return multiple authors,
we have to use \f(CW\*(C`first\*(C'\fR to display a single author).  \f(CW\*(C`many_to_many\*(C'\fR
allows us to use the shorter
\&\f(CW\*(C`$book\->author\->first\->last_name\*(C'\fR. Note that you cannot
define a \f(CW\*(C`many_to_many\*(C'\fR relationship bridge without also having the
\&\f(CW\*(C`has_many\*(C'\fR relationship in place.
.PP
Then edit \f(CW\*(C`lib/MyApp/Schema/Result/Author.pm\*(C'\fR and add the reverse
\&\f(CW\*(C`many_to_many\*(C'\fR relationship bridge for \f(CW\*(C`Author\*(C'\fR as follows (again, be
careful to put in above the \f(CW\*(C`1;\*(C'\fR but below the \f(CW\*(C`# DO NOT MODIFY THIS
OR ANYTHING ABOVE!\*(C'\fR comment):
.PP
.Vb 7
\&    # many_to_many():
\&    #   args:
\&    #     1) Name of relationship bridge, DBIC will create accessor with this name
\&    #     2) Name of has_many() relationship this many_to_many() is shortcut for
\&    #     3) Name of belongs_to() relationship in model class of has_many() above
\&    #   You must already have the has_many() defined to use a many_to_many().
\&    _\|_PACKAGE_\|_\->many_to_many(books => \*(Aqbook_authors\*(Aq, \*(Aqbook\*(Aq);
.Ve
.SS "Run The Application"
.IX Subsection "Run The Application"
Run the Catalyst development server script with the \f(CW\*(C`DBIC_TRACE\*(C'\fR option
(it might still be enabled from earlier in the tutorial, but here is an
alternate way to specify the trace option just in case):
.PP
.Vb 1
\&    $ DBIC_TRACE=1 script/myapp_server.pl \-r
.Ve
.PP
Make sure that the application loads correctly and that you see the
three dynamically created model class (one for each of the Result
Classes we created).
.PP
Then hit the \s-1URL\s0 <http://localhost:3000/books/list> with your browser
and be sure that the book list still displays correctly.
.PP
\&\fBNote:\fR You will not see the authors yet because the view isn't taking
advantage of these relationships. Read on to the next section where we
update the template to do that.
.SH "UPDATING THE VIEW"
.IX Header "UPDATING THE VIEW"
Let's add a new column to our book list page that takes advantage of the
relationship information we manually added to our schema files in the
previous section.  Edit \f(CW\*(C`root/src/books/list.tt2\*(C'\fR and replace the
\&\*(L"empty\*(R" table cell \*(L"<td></td>\*(R" with the following:
.PP
.Vb 10
\&    ...
\&    <td>
\&      [% # NOTE: See Chapter 4 for a better way to do this!                      \-%]
\&      [% # First initialize a TT variable to hold a list.  Then use a TT FOREACH \-%]
\&      [% # loop in \*(Aqside effect notation\*(Aq to load just the last names of the     \-%]
\&      [% # authors into the list. Note that the \*(Aqpush\*(Aq TT vmethod doesn\*(Aqt return \-%]
\&      [% # a value, so nothing will be printed here.  But, if you have something \-%]
\&      [% # in TT that does return a value and you don\*(Aqt want it printed, you     \-%]
\&      [% # 1) assign it to a bogus value, or                                     \-%]
\&      [% # 2) use the CALL keyword to call it and discard the return value.      \-%]
\&      [% tt_authors = [ ];
\&         tt_authors.push(author.last_name) FOREACH author = book.authors %]
\&      [% # Now use a TT \*(Aqvirtual method\*(Aq to display the author count in parens   \-%]
\&      [% # Note the use of the TT filter "| html" to escape dangerous characters \-%]
\&      ([% tt_authors.size | html %])
\&      [% # Use another TT vmethod to join & print the names & comma separators   \-%]
\&      [% tt_authors.join(\*(Aq, \*(Aq) | html %]
\&    </td>
\&    ...
.Ve
.PP
\&\fB\s-1IMPORTANT\s0 \s-1NOTE:\s0\fR Again, you should keep as much \*(L"logic code\*(R" as
possible out of your views.  This kind of logic belongs in your model
(the same goes for controllers \*(-- keep them as \*(L"thin\*(R" as possible and
push all of the \*(L"complicated code\*(R" out to your model objects).  Avoid
code like you see in the previous example \*(-- we are only using it here
to show some extra features in \s-1TT\s0 until we get to the more advanced
model features we will see in Chapter 4 (see
\&\*(L"\s-1EXPLORING\s0 \s-1THE\s0 \s-1POWER\s0 \s-1OF\s0 \s-1DBIC\s0\*(R" in Catalyst::Manual::Tutorial::04_BasicCRUD).
.PP
Then hit \*(L"Reload\*(R" in your browser (note that you don't need to reload
the development server or use the \f(CW\*(C`\-r\*(C'\fR option when updating \s-1TT\s0
templates) and you should now see the number of authors each book has
along with a comma-separated list of the authors' last names.  (If you
didn't leave the development server running from the previous step, you
will obviously need to start it before you can refresh your browser
window.)
.PP
If you are still running the development server with \f(CW\*(C`DBIC_TRACE\*(C'\fR
enabled, you should also now see five more \f(CW\*(C`SELECT\*(C'\fR statements in the
debug output (one for each book as the authors are being retrieved by
DBIx::Class):
.PP
.Vb 11
\&    SELECT me.id, me.title, me.rating FROM book me:
\&    SELECT author.id, author.first_name, author.last_name FROM book_author me  
\&    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(Aq1\*(Aq
\&    SELECT author.id, author.first_name, author.last_name FROM book_author me  
\&    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(Aq2\*(Aq
\&    SELECT author.id, author.first_name, author.last_name FROM book_author me  
\&    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(Aq3\*(Aq
\&    SELECT author.id, author.first_name, author.last_name FROM book_author me  
\&    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(Aq4\*(Aq
\&    SELECT author.id, author.first_name, author.last_name FROM book_author me  
\&    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(Aq5\*(Aq
.Ve
.PP
Also note in \f(CW\*(C`root/src/books/list.tt2\*(C'\fR that we are using \*(L"| html\*(R", a
type of \s-1TT\s0 filter, to escape characters such as < and > to &lt;
and &gt; and avoid various types of dangerous hacks against your
application.  In a real application, you would probably want to put \*(L"|
html\*(R" at the end of every field where a user has control over the
information that can appear in that field (and can therefore inject
markup or code if you don't \*(L"neutralize\*(R" those fields).  In addition to
\&\*(L"| html\*(R", Template Toolkit has a variety of other useful filters that
can found in the documentation for Template::Filters.  (While we are
on the topic of security and escaping of dangerous values, one of the
advantages of using tools like \s-1DBIC\s0 for database access or
HTML::FormFu for form management [see
Chapter 9
is that they automatically handle most escaping for you and therefore
dramatically increase the security of your app.)
.SH "RUNNING THE APPLICATION FROM THE COMMAND LINE"
.IX Header "RUNNING THE APPLICATION FROM THE COMMAND LINE"
In some situations, it can be useful to run your application and display
a page without using a browser.  Catalyst lets you do this using the
\&\f(CW\*(C`scripts/myapp_test.pl\*(C'\fR script.  Just supply the \s-1URL\s0 you wish to
display and it will run that request through the normal controller
dispatch logic and use the appropriate view to render the output
(obviously, complex pages may dump a lot of text to your terminal
window).  For example, if \f(CW\*(C`Ctrl+C\*(C'\fR out of the development server
and then type:
.PP
.Vb 1
\&    $ script/myapp_test.pl "/books/list"
.Ve
.PP
You should get the same text as if you visited
<http://localhost:3000/books/list> with the normal development server
and asked your browser to view the page source.  You can even pipe this
\&\s-1HTML\s0 text output to a text-based browser using a command like:
.PP
.Vb 1
\&    $ script/myapp_test.pl "/books/list" | lynx \-stdin
.Ve
.PP
And you should see a fully rendered text-based view of your page.  (If
you are following along in Debian 6, type
\&\f(CW\*(C`sudo aptitude \-y install lynx\*(C'\fR to install lynx.)  If you do start
lynx, you can use the \*(L"Q\*(R" key to quit.
.SH "OPTIONAL INFORMATION"
.IX Header "OPTIONAL INFORMATION"
\&\fB\s-1NOTE:\s0 The rest of this chapter of the tutorial is optional.  You can
skip to Chapter 4, Basic \s-1CRUD\s0,
if you wish.\fR
.SS "Using 'RenderView' for the Default View"
.IX Subsection "Using 'RenderView' for the Default View"
Once your controller logic has processed the request from a user, it
forwards processing to your view in order to generate the appropriate
response output.  Catalyst uses
Catalyst::Action::RenderView by default
to automatically perform this operation.  If you look in
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR, you should see the empty definition for
the \f(CW\*(C`sub end\*(C'\fR method:
.PP
.Vb 1
\&    sub end : ActionClass(\*(AqRenderView\*(Aq) {}
.Ve
.PP
The following bullet points provide a quick overview of the
\&\f(CW\*(C`RenderView\*(C'\fR process:
.IP "\(bu" 4
\&\f(CW\*(C`Root.pm\*(C'\fR is designed to hold application-wide logic.
.IP "\(bu" 4
At the end of a given user request, Catalyst will call the most specific
\&\f(CW\*(C`end\*(C'\fR method that's appropriate.  For example, if the controller for a
request has an \f(CW\*(C`end\*(C'\fR method defined, it will be called.  However, if
the controller does not define a controller-specific \f(CW\*(C`end\*(C'\fR method, the
\&\*(L"global\*(R" \f(CW\*(C`end\*(C'\fR method in \f(CW\*(C`Root.pm\*(C'\fR will be called.
.IP "\(bu" 4
Because the definition includes an \f(CW\*(C`ActionClass\*(C'\fR attribute, the
Catalyst::Action::RenderView logic will be executed \fBafter\fR any code
inside the definition of \f(CW\*(C`sub end\*(C'\fR is run.  See
Catalyst::Manual::Actions for more information on \f(CW\*(C`ActionClass\*(C'\fR.
.IP "\(bu" 4
Because \f(CW\*(C`sub end\*(C'\fR is empty, this effectively just runs the default
logic in \f(CW\*(C`RenderView\*(C'\fR.  However, you can easily extend the
\&\f(CW\*(C`RenderView\*(C'\fR logic by adding your own code inside the empty method body
(\f(CW\*(C`{}\*(C'\fR) created by the Catalyst Helpers when we first ran the
\&\f(CW\*(C`catalyst.pl\*(C'\fR to initialize our application.  See
Catalyst::Action::RenderView for more
detailed information on how to extend \f(CW\*(C`RenderView\*(C'\fR in \f(CW\*(C`sub end\*(C'\fR.
.ie n .SS "RenderView's ""dump_info"" Feature"
.el .SS "RenderView's ``dump_info'' Feature"
.IX Subsection "RenderView's dump_info Feature"
One of the nice features of \f(CW\*(C`RenderView\*(C'\fR is that it automatically
allows you to add \f(CW\*(C`dump_info=1\*(C'\fR to the end of any \s-1URL\s0 for your
application and it will force the display of the \*(L"exception dump\*(R" screen
to the client browser.  You can try this out by pointing your browser to
this \s-1URL:\s0
.PP
.Vb 1
\&    http://localhost:3000/books/list?dump_info=1
.Ve
.PP
You should get a page with the following message at the top:
.PP
.Vb 2
\&    Caught exception in MyApp::Controller::Root\->end "Forced debug \- 
\&    Scrubbed output at /usr/share/perl5/Catalyst/Action/RenderView.pm line 46."
.Ve
.PP
Along with a summary of your application's state at the end of the
processing for that request.  The \*(L"Stash\*(R" section should show a
summarized version of the \s-1DBIC\s0 book model objects.  If desired, you can
adjust the summarization logic (called \*(L"scrubbing\*(R" logic) \*(-- see
Catalyst::Action::RenderView for
details.
.PP
Note that you shouldn't need to worry about \*(L"normal clients\*(R" using this
technique to \*(L"reverse engineer\*(R" your application \*(-- \f(CW\*(C`RenderView\*(C'\fR only
supports the \f(CW\*(C`dump_info=1\*(C'\fR feature when your application is running in
\&\f(CW\*(C`\-Debug\*(C'\fR mode (something you won't do once you have your application
deployed in production).
.SS "Using The Default Template Name"
.IX Subsection "Using The Default Template Name"
By default, \f(CW\*(C`Catalyst::View::TT\*(C'\fR will look for a template that uses the
same name as your controller action, allowing you to save the step of
manually specifying the template name in each action.  For example, this
would allow us to remove the
\&\f(CW\*(C`$c\->stash\->{template} = \*(Aqbooks/list.tt2\*(Aq;\*(C'\fR
line of our \f(CW\*(C`list\*(C'\fR action in the Books controller.
Open \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR in your editor and comment out
this line to match the following (only the
\&\f(CW\*(C`$c\->stash\->{template}\*(C'\fR line has changed):
.PP
.Vb 1
\&    =head2 list
\&    
\&    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
\&    
\&    =cut
\&    
\&    sub list :Local {
\&        # Retrieve the usual Perl OO \*(Aq$self\*(Aq for this object. $c is the Catalyst
\&        # \*(AqContext\*(Aq that\*(Aqs used to \*(Aqglue together\*(Aq the various components
\&        # that make up the application
\&        my ($self, $c) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store in the
\&        # stash where they can be accessed by the TT template
\&        $c\->stash(books => [$c\->model(\*(AqDB::Book\*(Aq)\->all]);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (actions methods respond to user input in
\&        # your controllers).
\&        #$c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
You should now be able to access the <http://localhost:3000/books/list>
\&\s-1URL\s0 as before.
.PP
\&\fB\s-1NOTE:\s0\fR Please note that if you use the default template technique, you
will \fBnot\fR be able to use either the \f(CW\*(C`$c\->forward\*(C'\fR or the
\&\f(CW\*(C`$c\->detach\*(C'\fR mechanisms (these are discussed in Chapter 2 and
Chapter 9 of the Tutorial).
.PP
\&\fB\s-1IMPORTANT:\s0\fR Make sure that you do \s-1NOT\s0 skip the following section
before continuing to the next chapter 4 Basic \s-1CRUD\s0.
.SS "Return To A Manually Specified Template"
.IX Subsection "Return To A Manually Specified Template"
In order to be able to use \f(CW\*(C`$c\->forward\*(C'\fR and \f(CW\*(C`$c\->detach\*(C'\fR
later in the tutorial, you should remove the comment from the statement
in \f(CW\*(C`sub list\*(C'\fR in \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR:
.PP
.Vb 1
\&    $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
.Ve
.PP
Then delete the \f(CW\*(C`TEMPLATE_EXTENSION\*(C'\fR line in \f(CW\*(C`lib/MyApp/View/HTML.pm\*(C'\fR.
.PP
Check the <http://localhost:3000/books/list> \s-1URL\s0 in your browser.  It
should look the same manner as with earlier sections.
.PP
You can jump to the next chapter of the tutorial here:
Basic \s-1CRUD\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Kennedy Clark, \f(CW\*(C`hkclark@gmail.com\*(C'\fR
.PP
Feel free to contact the author for any errors or suggestions, but the
best way to report issues is via the \s-1CPAN\s0 \s-1RT\s0 Bug system at
https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst\-Manual <https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst-Manual>.
.PP
Copyright 2006\-2011, Kennedy Clark, under the
Creative Commons Attribution Share-Alike License Version 3.0
(http://creativecommons.org/licenses/by\-sa/3.0/us/ <http://creativecommons.org/licenses/by-sa/3.0/us/>).
