.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::WWW::Mechanize::Catalyst 3"
.TH Test::WWW::Mechanize::Catalyst 3 "2011-10-14" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::WWW::Mechanize::Catalyst \- Test::WWW::Mechanize for Catalyst
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # We\*(Aqre in a t/*.t test script...
\&  use Test::WWW::Mechanize::Catalyst;
\&
\&  # To test a Catalyst application named \*(AqCatty\*(Aq:
\&  my $mech = Test::WWW::Mechanize::Catalyst\->new(catalyst_app => \*(AqCatty\*(Aq);
\&
\&  $mech\->get_ok("/"); # no hostname needed
\&  is($mech\->ct, "text/html");
\&  $mech\->title_is("Root", "On the root page");
\&  $mech\->content_contains("This is the root page", "Correct content");
\&  $mech\->follow_link_ok({text => \*(AqHello\*(Aq}, "Click on Hello");
\&  # ... and all other Test::WWW::Mechanize methods
\&  
\&  # White label site testing
\&  $mech\->host("foo.com");
\&  $mech\->get_ok("/");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Catalyst is an elegant \s-1MVC\s0 Web Application Framework.
Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates
features for web application testing. The Test::WWW::Mechanize::Catalyst
module meshes the two to allow easy testing of Catalyst applications without
needing to start up a web server.
.PP
Testing web applications has always been a bit tricky, normally
requiring starting a web server for your application and making real \s-1HTTP\s0
requests to it. This module allows you to test Catalyst web
applications but does not require a server or issue \s-1HTTP\s0
requests. Instead, it passes the \s-1HTTP\s0 request object directly to
Catalyst. Thus you do not need to use a real hostname:
\&\*(L"http://localhost/\*(R" will do. However, this is optional. The following
two lines of code do exactly the same thing:
.PP
.Vb 2
\&  $mech\->get_ok(\*(Aq/action\*(Aq);
\&  $mech\->get_ok(\*(Aqhttp://localhost/action\*(Aq);
.Ve
.PP
Links which do not begin with / or are not for localhost can be handled
as normal Web requests \- this is handy if you have an external 
single sign-on system. You must set allow_external to true for this:
.PP
.Vb 1
\&  $mech\->allow_external(1);
.Ve
.PP
You can also test a remote server by setting the environment variable
\&\s-1CATALYST_SERVER\s0; for example:
.PP
.Vb 1
\&  $ CATALYST_SERVER=http://example.com/myapp prove \-l t
.Ve
.PP
will run the same tests on the application running at
http://example.com/myapp regardless of whether or not you specify
http:://localhost for Test::WWW::Mechanize::Catalyst.
.PP
Furthermore, if you set \s-1CATALYST_SERVER\s0, the server will be regarded 
as a remote server even if your links point to localhost. Thus, you
can use Test::WWW::Mechanize::Catalyst to test your live webserver
running on your local machine, if you need to test aspects of your
deployment environment (for example, configuration options in an
http.conf file) instead of just the Catalyst request handling.
.PP
This makes testing fast and easy. Test::WWW::Mechanize provides
functions for common web testing scenarios. For example:
.PP
.Vb 4
\&  $mech\->get_ok( $page );
\&  $mech\->title_is( "Invoice Status", "Make sure we\*(Aqre on the invoice page" );
\&  $mech\->content_contains( "Andy Lester", "My name somewhere" );
\&  $mech\->content_like( qr/(cpan|perl)\e.org/, "Link to perl.org or CPAN" );
.Ve
.PP
This module supports cookies automatically.
.PP
To use this module you must pass it the name of the application. See
the \s-1SYNOPSIS\s0 above.
.PP
Note that Catalyst has a special development feature: the debug
screen. By default this module will treat responses which are the
debug screen as failures. If you actually want to test debug screens,
please use:
.PP
.Vb 1
\&  $mech\->{catalyst_debug} = 1;
.Ve
.PP
An alternative to this module is Catalyst::Test.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
Behaves like, and calls, WWW::Mechanize's \f(CW\*(C`new\*(C'\fR method.  Any params
passed in get passed to WWW::Mechanize's constructor. Note that we
need to pass the name of the Catalyst application to the \*(L"use\*(R":
.PP
.Vb 2
\&  use Test::WWW::Mechanize::Catalyst \*(AqCatty\*(Aq;
\&  my $mech = Test::WWW::Mechanize::Catalyst\->new;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "allow_external"
.IX Subsection "allow_external"
Links which do not begin with / or are not for localhost can be handled
as normal Web requests \- this is handy if you have an external 
single sign-on system. You must set allow_external to true for this:
.PP
.Vb 1
\&  $mech\->allow_external(1);
.Ve
.PP
head2 catalyst_app
.PP
The name of the Catalyst app which we are testing against. Read-only.
.SS "host"
.IX Subsection "host"
The host value to set the \*(L"Host:\*(R" \s-1HTTP\s0 header to, if none is present already in
the request. If not set (default) then Catalyst::Test will set this to
localhost:80
.SS "clear_host"
.IX Subsection "clear_host"
Unset the host attribute.
.SS "has_host"
.IX Subsection "has_host"
Do we have a value set for the host attribute
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIget()\fR, with similar options, except the
second argument needs to be a hash reference, not a hash. Returns true or 
false.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( "Invoice Summary" );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page does \s-1NOT\s0 match the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string.
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for \s-1HTTP\s0 status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex,[ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP,[ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex,[ $desc ] )"
Follow all links on the current page and test their contents for \fI\f(CI$regex\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->page_links_content_unlike( $regex,[ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_unlike( \f(CW$regex\fP,[ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_unlike( $regex,[ $desc ] )"
Follow all links on the current page and test their contents do not
contain the specified regex.
.PP
.Vb 2
\&    $mech\->page_links_content_unlike(qr/Restricted/,
\&      \*(AqCheck all links do not contain Restricted\*(Aq);
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Check the current page for specified links and test for \s-1HTTP\s0 status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar \s-1URL\s0
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Check the current page for specified links and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Check the current page for specified links and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Check the current page for specified links and test the content of
each against \fI\f(CI$regex\fI\fR.  The links may be specified as a reference to
an array containing WWW::Mechanize::Link objects, an array of URLs,
or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Check the current page for specified links and test that the content of each
does not match \fI\f(CI$regex\fI\fR.  The links may be specified as a reference to
an array containing WWW::Mechanize::Link objects, an array of URLs,
or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "follow_link_ok( \e%parms [, $comment] )"
.el .SS "follow_link_ok( \e%parms [, \f(CW$comment\fP] )"
.IX Subsection "follow_link_ok( %parms [, $comment] )"
Makes a \f(CW\*(C`follow_link()\*(C'\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the params to pass to \f(CW\*(C`follow_link()\*(C'\fR.
Note that the params to \f(CW\*(C`follow_link()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $agent\->follow_link_ok( {n=>3}, "looking for 3rd link" );
.Ve
.PP
As with other test functions, \f(CW$comment\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIfollow_link()\fR
is not available.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "External Redirects and allow_external"
.IX Subsection "External Redirects and allow_external"
If you use non-fully qualified urls in your test scripts (i.e. anything without
a host, such as \f(CW\*(C`\->get_ok( "/foo")\*(C'\fR ) and your app redirects to an
external \s-1URL\s0, expect to be bitten once you come back to your application's urls
(it will try to request them on the remote server). This is due to a limitation
in WWW::Mechanize.
.PP
One workaround for this is that if you are expecting to redirect to an external
site, clone the \s-1TWMC\s0 object and use the cloned object for the external
redirect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Related modules which may be of interest: Catalyst,
Test::WWW::Mechanize, WWW::Mechanize.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR (current maintiner)
.PP
Original Author: Leon Brocard, \f(CW\*(C`<acme@astray.com>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005\-9, Leon Brocard
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.
