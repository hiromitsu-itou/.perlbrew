.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Xslate::Manual::Cookbook 3"
.TH Text::Xslate::Manual::Cookbook 3 "2011-11-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Xslate::Manual::Cookbook \- How to cook Xslate templates
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Xslate cookbook is a set of recipes showing Xslate features.
.SH "RECIPES"
.IX Header "RECIPES"
.SS "How to manage \s-1HTML\s0 forms"
.IX Subsection "How to manage HTML forms"
Managing \s-1HTML\s0 forms is an important issue on web applications.
You'd better to use modules that manage \s-1HTML\s0 forms, rather than do something
with templates by yourself. This section proposes two basic solutions:
using FillInForm and \s-1HTML\s0 form builders.
.PP
In both solutions, one should not use the \f(CW\*(C`mark_raw filter\*(C'\fR in templates,
which easily makes \fBsecurity holes\fR. Instead, application code should be
responsible to call the \f(CW\*(C`mark_raw function\*(C'\fR that \f(CW\*(C`Text::Xslate\*(C'\fR can export.
.PP
\fIUsing FillInForm\fR
.IX Subsection "Using FillInForm"
.PP
One solution to manage \s-1HTML\s0 forms is to use FillInForm modules with
the block filter syntax.
.PP
Example code using \f(CW\*(C`HTML::FillInForm\*(C'\fR:
.PP
.Vb 3
\&    #!perl \-w
\&    use strict;
\&    use Text::Xslate qw(html_builder);
\&
\&    use HTML::FillInForm; # HTML::FillInForm::Lite is okay
\&
\&    sub fillinform {
\&        my($q) = @_;
\&        my $fif = HTML::FillInForm\->new();
\&        return html_builder {
\&            my($html) = @_;
\&            return $fif\->fill(\e$html, $q);
\&        };
\&    }
\&
\&    my $tx = Text::Xslate\->new(
\&        function => {
\&            fillinform => \e&fillinform,
\&        },
\&    );
\&
\&    my %vars = (
\&        q => { foo => "<filled value>" },
\&    );
\&    print $tx\->render_string(<<\*(AqT\*(Aq, \e%vars);
\&    FillInForm:
\&    : block form | fillinform($q) \-> {
\&    <form>
\&    <input type="text" name="foo" />
\&    </form>
\&    : }
\&    T
.Ve
.PP
Output:
.PP
.Vb 4
\&    FillInForm:
\&    <form>
\&    <input type="text" name="foo" value="&lt;filled value&gt;" />
\&    </form>
.Ve
.PP
Because HTML::FillInForm::Lite provides \f(CW\*(C`fillinform\*(C'\fR function,
it becomes more simple:
.PP
.Vb 1
\&    use HTML::FillInForm qw(fillinform);
\&
\&    my $tx = Text::Xslate\->new(
\&        function => { fillinform => html_builder(\e&fillinform) },
\&    );
.Ve
.PP
See also HTML::FillInForm or HTML::FillInForm::Lite for details.
.PP
\fIUsing \s-1HTML\s0 form builders\fR
.IX Subsection "Using HTML form builders"
.PP
Another solution to manage \s-1HTML\s0 forms is to use form builders.
In such cases, all you have to do is to apply \f(CW\*(C`mark_raw()\*(C'\fR to \s-1HTML\s0 parts.
.PP
Here is a \s-1PSGI\s0 application that uses \f(CW\*(C`HTML::Shakan\*(C'\fR:
.PP
.Vb 6
\&    #!psgi
\&    use strict;
\&    use warnings;
\&    use Text::Xslate qw(mark_raw);
\&    use HTML::Shakan;
\&    use Plack::Request;
\&
\&    my $tx = Text::Xslate\->new();
\&
\&    sub app {
\&        my($env) = @_;
\&        my $req  = Plack::Request\->new($env);
\&
\&        my $shakan = HTML::Shakan\->new(
\&            request => $req,
\&            fields  => [ TextField(name => \*(Aqname\*(Aq, label => \*(AqYour name: \*(Aq) ],
\&        );
\&
\&        my $res = $req\->new_response(200);
\&
\&        # do mark_raw here, not in templates
\&        my $form = mark_raw($shakan\->render());
\&        $res\->body( $tx\->render_string(<<\*(AqT\*(Aq, { form => $form }) );
\&    <!doctype html>
\&    <html>
\&    <head><title>Building form</title></head>
\&    <body>
\&    <form>
\&    <p>
\&    Form:<br />
\&    <: $form :>
\&    </p>
\&    </body>
\&    </html>
\&    T
\&        return $res\->finalize();
\&
\&    }
\&
\&    return \e&app;
.Ve
.PP
Output:
.PP
.Vb 12
\&    <!doctype html>
\&    <html>
\&    <head><title>Building form</title></head>
\&    <body>
\&    <form>
\&    <p>
\&    Form:<br />
\&    <label for="id_name">Your name</label>
\&    <input id="id_name" name="name" type="text" value="&lt;Xslate&gt;" />
\&    </p>
\&    </body>
\&    </html>
.Ve
.PP
See also HTML::Shakan for details.
.SS "How to use Template Toolkit's \s-1WRAPPER\s0 feature in Kolon"
.IX Subsection "How to use Template Toolkit's WRAPPER feature in Kolon"
Use template cascading, which is a super-set of the \f(CW\*(C`WRAPPER\*(C'\fR directive.
.PP
\&\fIwrapper.tx\fR:
.PP
.Vb 3
\&    <div class="wrapper">
\&    block content \-> { }
\&    </div>
.Ve
.PP
\&\fIcontent.tx\fR
.PP
.Vb 1
\&    : cascade wrapper
\&
\&    : override content \-> {
\&        Hello, world!
\&    : }
.Ve
.PP
Output:
.PP
.Vb 3
\&    <div class="wrapper">
\&        Hello, world!
\&    </div>
.Ve
.PP
\fITemplate cascading\fR
.IX Subsection "Template cascading"
.PP
Xslate supports \fBtemplate cascading\fR, which allows you to extend
templates with block modifiers. It is like traditional template inclusion,
but is more powerful.
.PP
This mechanism is also called as template inheritance.
.PP
See also \*(L"Template cascading\*(R" in Text::Xslate.
.SS "How to map _\|_DATA_\|_ sections to the include path"
.IX Subsection "How to map __DATA__ sections to the include path"
Use \f(CW\*(C`Data::Section::Simple\*(C'\fR, and the \f(CW\*(C`path\*(C'\fR option of \f(CW\*(C`new()\*(C'\fR, which accepts
\&\s-1HASH\s0 references which contain \f(CW\*(C`$file_name => $content\*(C'\fR mapping.
.PP
.Vb 2
\&    use Text::Xslate;
\&    use Data::Section::Simple;
\&
\&    my $vpath = Data::Section::Simple\->new()\->get_data_section();
\&    my $tx = Text::Xslate\->new(
\&        path => [$vpath],
\&    );
\&
\&    print $tx\->render(\*(Aqchild.tx\*(Aq);
\&
\&    _\|_DATA_\|_
\&    @@ base.tx
\&    <html>
\&    <body><: block body \-> { :>default body<: } :></body>
\&    </html>
\&    @@ child.tx
\&    : cascade base;
\&    : override body \-> {
\&    child body
\&    : } # endblock body
.Ve
.PP
This feature is directly inspired by Text::MicroTemplate::DataSection,
and originated from Mojolicious.
.PP
See also Data::Section::Simple, Text::MicroTemplate::DataSection,
and Mojolicious.
.SS "How to interpolate data into JavaScript sections without \s-1XSS\s0"
.IX Subsection "How to interpolate data into JavaScript sections without XSS"
Because Xslate escapes only \s-1HTML\s0 meta characters, you must escape
JavaScript meta characters by yourself when you put data into
\&\f(CW\*(C`<script> ... </script>\*(C'\fR sections.
.PP
\&\f(CW\*(C`JSON\*(C'\fR module is not suitable because it doesn't escape some meta
characters such as \f(CW"</script>"\fR.
.PP
It is better to use utilities proven to be secure for JavaScript escaping
to avoid \s-1XSS\s0.
JavaScript::Value::Escape helps you for this aim.
.PP
.Vb 3
\&    my $tx = Text::Xslate\->new(
\&        module => [\*(AqJavaScript::Value::Escape\*(Aq => [qw(js)]],
\&        );
\&
\&    my %params = (
\&        user_input => \*(Aq</script><script>alert("XSS")</script>\*(Aq,
\&        );
\&
\&    print $tx\->render_string(<<\*(AqT\*(Aq, \e%params);
\&    <script>
\&    document.write(\*(Aq<: $user_input | html | js :>\*(Aq);
\&    var user_input = \*(Aq<: $user_input | js :>\*(Aq;
\&    </script>
\&    T
.Ve
.PP
You'd better to consult the security experts on more complex cases.
.SS "How to interpolate structured texts into \s-1HTML\s0 without \s-1XSS\s0"
.IX Subsection "How to interpolate structured texts into HTML without XSS"
There's no silver bullet to parse structured texts in secure ways.
You'd better to consult the security experts to do so.
.PP
Some \s-1CPAN\s0 module might hep you. See String::Filter for example.
.SS "How to manage localization in templates"
.IX Subsection "How to manage localization in templates"
You can register any functions including \f(CW\*(C`_()\*(C'\fR, so no specific techniques are required.
.PP
For example:
.PP
.Vb 4
\&    use I18N::Handle;
\&    # I18N::Handle installs the locale function "_" to the global namespace.
\&    # (remember the symbol *_ is global)
\&    I18N::Handle\->new( ... )\->speak(\*(Aqzh_tw\*(Aq);
\&
\&    my $tx = Text::Xslate\->new(
\&        function => {
\&            _ => \e&_,
\&        },
\&    );
.Ve
.PP
Then in your templates:
.PP
.Vb 1
\&    <: _(\*(AqHello %1\*(Aq, $john ) :>
.Ve
.PP
See also: I18N::Handle, App::I18N.
.ie n .SS "How to load templates before ""fork()""ing?"
.el .SS "How to load templates before \f(CWfork()\fPing?"
.IX Subsection "How to load templates before fork()ing?"
It is a good idea to load templates in preforking-model applications.
Here is an example to to load all the templates which is in a given path:
.PP
.Vb 1
\&    use File::Find;
\&
\&    my $path = ...;
\&    my $tx = Text::Xslate\->new(
\&        path      => [$path],
\&        cache_dir =>  $path,
\&    );
\&
\&    # pre\-load files
\&    find sub {
\&        if(/\e.tx$/) {
\&            my $file = $File::Find::name;
\&            $file =~ s/\eQ$path\eE .//xsm; # fix path names
\&            $tx\->load_file($file);
\&        }
\&    }, $path;
\&
\&    # fork and render ...
.Ve
.SS "How to pre-process templates?"
.IX Subsection "How to pre-process templates?"
You can override \f(CW\*(C`slurp_template()\*(C'\fR in Text::Xslate to process contents
before parsing them:
.PP
.Vb 3
\&    {
\&        package MyTemplate;
\&        use parent qw(Text::Xslate);
\&
\&        sub slurp_template {
\&            my($self, $input_layer, $fullpath) = @_;
\&
\&            my $content = $self\->SUPER::slurp_template(
\&                            $input_layer,
\&                            $fullpath,
\&            );
\&            ### process $content ###
\&            return $content;
\&        }
\&    }
.Ve
.PP
The first argument \fI\f(CI$self\fI\fR is an Text::Xslate instance; the second is
the argument of \f(CW\*(C`input_layer\*(C'\fR option (default to \f(CW\*(C`:utf8\*(C'\fR); the third
is the full path of a template file to load.
.PP
\&\f(CW\*(C`slurp_template\*(C'\fR may return both \fBtext strings\fR and \f(CW\*(C`byte strings\*(C'\fR.
.PP
Note that this hook is provided for pre-processing template contents, so you should call \f(CW\*(C`SUPER::slurp_template\*(C'\fR to load templates into the memory.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::Xslate
.PP
Text::Xslate::Manual
.PP
Text::Xslate::Manual::FAQ
