.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Utils 3"
.TH B::Utils 3 "2011-11-28" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Utils \- Helper functions for op tree manipulation
.SH "VERSION"
.IX Header "VERSION"
0.17
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module, run the following commands:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use B::Utils;
.Ve
.SH "OP METHODS"
.IX Header "OP METHODS"
.ie n .IP """$op\->oldname""" 4
.el .IP "\f(CW$op\->oldname\fR" 4
.IX Item "$op->oldname"
Returns the name of the op, even if it is currently optimized to null.
This helps you understand the stucture of the op tree.
.ie n .IP """$op\->kids""" 4
.el .IP "\f(CW$op\->kids\fR" 4
.IX Item "$op->kids"
Returns an array of all this op's non-null children, in order.
.ie n .IP """$op\->parent""" 4
.el .IP "\f(CW$op\->parent\fR" 4
.IX Item "$op->parent"
Returns the parent node in the op tree, if possible. Currently
\&\*(L"possible\*(R" means \*(L"if the tree has already been optimized\*(R"; that is, if
we're during a \f(CW\*(C`CHECK\*(C'\fR block. (and hence, if we have valid \f(CW\*(C`next\*(C'\fR
pointers.)
.Sp
In the future, it may be possible to search for the parent before we
have the \f(CW\*(C`next\*(C'\fR pointers in place, but it'll take me a while to
figure out how to do that.
.ie n .IP """$op\->ancestors""" 4
.el .IP "\f(CW$op\->ancestors\fR" 4
.IX Item "$op->ancestors"
Returns all parents of this node, recursively. The list is ordered
from younger/closer parents to older/farther parents.
.ie n .IP """$op\->descendants""" 4
.el .IP "\f(CW$op\->descendants\fR" 4
.IX Item "$op->descendants"
Returns all children of this node, recursively. The list is unordered.
.ie n .IP """$op\->siblings""" 4
.el .IP "\f(CW$op\->siblings\fR" 4
.IX Item "$op->siblings"
Returns all younger siblings of this node. The list is ordered from
younger/closer siblings to older/farther siblings.
.ie n .IP """$op\->previous""" 4
.el .IP "\f(CW$op\->previous\fR" 4
.IX Item "$op->previous"
Like \f(CW\*(C` $op\->next \*(C'\fR, but not quite.
.ie n .IP """$op\->stringify""" 4
.el .IP "\f(CW$op\->stringify\fR" 4
.IX Item "$op->stringify"
Returns a nice stringification of an opcode.
.ie n .IP """$op\->as_opgrep_pattern(%options)""" 4
.el .IP "\f(CW$op\->as_opgrep_pattern(%options)\fR" 4
.IX Item "$op->as_opgrep_pattern(%options)"
From the op tree it is called on, \f(CW\*(C`as_opgrep_pattern()\*(C'\fR
generates a data structure suitable for use as a condition pattern
for the \f(CW\*(C`opgrep()\*(C'\fR function described below in detail.
\&\fIBeware\fR: When using such generated patterns, there may be
false positives: The pattern will most likely not match \fIonly\fR
the op tree it was generated from since by default, not all properties
of the op are reproduced.
.Sp
You can control which properties of the op to include in the pattern
by passing named arguments. The default behaviour is as if you
passed in the following options:
.Sp
.Vb 4
\&  my $pattern = $op\->as_opgrep_pattern(
\&    attributes          => [qw(name flags)],
\&    max_recursion_depth => undef,
\&  );
.Ve
.Sp
So obviously, you can set \f(CW\*(C`max_recursion_depth\*(C'\fR to a number to
limit the maximum depth of recursion into the op tree. Setting
it to \f(CW0\fR will limit the dump to the current op.
.Sp
\&\f(CW\*(C`attributes\*(C'\fR is a list of attributes to include in the produced
pattern. The attributes that can be checked against in this way
are
.Sp
.Vb 1
\&  name targ type seq flags private pmflags pmpermflags.
.Ve
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.ie n .IP """all_starts""" 4
.el .IP "\f(CWall_starts\fR" 4
.IX Item "all_starts"
.PD 0
.ie n .IP """all_roots""" 4
.el .IP "\f(CWall_roots\fR" 4
.IX Item "all_roots"
.PD
Returns a hash of all of the starting ops or root ops of optrees, keyed
to subroutine name; the optree for main program is simply keyed to \f(CW\*(C`_\|_MAIN_\|_\*(C'\fR.
.Sp
\&\fBNote\fR: Certain \*(L"dangerous\*(R" stashes are not scanned for subroutines:
the list of such stashes can be found in
\&\f(CW@B::Utils::bad_stashes\fR. Feel free to examine and/or modify this to
suit your needs. The intention is that a simple program which uses no
modules other than \f(CW\*(C`B\*(C'\fR and \f(CW\*(C`B::Utils\*(C'\fR would show no addition
symbols.
.Sp
This does \fBnot\fR return the details of ops in anonymous subroutines
compiled at compile time. For instance, given
.Sp
.Vb 1
\&    $a = sub { ... };
.Ve
.Sp
the subroutine will not appear in the hash. This is just as well,
since they're anonymous... If you want to get at them, use...
.ie n .IP """anon_subs""" 4
.el .IP "\f(CWanon_subs\fR" 4
.IX Item "anon_subs"
This returns an array of hash references. Each element has the keys
\&\*(L"start\*(R" and \*(L"root\*(R". These are the starting and root ops of all of the
anonymous subroutines in the program.
.ie n .IP """recalc_sub_cache""" 4
.el .IP "\f(CWrecalc_sub_cache\fR" 4
.IX Item "recalc_sub_cache"
If PL_sub_generation has changed or you have some other reason to want
to force the re-examination of the optrees, everywhere, call this
function.
.ie n .IP """walkoptree_simple($op, \e&callback, [$data])""" 4
.el .IP "\f(CWwalkoptree_simple($op, \e&callback, [$data])\fR" 4
.IX Item "walkoptree_simple($op, &callback, [$data])"
The \f(CW\*(C`B\*(C'\fR module provides various functions to walk the op tree, but
they're all rather difficult to use, requiring you to inject methods
into the \f(CW\*(C`B::OP\*(C'\fR class. This is a very simple op tree walker with
more expected semantics.
.Sp
All the \f(CW\*(C`walk\*(C'\fR functions set \f(CW$B::Utils::file\fR, \f(CW$B::Utils::line\fR,
and \f(CW$B::Utils::sub\fR to the appropriate values of file, line number,
and sub name in the program being examined.
.ie n .IP """walkoptree_filtered($op, \e&filter, \e&callback, [$data])""" 4
.el .IP "\f(CWwalkoptree_filtered($op, \e&filter, \e&callback, [$data])\fR" 4
.IX Item "walkoptree_filtered($op, &filter, &callback, [$data])"
This is much the same as \f(CW\*(C`walkoptree_simple\*(C'\fR, but will only call the
callback if the \f(CW\*(C`filter\*(C'\fR returns true. The \f(CW\*(C`filter\*(C'\fR is passed the
op in question as a parameter; the \f(CW\*(C`opgrep\*(C'\fR function is fantastic
for building your own filters.
.ie n .IP """walkallops_simple(\e&callback, [$data])""" 4
.el .IP "\f(CWwalkallops_simple(\e&callback, [$data])\fR" 4
.IX Item "walkallops_simple(&callback, [$data])"
This combines \f(CW\*(C`walkoptree_simple\*(C'\fR with \f(CW\*(C`all_roots\*(C'\fR and \f(CW\*(C`anon_subs\*(C'\fR
to examine every op in the program. \f(CW$B::Utils::sub\fR is set to the
subroutine name if you're in a subroutine, \f(CW\*(C`_\|_MAIN_\|_\*(C'\fR if you're in
the main program and \f(CW\*(C`_\|_ANON_\|_\*(C'\fR if you're in an anonymous subroutine.
.ie n .IP """walkallops_filtered(\e&filter, \e&callback, [$data])""" 4
.el .IP "\f(CWwalkallops_filtered(\e&filter, \e&callback, [$data])\fR" 4
.IX Item "walkallops_filtered(&filter, &callback, [$data])"
Same as above, but filtered.
.ie n .IP """opgrep(\e%conditions, @ops)""" 4
.el .IP "\f(CWopgrep(\e%conditions, @ops)\fR" 4
.IX Item "opgrep(%conditions, @ops)"
Returns the ops which meet the given conditions. The conditions should
be specified like this:
.Sp
.Vb 4
\&    @barewords = opgrep(
\&                        { name => "const", private => OPpCONST_BARE },
\&                        @ops
\&                       );
.Ve
.Sp
where the first argument to \f(CW\*(C`opgrep()\*(C'\fR is the condition to be matched against the
op structure. We'll henceforth refer to it as an op-pattern.
.Sp
You can specify alternation by giving an arrayref of values:
.Sp
.Vb 1
\&    @svs = opgrep ( { name => ["padsv", "gvsv"] }, @ops)
.Ve
.Sp
And you can specify inversion by making the first element of the
arrayref a \*(L"!\*(R". (Hint: if you want to say \*(L"anything\*(R", say \*(L"not
nothing\*(R": \f(CW\*(C`["!"]\*(C'\fR)
.Sp
You may also specify the conditions to be matched in nearby ops as nested patterns.
.Sp
.Vb 12
\&    walkallops_filtered(
\&        sub { opgrep( {name => "exec",
\&                       next => {
\&                                 name    => "nextstate",
\&                                 sibling => { name => [qw(! exit warn die)] }
\&                               }
\&                      }, @_)},
\&        sub {
\&              carp("Statement unlikely to be reached");
\&              carp("\et(Maybe you meant system() when you said exec()?)\en");
\&        }
\&    )
.Ve
.Sp
Get that?
.Sp
Here are the things that can be tested in this way:
.Sp
.Vb 2
\&        name targ type seq flags private pmflags pmpermflags
\&        first other last sibling next pmreplroot pmreplstart pmnext
.Ve
.Sp
Additionally, you can use the \f(CW\*(C`kids\*(C'\fR keyword with an array reference
to match the result of a call to \f(CW\*(C`$op\->kids()\*(C'\fR. An example use is
given in the documentation for \f(CW\*(C`op_or\*(C'\fR below.
.Sp
For debugging, you can have many properties of an op that is currently being
matched against a given condition dumped to \s-1STDERR\s0
by specifying \f(CW\*(C`dump =\*(C'\fR 1> in the condition's hash reference.
.Sp
If you match a complex condition against an op tree, you may want to extract
a specific piece of information from the tree if the condition matches.
This normally entails manually walking the tree a second time down to
the op you wish to extract, investigate or modify. Since this is tedious
duplication of code and information, you can specify a special property
in the pattern of the op you wish to extract to capture the sub-op
of interest. Example:
.Sp
.Vb 10
\&  my ($result) = opgrep(
\&    { name => "exec",
\&      next => { name    => "nextstate",
\&                sibling => { name => [qw(! exit warn die)]
\&                             capture => "notreached",
\&                           },
\&              }
\&    },
\&    $root_op
\&  );
\&  
\&  if ($result) {
\&    my $name = $result\->{notreached}\->name; # result is *not* the root op
\&    carp("Statement unlikely to be reached (op name: $name)");
\&    carp("\et(Maybe you meant system() when you said exec()?)\en");
\&  }
.Ve
.Sp
While the above is a terribly contrived example, consider the win for a
deeply nested pattern or worse yet, a pattern with many disjunctions.
If a \f(CW\*(C`capture\*(C'\fR property is found anywhere in
the op pattern, \f(CW\*(C`opgrep()\*(C'\fR returns an unblessed hash reference on success
instead of the tested op. You can tell them apart using Scalar::Util's
\&\f(CW\*(C`blessed()\*(C'\fR. That hash reference contains all captured ops plus the
tested root up as the hash entry \f(CW\*(C`$result\->{op}\*(C'\fR. Note that you cannot
use this feature with \f(CW\*(C`walkoptree_filtered\*(C'\fR since that function was
specifically documented to pass the tested op itself to the callback.
.Sp
You cannot capture disjunctions, but that doesn't really make sense anyway.
.ie n .IP """opgrep( \e@conditions, @ops )""" 4
.el .IP "\f(CWopgrep( \e@conditions, @ops )\fR" 4
.IX Item "opgrep( @conditions, @ops )"
Same as above, except that you don't have to chain the conditions
yourself.  If you pass an array-ref, opgrep will chain the conditions
for you using \f(CW\*(C`next\*(C'\fR. 
The conditions can either be strings (taken as op-names), or
hash-refs, with the same testable conditions as given above.
.ie n .IP """op_or( @conditions )""" 4
.el .IP "\f(CWop_or( @conditions )\fR" 4
.IX Item "op_or( @conditions )"
Unlike the chaining of conditions done by \f(CW\*(C`opgrep\*(C'\fR itself if there are multiple
conditions, this function creates a disjunction (\f(CW\*(C`$cond1 || $cond2 || ...\*(C'\fR) of
the conditions and returns a structure (hash reference) that can be passed to
opgrep as a single condition.
.Sp
Example:
.Sp
.Vb 5
\&  my $sub_structure = {
\&    name => \*(Aqhelem\*(Aq,
\&    first => { name => \*(Aqrv2hv\*(Aq, },
\&    \*(Aqlast\*(Aq => { name => \*(Aqconst\*(Aq, },
\&  };
\&  
\&  my @ops = opgrep( {
\&      name => \*(Aqleavesub\*(Aq,
\&      first => {
\&        name => \*(Aqlineseq\*(Aq,
\&        kids => [,
\&          { name => \*(Aqnextstate\*(Aq, },
\&          op_or(
\&            {
\&              name => \*(Aqreturn\*(Aq,
\&              first => { name => \*(Aqpushmark\*(Aq },
\&              last => $sub_structure,
\&            },
\&            $sub_structure,
\&          ),
\&        ],
\&      },
\&  }, $op_obj );
.Ve
.Sp
This example matches the code in a typical simplest-possible
accessor method (albeit not down to the last bit):
.Sp
.Vb 1
\&  sub get_foo { $_[0]\->{foo} }
.Ve
.Sp
But by adding an alternation
we can also match optional op layers. In this case, we optionally
match a return statement, so the following implementation is also
recognized:
.Sp
.Vb 1
\&  sub get_foo { return $_[0]\->{foo} }
.Ve
.Sp
Essentially, this is syntactic sugar for the following structure
recognized by \f(CW\*(C`opgrep()\*(C'\fR:
.Sp
.Vb 1
\&  { disjunction => [@conditions] }
.Ve
.ie n .IP """carp(@args)""" 4
.el .IP "\f(CWcarp(@args)\fR" 4
.IX Item "carp(@args)"
.PD 0
.ie n .IP """croak(@args)""" 4
.el .IP "\f(CWcroak(@args)\fR" 4
.IX Item "croak(@args)"
.PD
Warn and die, respectively, from the perspective of the position of
the op in the program. Sounds complicated, but it's exactly the kind
of error reporting you expect when you're grovelling through an op
tree.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SS "\s-1XS\s0 \s-1EXPORT\s0"
.IX Subsection "XS EXPORT"
This modules uses ExtUtils::Depends to export some useful functions
for \s-1XS\s0 modules to use.  To use those, include in your Makefile.PL:
.PP
.Vb 5
\&  my $pkg = ExtUtils::Depends\->new("Your::XSModule", "B::Utils");
\&  WriteMakefile(
\&    ... # your normal makefile flags
\&    $pkg\->get_makefile_vars,
\&  );
.Ve
.PP
Your \s-1XS\s0 module can now include \fIBUtils.h\fR and \fIBUtils_op.h\fR.  To see
document for the functions provided, use:
.PP
.Vb 2
\&  perldoc \-m B::Utils::Install::BUtils.h
\&  perldoc \-m B::Utils::Install::BUtils_op.h
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally written by Simon Cozens, \f(CW\*(C`simon@cpan.org\*(C'\fR
Maintained by Joshua ben Jore, \f(CW\*(C`jjore@cpan.org\*(C'\fR
.PP
Contributions from Mattia Barbon, Jim Cromie, Steffen Mueller, and
Chia-liang Kao, Alexandr Ciornii.
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
B, B::Generate.
