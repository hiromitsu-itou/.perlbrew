.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::IOLoop 3"
.TH Mojo::IOLoop 3 "2012-03-10" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::IOLoop \- Minimalistic reactor for non\-blocking TCP clients and servers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::IOLoop;
\&
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $chunk) = @_;
\&
\&      # Process input
\&      say $chunk;
\&
\&      # Got some data, time to write
\&      $stream\->write(\*(AqHTTP/1.1 200 OK\*(Aq);
\&    });
\&  });
\&
\&  # Connect to port 3000
\&  my $id = Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $chunk) = @_;
\&
\&      # Process input
\&      say "Input: $chunk";
\&    });
\&
\&    # Write request
\&    $stream\->write("GET / HTTP/1.1\er\en\er\en");
\&  });
\&
\&  # Add a timer
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    $loop\->drop($id);
\&  });
\&
\&  # Start and stop loop
\&  Mojo::IOLoop\->start;
\&  Mojo::IOLoop\->stop;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::IOLoop is a very minimalistic reactor that has been reduced to the
absolute minimal feature set required to build solid and scalable
non-blocking \s-1TCP\s0 clients and servers.
.PP
Optional modules \s-1EV\s0, IO::Socket::IP and IO::Socket::SSL are
supported transparently and used if installed. Individual features can also
be disabled with the \f(CW\*(C`MOJO_NO_IPV6\*(C'\fR and \f(CW\*(C`MOJO_NO_TLS\*(C'\fR environment
variables.
.PP
A \s-1TLS\s0 certificate and key are also built right in to make writing test
servers as easy as possible. Also note that for convenience the \f(CW\*(C`PIPE\*(C'\fR
signal will be set to \f(CW\*(C`IGNORE\*(C'\fR when Mojo::IOLoop is loaded.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::IOLoop implements the following attributes.
.ie n .SS """client_class"""
.el .SS "\f(CWclient_class\fP"
.IX Subsection "client_class"
.Vb 2
\&  my $class = $loop\->client_class;
\&  $loop     = $loop\->client_class(\*(AqMojo::IOLoop::Client\*(Aq);
.Ve
.PP
Class to be used for opening \s-1TCP\s0 connections with the \f(CW\*(C`client\*(C'\fR method,
defaults to Mojo::IOLoop::Client. Note that this attribute is \s-1EXPERIMENTAL\s0
and might change without warning!
.ie n .SS """iowatcher"""
.el .SS "\f(CWiowatcher\fP"
.IX Subsection "iowatcher"
.Vb 2
\&  my $watcher = $loop\->iowatcher;
\&  $loop       = $loop\->iowatcher(Mojo::IOWatcher\->new);
.Ve
.PP
Low level event watcher, usually a Mojo::IOWatcher or
Mojo::IOWatcher::EV object. Note that this attribute is \s-1EXPERIMENTAL\s0 and
might change without warning!
.ie n .SS """lock"""
.el .SS "\f(CWlock\fP"
.IX Subsection "lock"
.Vb 2
\&  my $cb = $loop\->lock;
\&  $loop  = $loop\->lock(sub {...});
.Ve
.PP
A locking callback that decides if this loop is allowed to accept new
incoming connections, used to sync multiple server processes. The callback
should return true or false. Note that exceptions in this callback are not
captured.
.PP
.Vb 2
\&  $loop\->lock(sub {
\&    my ($loop, $blocking) = @_;
\&
\&    # Got the lock, listen for new connections
\&    return 1;
\&  });
.Ve
.ie n .SS """max_accepts"""
.el .SS "\f(CWmax_accepts\fP"
.IX Subsection "max_accepts"
.Vb 2
\&  my $max = $loop\->max_accepts;
\&  $loop   = $loop\->max_accepts(1000);
.Ve
.PP
The maximum number of connections this loop is allowed to accept before
shutting down gracefully without interrupting existing connections, defaults
to \f(CW0\fR. Setting the value to \f(CW0\fR will allow this loop to accept new
connections infinitely. Note that this attribute is \s-1EXPERIMENTAL\s0 and might
change without warning!
.ie n .SS """max_connections"""
.el .SS "\f(CWmax_connections\fP"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $loop\->max_connections;
\&  $loop   = $loop\->max_connections(1000);
.Ve
.PP
The maximum number of parallel connections this loop is allowed to handle
before stopping to accept new incoming connections, defaults to \f(CW1000\fR.
Setting the value to \f(CW0\fR will make this loop stop accepting new connections
and allow it to shutdown gracefully without interrupting existing
connections.
.ie n .SS """server_class"""
.el .SS "\f(CWserver_class\fP"
.IX Subsection "server_class"
.Vb 2
\&  my $class = $loop\->server_class;
\&  $loop     = $loop\->server_class(\*(AqMojo::IOLoop::Server\*(Aq);
.Ve
.PP
Class to be used for accepting \s-1TCP\s0 connections with the \f(CW\*(C`server\*(C'\fR method,
defaults to Mojo::IOLoop::Server. Note that this attribute is \s-1EXPERIMENTAL\s0
and might change without warning!
.ie n .SS """stream_class"""
.el .SS "\f(CWstream_class\fP"
.IX Subsection "stream_class"
.Vb 2
\&  my $class = $loop\->stream_class;
\&  $loop     = $loop\->stream_class(\*(AqMojo::IOLoop::Stream\*(Aq);
.Ve
.PP
Class to be used by \f(CW\*(C`client\*(C'\fR and \f(CW\*(C`server\*(C'\fR methods for I/O streams, defaults
to Mojo::IOLoop::Stream. Note that this attribute is \s-1EXPERIMENTAL\s0 and
might change without warning!
.ie n .SS """unlock"""
.el .SS "\f(CWunlock\fP"
.IX Subsection "unlock"
.Vb 2
\&  my $cb = $loop\->unlock;
\&  $loop  = $loop\->unlock(sub {...});
.Ve
.PP
A callback to free the accept lock, used to sync multiple server processes.
Note that exceptions in this callback are not captured.
.SH "METHODS"
.IX Header "METHODS"
Mojo::IOLoop inherits all methods from Mojo::Base and implements the
following new ones.
.ie n .SS """client"""
.el .SS "\f(CWclient\fP"
.IX Subsection "client"
.Vb 4
\&  my $id =
\&    Mojo::IOLoop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client({address => \*(Aq127.0.0.1\*(Aq, port => 3000}, sub {...});
.Ve
.PP
Open \s-1TCP\s0 connection with \f(CW\*(C`client_class\*(C'\fR, which is usually
Mojo::IOLoop::Client, takes the same arguments as
\&\*(L"connect\*(R" in Mojo::IOLoop::Client. Note that this method is \s-1EXPERIMENTAL\s0 and
might change without warning!
.PP
.Vb 4
\&  Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&    ...
\&  });
.Ve
.ie n .SS """delay"""
.el .SS "\f(CWdelay\fP"
.IX Subsection "delay"
.Vb 3
\&  my $delay = Mojo::IOLoop\->delay;
\&  my $delay = $loop\->delay;
\&  my $delay = $loop\->delay(sub {...});
.Ve
.PP
Get Mojo::IOLoop::Delay object to synchronize events and subscribe to
\&\f(CW\*(C`finish\*(C'\fR event if optional callback is provided.
.PP
.Vb 9
\&  # Synchronize multiple events
\&  my $delay = Mojo::IOLoop\->delay(sub { say \*(AqBOOM!\*(Aq });
\&  for my $i (1 .. 10) {
\&    $delay\->begin;
\&    Mojo::IOLoop\->timer($i => sub {
\&      say 10 \- $i;
\&      $delay\->end;
\&    });
\&  }
\&
\&  # Wait for events if necessary
\&  $delay\->wait unless Mojo::IOLoop\->is_running;
.Ve
.ie n .SS """drop"""
.el .SS "\f(CWdrop\fP"
.IX Subsection "drop"
.Vb 2
\&  Mojo::IOLoop\->drop($id);
\&  $loop\->drop($id);
.Ve
.PP
Drop anything with an id. Connections will be dropped gracefully by allowing
them to finish writing all data in their write buffers.
.ie n .SS """generate_port"""
.el .SS "\f(CWgenerate_port\fP"
.IX Subsection "generate_port"
.Vb 2
\&  my $port = Mojo::IOLoop\->generate_port;
\&  my $port = $loop\->generate_port;
.Ve
.PP
Find a free \s-1TCP\s0 port, this is a utility function primarily used for tests.
.ie n .SS """is_running"""
.el .SS "\f(CWis_running\fP"
.IX Subsection "is_running"
.Vb 2
\&  my $success = Mojo::IOLoop\->is_running;
\&  my $success = $loop\->is_running;
.Ve
.PP
Check if loop is running.
.PP
.Vb 1
\&  exit unless Mojo::IOLoop\->is_running;
.Ve
.ie n .SS """one_tick"""
.el .SS "\f(CWone_tick\fP"
.IX Subsection "one_tick"
.Vb 4
\&  Mojo::IOLoop\->one_tick;
\&  $loop\->one_tick;
\&  $loop\->one_tick(\*(Aq0.25\*(Aq);
\&  $loop\->one_tick(0);
.Ve
.PP
Run reactor for roughly one tick and try not to block longer than the given
amount of time in seconds.
.ie n .SS """recurring"""
.el .SS "\f(CWrecurring\fP"
.IX Subsection "recurring"
.Vb 2
\&  my $id = Mojo::IOLoop\->recurring(0 => sub {...});
\&  my $id = $loop\->recurring(3 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.PP
.Vb 3
\&  # Run multiple reactors next to each other
\&  my $loop2 = Mojo::IOLoop\->new;
\&  Mojo::IOLoop\->recurring(0 => sub { $loop2\->one_tick(0) });
.Ve
.ie n .SS """server"""
.el .SS "\f(CWserver\fP"
.IX Subsection "server"
.Vb 3
\&  my $id = Mojo::IOLoop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server({port => 3000}, sub {...});
.Ve
.PP
Accept \s-1TCP\s0 connections with \f(CW\*(C`server_class\*(C'\fR, which is usually
Mojo::IOLoop::Server, takes the same arguments as
\&\*(L"listen\*(R" in Mojo::IOLoop::Server. Note that this method is \s-1EXPERIMENTAL\s0 and
might change without warning!
.PP
.Vb 4
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
.Ve
.ie n .SS """singleton"""
.el .SS "\f(CWsingleton\fP"
.IX Subsection "singleton"
.Vb 1
\&  my $loop = Mojo::IOLoop\->singleton;
.Ve
.PP
The global Mojo::IOLoop singleton, used to access a single shared loop
object from everywhere inside the process.
.PP
.Vb 3
\&  # Many methods also allow you to take shortcuts
\&  Mojo::IOLoop\->timer(2 => sub { Mojo::IOLoop\->stop });
\&  Mojo::IOLoop\->start;
.Ve
.ie n .SS """start"""
.el .SS "\f(CWstart\fP"
.IX Subsection "start"
.Vb 2
\&  Mojo::IOLoop\->start;
\&  $loop\->start;
.Ve
.PP
Start the loop, this will block until \f(CW\*(C`stop\*(C'\fR is called or no events are
being watched anymore.
.ie n .SS """stop"""
.el .SS "\f(CWstop\fP"
.IX Subsection "stop"
.Vb 2
\&  Mojo::IOLoop\->stop;
\&  $loop\->stop;
.Ve
.PP
Stop the loop immediately, this will not interrupt any existing connections
and the loop can be restarted by running \f(CW\*(C`start\*(C'\fR again.
.ie n .SS """stream"""
.el .SS "\f(CWstream\fP"
.IX Subsection "stream"
.Vb 3
\&  my $stream = Mojo::IOLoop\->stream($id);
\&  my $stream = $loop\->stream($id);
\&  my $id     = $loop\->stream($stream);
.Ve
.PP
Get Mojo::IOLoop::Stream object for id or turn object into a connection.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($id)\->timeout(300);
.Ve
.ie n .SS """timer"""
.el .SS "\f(CWtimer\fP"
.IX Subsection "timer"
.Vb 3
\&  my $id = Mojo::IOLoop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(0.25 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_IOLOOP_DEBUG\*(C'\fR environment variable to get some
advanced diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_IOLOOP_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
