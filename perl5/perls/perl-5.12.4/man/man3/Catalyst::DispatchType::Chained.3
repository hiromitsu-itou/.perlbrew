.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::DispatchType::Chained 3"
.TH Catalyst::DispatchType::Chained 3 "2011-11-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::DispatchType::Chained \- Path Part DispatchType
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Path part matching, allowing several actions to sequentially take care of processing a request:
.PP
.Vb 5
\&  #   root action \- captures one argument after it
\&  sub foo_setup : Chained(\*(Aq/\*(Aq) PathPart(\*(Aqfoo\*(Aq) CaptureArgs(1) {
\&      my ( $self, $c, $foo_arg ) = @_;
\&      ...
\&  }
\&
\&  #   child action endpoint \- takes one argument
\&  sub bar : Chained(\*(Aqfoo_setup\*(Aq) Args(1) {
\&      my ( $self, $c, $bar_arg ) = @_;
\&      ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dispatch type managing default behaviour.  For more information on
dispatch types, see:
.IP "\(bu" 4
Catalyst::Manual::Intro for how they affect application authors
.IP "\(bu" 4
Catalyst::DispatchType for implementation information.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$self\->list($c)"
.el .SS "\f(CW$self\fP\->list($c)"
.IX Subsection "$self->list($c)"
Debug output for Path Part dispatch points
.ie n .SS "$self\->match( $c, $path )"
.el .SS "\f(CW$self\fP\->match( \f(CW$c\fP, \f(CW$path\fP )"
.IX Subsection "$self->match( $c, $path )"
Calls \f(CW\*(C`recurse_match\*(C'\fR to see if a chain matches the \f(CW$path\fR.
.ie n .SS "$self\->recurse_match( $c, $parent, \e@path_parts )"
.el .SS "\f(CW$self\fP\->recurse_match( \f(CW$c\fP, \f(CW$parent\fP, \e@path_parts )"
.IX Subsection "$self->recurse_match( $c, $parent, @path_parts )"
Recursive search for a matching chain.
.ie n .SS "$self\->register( $c, $action )"
.el .SS "\f(CW$self\fP\->register( \f(CW$c\fP, \f(CW$action\fP )"
.IX Subsection "$self->register( $c, $action )"
Calls register_path for every Path attribute for the given \f(CW$action\fR.
.ie n .SS "$self\->uri_for_action($action, $captures)"
.el .SS "\f(CW$self\fP\->uri_for_action($action, \f(CW$captures\fP)"
.IX Subsection "$self->uri_for_action($action, $captures)"
Get the \s-1URI\s0 part for the action, using \f(CW$captures\fR to fill
the capturing parts.
.ie n .SS "$c\->expand_action($action)"
.el .SS "\f(CW$c\fP\->expand_action($action)"
.IX Subsection "$c->expand_action($action)"
Return a list of actions that represents a chained action. See
Catalyst::Dispatcher for more info. You probably want to
use the expand_action it provides rather than this directly.
.SH "USAGE"
.IX Header "USAGE"
.SS "Introduction"
.IX Subsection "Introduction"
The \f(CW\*(C`Chained\*(C'\fR attribute allows you to chain public path parts together
by their private names. A chain part's path can be specified with
\&\f(CW\*(C`PathPart\*(C'\fR and can be declared to expect an arbitrary number of
arguments. The endpoint of the chain specifies how many arguments it
gets through the \f(CW\*(C`Args\*(C'\fR attribute. \f(CW:Args(0)\fR would be none at all,
\&\f(CW\*(C`:Args\*(C'\fR without an integer would be unlimited. The path parts that
aren't endpoints are using \f(CW\*(C`CaptureArgs\*(C'\fR to specify how many parameters
they expect to receive. As an example setup:
.PP
.Vb 2
\&  package MyApp::Controller::Greeting;
\&  use base qw/ Catalyst::Controller /;
\&
\&  #   this is the beginning of our chain
\&  sub hello : PathPart(\*(Aqhello\*(Aq) Chained(\*(Aq/\*(Aq) CaptureArgs(1) {
\&      my ( $self, $c, $integer ) = @_;
\&      $c\->stash\->{ message } = "Hello ";
\&      $c\->stash\->{ arg_sum } = $integer;
\&  }
\&
\&  #   this is our endpoint, because it has no :CaptureArgs
\&  sub world : PathPart(\*(Aqworld\*(Aq) Chained(\*(Aqhello\*(Aq) Args(1) {
\&      my ( $self, $c, $integer ) = @_;
\&      $c\->stash\->{ message } .= "World!";
\&      $c\->stash\->{ arg_sum } += $integer;
\&
\&      $c\->response\->body( join "<br/>\en" =>
\&          $c\->stash\->{ message }, $c\->stash\->{ arg_sum } );
\&  }
.Ve
.PP
The debug output provides a separate table for chained actions, showing
the whole chain as it would match and the actions it contains. Here's an
example of the startup output with our actions above:
.PP
.Vb 9
\&  ...
\&  [debug] Loaded Path Part actions:
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | Path Spec             | Private                      |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | /hello/*/world/*      | /greeting/hello (1)          |
\&  |                       | => /greeting/world           |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  ...
.Ve
.PP
As you can see, Catalyst only deals with chains as whole paths and
builds one for each endpoint, which are the actions with \f(CW\*(C`:Chained\*(C'\fR but
without \f(CW\*(C`:CaptureArgs\*(C'\fR.
.PP
Let's assume this application gets a request at the path
\&\f(CW\*(C`/hello/23/world/12\*(C'\fR. What happens then? First, Catalyst will dispatch
to the \f(CW\*(C`hello\*(C'\fR action and pass the value \f(CW23\fR as an argument to it
after the context. It does so because we have previously used
\&\f(CW:CaptureArgs(1)\fR to declare that it has one path part after itself as
its argument. We told Catalyst that this is the beginning of the chain
by specifying \f(CW\*(C`:Chained(\*(Aq/\*(Aq)\*(C'\fR. Also note that instead of saying
\&\f(CW\*(C`:PathPart(\*(Aqhello\*(Aq)\*(C'\fR we could also just have said \f(CW\*(C`:PathPart\*(C'\fR, as it
defaults to the name of the action.
.PP
After \f(CW\*(C`hello\*(C'\fR has run, Catalyst goes on to dispatch to the \f(CW\*(C`world\*(C'\fR
action. This is the last action to be called: Catalyst knows this is an
endpoint because we did not specify a \f(CW\*(C`:CaptureArgs\*(C'\fR
attribute. Nevertheless we specify that this action expects an argument,
but at this point we're using \f(CW:Args(1)\fR to do that. We could also have
said \f(CW\*(C`:Args\*(C'\fR or left it out altogether, which would mean this action
would get all arguments that are there. This action's \f(CW\*(C`:Chained\*(C'\fR
attribute says \f(CW\*(C`hello\*(C'\fR and tells Catalyst that the \f(CW\*(C`hello\*(C'\fR action in
the current controller is its parent.
.PP
With this we have built a chain consisting of two public path parts.
\&\f(CW\*(C`hello\*(C'\fR captures one part of the path as its argument, and also
specifies the path root as its parent. So this part is
\&\f(CW\*(C`/hello/$arg\*(C'\fR. The next part is the endpoint \f(CW\*(C`world\*(C'\fR, expecting one
argument. It sums up to the path part \f(CW\*(C`world/$arg\*(C'\fR. This leads to a
complete chain of \f(CW\*(C`/hello/$arg/world/$arg\*(C'\fR which is matched against the
requested paths.
.PP
This example application would, if run and called by e.g.
\&\f(CW\*(C`/hello/23/world/12\*(C'\fR, set the stash value \f(CW\*(C`message\*(C'\fR to \*(L"Hello\*(R" and the
value \f(CW\*(C`arg_sum\*(C'\fR to \*(L"23\*(R". The \f(CW\*(C`world\*(C'\fR action would then append \*(L"World!\*(R"
to \f(CW\*(C`message\*(C'\fR and add \f(CW12\fR to the stash's \f(CW\*(C`arg_sum\*(C'\fR value.  For the
sake of simplicity no view is shown. Instead we just put the values of
the stash into our body. So the output would look like:
.PP
.Vb 2
\&  Hello World!
\&  35
.Ve
.PP
And our test server would have given us this debugging output for the
request:
.PP
.Vb 12
\&  ...
\&  [debug] "GET" request for "hello/23/world/12" from "127.0.0.1"
\&  [debug] Path is "/greeting/world"
\&  [debug] Arguments are "12"
\&  [info] Request took 0.164113s (6.093/s)
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-.
\&  | Action                                   | Time      |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&  | /greeting/hello                          | 0.000029s |
\&  | /greeting/world                          | 0.000024s |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  ...
.Ve
.PP
What would be common uses of this dispatch technique? It gives the
possibility to split up logic that contains steps that each depend on
each other. An example would be, for example, a wiki path like
\&\f(CW\*(C`/wiki/FooBarPage/rev/23/view\*(C'\fR. This chain can be easily built with
these actions:
.PP
.Vb 5
\&  sub wiki : PathPart(\*(Aqwiki\*(Aq) Chained(\*(Aq/\*(Aq) CaptureArgs(1) {
\&      my ( $self, $c, $page_name ) = @_;
\&      #  load the page named $page_name and put the object
\&      #  into the stash
\&  }
\&
\&  sub rev : PathPart(\*(Aqrev\*(Aq) Chained(\*(Aqwiki\*(Aq) CaptureArgs(1) {
\&      my ( $self, $c, $revision_id ) = @_;
\&      #  use the page object in the stash to get at its
\&      #  revision with number $revision_id
\&  }
\&
\&  sub view : PathPart Chained(\*(Aqrev\*(Aq) Args(0) {
\&      my ( $self, $c ) = @_;
\&      #  display the revision in our stash. Another option
\&      #  would be to forward a compatible object to the action
\&      #  that displays the default wiki pages, unless we want
\&      #  a different interface here, for example restore
\&      #  functionality.
\&  }
.Ve
.PP
It would now be possible to add other endpoints, for example \f(CW\*(C`restore\*(C'\fR
to restore this specific revision as the current state.
.PP
You don't have to put all the chained actions in one controller. The
specification of the parent through \f(CW\*(C`:Chained\*(C'\fR also takes an absolute
action path as its argument. Just specify it with a leading \f(CW\*(C`/\*(C'\fR.
.PP
If you want, for example, to have actions for the public paths
\&\f(CW\*(C`/foo/12/edit\*(C'\fR and \f(CW\*(C`/foo/12\*(C'\fR, just specify two actions with
\&\f(CW\*(C`:PathPart(\*(Aqfoo\*(Aq)\*(C'\fR and \f(CW\*(C`:Chained(\*(Aq/\*(Aq)\*(C'\fR. The handler for the former
path needs a \f(CW:CaptureArgs(1)\fR attribute and a endpoint with
\&\f(CW\*(C`:PathPart(\*(Aqedit\*(Aq)\*(C'\fR and \f(CW\*(C`:Chained(\*(Aqfoo\*(Aq)\*(C'\fR. For the latter path give
the action just a \f(CW:Args(1)\fR to mark it as endpoint. This sums up to
this debugging output:
.PP
.Vb 10
\&  ...
\&  [debug] Loaded Path Part actions:
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | Path Spec             | Private                      |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | /foo/*                | /controller/foo_view         |
\&  | /foo/*/edit           | /controller/foo_load (1)     |
\&  |                       | => /controller/edit          |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  ...
.Ve
.PP
Here's a more detailed specification of the attributes belonging to
\&\f(CW\*(C`:Chained\*(C'\fR:
.SS "Attributes"
.IX Subsection "Attributes"
.IP "PathPart" 8
.IX Item "PathPart"
Sets the name of this part of the chain. If it is specified without
arguments, it takes the name of the action as default. So basically
\&\f(CW\*(C`sub foo :PathPart\*(C'\fR and \f(CW\*(C`sub foo :PathPart(\*(Aqfoo\*(Aq)\*(C'\fR are identical.
This can also contain slashes to bind to a deeper level. An action
with \f(CW\*(C`sub bar :PathPart(\*(Aqfoo/bar\*(Aq) :Chained(\*(Aq/\*(Aq)\*(C'\fR would bind to
\&\f(CW\*(C`/foo/bar/...\*(C'\fR. If you don't specify \f(CW\*(C`:PathPart\*(C'\fR it has the same
effect as using \f(CW\*(C`:PathPart\*(C'\fR, it would default to the action name.
.IP "PathPrefix" 8
.IX Item "PathPrefix"
Sets PathPart to the path_prefix of the current controller.
.IP "Chained" 8
.IX Item "Chained"
Has to be specified for every child in the chain. Possible values are
absolute and relative private action paths or a single slash \f(CW\*(C`/\*(C'\fR to
tell Catalyst that this is the root of a chain. The attribute
\&\f(CW\*(C`:Chained\*(C'\fR without arguments also defaults to the \f(CW\*(C`/\*(C'\fR behavior.
Relative action paths may use \f(CW\*(C`../\*(C'\fR to refer to actions in parent
controllers.
.Sp
Because you can specify an absolute path to the parent action, it
doesn't matter to Catalyst where that parent is located. So, if your
design requests it, you can redispatch a chain through any controller or
namespace you want.
.Sp
Another interesting possibility gives \f(CW\*(C`:Chained(\*(Aq.\*(Aq)\*(C'\fR, which chains
itself to an action with the path of the current controller's namespace.
For example:
.Sp
.Vb 2
\&  #   in MyApp::Controller::Foo
\&  sub bar : Chained CaptureArgs(1) { ... }
\&
\&  #   in MyApp::Controller::Foo::Bar
\&  sub baz : Chained(\*(Aq.\*(Aq) Args(1) { ... }
.Ve
.Sp
This builds up a chain like \f(CW\*(C`/bar/*/baz/*\*(C'\fR. The specification of \f(CW\*(C`.\*(C'\fR
as the argument to Chained here chains the \f(CW\*(C`baz\*(C'\fR action to an action
with the path of the current controller namespace, namely
\&\f(CW\*(C`/foo/bar\*(C'\fR. That action chains directly to \f(CW\*(C`/\*(C'\fR, so the \f(CW\*(C`/bar/*/baz/*\*(C'\fR
chain comes out as the end product.
.IP "ChainedParent" 8
.IX Item "ChainedParent"
Chains an action to another action with the same name in the parent
controller. For Example:
.Sp
.Vb 2
\&  # in MyApp::Controller::Foo
\&  sub bar : Chained CaptureArgs(1) { ... }
\&
\&  # in MyApp::Controller::Foo::Moo
\&  sub bar : ChainedParent Args(1) { ... }
.Ve
.Sp
This builds a chain like \f(CW\*(C`/bar/*/bar/*\*(C'\fR.
.IP "CaptureArgs" 8
.IX Item "CaptureArgs"
Must be specified for every part of the chain that is not an
endpoint. With this attribute Catalyst knows how many of the following
parts of the path (separated by \f(CW\*(C`/\*(C'\fR) this action wants to capture as
its arguments. If it doesn't expect any, just specify
\&\f(CW:CaptureArgs(0)\fR.  The captures get passed to the action's \f(CW@_\fR right
after the context, but you can also find them as array references in
\&\f(CW\*(C`$c\->request\->captures\->[$level]\*(C'\fR. The \f(CW$level\fR is the
level of the action in the chain that captured the parts of the path.
.Sp
An action that is part of a chain (that is, one that has a \f(CW\*(C`:Chained\*(C'\fR
attribute) but has no \f(CW\*(C`:CaptureArgs\*(C'\fR attribute is treated by Catalyst
as a chain end.
.IP "Args" 8
.IX Item "Args"
By default, endpoints receive the rest of the arguments in the path. You
can tell Catalyst through \f(CW\*(C`:Args\*(C'\fR explicitly how many arguments your
endpoint expects, just like you can with \f(CW\*(C`:CaptureArgs\*(C'\fR. Note that this
also affects whether this chain is invoked on a request. A chain with an
endpoint specifying one argument will only match if exactly one argument
exists in the path.
.Sp
You can specify an exact number of arguments like \f(CW:Args(3)\fR, including
\&\f(CW0\fR. If you just say \f(CW\*(C`:Args\*(C'\fR without any arguments, it is the same as
leaving it out altogether: The chain is matched regardless of the number
of path parts after the endpoint.
.Sp
Just as with \f(CW\*(C`:CaptureArgs\*(C'\fR, the arguments get passed to the action in
\&\f(CW@_\fR after the context object. They can also be reached through
\&\f(CW\*(C`$c\->request\->arguments\*(C'\fR.
.SS "Auto actions, dispatching and forwarding"
.IX Subsection "Auto actions, dispatching and forwarding"
Note that the list of \f(CW\*(C`auto\*(C'\fR actions called depends on the private path
of the endpoint of the chain, not on the chained actions way. The
\&\f(CW\*(C`auto\*(C'\fR actions will be run before the chain dispatching begins. In
every other aspect, \f(CW\*(C`auto\*(C'\fR actions behave as documented.
.PP
The \f(CW\*(C`forward\*(C'\fRing to other actions does just what you would expect. But if
you \f(CW\*(C`detach\*(C'\fR out of a chain, the rest of the chain will not get called
after the \f(CW\*(C`detach\*(C'\fR.
.SS "match_captures"
.IX Subsection "match_captures"
A method which can optionally be implemented by actions to
stop chain matching.
.PP
See Catalyst::Action for further details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
