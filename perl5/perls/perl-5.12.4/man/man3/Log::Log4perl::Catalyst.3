.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst 3"
.TH Catalyst 3 "2010-07-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Log4perl::Catalyst \- Log::Log4perl Catalyst Module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In your main Catalyst application module:
.PP
.Vb 1
\&  use Log::Log4perl::Catalyst;
\&
\&    # Either make Log4perl act like the Catalyst default logger:
\&  _\|_PACKAGE_\|_\->log(Log::Log4perl::Catalyst\->new());
\&
\&    # or use a Log4perl configuration file, utilizing the full 
\&    # functionality of Log4perl
\&  _\|_PACKAGE_\|_\->log(Log::Log4perl::Catalyst\->new(\*(Aql4p.conf\*(Aq));
.Ve
.PP
\&... and then sprinkly logging statements all over any code executed
by Catalyst:
.PP
.Vb 1
\&    $c\->log\->debug("This is using log4perl!");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides Log4perl functions to Catalyst applications. It was
inspired by Catalyst::Log::Log4perl on \s-1CPAN\s0, but has been completely 
rewritten and uses a different approach to unite Catalyst and Log4perl.
.PP
Log4perl provides loggers, usually associated with the current
package, which can then be remote-controlled by a central
configuration. This means that if you have a controller function like
.PP
.Vb 1
\&    package MyApp::Controller::User;
\&
\&    sub add : Chained(\*(Aqbase\*(Aq): PathPart(\*(Aqadd\*(Aq): Args(0) {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->log\->info("Adding a user");
\&        # ...
\&    }
.Ve
.PP
Level-based control is available via the following methods:
.PP
.Vb 5
\&   $c\->log\->debug("Reading configuration");
\&   $c\->log\->info("Adding a user");
\&   $c\->log\->warn("Can\*(Aqt read configuration ($!)");
\&   $c\->log\->error("Can\*(Aqt add user ", $user);
\&   $c\->log\->fatal("Database down, aborting request");
.Ve
.PP
But that's no all, Log4perl is much more powerful.
.PP
The logging statement can be suppressed or activated based on a Log4perl
file that looks like
.PP
.Vb 3
\&      # All MyApp loggers opened up for DEBUG and above
\&    log4perl.logger.MyApp = DEBUG, Screen
\&    # ...
.Ve
.PP
or
.PP
.Vb 3
\&      # All loggers block messages below INFO
\&    log4perl.logger=INFO, Screen
\&    # ...
.Ve
.PP
respectively. See the Log4perl manpage on how to perform fine-grained 
log-level and location filtering, and how to forward messages not only
to the screen or to log files, but also to databases, email appenders,
and much more.
.PP
Also, you can vary the layout of each message. For example if you want
to know where a particular statement was logged, turn on file names and 
line numbers:
.PP
.Vb 4
\&    # Log4perl configuration file
\&    # ...
\&    log4perl.appender.Screen.layout.ConversionPattern = \e
\&          %F{1}\-%L: %p %m%n
.Ve
.PP
Messages will then look like
.PP
.Vb 1
\&    MyApp.pm\-1869: INFO Saving user profile for user "wonko"
.Ve
.PP
Or want to log a request's \s-1IP\s0 address with every log statement? No problem 
with Log4perl, just call
.PP
.Vb 1
\&    Log::Log4perl::MDC\->put( "ip", $c\->req\->address() );
.Ve
.PP
at the beginning of the request cycle and use
.PP
.Vb 4
\&    # Log4perl configuration file
\&    # ...
\&    log4perl.appender.Screen.layout.ConversionPattern = \e
\&          [%d]\-%X{ip} %F{1}\-%L: %p %m%n
.Ve
.PP
as a Log4perl layout. Messages will look like
.PP
.Vb 1
\&    [2010/02/22 23:25:55]\-123.122.108.10 MyApp.pm\-1953: INFO Reading profile for user "wonko"
.Ve
.PP
Again, check the Log4perl manual page, there's a plethora of configuration
options.
.SH "METHODS"
.IX Header "METHODS"
.IP "new($config, [%options])" 4
.IX Item "new($config, [%options])"
If called without parameters, \fInew()\fR initializes Log4perl in a way 
so that messages are logged similiarly to Catalyst's default logging
mechanism. If you provide configuration, either the name of a configuration
file or a reference to scalar string containing the configuration, it
will call Log4perl with these parameters.
.Sp
The second (optional) parameter is a list of key/value pairs:
.Sp
.Vb 2
\&  \*(Aqautoflush\*(Aq   =>  1   # Log without buffering (\*(Aqabort\*(Aq not supported)
\&  \*(Aqwatch_delay\*(Aq => 30   # If set, use L<Log::Log4perl>\*(Aqs init_and_watch
.Ve
.IP "\fI_flush()\fR" 4
.IX Item "_flush()"
Flushes the cache.
.IP "abort($abort)" 4
.IX Item "abort($abort)"
Clears the logging system's internal buffers without logging anything.
.SS "Using :easy Macros with Catalyst"
.IX Subsection "Using :easy Macros with Catalyst"
If you're tired of typing
.PP
.Vb 1
\&    $c\->log\->debug("...");
.Ve
.PP
and would prefer to use Log4perl's convenient :easy mode macros like
.PP
.Vb 1
\&    DEBUG "...";
.Ve
.PP
then just pull those macros in via Log::Log4perl's :easy mode and start
cranking:
.PP
.Vb 1
\&    use Log::Log4perl qw(:easy);
\&
\&      # ... use macros later on
\&    sub base :Chained(\*(Aq/\*(Aq) :PathPart(\*(Aqapples\*(Aq) :CaptureArgs(0) {
\&        my ( $self, $c ) = @_;
\&
\&        DEBUG "Handling apples";
\&    }
.Ve
.PP
Note the difference between Log4perl's initialization in Catalyst, which
uses the Catalyst-specific Log::Log4perl::Catalyst module (top of this
page), and making use of Log4perl's loggers with the standard 
Log::Log4perl loggers and macros. While initialization requires Log4perl
to perform dark magic to conform to Catalyst's different logging strategy,
obtaining Log4perl's logger objects or calling its macros are unchanged.
.PP
Instead of using Catalyst's way of referencing the \*(L"context\*(R" object \f(CW$c\fR to 
obtain logger references via its \fIlog()\fR method, you can just as well use 
Log4perl's \fIget_logger()\fR or macros to access Log4perl's logger singletons. 
The result is the same.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2002\-2010 by Mike Schilli <m@perlmeister.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
