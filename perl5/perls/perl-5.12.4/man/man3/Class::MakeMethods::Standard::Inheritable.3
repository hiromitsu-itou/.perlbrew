.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Standard::Inheritable 3"
.TH MakeMethods::Standard::Inheritable 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Standard::Inheritable \- Overridable data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyClass;
\&
\&  use Class::MakeMethods( \*(AqStandard::Inheritable:scalar\*(Aq => \*(Aqfoo\*(Aq );
\&  # We now have an accessor method for an "inheritable" scalar value
\&  
\&  MyClass\->foo( \*(AqFoozle\*(Aq );   # Set a class\-wide value
\&  print MyClass\->foo();       # Retrieve class\-wide value
\&  
\&  my $obj = MyClass\->new(...);
\&  print $obj\->foo();          # All instances "inherit" that value...
\&  
\&  $obj\->foo( \*(AqFoible\*(Aq );      # until you set a value for an instance.
\&  print $obj\->foo();          # This now finds object\-specific value.
\&  ...
\&  
\&  package MySubClass;
\&  @ISA = \*(AqMyClass\*(Aq;
\&  
\&  print MySubClass\->foo();    # Intially same as superclass,
\&  MySubClass\->foo(\*(AqFoobar\*(Aq);  # but overridable per subclass,
\&  print $subclass_obj\->foo(); # and shared by its instances
\&  $subclass_obj\->foo(\*(AqFosil\*(Aq);# until you override them... 
\&  ...
\&  
\&  # Similar behaviour for hashes and arrays is currently incomplete
\&  package MyClass;
\&  use Class::MakeMethods::Standard::Inheritable (
\&    array => \*(Aqmy_list\*(Aq,
\&    hash => \*(Aqmy_index\*(Aq,
\&  );
\&  
\&  MyClass\->my_list(0 => \*(AqFoozle\*(Aq, 1 => \*(AqBang!\*(Aq);
\&  print MyClass\->my_list(1);
\&  
\&  MyClass\->my_index(\*(Aqbroccoli\*(Aq => \*(AqBlah!\*(Aq, \*(Aqfoo\*(Aq => \*(AqFiddle\*(Aq);
\&  print MyClass\->my_index(\*(Aqfoo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The MakeMethods subclass provides accessor methods that search an inheritance tree to find a value. This allows you to set a shared or default value for a given class, optionally override it in a subclass, and then optionally override it on a per-instance basis.
.PP
Note that all MakeMethods methods are inheritable, in the sense that they work as expected for subclasses. These methods are different in that the \fIdata\fR accessed by each method can be inherited or overridden in each subclass or instance. See \*(L" Class::MakeMethods::Utility::Inheritable\*(R" for more about this type of \*(L"inheritable\*(R" or overridable" data.
.SS "Calling Conventions"
.IX Subsection "Calling Conventions"
When you \f(CW\*(C`use\*(C'\fR this package, the method names you provide
as arguments cause subroutines to be generated and installed in
your module.
.PP
See \*(L"Calling Conventions\*(R" in Class::MakeMethods::Standard for more information.
.SS "Declaration Syntax"
.IX Subsection "Declaration Syntax"
To declare methods, pass in pairs of a method-type name followed
by one or more method names.
.PP
Valid method-type names for this package are listed in \*(L"\s-1METHOD\s0
\&\s-1GENERATOR\s0 \s-1TYPES\s0\*(R".
.PP
See \*(L"Declaration Syntax\*(R" in Class::MakeMethods::Standard and \*(L"Parameter Syntax\*(R" in Class::MakeMethods::Standard for more information.
.SH "METHOD GENERATOR TYPES"
.IX Header "METHOD GENERATOR TYPES"
.SS "scalar \- Class-specific Accessor"
.IX Subsection "scalar - Class-specific Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class or instance method, on the declaring class or any subclass.
.IP "\(bu" 4
If called without any arguments returns the current value for the callee. If the callee has not had a value defined for this method, searches up from instance to class, and from class to superclass, until a callee with a value is located.
.IP "\(bu" 4
If called with an argument, stores that as the value associated with the callee, whether instance or class, and returns it,
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MakeMethods::Standard::Inheritable (
\&    scalar => \*(Aqfoo\*(Aq,
\&  );
\&  ...
\&  
\&  # Store value
\&  MyClass\->foo(\*(AqFoozle\*(Aq);
\&  
\&  # Retrieve value
\&  print MyClass\->foo;
.Ve
.SS "array \- Class-specific Ref Accessor"
.IX Subsection "array - Class-specific Ref Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or on any instance or subclass, Must be called on a hash-based instance.
.IP "\(bu" 4
The class value will be a reference to an array (or undef).
.IP "\(bu" 4
If called without any arguments, returns the contents of the array in list context, or an array reference in scalar context (or undef).
.IP "\(bu" 4
If called with a single array ref argument, sets the contents of the array to match the contents of the provided one.
.IP "\(bu" 4
If called with a single numeric argument, uses that argument as an index to retrieve from the referenced array, and returns that value (or undef).
.IP "\(bu" 4
If called with a two arguments, the first undefined and the second an array ref argument, uses that array's contents as a list of indexes to return a slice of the referenced array.
.IP "\(bu" 4
If called with a list of argument pairs, each with a non-ref index and an associated value, stores the value at the given index in the referenced array. If the class value was previously undefined, a new array is autovivified. The current value in each position will be overwritten, and later arguments with the same index will override earlier ones. Returns the current array-ref value.
.IP "\(bu" 4
If called with a list of argument pairs, each with the first item being a reference to an array of up to two numbers, loops over each pair and uses those numbers to splice the value array.
.Sp
The first controlling number is the position at which the splice will begin. Zero will start before the first item in the list. Negative numbers count backwards from the end of the array.
.Sp
The second number is the number of items to be removed from the list. If it is omitted, or undefined, or zero, no items are removed. If it is a positive integer, that many items will be returned.
.Sp
If both numbers are omitted, or are both undefined, they default to containing the entire value array.
.Sp
If the second argument is undef, no values will be inserted; if it is a non-reference value, that one value will be inserted; if it is an array-ref, its values will be copied.
.Sp
The method returns the items that removed from the array, if any.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MakeMethods::Standard::Inheritable (
\&    array => \*(Aqbar\*(Aq,
\&  );
\&  ...
\&  
\&  # Clear and set contents of list
\&  print MyClass\->bar([ \*(AqSpume\*(Aq, \*(AqFrost\*(Aq ] );  
\&  
\&  # Set values by position
\&  MyClass\->bar(0 => \*(AqFoozle\*(Aq, 1 => \*(AqBang!\*(Aq);
\&  
\&  # Positions may be overwritten, and in any order
\&  MyClass\->bar(2 => \*(AqAnd Mash\*(Aq, 1 => \*(AqBlah!\*(Aq);
\&  
\&  # Retrieve value by position
\&  print MyClass\->bar(1);
\&  
\&  # Direct access to referenced array
\&  print scalar @{ MyClass\->bar() };
.Ve
.PP
There are also calling conventions for slice and splice operations:
.PP
.Vb 2
\&  # Retrieve slice of values by position
\&  print join(\*(Aq, \*(Aq, MyClass\->bar( undef, [0, 2] ) );
\&  
\&  # Insert an item at position in the array
\&  MyClass\->bar([3], \*(AqPotatoes\*(Aq );  
\&  
\&  # Remove 1 item from position 3 in the array
\&  MyClass\->bar([3, 1], undef );  
\&  
\&  # Set a new value at position 2, and return the old value 
\&  print MyClass\->bar([2, 1], \*(AqFroth\*(Aq );
.Ve
.SS "hash \- Class-specific Ref Accessor"
.IX Subsection "hash - Class-specific Ref Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or on any instance or subclass, Must be called on a hash-based instance.
.IP "\(bu" 4
The class value will be a reference to a hash (or undef).
.IP "\(bu" 4
If called without any arguments, returns the contents of the hash in list context, or a hash reference in scalar context. If the callee has not had a value defined for this method, searches up from instance to class, and from class to superclass, until a callee with a value is located.
.IP "\(bu" 4
If called with one non-ref argument, uses that argument as an index to retrieve from the referenced hash, and returns that value (or undef). If the callee has not had a value defined for this method, searches up from instance to class, and from class to superclass, until a callee with a value is located.
.IP "\(bu" 4
If called with one array-ref argument, uses the contents of that array to retrieve a slice of the referenced hash. If the callee has not had a value defined for this method, searches up from instance to class, and from class to superclass, until a callee with a value is located.
.IP "\(bu" 4
If called with one hash-ref argument, sets the contents of the referenced hash to match that provided.
.IP "\(bu" 4
If called with a list of key-value pairs, stores the value under the given key in the hash associated with the callee, whether instance or class. If the callee did not previously have a hash-ref value associated with it, searches up instance to class, and from class to superclass, until a callee with a value is located, and copies that hash before making the assignments. The current value under each key will be overwritten, and later arguments with the same key will override earlier ones. Returns the contents of the hash in list context, or a hash reference in scalar context.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MakeMethods::Standard::Inheritable (
\&    hash => \*(Aqbaz\*(Aq,
\&  );
\&  ...
\&  
\&  # Set values by key
\&  MyClass\->baz(\*(Aqfoo\*(Aq => \*(AqFoozle\*(Aq, \*(Aqbar\*(Aq => \*(AqBang!\*(Aq);
\&  
\&  # Values may be overwritten, and in any order
\&  MyClass\->baz(\*(Aqbroccoli\*(Aq => \*(AqBlah!\*(Aq, \*(Aqfoo\*(Aq => \*(AqFiddle\*(Aq);
\&  
\&  # Retrieve value by key
\&  print MyClass\->baz(\*(Aqfoo\*(Aq);
\&  
\&  # Retrive slice of values by position
\&  print join(\*(Aq, \*(Aq, MyClass\->baz( [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq] ) );
\&  
\&  # Direct access to referenced hash
\&  print keys %{ MyClass\->baz() };
\&  
\&  # Reset the hash contents to empty
\&  @{ MyClass\->baz() } = ();
.Ve
.PP
\&\fB\s-1NOTE:\s0 \s-1THIS\s0 \s-1METHOD\s0 \s-1GENERATOR\s0 \s-1IS\s0 \s-1INCOMPLETE\s0.\fR
.SS "object \- Class-specific Ref Accessor"
.IX Subsection "object - Class-specific Ref Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or on any instance or subclass, Must be called on a hash-based instance.
.IP "\(bu" 4
The class value will be a reference to an object (or undef).
.IP "\(bu" 4
If called without any arguments returns the current value for the callee. If the callee has not had a value defined for this method, searches up from instance to class, and from class to superclass, until a callee with a value is located.
.IP "\(bu" 4
If called with an argument, stores that as the value associated with the callee, whether instance or class, and returns it,
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MakeMethods::Standard::Inheritable (
\&    object => \*(Aqfoo\*(Aq,
\&  );
\&  ...
\&  
\&  # Store value
\&  MyClass\->foo( Foozle\->new() );
\&  
\&  # Retrieve value
\&  print MyClass\->foo;
.Ve
.PP
\&\fB\s-1NOTE:\s0 \s-1THIS\s0 \s-1METHOD\s0 \s-1GENERATOR\s0 \s-1HAS\s0 \s-1NOT\s0 \s-1BEEN\s0 \s-1WRITTEN\s0 \s-1YET\s0.\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.PP
See Class::MakeMethods::Standard for more about this family of subclasses.
