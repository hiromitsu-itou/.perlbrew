.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Xslate 3"
.TH Text::Xslate 3 "2011-11-17" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Xslate \- Scalable template engine for Perl5
.SH "VERSION"
.IX Header "VERSION"
This document describes Text::Xslate version 1.5007.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Text::Xslate qw(mark_raw);
\&
\&    my $tx = Text::Xslate\->new();
\&
\&    my %vars = (
\&        title => \*(AqA list of books\*(Aq,
\&        books => [
\&            { title => \*(AqIslands in the stream\*(Aq },
\&            { title => \*(AqProgramming Perl\*(Aq      },
\&            # ...
\&        ],
\&
\&        # mark HTML components as raw not to escape its HTML tags
\&        gadget => mark_raw(\*(Aq<div class="gadget">...</div>\*(Aq),
\&    );
\&
\&    # for files
\&    print $tx\->render(\*(Aqhello.tx\*(Aq, \e%vars);
\&
\&    # for strings
\&    my $template = q{
\&        <h1><: $title :></h1>
\&        <ul>
\&        : for $books \-> $book {
\&            <li><: $book.title :></li>
\&        : } # for
\&        </ul>
\&    };
\&
\&    print $tx\->render_string($template, \e%vars);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBXslate\fR is a template engine, tuned for persistent applications,
safe as an \s-1HTML\s0 generator, and with rich features.
.PP
There are a lot of template engines in \s-1CPAN\s0, for example Template-Toolkit,
Text::MicroTemplate, HTML::Template, and so on, but all of them have
demerits at some points. This is why Xslate is developed and now it is
well-honed as the standard template engine for web applications.
.PP
The concept of Xslate is strongly influenced by Text::MicroTemplate
and Template-Toolkit 2, but the central philosophy of Xslate is different
from them. That is, the philosophy is \fBsandboxing\fR that the template logic
should not have no access outside the template beyond your permission.
.PP
Other remarkable features are as follows:
.SS "Features"
.IX Subsection "Features"
\fIHigh performance\fR
.IX Subsection "High performance"
.PP
This engine introduces the virtual machine paradigm. Templates are
compiled into intermediate code, and then executed by the virtual machine,
which is highly optimized for rendering templates. Thus, Xslate is
much faster than any other template engines.
.PP
The template roundup project by Sam Graham shows Text::Xslate got very
high scores in \fIinstance_reuse\fR condition (i.e. for persistent application).
.IP "The template roundup project" 4
.IX Item "The template roundup project"
http://illusori.co.uk/projects/Template\-Roundup/ <http://illusori.co.uk/projects/Template-Roundup/>
.IP "Perl Template Roundup October 2010 Performance vs Variant Report: instance_reuse" 4
.IX Item "Perl Template Roundup October 2010 Performance vs Variant Report: instance_reuse"
http://illusori.co.uk/projects/Template\-Roundup/201010/performance_vs_variant_by_feature_for_instance_reuse.html <http://illusori.co.uk/projects/Template-Roundup/201010/performance_vs_variant_by_feature_for_instance_reuse.html>
.PP
There are some benchmarks in \fIbenchmark/\fR directory in the Xslate distribution.
.PP
\fISmart escaping for \s-1HTML\s0 metacharacters\fR
.IX Subsection "Smart escaping for HTML metacharacters"
.PP
All \s-1HTML\s0 metacharacters in template expressions which are interpolated into
template texts by the engine are escaped automatically. This means that, by default,
the output is not prone to \s-1XSS\s0.
.PP
\fITemplate cascading\fR
.IX Subsection "Template cascading"
.PP
Xslate supports \fBtemplate cascading\fR, which allows you to extend
templates with block modifiers. It is like traditional template inclusion,
but is more powerful.
.PP
This mechanism is also called as template inheritance.
.PP
\fIEasiness to enhance\fR
.IX Subsection "Easiness to enhance"
.PP
Xslate is ready to enhance. You can add functions and methods to the template
engine and even add a new syntax via extending the parser.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Methods"
.IX Subsection "Methods"
\fI\f(BIText::Xslate\->new(%options) :XslateEngine\fI\fR
.IX Subsection "Text::Xslate->new(%options) :XslateEngine"
.PP
Creates a new xslate template engine with options. You can reuse the instance
for multiple call of \f(CW\*(C`render()\*(C'\fR.
.PP
Possible options are:
.ie n .IP """path => \e@path // [\*(Aq.\*(Aq]""" 4
.el .IP "\f(CWpath => \e@path // [\*(Aq.\*(Aq]\fR" 4
.IX Item "path => @path // [.]"
Specifies the include paths, which may be directory names or virtual paths,
i.e. \s-1HASH\s0 references which contain \f(CW\*(C`$file_name => $content\*(C'\fR pairs.
.ie n .IP """cache => $level // 1""" 4
.el .IP "\f(CWcache => $level // 1\fR" 4
.IX Item "cache => $level // 1"
Sets the cache level.
.Sp
If \fI\f(CI$level\fI\fR == 1 (default), Xslate caches compiled templates on the disk, and
checks the freshness of the original templates every time.
.Sp
If \fI\f(CI$level\fI\fR >= 2, caches will be created but the freshness
will not be checked.
.Sp
\&\fI\f(CI$level\fI\fR == 0 uses no caches, which is provided for testing.
.ie n .IP """cache_dir => $dir // ""$ENV{HOME}/.xslate_cache""""" 4
.el .IP "\f(CWcache_dir => $dir // ``$ENV{HOME}/.xslate_cache''\fR" 4
.IX Item "cache_dir => $dir // ""$ENV{HOME}/.xslate_cache"""
Specifies the directory used for caches. If \f(CW$ENV{HOME}\fR doesn't exist,
\&\f(CW\*(C`File::Spec\->tmpdir\*(C'\fR will be used.
.Sp
You \fBshould\fR specify this option for productions to avoid conflicts of
template names.
.ie n .IP """function => \e%functions""" 4
.el .IP "\f(CWfunction => \e%functions\fR" 4
.IX Item "function => %functions"
Specifies a function map which contains name-coderef pairs.
A function \f(CW\*(C`f\*(C'\fR may be called as \f(CW\*(C`f($arg)\*(C'\fR or \f(CW\*(C`$arg | f\*(C'\fR in templates.
.Sp
There are built-in functions described in Text::Xslate::Manual::Builtin.
.ie n .IP """module => [$module => ?\e@import_args, ...]""" 4
.el .IP "\f(CWmodule => [$module => ?\e@import_args, ...]\fR" 4
.IX Item "module => [$module => ?@import_args, ...]"
Imports functions from \fI\f(CI$module\fI\fR, which may be a function-based or bridge module.
Optional \fI\f(CI@import_args\fI\fR are passed to \f(CW\*(C`import\*(C'\fR as \f(CW\*(C`$module\->import(@import_args)\*(C'\fR.
.Sp
For example:
.Sp
.Vb 8
\&    # for function\-based modules
\&    my $tx = Text::Xslate\->new(
\&        module => [\*(AqTime::Piece\*(Aq],
\&    );
\&    print $tx\->render_string(
\&        \*(Aq<: localtime($x).strftime() :>\*(Aq,
\&        { x => time() },
\&    ); # => Wed, 09 Jun 2010 10:22:06 JST
\&
\&    # for bridge modules
\&    my $tx = Text::Xslate\->new(
\&        module => [\*(AqText::Xslate::Bridge::Star\*(Aq],
\&    );
\&    print $tx\->render_string(
\&        \*(Aq<: uc($x) :>\*(Aq,
\&        { x => \*(Aqfoo\*(Aq },
\&    ); # => \*(AqFOO\*(Aq
.Ve
.Sp
Because you can use function-based modules with the \f(CW\*(C`module\*(C'\fR option, and
also can invoke any object methods in templates, Xslate doesn't require
specific namespaces for plugins.
.ie n .IP """input_layer => $perliolayers // \*(Aq:utf8\*(Aq""" 4
.el .IP "\f(CWinput_layer => $perliolayers // \*(Aq:utf8\*(Aq\fR" 4
.IX Item "input_layer => $perliolayers // :utf8"
Specifies PerlIO layers to open template files.
.ie n .IP """verbose => $level // 1""" 4
.el .IP "\f(CWverbose => $level // 1\fR" 4
.IX Item "verbose => $level // 1"
Specifies the verbose level.
.Sp
If \f(CW\*(C`$level == 0\*(C'\fR, all the possible errors will be ignored.
.Sp
If \f(CW\*(C`$level> >= 1\*(C'\fR (default), trivial errors (e.g. to print nil) will be ignored,
but severe errors (e.g. for a method to throw the error) will be warned.
.Sp
If \f(CW\*(C`$level >= 2\*(C'\fR, all the possible errors will be warned.
.ie n .IP """suffix => $ext // \*(Aq.tx\*(Aq""" 4
.el .IP "\f(CWsuffix => $ext // \*(Aq.tx\*(Aq\fR" 4
.IX Item "suffix => $ext // .tx"
Specify the template suffix, which is used for \f(CW\*(C`cascade\*(C'\fR and \f(CW\*(C`include\*(C'\fR
in Kolon.
.Sp
Note that this is used for static name resolution. That is, the compiler
uses it but the runtime engine doesn't.
.ie n .IP """syntax => $name // \*(AqKolon\*(Aq""" 4
.el .IP "\f(CWsyntax => $name // \*(AqKolon\*(Aq\fR" 4
.IX Item "syntax => $name // Kolon"
Specifies the template syntax you want to use.
.Sp
\&\fI\f(CI$name\fI\fR may be a short name (e.g. \f(CW\*(C`Kolon\*(C'\fR), or a fully qualified name
(e.g. \f(CW\*(C`Text::Xslate::Syntax::Kolon\*(C'\fR).
.Sp
This option is passed to the compiler directly.
.ie n .IP """type => $type // \*(Aqhtml\*(Aq""" 4
.el .IP "\f(CWtype => $type // \*(Aqhtml\*(Aq\fR" 4
.IX Item "type => $type // html"
Specifies the output content type. If \fI\f(CI$type\fI\fR is \f(CW\*(C`html\*(C'\fR or \f(CW\*(C`xml\*(C'\fR,
smart escaping is applied to template expressions. That is,
they are interpolated via the \f(CW\*(C`html_escape\*(C'\fR filter.
If \fI\f(CI$type\fI\fR is \f(CW\*(C`text\*(C'\fR smart escaping is not applied so that it is
suitable for plain texts like e\-mails.
.Sp
\&\fI\f(CI$type\fI\fR may be \fBhtml\fR, \fBxml\fR (identical to \f(CW\*(C`html\*(C'\fR), and \fBtext\fR.
.Sp
This option is passed to the compiler directly.
.ie n .IP """line_start => $token // $parser_defined_str""" 4
.el .IP "\f(CWline_start => $token // $parser_defined_str\fR" 4
.IX Item "line_start => $token // $parser_defined_str"
Specify the token to start line code as a string, which \f(CW\*(C`quotemeta\*(C'\fR will be applied to. If you give \f(CW\*(C`undef\*(C'\fR, the line code style is disabled.
.Sp
This option is passed to the parser via the compiler.
.ie n .IP """tag_start => $str // $parser_defined_str""" 4
.el .IP "\f(CWtag_start => $str // $parser_defined_str\fR" 4
.IX Item "tag_start => $str // $parser_defined_str"
Specify the token to start inline code as a string, which \f(CW\*(C`quotemeta\*(C'\fR will be applied to.
.Sp
This option is passed to the parser via the compiler.
.ie n .IP """tag_end => $str // $parser_defined_str""" 4
.el .IP "\f(CWtag_end => $str // $parser_defined_str\fR" 4
.IX Item "tag_end => $str // $parser_defined_str"
Specify the token to end inline code as a string, which \f(CW\*(C`quotemeta\*(C'\fR will be applied to.
.Sp
This option is passed to the parser via the compiler.
.ie n .IP """header => \e@template_files""" 4
.el .IP "\f(CWheader => \e@template_files\fR" 4
.IX Item "header => @template_files"
Specify the header template files, which are inserted to the head of each template.
.Sp
This option is passed to the compiler.
.ie n .IP """footer => \e@template_files""" 4
.el .IP "\f(CWfooter => \e@template_files\fR" 4
.IX Item "footer => @template_files"
Specify the footer template files, which are inserted to the foot of each template.
.Sp
This option is passed to the compiler.
.ie n .IP """warn_handler => \e&cb""" 4
.el .IP "\f(CWwarn_handler => \e&cb\fR" 4
.IX Item "warn_handler => &cb"
Specify the callback \fI&cb\fR which is called on warnings.
.ie n .IP """die_handler => \e&cb""" 4
.el .IP "\f(CWdie_handler => \e&cb\fR" 4
.IX Item "die_handler => &cb"
Specify the callback \fI&cb\fR which is called on fatal errors.
.PP
\fI\f(BI\f(CB$tx\f(BI\->render($file, \e%vars) :Str\fI\fR
.IX Subsection "$tx->render($file, %vars) :Str"
.PP
Renders a template file with given variables, and returns the result.
\&\fI\e%vars\fR is optional.
.PP
Note that \fI\f(CI$file\fI\fR may be cached according to the cache level.
.PP
\fI\f(BI\f(CB$tx\f(BI\->render_string($string, \e%vars) :Str\fI\fR
.IX Subsection "$tx->render_string($string, %vars) :Str"
.PP
Renders a template string with given variables, and returns the result.
\&\fI\e%vars\fR is optional.
.PP
Note that \fI\f(CI$string\fI\fR is never cached, so this method should be avoided in
production environment. If you want in-memory templates, consider the \fIpath\fR
option for \s-1HASH\s0 references which are cached as you expect:
.PP
.Vb 3
\&    my %vpath = (
\&        \*(Aqhello.tx\*(Aq => \*(AqHello, <: $lang :> world!\*(Aq,
\&    );
\&
\&    my $tx = Text::Xslate\->new( path => \e%vpath );
\&    print $tx\->render(\*(Aqhello.tx\*(Aq, { lang => \*(AqXslate\*(Aq });
.Ve
.PP
Note that \fI\f(CI$string\fI\fR must be a text string, not a binary string.
.PP
\fI\f(BI\f(CB$tx\f(BI\->load_file($file) :Void\fI\fR
.IX Subsection "$tx->load_file($file) :Void"
.PP
Loads \fI\f(CI$file\fI\fR into memory for following \f(CW\*(C`render()\*(C'\fR.
Compiles and saves it as disk caches if needed.
.PP
\fI\f(BIText::Xslate\->current_engine :XslateEngine\fI\fR
.IX Subsection "Text::Xslate->current_engine :XslateEngine"
.PP
Returns the current Xslate engine while executing. Otherwise returns \f(CW\*(C`undef\*(C'\fR.
This method is significant when it is called by template functions and methods.
.PP
\fI\f(BIText::Xslate\->current_vars :HashRef\fI\fR
.IX Subsection "Text::Xslate->current_vars :HashRef"
.PP
Returns the current variable table, namely the second argument of
\&\f(CW\*(C`render()\*(C'\fR while executing. Otherwise returns \f(CW\*(C`undef\*(C'\fR.
.PP
\fI\f(BIText::Xslate\->current_file :Str\fI\fR
.IX Subsection "Text::Xslate->current_file :Str"
.PP
Returns the current file name while executing. Otherwise returns \f(CW\*(C`undef\*(C'\fR.
This method is significant when it is called by template functions and methods.
.PP
\fI\f(BIText::Xslate\->current_line :Int\fI\fR
.IX Subsection "Text::Xslate->current_line :Int"
.PP
Returns the current line number while executing. Otherwise returns \f(CW\*(C`undef\*(C'\fR.
This method is significant when it is called by template functions and methods.
.PP
\fI\f(BIText::Xslate\->print(...) :Void\fI\fR
.IX Subsection "Text::Xslate->print(...) :Void"
.PP
Adds the argument into the output buffer. This method is available on executing.
.SS "Exportable functions"
.IX Subsection "Exportable functions"
\fI\f(CI\*(C`mark_raw($str :Str) :RawStr\*(C'\fI\fR
.IX Subsection "mark_raw($str :Str) :RawStr"
.PP
Marks \fI\f(CI$str\fI\fR as raw, so that the content of \fI\f(CI$str\fI\fR will be rendered as is,
so you have to escape these strings by yourself.
.PP
For example:
.PP
.Vb 7
\&    my $tx   = Text::Xslate\->new();
\&    my $tmpl = \*(AqMailaddress: <: $email :>\*(Aq;
\&    my %vars = (
\&        email => mark_raw(\*(AqFoo &lt;foo at example.com&gt;\*(Aq),
\&    );
\&    print $tx\->render_string($tmpl, \e%email);
\&    # => Mailaddress: Foo &lt;foo@example.com&gt;
.Ve
.PP
This function is available in templates as the \f(CW\*(C`mark_raw\*(C'\fR filter, although
the use of it is strongly discouraged.
.PP
\fI\f(CI\*(C`unmark_raw($str :Str) :Str\*(C'\fI\fR
.IX Subsection "unmark_raw($str :Str) :Str"
.PP
Clears the raw marker from \fI\f(CI$str\fI\fR, so that the content of \fI\f(CI$str\fI\fR will
be escaped before rendered.
.PP
This function is available in templates as the \f(CW\*(C`unmark_raw\*(C'\fR filter.
.PP
\fI\f(CI\*(C`html_escape($str :Str) :RawStr\*(C'\fI\fR
.IX Subsection "html_escape($str :Str) :RawStr"
.PP
Escapes \s-1HTML\s0 meta characters in \fI\f(CI$str\fI\fR, and returns it as a raw string (see above).
If \fI\f(CI$str\fI\fR is already a raw string, it returns \fI\f(CI$str\fI\fR as is.
.PP
By default, this function will be automatically applied to all the template
expressions.
.PP
This function is available in templates as the \f(CW\*(C`html\*(C'\fR filter, but you'd better
to use \f(CW\*(C`unmark_raw\*(C'\fR to ensure expressions to be html-escaped.
.PP
\fI\f(CI\*(C`uri_escape($str :Str) :Str\*(C'\fI\fR
.IX Subsection "uri_escape($str :Str) :Str"
.PP
Escapes \s-1URI\s0 unsafe characters in \fI\f(CI$str\fI\fR, and returns it.
.PP
This function is available in templates as the \f(CW\*(C`uri\*(C'\fR filter.
.PP
\fI\f(CI\*(C`html_builder { block } | \e&function :CodeRef\*(C'\fI\fR
.IX Subsection "html_builder { block } | &function :CodeRef"
.PP
Wraps a block or \fI&function\fR with \f(CW\*(C`mark_raw\*(C'\fR so that the new subroutine
will return a raw string.
.PP
This function is used to tell the xslate engine that \fI&function\fR is an
\&\s-1HTML\s0 builder that returns \s-1HTML\s0 sources. For example:
.PP
.Vb 6
\&    sub some_html_builder {
\&        my @args = @_;
\&        my $html;
\&        # build HTML ...
\&        return $html;
\&    }
\&
\&    my $tx = Text::Xslate\->new(
\&        function => {
\&            some_html_builder => html_builder(\e&some_html_builder),
\&        },
\&    );
.Ve
.PP
See also Text::Xslate::Manual::Cookbook.
.SS "Command line interface"
.IX Subsection "Command line interface"
The \f(CWxslate(1)\fR command is provided as a \s-1CLI\s0 to the Text::Xslate module,
which is used to process directory trees or to evaluate one liners.
For example:
.PP
.Vb 1
\&    $ xslate \-Dname=value \-o dest_path src_path
\&
\&    $ xslate \-e \*(AqHello, <: $ARGV[0] :> wolrd!\*(Aq Xslate
\&    $ xslate \-s TTerse \-e \*(AqHello, [% ARGV.0 %] world!\*(Aq TTerse
.Ve
.PP
See \fIxslate\fR\|(1) for details.
.SH "TEMPLATE SYNTAX"
.IX Header "TEMPLATE SYNTAX"
There are multiple template syntaxes available in Xslate.
.IP "Kolon" 4
.IX Item "Kolon"
\&\fBKolon\fR is the default syntax, using \f(CW\*(C`<: ... :>\*(C'\fR inline code and
\&\f(CW\*(C`: ...\*(C'\fR line code, which is explained in Text::Xslate::Syntax::Kolon.
.IP "Metakolon" 4
.IX Item "Metakolon"
\&\fBMetakolon\fR is the same as Kolon except for using \f(CW\*(C`[% ... %]\*(C'\fR inline code and
\&\f(CW\*(C`%% ...\*(C'\fR line code, instead of \f(CW\*(C`<: ... :>\*(C'\fR and \f(CW\*(C`: ...\*(C'\fR.
.IP "TTerse" 4
.IX Item "TTerse"
\&\fBTTerse\fR is a syntax that is a subset of Template-Toolkit 2 (and partially \s-1TT3\s0),
which is explained in Text::Xslate::Syntax::TTerse.
.IP "HTMLTemplate" 4
.IX Item "HTMLTemplate"
There's HTML::Template compatible layers in \s-1CPAN\s0.
.Sp
Text::Xslate::Syntax::HTMLTemplate is a syntax for HTML::Template.
.Sp
HTML::Template::Parser is a converter from HTML::Template to Text::Xslate.
.SH "NOTES"
.IX Header "NOTES"
There are common notes in Xslate.
.SS "Nil/undef handling"
.IX Subsection "Nil/undef handling"
Note that nil (i.e. \f(CW\*(C`undef\*(C'\fR in Perl) handling is different from Perl's.
Basically it does nothing, but \f(CW\*(C`verbose => 2\*(C'\fR will produce warnings on it.
.IP "to print" 4
.IX Item "to print"
Prints nothing.
.IP "to access fields" 4
.IX Item "to access fields"
Returns nil. That is, \f(CW\*(C`nil.foo.bar.baz\*(C'\fR produces nil.
.IP "to invoke methods" 4
.IX Item "to invoke methods"
Returns nil. That is, \f(CW\*(C`nil.foo().bar().baz()\*(C'\fR produces nil.
.IP "to iterate" 4
.IX Item "to iterate"
Dealt as an empty array.
.IP "equality" 4
.IX Item "equality"
\&\f(CW\*(C`$var == nil\*(C'\fR returns true if and only if \fI\f(CI$var\fI\fR is nil.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Perl 5.8.1 or later.
.PP
If you have a C compiler, the \s-1XS\s0 backend will be used. Otherwise the pure Perl
backend will be used.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Context controls. e.g. \f(CW\*(C`<: [ $foo\->bar @list ] :>\*(C'\fR.
.IP "\(bu" 4
Augment modifiers.
.IP "\(bu" 4
Default arguments and named arguments for macros.
.IP "\(bu" 4
External macros.
.Sp
Just idea: in the new macro concept, macros and external templates will be
the same in internals:
.Sp
.Vb 3
\&    : macro foo($lang) { "Hello, " ~ $lang ~ " world!" }
\&    : include foo { lang => \*(AqXslate\*(Aq }
\&    : # => \*(AqHello, Xslate world!\*(Aq
\&
\&    : extern bar \*(Aqmy/bar.tx\*(Aq;     # \*(Aqextern bar $file\*(Aq is ok
\&    : bar( value => 42 );         # calls an external template
\&    : include bar { value => 42 } # ditto
.Ve
.IP "\(bu" 4
An \*(L"too-safe\*(R" \s-1HTML\s0 escaping filter which escape all the symbolic characters
.SH "RESOURCES"
.IX Header "RESOURCES"
\&\s-1WEB:\s0 <http://xslate.org/>
.PP
\&\s-1ML:\s0 <http://groups.google.com/group/xslate>
.PP
\&\s-1IRC:\s0 #xslate @ irc.perl.org
.PP
\&\s-1PROJECT\s0 \s-1HOME:\s0 <http://github.com/xslate/>
.PP
\&\s-1REPOSITORY:\s0 http://github.com/xslate/p5\-Text\-Xslate/ <http://github.com/xslate/p5-Text-Xslate/>
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception. If you find a bug please either email me, or add the bug
to cpan-RT. Patches are welcome :)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Documents:
.PP
Text::Xslate::Manual
.PP
Xslate template syntaxes:
.PP
Text::Xslate::Syntax::Kolon
.PP
Text::Xslate::Syntax::Metakolon
.PP
Text::Xslate::Syntax::TTerse
.PP
Xslate command:
.PP
xslate
.PP
Other template modules that Xslate has been influenced by:
.PP
Text::MicroTemplate
.PP
Text::MicroTemplate::Extended
.PP
Text::ClearSilver
.PP
Template (Template::Toolkit)
.PP
HTML::Template
.PP
HTML::Template::Pro
.PP
Template::Alloy
.PP
Template::Sandbox
.PP
Benchmarks:
.PP
Template::Benchmark
.PP
<http://xslate.org/benchmark.html>
.PP
Papers:
.PP
<http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf> \-  Enforcing Strict Model-View Separation in Template Engines
.SH "ACKNOWLEDGEMENT"
.IX Header "ACKNOWLEDGEMENT"
Thanks to lestrrat for the suggestion to the interface of \f(CW\*(C`render()\*(C'\fR,
the contribution of Text::Xslate::Runner (was App::Xslate), and a lot of
suggestions.
.PP
Thanks to tokuhirom for the ideas, feature requests, encouragement, and bug finding.
.PP
Thanks to gardejo for the proposal to the name \fBtemplate cascading\fR.
.PP
Thanks to makamaka for the contribution of Text::Xslate::PP.
.PP
Thanks to jjn1056 to the concept of template overlay (now implemented as \f(CW\*(C`cascade with ...\*(C'\fR).
.PP
Thanks to typester for the various inspirations.
.PP
Thanks to clouder for the patch of adding \f(CW\*(C`AND\*(C'\fR and \f(CW\*(C`OR\*(C'\fR to TTerse.
.PP
Thanks to punytan for the documentation improvement.
.PP
Thanks to chiba for the bug reports and patches.
.PP
Thanks to turugina for the patch to fix Win32 problems
.PP
Thanks to Sam Graham for the bug reports.
.PP
Thanks to Mons Anderson for the bug reports and patches.
.PP
Thanks to hirose31 for the feature requests and bug reports.
.PP
Thanks to c9s for the contribution of the documents.
.PP
Thanks to shiba_yu36 for the bug reports.
.PP
Thanks to kane46taka for the bug reports.
.PP
Thanks to cho45 for the bug reports.
.PP
Thanks to shmorimo for the bug reports.
.PP
Thanks to ueda for the suggestions.
.SH "AUTHOR"
.IX Header "AUTHOR"
Fuji, Goro (gfx) <gfuji(at)cpan.org>
.PP
Makamaka Hannyaharamitu (makamaka) (Text::Xslate::PP)
.PP
Maki, Daisuke (lestrrat) (Text::Xslate::Runner)
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2010, Fuji, Goro (gfx). All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
