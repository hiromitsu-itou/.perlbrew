.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::CSV::Encoded 3"
.TH Text::CSV::Encoded 3 "2010-04-26" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::CSV::Encoded \- Encoding aware Text::CSV.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    # Here in Perl 5.8 or later
\&    $csv = Text::CSV::Encoded\->new ({
\&        encoding_in  => "iso\-8859\-1", # the encoding comes into   Perl
\&        encoding_out => "cp1252",     # the encoding comes out of Perl
\&    });
\&
\&    # parsing CSV is regarded as input
\&    $csv\->parse( $line );      # $line is a iso\-8859\-1 encoded string
\&    @columns = $csv\->fields(); # they are unicode data
\&
\&    # combining list is regarded as output
\&    $csv\->combine(@columns);   # they are unicode data
\&    $line = $csv\->string();    # $line is a cp1252 encoded string
\&
\&    # if you want for returned @columns to be encoded in $encoding
\&    #   or want for combining @columns to be assumed in $encoding
\&    $csv\->encoding( $encoding );
\&
\&    # change input/output encodings
\&    $csv\->encoding_in(\*(Aqshiftjis\*(Aq)\->encoding_out(\*(Aqutf8\*(Aq);
\&    $csv\->eol("\en");
\&
\&    open (my $in,  "sjis.csv");
\&    open (my $out, "output.csv");
\&
\&    # change an encoding from shiftjis to utf8
\&
\&    while( my $columns = $csv\->getline( $in ) ) {
\&        $csv\->print( $out, $columns );
\&    }
\&
\&    close($in);
\&    close($out);
\&
\&    # simple shortcuts
\&    # (regardless of encoding_in/out and encoding)
\&
\&    $uni_columns = $csv\->decode( \*(Aqeuc\-jp\*(Aq, $line );         # euc\-jp => unicode
\&    $line        = $csv\->encode( \*(Aqeuc\-jp\*(Aq, $uni_columns );  # unicode => euc\-jp
\&
\&    # pass check value to coder class
\&    $csv\->coder\->encode_check_value( Encode::FB_PERLQQ );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module inherits Text::CSV and is aware of input/output encodings.
.SH "ENCODINGS"
.IX Header "ENCODINGS"
Acceptable names of encodings (\f(CW\*(C`encoding_in\*(C'\fR, \f(CW\*(C`encoding_out\*(C'\fR and \f(CW\*(C`encoding\*(C'\fR)
are depend upon its coder class (see to \*(L"\s-1CODER\s0 \s-1CLASS\s0\*(R"). But these names should
be based on Encode supported names. See to Encode::Supported and Encode::Alias.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $csv = Text::CSV::Encoded\->new();
\&
\&    Text::CSV::Encoded\->error_diag unless $csv; # report error message
.Ve
.PP
Creates a new Text::CSV::Encoded object. It can take all options of Text::CSV.
Of course, \f(CW\*(C`binary\*(C'\fR option is always on.
.PP
If Text::CSV::Encoded fails in constructing, you can get an error message using \f(CW\*(C`error_diag\*(C'\fR.
See to \*(L"error_diag\*(R" in Text::CSV.
.PP
The following options are supported by this method:
.IP "encoding" 4
.IX Item "encoding"
The encoding of list data in below cases.
.Sp
.Vb 4
\&  * list data returned by fields() after successful parse().
\&  * list data consumed by combine().
\&  * list reference returned by getline().
\&  * list reference taken by print().
.Ve
.Sp
See to \*(L"encoding\*(R".
.IP "encoding_in" 4
.IX Item "encoding_in"
.PD 0
.IP "encoding_io_in" 4
.IX Item "encoding_io_in"
.IP "encoding_to_parse" 4
.IX Item "encoding_to_parse"
.PD
The encoding for pre-parsing \s-1CSV\s0 strings. See to \*(L"encoding_in\*(R".
.Sp
\&\f(CW\*(C`encoding_io_in\*(C'\fR is an alias to \f(CW\*(C`encoding_in\*(C'\fR. If both \f(CW\*(C`encoding_in\*(C'\fR
and \f(CW\*(C`encoding_io_in\*(C'\fR are set at the same time, the \f(CW\*(C`encoding_in\*(C'\fR
takes precedence.
.Sp
\&\f(CW\*(C`encoding_to_parse\*(C'\fR is an alias to \f(CW\*(C`encoding_in\*(C'\fR. If both \f(CW\*(C`encoding_in\*(C'\fR
and \f(CW\*(C`encoding_to_parse\*(C'\fR are set at the same time, the \f(CW\*(C`encoding_in\*(C'\fR
takes precedence.
.IP "encoding_out" 4
.IX Item "encoding_out"
.PD 0
.IP "encoding_io_out" 4
.IX Item "encoding_io_out"
.IP "encoding_to_combine" 4
.IX Item "encoding_to_combine"
.PD
The encoding for combined \s-1CSV\s0 strings. See to \*(L"encoding_out\*(R".
.Sp
\&\f(CW\*(C`encoding_io_out\*(C'\fR is an alias to \f(CW\*(C`encoding_out\*(C'\fR. If both \f(CW\*(C`encoding_out\*(C'\fR
and \f(CW\*(C`encoding_io_out\*(C'\fR are set at the same time, the \f(CW\*(C`encoding_out\*(C'\fR
takes precedence.
.Sp
\&\f(CW\*(C`encoding_to_combine\*(C'\fR is an alias to \f(CW\*(C`encoding_out\*(C'\fR. If both \f(CW\*(C`encoding_out\*(C'\fR
and \f(CW\*(C`encoding_io_out\*(C'\fR are set at the same time, the \f(CW\*(C`encoding_out\*(C'\fR
takes precedence.
.IP "coder_class" 4
.IX Item "coder_class"
A name of coder class that really decodes and encodes data.
.SS "encoding_in"
.IX Subsection "encoding_in"
.Vb 1
\&    $csv = $csv\->encoding_in( $encoding );
.Ve
.PP
The accessor to an encoding for pre-parsing \s-1CSV\s0 strings.
If no encoding is given, returns current \f(CW$encoding\fR, otherwise the object itself.
.PP
.Vb 1
\&    $encoding = $csv\->encoding_in()
.Ve
.PP
In \f(CW\*(C`parse\*(C'\fR or \f(CW\*(C`getline\*(C'\fR, the \f(CW$csv\fR will assume \s-1CSV\s0 data as the given
encoding. If \f(CW\*(C`encoding_in\*(C'\fR is not specified or is set with false value (undef),
it will assume input \s-1CSV\s0 strings as Unicode (not \s-1UTF\-8\s0) when Text::CSV::Encoded::Coder::Encode is used.
.PP
.Vb 2
\&    $csv\->encoding_in( undef );
\&    # assume as Unicode when Text::CSV::Encoded::Coder::Encode is used.
.Ve
.PP
If you pass a list reference that contains multiple encodings to the method,
the working are depend upon the coder class.
For example, if you use the coder class with Text::CSV::Encoded::Coder::EncodeGuess,
it might guess the encoding from the given list.
.PP
.Vb 2
\&    $csv\->coder_class( \*(AqText::CSV::Encoded::Coder::EncodeGuess\*(Aq );
\&    $csv\->encoding_in( [\*(Aqshiftjis\*(Aq, \*(Aqeuc\-jp\*(Aq, \*(Aqiso\-20022\-jp\*(Aq] );
.Ve
.PP
See to \*(L"Coder Class\*(R" and Text::CSV::Encoded::Coder::EncodeGuess.
.SS "encoding_out"
.IX Subsection "encoding_out"
.Vb 1
\&    $csv = $csv\->encoding_out( $encoding );
.Ve
.PP
The accessor to an encoding for converting combined \s-1CSV\s0 strings.
If no encoding is given, returns current \f(CW$encoding\fR, otherwise the object itself.
.PP
.Vb 1
\&    $encoding = $csv\->encoding_out();
.Ve
.PP
In \f(CW\*(C`combine\*(C'\fR or \f(CW\*(C`print\*(C'\fR, the \f(CW$csv\fR will return a result string encoded in the
given encoding. If \f(CW\*(C`encoding_out\*(C'\fR is not specified or is set with false value,
it will return a result string as Unicode (not \s-1UTF\-8\s0).
.PP
.Vb 2
\&    $csv\->encoding_out( undef );
\&    # return as Unicode when Text::CSV::Encoded::Coder::Encode is used.
.Ve
.PP
You must not pass a list reference to \f(CW\*(C`encoding_out\*(C'\fR, unlike \f(CW\*(C`encoding_in\*(C'\fR or \f(CW\*(C`encoding\*(C'\fR.
.SS "encoding"
.IX Subsection "encoding"
.Vb 2
\&    $csv = $csv\->encoding( $encoding );
\&    $encoding = $csv\->encoding();
.Ve
.PP
The accessor to an encoding for list data in the below cases.
.PP
.Vb 4
\&  * list data returned by fields() after successful parse().
\&  * list data consumed by combine().
\&  * list reference returned by getline().
\&  * list reference taken by print().
.Ve
.PP
In other word, in \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`getline\*(C'\fR, \f(CW\*(C`encoding\*(C'\fR is an encoding of the returned list.
And in \f(CW\*(C`combine\*(C'\fR and \f(CW\*(C`print\*(C'\fR, it is assumed as an encoding for the passing list data.
.PP
If \f(CW\*(C`encoding\*(C'\fR is not specified or is set with false value (\f(CW\*(C`undef\*(C'\fR),
the field data will be regarded as Unicode (when Text::CSV::Encoded::Coder::Encode is used).
.PP
.Vb 5
\&    # ex.) a souce code is encoded in euc\-jp, and print to stdout in shiftjis.
\&    @fields = ( .... );
\&    $csv\->encoding(\*(Aqeuc\-jp\*(Aq)
\&        \->encoding_to_combine(\*(Aqshiftjis\*(Aq) # same as encoding_out
\&        \->combine( @fields ); # from euc\-jp to shift_jis
\&
\&    print $csv\->string;
\&
\&    $csv\->encoding(\*(Aqshiftjis\*(Aq)
\&        \->encoding_to_parse(\*(Aqshiftjis\*(Aq) # same as encoding_in
\&        \->parse( $csv\->string ); # from shift_jis to shift_jis
\&
\&    print join(", ", $csv\->fields );
.Ve
.PP
If you pass a list reference contains multiple encodings to the method,
The working are depend upon the coder class. For example,
Text::CSV::Encoded::EncodeGuess might guess the encoding from the given list.
.PP
.Vb 2
\&    $csv\->coder_class( \*(AqText::CSV::Encoded::Coder::EncodeGuess\*(Aq );
\&    $csv\->encoding( [\*(Aqascii\*(Aq, \*(Aqucs2\*(Aq] )\->combine( @cols );
.Ve
.PP
See to \*(L"Coder Class\*(R" and Text::CSV::Encoded::Coder::EncodeGuess.
.SS "parse/combine/getline/print"
.IX Subsection "parse/combine/getline/print"
.Vb 2
\&    $csv\->parse( $encoded_string );
\&    @unicode_array = $csv\->fields();
\&
\&    $csv\->combine( @unicode_array );
\&    $encoded_string = $csv\->string;
\&
\&    $unicode_arrayref = $csv\->getline( $io );
\&    # get arrayref contains unicode strings
\&    $csv\->print( $io, $unicode_arrayref );
\&    # print $io with string encoded in $csv\->encoded_in.
\&
\&    $encoded_arrayref = $csv\->getline( $io => $encoding )
\&    # directly encoded in $encoding.
.Ve
.PP
Here is the relation of \f(CW\*(C`encoding_in\*(C'\fR, \f(CW\*(C`encoding_out\*(C'\fR and \f(CW\*(C`encoding\*(C'\fR.
.PP
.Vb 3
\&    # CSV string        =>  (getline/parsed)  =>     Perl array
\&    #           assumed as                  encoded in
\&    #                encoding_in                encoding
\&
\&
\&    # Perl array        =>  (print/combined)  =>     CSV string
\&    #           assumed as                  encoded in
\&    #               encoding                    encoding_out
.Ve
.PP
If you want to treat Perl array data as Unicode in Perl5.8 and later,
don't specify \f(CW\*(C`encoding\*(C'\fR (or set \f(CW\*(C`undef\*(C'\fR into \f(CW\*(C`encoding\*(C'\fR).
.SS "decode"
.IX Subsection "decode"
.Vb 1
\&    $arrayref = $csv\->decode( $encoding, $encoded_string );
\&
\&    $arrayref = $csv\->decode( $string );
.Ve
.PP
A short cut method to convert \s-1CSV\s0 to Perl.
Without \f(CW$encoding\fR, \f(CW$string\fR is assumed as a Unicode.
.PP
The returned value status is depend upon its coder class.
With Text::CSV::Encoded::Coder::Encode, \f(CW$arrayref\fR contains Unicode strings.
.SS "encode"
.IX Subsection "encode"
.Vb 1
\&    $encoded_string = $csv\->encode( $encoding, $arrayref );
\&
\&    $string = $csv\->encode( $arrayref );
.Ve
.PP
A short cut method to convert Perl to \s-1CSV\s0.
With Text::CSV::Encoded::Coder::Encode, \f(CW$arrayref\fR is assumed to contain Unicode strings.
.PP
Without \f(CW$encoding\fR, return as is.
.SS "coder_class"
.IX Subsection "coder_class"
.Vb 2
\&    $csv = $csv\->coder_class( $classname );
\&    $classname = $csv\->coder_class();
.Ve
.PP
Returns the coder class name. See to \*(L"\s-1CODER\s0 \s-1CLASS\s0\*(R".
.SS "coder"
.IX Subsection "coder"
.Vb 1
\&    $coder = $csv\->coder();
.Ve
.PP
Returns a coder object.
.SH "CODER CLASS"
.IX Header "CODER CLASS"
Text::CSV::Encoded delegates the encoding converting process to another module.
Since version 5.8, Perl standardly has Encode module. So the default coder
module Text::CSV::Encoded::Coder::Encode also uses it. In this case,
you don't have to take care of it.
.PP
In older Perl, the default is Text::CSV::Encoded::Coder::Base. It does nothing.
So you have to make a coder module using your favorite converting module, for example,
Unicode::String or Jcode and so on.
.PP
Please check Text::CSV::Encoded::Coder::Base and Text::CSV::Encoded::Coder::Encode
to make such a module.
.PP
In calling Text::CSV::Encoded, you can set another coder module with \f(CW\*(C`coder_class\*(C'\fR;
.PP
.Vb 1
\&  use Text::CSV::Encoded coder_class => \*(AqYourCoder\*(Aq;
.Ve
.PP
This will call \f(CW\*(C`YourCoder\*(C'\fR module in runtime.
.SS "Use Encode module"
.IX Subsection "Use Encode module"
Perl 5.8 or later, Text::CSV::Encoded use Text::CSV::Encoded::Coder::Encode
as its backend engine. You can set \f(CW\*(C`encoding_in\*(C'\fR, \f(CW\*(C`encoding_out\*(C'\fR and \f(CW\*(C`encoding\*(C'\fR
with Encode supported encodings. See to Encode::Supported and Encode::Alias.
.PP
Without \f(CW\*(C`encoding\*(C'\fR (or set \f(CW\*(C`undef\*(C'\fR), \f(CW\*(C`parse\*(C'\fR/\f(CW\*(C`getline\*(C'\fR/\f(CW\*(C`getline_hr\*(C'\fR return
list data whose entries are \f(CW\*(C`Unicode\*(C'\fR strings.
On the contrary, \f(CW\*(C`combine\*(C'\fR/\f(CW\*(C`print\*(C'\fR take data as \f(CW\*(C`Unicode\*(C'\fR string list.
.PP
About the extra methods \f(CW\*(C`decode\*(C'\fR and \f(CW\*(C`encode\*(C'\fR. \f(CW\*(C`decode\*(C'\fR returns \f(CW\*(C`Unicode\*(C'\fR string list
and \f(CW\*(C`encode\*(C'\fR takes \f(CW\*(C`Unicode\*(C'\fR string list. But If no \f(CW$encoding\fR is passed to \f(CW\*(C`encode\*(C'\fR,
it returns a non-Unicode \s-1CSV\s0 string for non-Unicode list data.
.SS "Use Encode::Guess module"
.IX Subsection "Use Encode::Guess module"
If you don't know definitely input \s-1CSV\s0 data encoding (for parse/getline),
Text::CSV::Encoded::Coder::EncodeGuess may be useful to you.
It inherits from Text::CSV::Encoded::Coder::Encode, so you can treate methods and
attributes as same as Text::CSV::Encoded::Coder::Encode. And it provides a guessing
fucntion with Encode::Guess.
.PP
When it is backend coder class, \f(CW\*(C`encoding_in\*(C'\fR and \f(CW\*(C`encoding\*(C'\fR can take a encoding list reference,
and then it might guess the encoding from the given list.
.PP
.Vb 1
\&    $csv\->encoding_in( [\*(Aqshiftjis\*(Aq, \*(Aqeuc\-jp\*(Aq] )\->parse( $sjis_or_eucjp_encoded_csv_string );
.Ve
.PP
It is important to remember the guessing feature is not always successful.
.PP
Or, the method can be applied to \f(CW\*(C`encoding\*(C'\fR.
For exmaple, you want to convert data from Microsoft Excel to \s-1CSV\s0.
.PP
.Vb 2
\&    use Text::CSV::Encoded  coder_class => \*(AqText::CSV::Encoded::Coder::EncodeGuess\*(Aq;
\&    use Spreadsheet::ParseExcel;
\&
\&    my $csv = Text::CSV::Encoded\->new( eol => "\en" );
\&    $csv\->encoding( [\*(Aqucs2\*(Aq, \*(Aqascii\*(Aq] ); # guessing ucs2 or ascii?
\&    $csv\->encoding_out(\*(Aqshiftjis\*(Aq); # print in shift_jis
\&
\&    my $excel = Spreadsheet::ParseExcel::Workbook\->Parse( $file );
\&    my $sheet = $excel\->{Worksheet}\->[0];
\&
\&    for my $row ( $sheet\->{MinRow} .. $sheet\->{MaxRow} ) {
\&        my @fields;
\&        for my $col ( $sheet\->{MinCol} ..  $sheet\->{MaxCol} ) {
\&            my $cell = $sheet\->{Cells}[$row][$col];
\&            push @fields, $cell\->{Val};
\&        }
\&        $csv\->print( \e@fields );
\&    }
.Ve
.PP
In this case, guessing for list data.
After combining, you may have a need to clear \f(CW\*(C`encoding\*(C'\fR.
Again remember that the feature is not always successful.
.PP
In addtion, Microsoft Excel data converting is a carefult thing.
See to \*(L"\s-1CAVEATS\s0\*(R" in Text::CSV_XS.
.SS "Use \s-1XXX\s0 module"
.IX Subsection "Use XXX module"
Someone might make a new coder module in older version Perl...
There is an example with Jcode in Text::CSV::Encoded::Coder::Base document.
.SH "TODO"
.IX Header "TODO"
.IP "More sophisticated tests \- Welcome!" 4
.IX Item "More sophisticated tests - Welcome!"
.PD 0
.IP "Speed" 4
.IX Item "Speed"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::CSV, Text::CSV_XS, Encode, Encode::Guess, utf8,
Text::CSV::Encoded::Coder::Base,
Text::CSV::Encoded::Coder::Encode,
Text::CSV::Encoded::Coder::EncodeGuess
.SH "AUTHOR"
.IX Header "AUTHOR"
Makamaka Hannyaharamitu, <makamaka[at]cpan.org>
.PP
The basic idea for this module and suggestions were given by H.Merijn Brand.
He and Juerd advised me many points about documents and sources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008\-2010 by Makamaka Hannyaharamitu
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
