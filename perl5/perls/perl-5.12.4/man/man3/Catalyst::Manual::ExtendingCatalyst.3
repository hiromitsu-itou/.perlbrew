.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::ExtendingCatalyst 3"
.TH Catalyst::Manual::ExtendingCatalyst 3 "2011-09-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::ExtendingCatalyst \- Extending The Framework
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document will provide you with access points, techniques and best
practices to extend the Catalyst framework, or to find more elegant
ways to abstract and use your own code.
.PP
The design of Catalyst is such that the framework itself should not
get in your way. There are many entry points to alter or extend
Catalyst's behaviour, and this can be confusing. This document is
written to help you understand the possibilities, current practices
and their consequences.
.PP
Please read the \*(L"\s-1BEST\s0 \s-1PRACTICES\s0\*(R" section before deciding on a design,
especially if you plan to release your code to \s-1CPAN\s0. The Catalyst
developer and user communities, which \fByou are part of\fR, will benefit
most if we all work together and coordinate.
.PP
If you are unsure on an implementation or have an idea you would like
to have \s-1RFC\s0'ed, it surely is a good idea to send your questions and
suggestions to the Catalyst mailing list (See \*(L"\s-1SUPPORT\s0\*(R" in Catalyst)
and/or come to the \f(CW\*(C`#catalyst\*(C'\fR channel on the \f(CW\*(C`irc.perl.org\*(C'\fR
network. You might also want to refer to those places for research to
see if a module doing what you're trying to implement already
exists. This might give you a solution to your problem or a basis for
starting.
.SH "BEST PRACTICES"
.IX Header "BEST PRACTICES"
During Catalyst's early days, it was common to write plugins to
provide functionality application wide. Since then, Catalyst has
become a lot more flexible and powerful. It soon became a best
practice to use some other form of abstraction or interface, to keep
the scope of its influence as close as possible to where it belongs.
.PP
For those in a hurry, here's a quick checklist of some fundamental
points. If you are going to read the whole thing anyway, you can jump
forward to \*(L"Namespaces\*(R".
.SS "Quick Checklist"
.IX Subsection "Quick Checklist"
.ie n .IP "Use the ""CatalystX::*"" namespace if you can!" 4
.el .IP "Use the \f(CWCatalystX::*\fR namespace if you can!" 4
.IX Item "Use the CatalystX::* namespace if you can!"
If your extension isn't a Model, View, Controller, Plugin, Engine,
or Log, it's best to leave it out of the \f(CW\*(C`Catalyst::\*(C'\fR namespace.
Use <CatalystX::> instead.
.IP "Don't make it a plugin unless you have to!" 4
.IX Item "Don't make it a plugin unless you have to!"
A plugin should be careful since it's overriding Catalyst internals.
If your plugin doesn't really need to muck with the internals, make it a
base Controller or Model.
.Sp
Also, if you think you really need a plugin, please instead consider
using a Moose::Role.
.IP "There's a community. Use it!" 4
.IX Item "There's a community. Use it!"
There are many experienced developers in the Catalyst community,
there's always the \s-1IRC\s0 channel and the mailing list to discuss things.
.IP "Add tests and documentation!" 4
.IX Item "Add tests and documentation!"
This gives a stable basis for contribution, and even more importantly,
builds trust. The easiest way is a test application. See
Catalyst::Manual::Tutorial::Testing for more information.
.SS "Namespaces"
.IX Subsection "Namespaces"
While some core extensions (engines, plugins, etc.) have to be placed
in the \f(CW\*(C`Catalyst::*\*(C'\fR namespace, the Catalyst core would like to ask
developers to use the \f(CW\*(C`CatalystX::*\*(C'\fR namespace if possible.
.PP
Please \fBdo not\fR invent components which are outside the well
known \f(CW\*(C`Model\*(C'\fR, \f(CW\*(C`View\*(C'\fR, \f(CW\*(C`Controller\*(C'\fR or \f(CW\*(C`Plugin\*(C'\fR namespaces!
.PP
When you try to put a base class for a \f(CW\*(C`Model\*(C'\fR, \f(CW\*(C`View\*(C'\fR or
\&\f(CW\*(C`Controller\*(C'\fR directly under your \f(CW\*(C`MyApp\*(C'\fR directory as, for example,
\&\f(CW\*(C`MyApp::Controller::Foo\*(C'\fR, you will have the problem that Catalyst
will try to load that base class as a component of your
application. The solution is simple: Use another namespace. Common
ones are \f(CW\*(C`MyApp::Base::Controller::*\*(C'\fR or \f(CW\*(C`MyApp::ControllerBase::*\*(C'\fR
as examples.
.SS "Can it be a simple module?"
.IX Subsection "Can it be a simple module?"
Sometimes you want to use functionality in your application that
doesn't require the framework at all. Remember that Catalyst is just
Perl and you always can just \f(CW\*(C`use\*(C'\fR a module. If you have application
specific code that doesn't need the framework, there is no problem in
putting it in your \f(CW\*(C`MyApp::*\*(C'\fR namespace. Just don't put it in
\&\f(CW\*(C`Model\*(C'\fR, \f(CW\*(C`Controller\*(C'\fR or \f(CW\*(C`View\*(C'\fR, because that would make Catalyst
try to load them as components.
.PP
Writing a generic component that only works with Catalyst is wasteful
of your time.  Try writing a plain perl module, and then a small bit
of glue that integrates it with Catalyst.  See
Catalyst::Model::DBIC::Schema for a
module that takes the approach.  The advantage here is that your
\&\*(L"Catalyst\*(R" \s-1DBIC\s0 schema works perfectly outside of Catalyst, making
testing (and command-line scripts) a breeze.  The actual Catalyst
Model is just a few lines of glue that makes working with the schema
convenient.
.PP
If you want the thinnest interface possible, take a look at
Catalyst::Model::Adaptor.
.SS "Using Moose roles to apply method modifiers"
.IX Subsection "Using Moose roles to apply method modifiers"
Rather than having a complex set of base classes which you have to mixin
via multiple inheritence, if your functionality is well structured, then
it's possible to use the composability of Moose roles, and method modifiers
to hook onto to provide functionality.
.PP
These can be applied to your models/views/controllers, and your application
class, and shipped to \s-1CPAN\s0.
Please see Catalyst::Manual::CatalystAndMoose for specific information
about using Roles in combination with Catalyst, and Moose::Manual::Roles
for more information about roles in general.
.SS "Inheritance and overriding methods"
.IX Subsection "Inheritance and overriding methods"
When overriding a method, keep in mind that some day additional
arguments may be provided to the method, if the last parameter is not
a flat list. It is thus better to override a method by shifting the
invocant off of \f(CW@_\fR and assign the rest of the used arguments, so
you can pass your complete arguments to the original method via \f(CW@_\fR:
.PP
.Vb 1
\&  use MRO::Compat; ...
\&
\&  sub foo {
\&    my $self = shift;
\&    my ($bar, $baz) = @_; # ...  return
\&    $self\->next::method(@_);
\&  }
.Ve
.PP
If you would do the common
.PP
.Vb 1
\&  my ($self, $foo, $bar) = @_;
.Ve
.PP
you'd have to use a much uglier construct to ensure that all arguments
will be passed along and the method is future proof:
.PP
.Vb 1
\&  $self\->next::method(@_[ 1 .. $#_ ]);
.Ve
.SS "Tests and documentation"
.IX Subsection "Tests and documentation"
When you release your module to the \s-1CPAN\s0, proper documentation and at
least a basic test suite (which means more than pod or even just
\&\f(CW\*(C`use_ok\*(C'\fR, sorry) gives people a good base to contribute to the
module.  It also shows that you care for your users. If you would like
your module to become a recommended addition, these things will prove
invaluable.
.PP
If you're just getting started, try using
CatalystX::Starter to generate some example
tests for your module.
.SS "Maintenance"
.IX Subsection "Maintenance"
In planning to release a module to the community (Catalyst or \s-1CPAN\s0 and
Perl), you should consider if you have the resources to keep it up to
date, including fixing bugs and accepting contributions.
.PP
If you're not sure about this, you can always ask in the proper
Catalyst or Perl channels if someone else might be interested in the
project, and would jump in as co-maintainer.
.PP
A public repository can further ease interaction with the
community. Even read only access enables people to provide you with
patches to your current development version. subversion, \s-1SVN\s0 and \s-1SVK\s0,
are broadly preferred in the Catalyst community.
.PP
If you're developing a Catalyst extension, please consider asking the
core team for space in Catalyst's own subversion repository. You can
get in touch about this via \s-1IRC\s0 or the Catalyst developers mailing
list.
.SS "The context object"
.IX Subsection "The context object"
Sometimes you want to get a hold of the context object in a component
that was created on startup time, where no context existed yet. Often
this is about the model reading something out of the stash or other
context information (current language, for example).
.PP
If you use the context object in your component you have tied it to an
existing request.  This means that you might get into problems when
you try to use the component (e.g. the model \- the most common case)
outside of Catalyst, for example in cronjobs.
.PP
A stable solution to this problem is to design the Catalyst model
separately from the underlying model logic. Let's take
Catalyst::Model::DBIC::Schema as an example. You can create a
schema outside of Catalyst that knows nothing about the web. This kind
of design ensures encapsulation and makes development and maintenance
a whole lot easier. The you use the aforementioned model to tie your
schema to your application. This gives you a \f(CW\*(C`MyApp::DBIC\*(C'\fR (the name
is of course just an example) model as well as
\&\f(CW\*(C`MyApp::DBIC::TableName\*(C'\fR models to access your result sources
directly.
.PP
By creating such a thin layer between the actual model and the
Catalyst application, the schema itself is not at all tied to any
application and the layer in-between can access the model's \s-1API\s0 using
information from the context object.
.PP
A Catalyst component accesses the context object at request time with
\&\*(L"\s-1ACCEPT_CONTEXT\s0($c, \f(CW@args\fR)\*(R" in Catalyst::Component.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The application has to interact with the extension with some
configuration. There is of course again more than one way to do it.
.SS "Attributes"
.IX Subsection "Attributes"
You can specify any valid Perl attribute on Catalyst actions you like.
(See \*(L"Syntax of Attribute Lists\*(R" in attributes for a description of
what is valid.) These will be available on the \f(CW\*(C`Catalyst::Action\*(C'\fR
instance via its \f(CW\*(C`attributes\*(C'\fR accessor. To give an example, this
action:
.PP
.Vb 5
\&  sub foo : Local Bar(\*(AqBaz\*(Aq) {
\&      my ($self, $c) = @_;
\&      my $attributes = $self\->action_for(\*(Aqfoo\*(Aq)\->attributes;
\&      $c\->res\->body($attributes\->{Bar}[0] );
\&  }
.Ve
.PP
will set the response body to \f(CW\*(C`Baz\*(C'\fR. The values always come in an
array reference. As you can see, you can use attributes to configure
your actions. You can specify or alter these attributes via
\&\*(L"Component Configuration\*(R", or even react on them as soon as
Catalyst encounters them by providing your own component base
class.
.SS "Creating custom accessors"
.IX Subsection "Creating custom accessors"
Catalyst::Component uses Class::Accessor::Fast for accessor
creation. Please refer to the modules documentation for usage
information.
.SS "Component Configuration"
.IX Subsection "Component Configuration"
At creation time, the class configuration of your component (the one
available via \f(CW\*(C`$self\->config\*(C'\fR) will be merged with possible
configuration settings from the applications configuration (either
directly or via config file). This is done by Catalyst, and the
correctly merged configuration is passed to your component's
constructor (i.e. the new method).
.PP
Ergo, if you define an accessor for each configuration value
that your component takes, then the value will be automatically stored
in the controller object's hash reference, and available from the
accessor.
.PP
The \f(CW\*(C`config\*(C'\fR accessor always only contains the original class configuration
and you \fB\s-1MUST\s0 \s-1NEVER\s0\fR call \f(CW$self\fR\->config to get your component configuration,
as the data there is likely to be a subset of the correct config.
.PP
For example:
.PP
.Vb 2
\&  package MyApp
\&  use Moose;
\&
\&  extends \*(AqCatalyst\*(Aq;
\&
\&  ...
\&
\&  _\|_PACKAGE_\|_\->config(
\&    \*(AqController::Foo\*(Aq => { some_value => \*(Aqbar\*(Aq },
\&  );
\&
\&  ...
\&
\&  package MyApp::Controller::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  BEGIN { extends \*(AqCatalyst::Controller\*(Aq };
\&
\&  has some_value ( is => \*(Aqro\*(Aq, required => 1 );
\&
\&  sub some_method {
\&      my $self = shift;
\&      return "the value of \*(Aqsome_value\*(Aq is " . $self\->some_value;
\&  }
\&
\&  ...
\&
\&  my $controller = $c\->controller(\*(AqFoo\*(Aq);
\&  warn $controller\->some_value;
\&  warn $controller\->some_method;
.Ve
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This part contains the technical details of various implementation
methods. Please read the \*(L"\s-1BEST\s0 \s-1PRACTICES\s0\*(R" before you start your
implementation, if you haven't already.
.SS "Action classes"
.IX Subsection "Action classes"
Usually, your action objects are of the class Catalyst::Action.
You can override this with the \f(CW\*(C`ActionClass\*(C'\fR attribute to influence
execution and/or dispatching of the action. A widely used example of
this is Catalyst::Action::RenderView, which is used in every newly
created Catalyst application in your root controller:
.PP
.Vb 1
\&  sub end : ActionClass(\*(AqRenderView\*(Aq) { }
.Ve
.PP
Usually, you want to override the \f(CW\*(C`execute\*(C'\fR and/or the \f(CW\*(C`match\*(C'\fR
method. The execute method of the action will naturally call the
methods code. You can surround this by overriding the method in a
subclass:
.PP
.Vb 5
\&  package Catalyst::Action::MyFoo; 
\&  use Moose;
\&  use namespace::autoclean;
\&  use MRO::Compat; 
\&  extends \*(AqCatalyst::Action\*(Aq;
\&
\&  sub execute {
\&      my $self = shift;
\&      my ($controller, $c, @args) = @_;
\&      # put your \*(Aqbefore\*(Aq code here
\&      my $r = $self\->next::method(@_);
\&      # put your \*(Aqafter\*(Aq code here
\&      return $r;
\&  }
\&  1;
.Ve
.PP
We are using MRO::Compat to ensure that you have the next::method
call, from Class::C3 (in older perls), or natively (if you are using 
perl 5.10) to re-dispatch to the original \f(CW\*(C`execute\*(C'\fR method in the 
Catalyst::Action class.
.PP
The Catalyst dispatcher handles an incoming request and, depending
upon the dispatch type, will call the appropriate target or chain. 
From time to time it asks the actions themselves, or through the
controller, if they would match the current request. That's what the
\&\f(CW\*(C`match\*(C'\fR method does.  So by overriding this, you can change on what
the action will match and add new matching criteria.
.PP
For example, the action class below will make the action only match on
Mondays:
.PP
.Vb 5
\&  package Catalyst::Action::OnlyMondays; 
\&  use Moose;
\&  use namespace::autoclean;
\&  use MRO::Compat;
\&  extends \*(AqCatalyst::Action\*(Aq;
\&
\&  sub match {
\&      my $self = shift;
\&      return 0 if ( localtime(time) )[6] == 1;
\&      return $self\->next::method(@_);
\&   }
\&  1;
.Ve
.PP
And this is how we'd use it:
.PP
.Vb 4
\&  sub foo: Local ActionClass(\*(AqOnlyMondays\*(Aq) {
\&      my ($self, $c) = @_;
\&      $c\->res\->body(\*(AqI feel motivated!\*(Aq);
\&  }
.Ve
.PP
If you are using action classes often or have some specific base
classes that you want to specify more conveniently, you can implement
a component base class providing an attribute handler.
.PP
It is not possible to use multiple action classes at once, however
Catalyst::Controller::ActionRole allows you to apply Moose Roles
to actions.
.PP
For further information on action classes and roles, please refer to
Catalyst::Action and Catalyst::Manual::Actions.
.SS "Component base classes"
.IX Subsection "Component base classes"
Many Catalyst::Plugin that were written in Catalyst's early days
should really have been just controller base classes. With such a
class, you could provide functionality scoped to a single controller,
not polluting the global namespace in the context object.
.PP
You can provide regular Perl methods in a base class as well as
actions which will be inherited to the subclass. Please refer to
\&\*(L"Controllers\*(R" for an example of this.
.PP
You can introduce your own attributes by specifying a handler method
in the controller base. For example, to use a \f(CW\*(C`FullClass\*(C'\fR attribute
to specify a fully qualified action class name, you could use the
following implementation. Note, however, that this functionality is
already provided via the \f(CW\*(C`+\*(C'\fR prefix for action classes. A simple
.PP
.Vb 1
\&  sub foo : Local ActionClass(\*(Aq+MyApp::Action::Bar\*(Aq) { ... }
.Ve
.PP
will use \f(CW\*(C`MyApp::Action::Bar\*(C'\fR as action class.
.PP
.Vb 4
\&  package MyApp::Base::Controller::FullClass;
\&  use Moose;
\&  use namespace::autoclean;
\&  BEGIN { extends \*(AqCatalyst::Controller\*(Aq; }
\&
\&  sub _parse_FullClass_attr {
\&      my ($self, $app_class, $action_name, $value, $attrs) = @_;
\&      return( ActionClass => $value );
\&  }
\&  1;
.Ve
.PP
Note that the full line of arguments is only provided for completeness
sake. We could use this attribute in a subclass like any other
Catalyst attribute:
.PP
.Vb 4
\&  package MyApp::Controller::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  BEGIN { extends \*(AqMyApp::Base::Controller::FullClass\*(Aq; }
\&
\&  sub foo : Local FullClass(\*(AqMyApp::Action::Bar\*(Aq) { ... }
\&
\&  1;
.Ve
.SS "Controllers"
.IX Subsection "Controllers"
Many things can happen in controllers, and it often improves
maintainability to abstract some of the code out into reusable base
classes.
.PP
You can provide usual Perl methods that will be available via your
controller object, or you can even define Catalyst actions which will
be inherited by the subclasses. Consider this controller base class:
.PP
.Vb 3
\&  package MyApp::Base::Controller::ModelBase;
\&  use Moose;
\&  use namespace::autoclean;
\&
\&  BEGIN { extends \*(AqCatalyst::Controller\*(Aq; }
\&
\&  sub list : Chained(\*(Aqbase\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) {
\&      my ($self, $c) = @_;
\&      my $model = $c\->model( $self\->{model_name} );
\&      my $condition = $self\->{model_search_condition} || {};
\&      my $attrs = $self\->{model_search_attrs} || {};
\&      $c\->stash(rs => $model\->search($condition, $attrs);
\&  }
\&
\&  sub load : Chained(\*(Aqbase\*(Aq) PathPart(\*(Aq\*(Aq) CaptureArgs(1) {
\&      my ($self, $c, $id) = @_;
\&      my $model = $c\->model( $self\->{model_name} );
\&      $c\->stash(row => $model\->find($id));
\&  }
\&  1;
.Ve
.PP
This example implements two simple actions. The \f(CW\*(C`list\*(C'\fR action chains
to a (currently non-existent) \f(CW\*(C`base\*(C'\fR action and puts a result-set
into the stash taking a configured \f(CW\*(C`model_name\*(C'\fR as well as a search
condition and attributes. This action is a
chained endpoint. The other action,
called \f(CW\*(C` load \*(C'\fR is a chain midpoint that takes one argument. It takes
the value as an \s-1ID\s0 and loads the row from the configured model. Please
not that the above code is simplified for clarity. It misses error
handling, input validation, and probably other things.
.PP
The class above is not very useful on its own, but we can combine it
with some custom actions by sub-classing it:
.PP
.Vb 3
\&  package MyApp::Controller::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  
\&  BEGIN { extends \*(AqMyApp::Base::Controller::ModelBase\*(Aq; }
\&
\&  _\|_PACKAGE_\|_\->config( model_name => \*(AqDB::Foo\*(Aq,
\&                       model_search_condition=> { is_active => 1 },
\&                       model_search_attrs => { order_by => \*(Aqname\*(Aq },
\&                   );
\&
\&  sub base : Chained PathPart(\*(Aqfoo\*(Aq) CaptureArgs(0) { }
\&
\&  sub view : Chained(\*(Aqload\*(Aq) Args(0) {
\&      my ($self, $c) = @_;
\&      my $row = $c\->stash\->{row};
\&      $c\->res\->body(join \*(Aq: \*(Aq, $row\->name,
\&      $row\->description); }
\&  1;
.Ve
.PP
This class uses the formerly created controller as a base
class. First, we see the configurations that were used in the parent
class. Next comes the \f(CW\*(C`base\*(C'\fR action, where everything chains off of.
.PP
Note that inherited actions act like they were declared in your
controller itself. You can therefor call them just by their name in
\&\f(CW\*(C`forward\*(C'\fRs, \f(CW\*(C`detaches\*(C'\fR and \f(CW\*(C`Chained(..)\*(C'\fR specifications. This is an
important part of what makes this technique so useful.
.PP
The new \f(CW\*(C`view\*(C'\fR action ties itself to the \f(CW\*(C`load\*(C'\fR action specified in
the base class and outputs the loaded row's \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`description\*(C'\fR
columns. The controller \f(CW\*(C`MyApp::Controller::Foo\*(C'\fR now has these
publicly available paths:
.IP "/foo" 4
.IX Item "/foo"
Will call the controller's \f(CW\*(C`base\*(C'\fR, then the base classes \f(CW\*(C`list\*(C'\fR
action.
.IP "/foo/$id/view" 4
.IX Item "/foo/$id/view"
First, the controller's \f(CW\*(C`base\*(C'\fR will be called, then it will \f(CW\*(C`load\*(C'\fR
the row with the corresponding \f(CW$id\fR. After that, \f(CW\*(C`view\*(C'\fR will
display some fields out of the object.
.SS "Models and Views"
.IX Subsection "Models and Views"
If the functionality you'd like to add is really a data-set that you
want to manipulate, for example internal document types, images,
files, it might be better suited as a model.
.PP
The same applies for views. If your code handles representation or
deals with the applications interface and should be universally
available, it could be a perfect candidate for a view.
.PP
Please implement a \f(CW\*(C`process\*(C'\fR method in your views. This method will
be called by Catalyst if it is asked to forward to a component without
a specified action. Note that \f(CW\*(C`process\*(C'\fR is \fBnot a Catalyst action\fR
but a simple Perl method.
.PP
You are also encouraged to implement a \f(CW\*(C`render\*(C'\fR method corresponding
with the one in Catalyst::View::TT. This has proven invaluable,
because people can use your view for much more fine-grained content
generation.
.PP
Here is some example code for a fictional view:
.PP
.Vb 3
\&  package Catalyst::View::MyView;
\&  use Moose;
\&  use namespace::autoclean;
\&  
\&  extends \*(AqCatalyst::View\*(Aq;
\&
\&  sub process {
\&      my ($self, $c) = @_;
\&      my $template = $c\->stash\->{template};
\&      my $content = $self\->render($c, $template, $c\->stash);
\&      $c\->res\->body( $content );
\&  }
\&
\&  sub render {
\&      my ($self, $c, $template, $args) = @_;
\&      # prepare content here
\&      return $content;
\&  }
\&  1;
.Ve
.SS "Plugins"
.IX Subsection "Plugins"
The first thing to say about plugins is that if you're not sure if
your module should be a plugin, it probably shouldn't. It once was
common to add features to Catalyst by writing plugins that provide
accessors to said functionality. As Catalyst grew more popular, it
became obvious that this qualifies as bad practice.
.PP
By designing your module as a Catalyst plugin, every method you
implement, import or inherit will be available via your applications
context object.  A plugin pollutes the global namespace, and you
should be only doing that when you really need to.
.PP
Often, developers design extensions as plugins because they need to
get hold of the context object. Either to get at the stash or
request/response objects are the widely spread reasons. It is,
however, perfectly possible to implement a regular Catalyst component
(read: model, view or controller) that receives the current context
object via \*(L"\s-1ACCEPT_CONTEXT\s0($c, \f(CW@args\fR)\*(R" in Catalyst::Component.
.PP
When is a plugin suited to your task? Your code needs to be a
plugin to act upon or alter specific parts of Catalyst's request
lifecycle. If your functionality needs to change some \f(CW\*(C`prepare_*\*(C'\fR or
\&\f(CW\*(C`finalize_*\*(C'\fR stages, you won't get around a plugin.
.PP
Note, if you just want to hook into such a stage, and run code before,
or after it, then it is recommended that you use Mooses method modifiers
to do this.
.PP
Another valid target for a plugin architecture are things that
\&\fBreally\fR have to be globally available, like sessions or
authentication.
.PP
\&\fBPlease do not\fR release Catalyst extensions as plugins only to
provide some functionality application wide. Design it as a controller
base class or another better suited technique with a smaller scope, so that
your code only influences those parts of the application where it is
needed, and namespace clashes and conflicts are ruled out.
.PP
The implementation is pretty easy. Your plugin will be inserted in the
application's inheritance list, above Catalyst itself. You can by this
alter Catalyst's request lifecycle behaviour. Every method you
declare, every import in your package will be available as method on
the application and the context object. As an example, let's say you
want Catalyst to warn you every time uri_for was called without an action
object as the first parameter, for example to test that all your chained
uris are generated from actions (a recommended best practice).
You could do this with this simple
implementation (excuse the lame class name, it's just an example):
.PP
.Vb 4
\&  package Catalyst::Plugin::UriforUndefWarning;
\&  use strict;
\&  use Scalar::Util qw/blessed/;
\&  use MRO::Compat;
\&
\&  sub uri_for {
\&      my $c = shift;
\&      my $uri = $c\->next::method(@_);
\&      $c\->log\->warn( \*(Aquri_for with non action: \*(Aq, join(\*(Aq, \*(Aq, @_), )
\&        if (!blessed($_[0]) || !$_[0]\->isa(\*(AqCatalyst::Action\*(Aq));
\&      return $uri;
\&  }
\&
\&  1;
.Ve
.PP
This would override Catalyst's \f(CW\*(C`uri_for\*(C'\fR method and emit a \f(CW\*(C`warn\*(C'\fR
log entry containing the arguments to uri_for.
.PP
Please note this is not a practical example, as string URLs are fine for
static content etc.
.PP
A simple example like this is actually better as a Moose role, for example:
.PP
.Vb 3
\&  package CatalystX::UriforUndefWarning;
\&  use Moose::Role;
\&  use namespace::autoclean;
\&
\&  after \*(Aquri_for\*(Aq => sub {
\&    my ($c, $arg) = @_;
\&    $c\->log\->warn( \*(Aquri_for with non action: \*(Aq, join(\*(Aq, \*(Aq, @_), )
\&      if (!blessed($_[0]) || !$_[0]\->isa(\*(AqCatalyst::Action\*(Aq));
\&    return $uri;
\&  };
.Ve
.PP
Note that Catalyst will load any Moose Roles in the plugin list,
and apply them to your application class.
.SS "Factory components with \s-1\fICOMPONENT\s0()\fP"
.IX Subsection "Factory components with COMPONENT()"
Every component inheriting from Catalyst::Component contains a
\&\f(CW\*(C`COMPONENT\*(C'\fR method. It is used on application startup by
\&\f(CW\*(C`setup_components\*(C'\fR to instantiate the component object for the
Catalyst application. By default, this will merge the components own
\&\f(CW\*(C`config\*(C'\fRuration with the application wide overrides and call the
class' \f(CW\*(C`new\*(C'\fR method to return the component object.
.PP
You can override this method and do and return whatever you want.
However, you should use Class::C3 (via MRO::Compat) to forward
to the original \f(CW\*(C`COMPONENT\*(C'\fR method to merge the configuration of
your component.
.PP
Here is a stub \f(CW\*(C`COMPONENT\*(C'\fR method:
.PP
.Vb 3
\&  package CatalystX::Component::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  
\&  extends \*(AqCatalyst::Component\*(Aq;
\&
\&  sub COMPONENT {
\&      my $class = shift;
\&      # Note: $app is like $c, but since the application isn\*(Aqt fully
\&      # initialized, we don\*(Aqt want to call it $c yet.  $config 
\&      # is a hashref of config options possibly set on this component.
\&      my ($app, $config) = @_;
\&
\&      # Do things here before instantiation
\&      $new = $class\->next::method(@_);
\&      # Do things to object after instantiation
\&      return $new;
\&  }
.Ve
.PP
The arguments are the class name of the component, the class name of
the application instantiating the component, and a hash reference with
the controller's configuration.
.PP
You are free to re-bless the object, instantiate a whole other
component or really do anything compatible with Catalyst's
expectations on a component.
.PP
For more information, please see
\&\*(L"\s-1COMPONENT\s0($c,$arguments)\*(R" in Catalyst::Component.
.SS "Applying roles to parts of the framework"
.IX Subsection "Applying roles to parts of the framework"
CatalystX::RoleApplicator will allow you to apply Roles to
the following classes:
.IP "Request" 4
.IX Item "Request"
.PD 0
.IP "Response" 4
.IX Item "Response"
.IP "Engine" 4
.IX Item "Engine"
.IP "Dispatcher" 4
.IX Item "Dispatcher"
.IP "Stats" 4
.IX Item "Stats"
.PD
.PP
These roles can add new methods to these classes, or wrap preexisting methods.
.PP
The namespace for roles like this is \f(CW\*(C`Catalyst::TraitFor::XXX::YYYY\*(C'\fR.
.PP
For an example of a \s-1CPAN\s0 component implemented in this manor, see
Catalyst::TraitFor::Request::BrowserDetect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst, Catalyst::Manual::Actions, Catalyst::Component
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
