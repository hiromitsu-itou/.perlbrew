.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Controller 3"
.TH Catalyst::Controller 3 "2011-10-27" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Controller \- Catalyst Controller base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyApp::Controller::Search
\&  use base qw/Catalyst::Controller/;
\&
\&  sub foo : Local {
\&    my ($self,$c,@args) = @_;
\&    ...
\&  } # Dispatches to /search/foo
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Controllers are where the actions in the Catalyst framework
reside. Each action is represented by a function with an attribute to
identify what kind of action it is. See the Catalyst::Dispatcher
for more info about how Catalyst dispatches to actions.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
Like any other Catalyst::Component, controllers have a config hash,
accessible through \f(CW$self\fR\->config from the controller actions.  Some
settings are in use by the Catalyst framework:
.SS "namespace"
.IX Subsection "namespace"
This specifies the internal namespace the controller should be bound
to. By default the controller is bound to the \s-1URI\s0 version of the
controller name. For instance controller 'MyApp::Controller::Foo::Bar'
will be bound to 'foo/bar'. The default Root controller is an example
of setting namespace to '' (the null string).
.SS "path"
.IX Subsection "path"
Sets 'path_prefix', as described below.
.SS "action"
.IX Subsection "action"
Allows you to set the attributes that the dispatcher creates actions out of.
This allows you to do 'rails style routes', or override some of the
attribute definitions of actions composed from Roles.
You can set arguments globally (for all actions of the controller) and
specifically (for a single action).
.PP
.Vb 6
\&    _\|_PACKAGE_\|_\->config(
\&        action => {
\&            \*(Aq*\*(Aq => { Chained => \*(Aqbase\*(Aq, Args => 0  },
\&            base => { Chained => \*(Aq/\*(Aq, PathPart => \*(Aq\*(Aq, CaptureArgs => 0 },
\&        },
\&     );
.Ve
.PP
In the case above every sub in the package would be made into a Chain
endpoint with a \s-1URI\s0 the same as the sub name for each sub, chained
to the sub named \f(CW\*(C`base\*(C'\fR. Ergo dispatch to \f(CW\*(C`/example\*(C'\fR would call the
\&\f(CW\*(C`base\*(C'\fR method, then the \f(CW\*(C`example\*(C'\fR method.
.SS "action_args"
.IX Subsection "action_args"
Allows you to set constructor arguments on your actions. You can set arguments
globally and specifically (as above).
This is particularly useful when using \f(CW\*(C`ActionRole\*(C'\fRs
(Catalyst::Controller::ActionRole) and custom \f(CW\*(C`ActionClass\*(C'\fRes.
.PP
.Vb 6
\&    _\|_PACKAGE_\|_\->config(
\&        action_args => {
\&            \*(Aq*\*(Aq => { globalarg1 => \*(Aqhello\*(Aq, globalarg2 => \*(Aqgoodbye\*(Aq },
\&            \*(Aqspecific_action\*(Aq => { customarg => \*(Aqarg1\*(Aq },
\&        },
\&     );
.Ve
.PP
In the case above the action class associated with \f(CW\*(C`specific_action\*(C'\fR would get
passed the following arguments, in addition to the normal action constructor
arguments, when it is instantiated:
.PP
.Vb 1
\&  (globalarg1 => \*(Aqhello\*(Aq, globalarg2 => \*(Aqgoodbye\*(Aq, customarg => \*(Aqarg1\*(Aq)
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "\s-1BUILDARGS\s0 ($app, @args)"
.el .SS "\s-1BUILDARGS\s0 ($app, \f(CW@args\fP)"
.IX Subsection "BUILDARGS ($app, @args)"
From Catalyst::Component::ApplicationAttribute, stashes the application
instance as \f(CW$self\fR\->_application.
.ie n .SS "$self\->action_for('name')"
.el .SS "\f(CW$self\fP\->action_for('name')"
.IX Subsection "$self->action_for('name')"
Returns the Catalyst::Action object (if any) for a given method name
in this component.
.ie n .SS "$self\->action_namespace($c)"
.el .SS "\f(CW$self\fP\->action_namespace($c)"
.IX Subsection "$self->action_namespace($c)"
Returns the private namespace for actions in this component. Defaults
to a value from the controller name (for
e.g. MyApp::Controller::Foo::Bar becomes \*(L"foo/bar\*(R") or can be
overridden from the \*(L"namespace\*(R" config key.
.ie n .SS "$self\->path_prefix($c)"
.el .SS "\f(CW$self\fP\->path_prefix($c)"
.IX Subsection "$self->path_prefix($c)"
Returns the default path prefix for :PathPrefix, :Local, :LocalRegex and
relative :Path actions in this component. Defaults to the action_namespace or
can be overridden from the \*(L"path\*(R" config key.
.ie n .SS "$self\->register_actions($c)"
.el .SS "\f(CW$self\fP\->register_actions($c)"
.IX Subsection "$self->register_actions($c)"
Finds all applicable actions for this component, creates
Catalyst::Action objects (using \f(CW$self\fR\->create_action) for them and
registers them with \f(CW$c\fR\->dispatcher.
.ie n .SS "$self\->\fIget_action_methods()\fP"
.el .SS "\f(CW$self\fP\->\fIget_action_methods()\fP"
.IX Subsection "$self->get_action_methods()"
Returns a list of Moose::Meta::Method objects, doing the
MooseX::MethodAttributes::Role::Meta::Method role, which are the set of
action methods for this package.
.ie n .SS "$self\->register_action_methods($c, @methods)"
.el .SS "\f(CW$self\fP\->register_action_methods($c, \f(CW@methods\fP)"
.IX Subsection "$self->register_action_methods($c, @methods)"
Creates action objects for a set of action methods using \f(CW\*(C` create_action \*(C'\fR,
and registers them with the dispatcher.
.ie n .SS "$self\->action_class(%args)"
.el .SS "\f(CW$self\fP\->action_class(%args)"
.IX Subsection "$self->action_class(%args)"
Used when a controller is creating an action to determine the correct base
action class to use.
.ie n .SS "$self\->create_action(%args)"
.el .SS "\f(CW$self\fP\->create_action(%args)"
.IX Subsection "$self->create_action(%args)"
Called with a hash of data to be use for construction of a new
Catalyst::Action (or appropriate sub/alternative class) object.
.ie n .SS "$self\->_application"
.el .SS "\f(CW$self\fP\->_application"
.IX Subsection "$self->_application"
.ie n .SS "$self\->_app"
.el .SS "\f(CW$self\fP\->_app"
.IX Subsection "$self->_app"
Returns the application instance stored by \f(CW\*(C`new()\*(C'\fR
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
