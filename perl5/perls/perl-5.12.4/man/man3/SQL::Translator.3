.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator 3"
.TH SQL::Translator 3 "2011-10-06" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator \- manipulate structured data definitions (SQL and more)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::Translator;
\&
\&  my $translator          = SQL::Translator\->new(
\&      # Print debug info
\&      debug               => 1,
\&      # Print Parse::RecDescent trace
\&      trace               => 0,
\&      # Don\*(Aqt include comments in output
\&      no_comments         => 0,
\&      # Print name mutations, conflicts
\&      show_warnings       => 0,
\&      # Add "drop table" statements
\&      add_drop_table      => 1,
\&      # to quote or not to quote, thats the question
\&      quote_table_names     => 1,
\&      quote_field_names     => 1,
\&      # Validate schema object
\&      validate            => 1,
\&      # Make all table names CAPS in producers which support this option
\&      format_table_name   => sub {my $tablename = shift; return uc($tablename)},
\&      # Null\-op formatting, only here for documentation\*(Aqs sake
\&      format_package_name => sub {return shift},
\&      format_fk_name      => sub {return shift},
\&      format_pk_name      => sub {return shift},
\&  );
\&
\&  my $output     = $translator\->translate(
\&      from       => \*(AqMySQL\*(Aq,
\&      to         => \*(AqOracle\*(Aq,
\&      # Or an arrayref of filenames, i.e. [ $file1, $file2, $file3 ]
\&      filename   => $file,
\&  ) or die $translator\->error;
\&
\&  print $output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documentation covers the \s-1API\s0 for SQL::Translator.  For a more general
discussion of how to use the modules and scripts, please see
SQL::Translator::Manual.
.PP
SQL::Translator is a group of Perl modules that converts
vendor-specific \s-1SQL\s0 table definitions into other formats, such as
other vendor-specific \s-1SQL\s0, \s-1ER\s0 diagrams, documentation (\s-1POD\s0 and \s-1HTML\s0),
\&\s-1XML\s0, and Class::DBI classes.  The main focus of SQL::Translator is
\&\s-1SQL\s0, but parsers exist for other structured data formats, including
Excel spreadsheets and arbitrarily delimited text files.  Through the
separation of the code into parsers and producers with an object model
in between, it's possible to combine any parser with any producer, to
plug in custom parsers or producers, or to manipulate the parsed data
via the built-in object model.  Presently only the definition parts of
\&\s-1SQL\s0 are handled (\s-1CREATE\s0, \s-1ALTER\s0), not the manipulation of data (\s-1INSERT\s0,
\&\s-1UPDATE\s0, \s-1DELETE\s0).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The constructor is called \f(CW\*(C`new\*(C'\fR, and accepts a optional hash of options.
Valid options are:
.IP "\(bu" 4
parser / from
.IP "\(bu" 4
parser_args
.IP "\(bu" 4
producer / to
.IP "\(bu" 4
producer_args
.IP "\(bu" 4
filters
.IP "\(bu" 4
filename / file
.IP "\(bu" 4
data
.IP "\(bu" 4
debug
.IP "\(bu" 4
add_drop_table
.IP "\(bu" 4
quote_table_names
.IP "\(bu" 4
quote_field_names
.IP "\(bu" 4
no_comments
.IP "\(bu" 4
trace
.IP "\(bu" 4
validate
.PP
All options are, well, optional; these attributes can be set via
instance methods.  Internally, they are; no (non-syntactical)
advantage is gained by passing options to the constructor.
.SH "METHODS"
.IX Header "METHODS"
.SS "add_drop_table"
.IX Subsection "add_drop_table"
Toggles whether or not to add \*(L"\s-1DROP\s0 \s-1TABLE\s0\*(R" statements just before the
create definitions.
.SS "quote_table_names"
.IX Subsection "quote_table_names"
Toggles whether or not to quote table names with " in \s-1DROP\s0 and \s-1CREATE\s0
statements. The default (true) is to quote them.
.SS "quote_field_names"
.IX Subsection "quote_field_names"
Toggles whether or not to quote field names with " in most
statements. The default (true), is to quote them.
.SS "no_comments"
.IX Subsection "no_comments"
Toggles whether to print comments in the output.  Accepts a true or false
value, returns the current value.
.SS "producer"
.IX Subsection "producer"
The \f(CW\*(C`producer\*(C'\fR method is an accessor/mutator, used to retrieve or
define what subroutine is called to produce the output.  A subroutine
defined as a producer will be invoked as a function (\fInot a method\fR)
and passed its container \f(CW\*(C`SQL::Translator\*(C'\fR instance, which it should
call the \f(CW\*(C`schema\*(C'\fR method on, to get the \f(CW\*(C`SQL::Translator::Schema\*(C'\fR
generated by the parser.  It is expected that the function transform the
schema structure to a string.  The \f(CW\*(C`SQL::Translator\*(C'\fR instance is also useful
for informational purposes; for example, the type of the parser can be
retrieved using the \f(CW\*(C`parser_type\*(C'\fR method, and the \f(CW\*(C`error\*(C'\fR and
\&\f(CW\*(C`debug\*(C'\fR methods can be called when needed.
.PP
When defining a producer, one of several things can be passed in:  A
module name (e.g., \f(CW\*(C`My::Groovy::Producer\*(C'\fR), a module name relative to
the \f(CW\*(C`SQL::Translator::Producer\*(C'\fR namespace (e.g., \f(CW\*(C`MySQL\*(C'\fR), a module
name and function combination (\f(CW\*(C`My::Groovy::Producer::transmogrify\*(C'\fR),
or a reference to an anonymous subroutine.  If a full module name is
passed in (for the purposes of this method, a string containing \*(L"::\*(R"
is considered to be a module name), it is treated as a package, and a
function called \*(L"produce\*(R" will be invoked: \f(CW$modulename::produce\fR.
If \f(CW$modulename\fR cannot be loaded, the final portion is stripped off and
treated as a function.  In other words, if there is no file named
\&\fIMy/Groovy/Producer/transmogrify.pm\fR, \f(CW\*(C`SQL::Translator\*(C'\fR will attempt
to load \fIMy/Groovy/Producer.pm\fR and use \f(CW\*(C`transmogrify\*(C'\fR as the name of
the function, instead of the default \f(CW\*(C`produce\*(C'\fR.
.PP
.Vb 1
\&  my $tr = SQL::Translator\->new;
\&
\&  # This will invoke My::Groovy::Producer::produce($tr, $data)
\&  $tr\->producer("My::Groovy::Producer");
\&
\&  # This will invoke SQL::Translator::Producer::Sybase::produce($tr, $data)
\&  $tr\->producer("Sybase");
\&
\&  # This will invoke My::Groovy::Producer::transmogrify($tr, $data),
\&  # assuming that My::Groovy::Producer::transmogrify is not a module
\&  # on disk.
\&  $tr\->producer("My::Groovy::Producer::transmogrify");
\&
\&  # This will invoke the referenced subroutine directly, as
\&  # $subref\->($tr, $data);
\&  $tr\->producer(\e&my_producer);
.Ve
.PP
There is also a method named \f(CW\*(C`producer_type\*(C'\fR, which is a string
containing the classname to which the above \f(CW\*(C`produce\*(C'\fR function
belongs.  In the case of anonymous subroutines, this method returns
the string \*(L"\s-1CODE\s0\*(R".
.PP
Finally, there is a method named \f(CW\*(C`producer_args\*(C'\fR, which is both an
accessor and a mutator.  Arbitrary data may be stored in name => value
pairs for the producer subroutine to access:
.PP
.Vb 3
\&  sub My::Random::producer {
\&      my ($tr, $data) = @_;
\&      my $pr_args = $tr\->producer_args();
\&
\&      # $pr_args is a hashref.
.Ve
.PP
Extra data passed to the \f(CW\*(C`producer\*(C'\fR method is passed to
\&\f(CW\*(C`producer_args\*(C'\fR:
.PP
.Vb 1
\&  $tr\->producer("xSV", delimiter => \*(Aq,\es*\*(Aq);
\&
\&  # In SQL::Translator::Producer::xSV:
\&  my $args = $tr\->producer_args;
\&  my $delimiter = $args\->{\*(Aqdelimiter\*(Aq}; # value is ,\es*
.Ve
.SS "parser"
.IX Subsection "parser"
The \f(CW\*(C`parser\*(C'\fR method defines or retrieves a subroutine that will be
called to perform the parsing.  The basic idea is the same as that of
\&\f(CW\*(C`producer\*(C'\fR (see above), except the default subroutine name is
\&\*(L"parse\*(R", and will be invoked as \f(CW\*(C`$module_name::parse($tr, $data)\*(C'\fR.
Also, the parser subroutine will be passed a string containing the
entirety of the data to be parsed.
.PP
.Vb 2
\&  # Invokes SQL::Translator::Parser::MySQL::parse()
\&  $tr\->parser("MySQL");
\&
\&  # Invokes My::Groovy::Parser::parse()
\&  $tr\->parser("My::Groovy::Parser");
\&
\&  # Invoke an anonymous subroutine directly
\&  $tr\->parser(sub {
\&    my $dumper = Data::Dumper\->new([ $_[1] ], [ "SQL" ]);
\&    $dumper\->Purity(1)\->Terse(1)\->Deepcopy(1);
\&    return $dumper\->Dump;
\&  });
.Ve
.PP
There is also \f(CW\*(C`parser_type\*(C'\fR and \f(CW\*(C`parser_args\*(C'\fR, which perform
analogously to \f(CW\*(C`producer_type\*(C'\fR and \f(CW\*(C`producer_args\*(C'\fR
.SS "filters"
.IX Subsection "filters"
Set or retreive the filters to run over the schema during the
translation, before the producer creates its output. Filters are sub
routines called, in order, with the schema object to filter as the 1st
arg and a hash of options (passed as a list) for the rest of the args.
They are free to do whatever they want to the schema object, which will be
handed to any following filters, then used by the producer.
.PP
Filters are set as an array, which gives the order they run in.
Like parsers and producers, they can be defined by a module name, a
module name relative to the SQL::Translator::Filter namespace, a module
name and function name together or a reference to an anonymous subroutine.
When using a module name a function called \f(CW\*(C`filter\*(C'\fR will be invoked in
that package to do the work.
.PP
To pass args to the filter set it as an array ref with the 1st value giving
the filter (name or sub) and the rest its args. e.g.
.PP
.Vb 10
\& $tr\->filters(
\&     sub {
\&        my $schema = shift;
\&        # Do stuff to schema here!
\&     },
\&     DropFKeys,
\&     [ "Names", table => \*(Aqlc\*(Aq ],
\&     [ "Foo",   foo => "bar", hello => "world" ],
\&     [ "Filter5" ],
\& );
.Ve
.PP
Although you normally set them in the constructor, which calls
through to filters. i.e.
.PP
.Vb 8
\&  my $translator  = SQL::Translator\->new(
\&      ...
\&      filters => [
\&          sub { ... },
\&          [ "Names", table => \*(Aqlc\*(Aq ],
\&      ],
\&      ...
\&  );
.Ve
.PP
See \fIt/36\-filters.t\fR for more examples.
.PP
Multiple set calls to filters are cumulative with new filters added to
the end of the current list.
.PP
Returns the filters as a list of array refs, the 1st value being a
reference to the filter sub and the rest its args.
.SS "show_warnings"
.IX Subsection "show_warnings"
Toggles whether to print warnings of name conflicts, identifier
mutations, etc.  Probably only generated by producers to let the user
know when something won't translate very smoothly (e.g., MySQL \*(L"enum\*(R"
fields into Oracle).  Accepts a true or false value, returns the
current value.
.SS "translate"
.IX Subsection "translate"
The \f(CW\*(C`translate\*(C'\fR method calls the subroutine referenced by the
\&\f(CW\*(C`parser\*(C'\fR data member, then calls any \f(CW\*(C`filters\*(C'\fR and finally calls
the \f(CW\*(C`producer\*(C'\fR sub routine (these members are described above).
It accepts as arguments a number of things, in key => value format,
including (potentially) a parser and a producer (they are passed
directly to the \f(CW\*(C`parser\*(C'\fR and \f(CW\*(C`producer\*(C'\fR methods).
.PP
Here is how the parameter list to \f(CW\*(C`translate\*(C'\fR is parsed:
.IP "\(bu" 4
1 argument means it's the data to be parsed; which could be a string
(filename) or a reference to a scalar (a string stored in memory), or a
reference to a hash, which is parsed as being more than one argument
(see next section).
.Sp
.Vb 2
\&  # Parse the file /path/to/datafile
\&  my $output = $tr\->translate("/path/to/datafile");
\&
\&  # Parse the data contained in the string $data
\&  my $output = $tr\->translate(\e$data);
.Ve
.IP "\(bu" 4
More than 1 argument means its a hash of things, and it might be
setting a parser, producer, or datasource (this key is named
\&\*(L"filename\*(R" or \*(L"file\*(R" if it's a file, or \*(L"data\*(R" for a \s-1SCALAR\s0 reference.
.Sp
.Vb 7
\&  # As above, parse /path/to/datafile, but with different producers
\&  for my $prod ("MySQL", "XML", "Sybase") {
\&      print $tr\->translate(
\&                producer => $prod,
\&                filename => "/path/to/datafile",
\&            );
\&  }
\&
\&  # The filename hash key could also be:
\&      datasource => \e$data,
.Ve
.Sp
You get the idea.
.SS "filename, data"
.IX Subsection "filename, data"
Using the \f(CW\*(C`filename\*(C'\fR method, the filename of the data to be parsed
can be set. This method can be used in conjunction with the \f(CW\*(C`data\*(C'\fR
method, below.  If both the \f(CW\*(C`filename\*(C'\fR and \f(CW\*(C`data\*(C'\fR methods are
invoked as mutators, the data set in the \f(CW\*(C`data\*(C'\fR method is used.
.PP
.Vb 1
\&    $tr\->filename("/my/data/files/create.sql");
.Ve
.PP
or:
.PP
.Vb 6
\&    my $create_script = do {
\&        local $/;
\&        open CREATE, "/my/data/files/create.sql" or die $!;
\&        <CREATE>;
\&    };
\&    $tr\->data(\e$create_script);
.Ve
.PP
\&\f(CW\*(C`filename\*(C'\fR takes a string, which is interpreted as a filename.
\&\f(CW\*(C`data\*(C'\fR takes a reference to a string, which is used as the data to be
parsed.  If a filename is set, then that file is opened and read when
the \f(CW\*(C`translate\*(C'\fR method is called, as long as the data instance
variable is not set.
.SS "schema"
.IX Subsection "schema"
Returns the SQL::Translator::Schema object.
.SS "trace"
.IX Subsection "trace"
Turns on/off the tracing option of Parse::RecDescent.
.SS "validate"
.IX Subsection "validate"
Whether or not to validate the schema object after parsing and before
producing.
.SS "version"
.IX Subsection "version"
Returns the version of the SQL::Translator release.
.SH "AUTHORS"
.IX Header "AUTHORS"
See the included \s-1AUTHORS\s0 file:
http://search.cpan.org/dist/SQL\-Translator/AUTHORS <http://search.cpan.org/dist/SQL-Translator/AUTHORS>
.PP
If you would like to contribute to the project, you can send patches
to the developers mailing list:
.PP
.Vb 1
\&    sqlfairy\-developers@lists.sourceforge.net
.Ve
.PP
Or send us a message (with your Sourceforge username) asking to be
added to the project and what you'd like to contribute.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; version 2.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0
General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, \s-1MA\s0 02111\-1307
\&\s-1USA\s0
.SH "BUGS"
.IX Header "BUGS"
Please use <http://rt.cpan.org/> for reporting bugs.
.SH "PRAISE"
.IX Header "PRAISE"
If you find this module useful, please use
http://cpanratings.perl.org/rate/?distribution=SQL\-Translator <http://cpanratings.perl.org/rate/?distribution=SQL-Translator> to rate it.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl,
SQL::Translator::Parser,
SQL::Translator::Producer,
Parse::RecDescent,
\&\s-1GD\s0,
GraphViz,
Text::RecordParser,
Class::DBI,
XML::Writer.
