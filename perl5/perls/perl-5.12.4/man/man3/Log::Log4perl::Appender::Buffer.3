.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Appender::Buffer 3"
.TH Appender::Buffer 3 "2011-11-01" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&    Log::Log4perl::Appender::Buffer \- Buffering Appender
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Log::Log4perl qw(:easy);
\&
\&    my $conf = qq(
\&    log4perl.category                  = DEBUG, Buffer
\&
\&        # Regular Screen Appender
\&    log4perl.appender.Screen           = Log::Log4perl::Appender::Screen
\&    log4perl.appender.Screen.stdout    = 1
\&    log4perl.appender.Screen.layout    = PatternLayout
\&    log4perl.appender.Screen.layout.ConversionPattern = %d %p %c %m %n
\&
\&        # Buffering appender, using the appender above as outlet
\&    log4perl.appender.Buffer               = Log::Log4perl::Appender::Buffer
\&    log4perl.appender.Buffer.appender      = Screen
\&    log4perl.appender.Buffer.trigger_level = ERROR
\&    );
\&
\&    Log::Log4perl\->init(\e$conf);
\&
\&    DEBUG("This message gets buffered.");
\&    INFO("This message gets buffered also.");
\&
\&    # Time passes. Nothing happens. But then ...
\&
\&    print "It\*(Aqs GO time!!!\en";
\&
\&    ERROR("This message triggers a buffer flush.");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR takes these arguments:
.ie n .IP """appender""" 4
.el .IP "\f(CWappender\fR" 4
.IX Item "appender"
Specifies the name of the appender it buffers messages for. The
appender specified must be defined somewhere in the configuration file,
not necessarily before the definition of 
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR.
.ie n .IP """max_messages""" 4
.el .IP "\f(CWmax_messages\fR" 4
.IX Item "max_messages"
Specifies the maximum number of messages the appender will hold in
its ring buffer. \f(CW\*(C`max_messages\*(C'\fR is optional. By default,
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR will \fInot\fR limit the number of
messages buffered. This might be undesirable in long-running processes
accumulating lots of messages before a flush happens. If
\&\f(CW\*(C`max_messages\*(C'\fR is set to a numeric value,
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR will displace old messages in its
buffer to make room if the buffer is full.
.ie n .IP """trigger_level""" 4
.el .IP "\f(CWtrigger_level\fR" 4
.IX Item "trigger_level"
If trigger_level is set to one of Log4perl's levels (see
Log::Log4perl::Level), a \f(CW\*(C`trigger\*(C'\fR function will be defined internally
to flush the buffer if a message with a priority of \f(CW$level\fR or higher
comes along. This is just a convenience function. Defining
.Sp
.Vb 1
\&    log4perl.appender.Buffer.trigger_level = ERROR
.Ve
.Sp
is equivalent to creating a trigger function like
.Sp
.Vb 4
\&    log4perl.appender.Buffer.trigger = sub {   \e
\&        my($self, $params) = @_;               \e
\&        return $params\->{log4p_level} >=       \e
\&               $Log::Log4perl::Level::ERROR; }
.Ve
.Sp
See the next section for defining generic trigger functions.
.ie n .IP """trigger""" 4
.el .IP "\f(CWtrigger\fR" 4
.IX Item "trigger"
\&\f(CW\*(C`trigger\*(C'\fR holds a reference to a subroutine, which
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR will call on every incoming message
with the same parameters as the appender's \f(CW\*(C`log()\*(C'\fR method:
.Sp
.Vb 1
\&        my($self, $params) = @_;
.Ve
.Sp
\&\f(CW$params\fR references a hash containing
the message priority (key \f(CW\*(C`l4p_level\*(C'\fR), the
message category (key \f(CW\*(C`l4p_category\*(C'\fR) and the content of the message
(key \f(CW\*(C`message\*(C'\fR).
.Sp
If the subroutine returns 1, it will trigger a flush of buffered messages.
.Sp
Shortcut
.SH "DEVELOPMENT NOTES"
.IX Header "DEVELOPMENT NOTES"
\&\f(CW\*(C`Log::Log4perl::Appender::Buffer\*(C'\fR is a \fIcomposite\fR appender.
Unlike other appenders, it doesn't log any messages, it just
passes them on to its attached sub-appender.
For this reason, it doesn't need a layout (contrary to regular appenders).
If it defines none, messages are passed on unaltered.
.PP
Custom filters are also applied to the composite appender only.
They are \fInot\fR applied to the sub-appender. Same applies to appender
thresholds. This behaviour might change in the future.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2002\-2009 by Mike Schilli <m@perlmeister.com> 
and Kevin Goess <cpan@goess.org>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
