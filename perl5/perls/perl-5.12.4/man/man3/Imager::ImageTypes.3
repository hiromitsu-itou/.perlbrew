.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::ImageTypes 3"
.TH Imager::ImageTypes 3 "2011-11-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::ImageTypes \- image models for Imager
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Imager;
\&
\&  $img = Imager\->new(); #  Empty image (size is 0 by 0)
\&  $img\->open(file=>\*(Aqlena.png\*(Aq,type=>\*(Aqpng\*(Aq); # Read image from file
\&
\&  $img = Imager\->new(xsize=>400, ysize=>300); # RGB data
\&
\&  $img = Imager\->new(xsize=>400, ysize=>300,  # Grayscale
\&                     channels=>1);            #
\&
\&  $img = Imager\->new(xsize=>400, ysize=>300,  # RGB with alpha
\&                     channels=>4);            #
\&                                              
\&  $img = Imager\->new(xsize=>200, ysize=>200,  
\&                     type=>\*(Aqpaletted\*(Aq);       # paletted image
\&                                              
\&  $img = Imager\->new(xsize=>200, ysize=>200,  
\&                     bits=>16);               # 16 bits/channel rgb
\&                                              
\&  $img = Imager\->new(xsize=>200, ysize=>200,  
\&                     bits=>\*(Aqdouble\*(Aq);         # \*(Aqdouble\*(Aq floating point
\&                                              #  per channel
\&
\&  $img\->img_set(xsize=>500, ysize=>500,       # reset the image object
\&                channels=>4);
\&
\&
\&  # Example getting information about an Imager object
\&
\&  print "Image information:\en";
\&  print "Width:        ", $img\->getwidth(),    "\en";
\&  print "Height:       ", $img\->getheight(),   "\en";
\&  print "Channels:     ", $img\->getchannels(), "\en";
\&  print "Bits/Channel: ", $img\->bits(),        "\en";
\&  print "Virtual:      ", $img\->virtual() ? "Yes" : "No", "\en";
\&  my $colorcount = $img\->getcolorcount(maxcolors=>512);
\&        print "Actual number of colors in image: ";
\&  print defined($colorcount) ? $colorcount : ">512", "\en";
\&  print "Type:         ", $img\->type(),        "\en";
\&
\&  if ($img\->type() eq \*(Aqdirect\*(Aq) {
\&    print "Modifiable Channels: ";
\&    print join " ", map {
\&      ($img\->getmask() & 1<<$_) ? $_ : ()
\&    } 0..$img\->getchannels();
\&    print "\en";
\&  
\&  } else {
\&    # palette info
\&    my $count = $img\->colorcount;  
\&    @colors = $img\->getcolors();
\&    print "Palette size: $count\en";
\&    my $mx = @colors > 4 ? 4 : 0+@colors;
\&    print "First $mx entries:\en";
\&    for (@colors[0..$mx\-1]) {
\&      my @res = $_\->rgba();
\&      print "(", join(", ", @res[0..$img\->getchannels()\-1]), ")\en";
\&    }
\&  }
\&  
\&  my @tags = $img\->tags();
\&  if (@tags) {
\&    print "Tags:\en";
\&    for(@tags) {
\&      print shift @$_, ": ", join " ", @$_, "\en";
\&    }
\&  } else {
\&    print "No tags in image\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imager supports two basic models of image:
.IP "\(bu" 4
direct color \- all samples are stored for every pixel.  eg. for an
8\-bit/sample \s-1RGB\s0 image, 24 bits are stored for each pixel.
.IP "\(bu" 4
paletted \- an index into a table of colors is stored for each pixel.
.PP
Direct color or paletted images can have 1 to 4 samples per color
stored.  Imager treats these as follows:
.IP "\(bu" 4
1 sample per color \- gray scale image.
.IP "\(bu" 4
2 samples per color \- gray scale image with alpha channel, allowing
transparency.
.IP "\(bu" 4
3 samples per color \- \s-1RGB\s0 image.
.IP "\(bu" 4
4 samples per color \- \s-1RGB\s0 image with alpha channel, allowing
transparency.
.PP
Direct color images can have sample sizes of 8\-bits per sample,
16\-bits per sample or a double precision floating point number per
sample (64\-bits on many systems).
.PP
Paletted images are always 8\-bits/sample.
.PP
To query an existing image about it's parameters see the \f(CW\*(C`bits()\*(C'\fR,
\&\f(CW\*(C`type()\*(C'\fR, \f(CW\*(C`getwidth()\*(C'\fR, \f(CW\*(C`getheight()\*(C'\fR, \f(CW\*(C`getchannels()\*(C'\fR and
\&\f(CW\*(C`virtual()\*(C'\fR methods.
.PP
The coordinate system in Imager has the origin in the upper left
corner, see Imager::Draw for details.
.PP
The alpha channel when one is present is considered unassociated \-
ie the color data has not been scaled by the alpha channel.  Note
that not all code follows this (recent) rule, but will over time.
.SS "Creating Imager Objects"
.IX Subsection "Creating Imager Objects"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 2
\&  $img = Imager\->new();
\&  $img\->read(file=>"alligator.ppm") or die $img\->errstr;
.Ve
.Sp
Here \f(CW\*(C`new()\*(C'\fR creates an empty image with width and height of zero.
It's only useful for creating an Imager object to call the \fIread()\fR
method on later.
.Sp
.Vb 3
\&  %opts = (xsize=>300, ysize=>200);
\&  $img = Imager\->new(%opts); # create direct mode RGBA image
\&  $img = Imager\->new(%opts, channels=>4); # create direct mode RGBA image
.Ve
.Sp
You can also read a file from \fInew()\fR:
.Sp
.Vb 1
\&  $img = Imager\->new(file => "someimage.png");
.Ve
.Sp
The parameters for new are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`xsize\*(C'\fR, \f(CW\*(C`ysize\*(C'\fR \- Defines the width and height in pixels of the
image.  These must be positive.
.Sp
If not supplied then only placeholder object is created, which can be
supplied to the \f(CW\*(C`read()\*(C'\fR or \f(CW\*(C`img_set()\*(C'\fR methods.
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- The number of channels for the image.  Default 3.  Valid
values are from 1 to 4.
.IP "\(bu" 4
\&\f(CW\*(C`bits\*(C'\fR \- The storage type for samples in the image.  Default: 8.
Valid values are:
.RS 4
.IP "\(bu" 4
\&\f(CW8\fR \- One byte per sample.  256 discrete values.
.IP "\(bu" 4
\&\f(CW16\fR \- 16\-bits per sample, 65536 discrete values.
.IP "\(bu" 4
\&\f(CW\*(C`double\*(C'\fR \- one C double per sample.
.RE
.RS 4
.Sp
Note: you can use any Imager function on any sample size image.
.Sp
Paletted images always use 8 bits/sample.
.RE
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- either \f(CW\*(Aqdirect\*(Aq\fR or \f(CW\*(Aqpaletted\*(Aq\fR.  Default: \f(CW\*(Aqdirect\*(Aq\fR.
.Sp
Direct images store color values for each pixel.
.Sp
Paletted images keep a table of up to 256 colors called the palette,
each pixel is represented as an index into that table.
.Sp
In most cases when working with Imager you will want to use the
\&\f(CW\*(C`direct\*(C'\fR image type.
.Sp
If you draw on a \f(CW\*(C`paletted\*(C'\fR image with a color not in the image's
palette then Imager will transparently convert it to a \f(CW\*(C`direct\*(C'\fR
image.
.IP "\(bu" 4
\&\f(CW\*(C`maxcolors\*(C'\fR \- the maximum number of colors in a paletted image.
Default: 256.  This must be in the range 1 through 256.
.IP "\(bu" 4
\&\f(CW\*(C`file\*(C'\fR, \f(CW\*(C`fh\*(C'\fR, \f(CW\*(C`fd\*(C'\fR, \f(CW\*(C`callback\*(C'\fR, \f(CW\*(C`readcb\*(C'\fR \- specify a file name,
filehandle, file descriptor or callback to read image data from.  See
Imager::Files for details.  The typical use is:
.Sp
.Vb 1
\&  my $im = Imager\->new(file => $filename);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`filetype\*(C'\fR \- treated as the file format parameter, as for \f(CW\*(C`type\*(C'\fR
with the \fIread()\fR method, eg:
.Sp
.Vb 1
\&  my $im = Imager\->new(file => $filename, filetype => "gif");
.Ve
.Sp
In most cases Imager will detect the file's format itself.
.RE
.RS 4
.Sp
In the simplest case just supply the width and height of the image:
.Sp
.Vb 2
\&  # 8 bit/sample, RGB image
\&  my $img = Imager\->new(xsize => $width, ysize => $height);
.Ve
.Sp
or if you want an alpha channel:
.Sp
.Vb 2
\&  # 8 bits/sample, RGBA image
\&  my $img = Imager\->new(xsize => $width, ysize => $height, channels=>4);
.Ve
.Sp
Note that it \fIis\fR possible for image creation to fail, for example if
channels is out of range, or if the image would take too much memory.
.Sp
To create paletted images, set the 'type' parameter to 'paletted':
.Sp
.Vb 1
\&  $img = Imager\->new(xsize=>200, ysize=>200, type=>\*(Aqpaletted\*(Aq);
.Ve
.Sp
which creates an image with a maximum of 256 colors, which you can
change by supplying the \f(CW\*(C`maxcolors\*(C'\fR parameter.
.Sp
For improved color precision you can use the bits parameter to specify
16 bit per channel:
.Sp
.Vb 2
\&  $img = Imager\->new(xsize=>200, ysize=>200,
\&                     channels=>3, bits=>16);
.Ve
.Sp
or for even more precision:
.Sp
.Vb 2
\&  $img = Imager\->new(xsize=>200, ysize=>200,
\&                     channels=>3, bits=>\*(Aqdouble\*(Aq);
.Ve
.Sp
to get an image that uses a double for each channel.
.Sp
Note that as of this writing all functions should work on images with
more than 8\-bits/channel, but many will only work at only
8\-bit/channel precision.
.Sp
If you want an empty Imager object to call the \fIread()\fR method on, just
call \fInew()\fR with no parameters:
.Sp
.Vb 3
\&  my $img = Imager\->new;
\&  $img\->read(file=>$filename)
\&    or die $img\->errstr;
.Ve
.Sp
Though it's much easier now to just call \fInew()\fR with a \f(CW\*(C`file\*(C'\fR
parameter:
.Sp
.Vb 2
\&  my $img = Imager\->new(file => $filename)
\&    or die Imager\->errstr;
.Ve
.RE
.IP "\fIimg_set()\fR" 4
.IX Item "img_set()"
img_set destroys the image data in the object and creates a new one
with the given dimensions and channels.  For a way to convert image
data between formats see the \f(CW\*(C`convert()\*(C'\fR method.
.Sp
.Vb 1
\&  $img\->img_set(xsize=>500, ysize=>500, channels=>4);
.Ve
.Sp
This takes exactly the same parameters as the \fInew()\fR method.
.SS "Image Attribute functions"
.IX Subsection "Image Attribute functions"
These return basic attributes of an image object.
.IP "\fIgetwidth()\fR" 4
.IX Item "getwidth()"
.Vb 1
\&  print "Image width: ", $img\->getwidth(), "\en";
.Ve
.Sp
The \f(CW\*(C`getwidth()\*(C'\fR method returns the width of the image.  This value
comes either from \f(CW\*(C`new()\*(C'\fR with \f(CW\*(C`xsize\*(C'\fR, \f(CW\*(C`ysize\*(C'\fR parameters or from
reading data from a file with \f(CW\*(C`read()\*(C'\fR.  If called on an image that
has no valid data in it like \f(CW\*(C`Imager\->new()\*(C'\fR returns, the return
value of \f(CW\*(C`getwidth()\*(C'\fR is undef.
.IP "\fIgetheight()\fR" 4
.IX Item "getheight()"
.Vb 1
\&  print "Image height: ", $img\->getheight(), "\en";
.Ve
.Sp
Same details apply as for \*(L"\fIgetwidth()\fR\*(R".
.IP "\fIgetchannels()\fR" 4
.IX Item "getchannels()"
.Vb 1
\&  print "Image has ",$img\->getchannels(), " channels\en";
.Ve
.Sp
To get the number of channels in an image \f(CW\*(C`getchannels()\*(C'\fR is used.
.IP "\fIbits()\fR" 4
.IX Item "bits()"
The \fIbits()\fR method retrieves the number of bits used to represent each
channel in a pixel, 8 for a normal image, 16 for 16\-bit image and
\&'double' for a double/channel image.
.Sp
.Vb 6
\&  if ($img\->bits eq 8) {
\&    # fast but limited to 8\-bits/sample
\&  }
\&  else {
\&    # slower but more precise
\&  }
.Ve
.IP "\fItype()\fR" 4
.IX Item "type()"
The \fItype()\fR method returns either 'direct' for direct color images or
\&'paletted' for paletted images.
.Sp
.Vb 6
\&  if ($img\->type eq \*(Aqpaletted\*(Aq) {
\&    # print the palette
\&    for my $color ($img\->getcolors) {
\&      print join(",", $color\->rgba), "\en";
\&    }
\&  }
.Ve
.IP "\fIvirtual()\fR" 4
.IX Item "virtual()"
The \fIvirtual()\fR method returns non-zero if the image contains no actual
pixels, for example masked images.
.Sp
This may also be used for non-native Imager images in the future, for
example, for an Imager object that draws on an \s-1SDL\s0 surface.
.IP "\fIis_bilevel()\fR" 4
.IX Item "is_bilevel()"
Tests if the image will be written as a monochrome or bi-level image
for formats that support that image organization.
.Sp
In scalar context, returns true if the image is bi-level.
.Sp
In list context returns a list:
.Sp
.Vb 1
\&  ($is_bilevel, $zero_is_white) = $img\->is_bilevel;
.Ve
.Sp
An image is considered bi-level, if all of the following are true:
.RS 4
.IP "\(bu" 4
the image is a paletted image
.IP "\(bu" 4
the image has 1 or 3 channels
.IP "\(bu" 4
the image has only 2 colors in the palette
.IP "\(bu" 4
those 2 colors are black and white, in either order.
.RE
.RS 4
.Sp
If a real bi-level organization image is ever added to Imager, this
function will return true for that too.
.RE
.SS "Direct Type Images"
.IX Subsection "Direct Type Images"
Direct images store the color value directly for each pixel in the
image.
.IP "\fIgetmask()\fR" 4
.IX Item "getmask()"
.Vb 6
\&  @rgbanames = qw( red green blue alpha );
\&  my $mask = $img\->getmask();
\&  print "Modifiable channels:\en";
\&  for (0..$img\->getchannels()\-1) {
\&    print $rgbanames[$_],"\en" if $mask & 1<<$_;
\&  }
.Ve
.Sp
\&\f(CW\*(C`getmask()\*(C'\fR is used to fetch the current channel mask.  The mask
determines what channels are currently modifiable in the image.  The
channel mask is an integer value, if the \f(CW\*(C`i\-th\*(C'\fR least significant bit
is set the \f(CW\*(C`i\-th\*(C'\fR channel is modifiable.  eg. a channel mask of 0x5
means only channels 0 and 2 are writable.
.IP "\fIsetmask()\fR" 4
.IX Item "setmask()"
.Vb 2
\&  $mask = $img\->getmask();
\&  $img\->setmask(mask=>8);     # modify alpha only
\&
\&    ...
\&
\&  $img\->setmask(mask=>$mask); # restore previous mask
.Ve
.Sp
\&\f(CW\*(C`setmask()\*(C'\fR is used to set the channel mask of the image.  See
\&\*(L"\fIgetmask()\fR\*(R" for details.
.SS "Palette Type Images"
.IX Subsection "Palette Type Images"
Paletted images keep an array of up to 256 colors, and each pixel is
stored as an index into that array.
.PP
In general you can work with paletted images in the same way as \s-1RGB\s0
images, except that if you attempt to draw to a paletted image with a
color that is not in the image's palette, the image will be converted
to an \s-1RGB\s0 image.  This means that drawing on a paletted image with
anti-aliasing enabled will almost certainly convert the image to \s-1RGB\s0.
.PP
Palette management takes place through \f(CW\*(C`addcolors()\*(C'\fR, \f(CW\*(C`setcolors()\*(C'\fR,
\&\f(CW\*(C`getcolors()\*(C'\fR and \f(CW\*(C`findcolor()\*(C'\fR:
.IP "\fIaddcolors()\fR" 4
.IX Item "addcolors()"
You can add colors to a paletted image with the \fIaddcolors()\fR method:
.Sp
.Vb 3
\&   my @colors = ( Imager::Color\->new(255, 0, 0), 
\&                  Imager::Color\->new(0, 255, 0) );
\&   my $index = $img\->addcolors(colors=>\e@colors);
.Ve
.Sp
The return value is the index of the first color added, or undef if
adding the colors would overflow the palette.
.Sp
The only parameter is \f(CW\*(C`colors\*(C'\fR which must be a reference to an array
of Imager::Color objects.
.IP "\fIsetcolors()\fR" 4
.IX Item "setcolors()"
.Vb 1
\&  $img\->setcolors(start=>$start, colors=>\e@colors);
.Ve
.Sp
Once you have colors in the palette you can overwrite them with the
\&\f(CW\*(C`setcolors()\*(C'\fR method:  \f(CW\*(C`setcolors()\*(C'\fR returns true on success.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
start \- the first index to be set.  Default: 0
.IP "\(bu" 4
colors \- reference to an array of Imager::Color objects.
.RE
.RS 4
.RE
.IP "\fIgetcolors()\fR" 4
.IX Item "getcolors()"
To retrieve existing colors from the palette use the \fIgetcolors()\fR method:
.Sp
.Vb 6
\&  # get the whole palette
\&  my @colors = $img\->getcolors();
\&  # get a single color
\&  my $color = $img\->getcolors(start=>$index);
\&  # get a range of colors
\&  my @colors = $img\->getcolors(start=>$index, count=>$count);
.Ve
.IP "\fIfindcolor()\fR" 4
.IX Item "findcolor()"
To quickly find a color in the palette use \fIfindcolor()\fR:
.Sp
.Vb 1
\&  my $index = $img\->findcolor(color=>$color);
.Ve
.Sp
which returns undef on failure, or the index of the color.
.Sp
Parameter:
.RS 4
.IP "\(bu" 4
color \- an Imager::Color object.
.RE
.RS 4
.RE
.IP "\fIcolorcount()\fR" 4
.IX Item "colorcount()"
Returns the number of colors in the image's palette:
.Sp
.Vb 1
\&  my $count = $img\->colorcount;
.Ve
.IP "\fImaxcolors()\fR" 4
.IX Item "maxcolors()"
Returns the maximum size of the image's palette.
.Sp
.Vb 1
\&  my $maxcount = $img\->maxcolors;
.Ve
.SS "Color Distribution"
.IX Subsection "Color Distribution"
.IP "\fIgetcolorcount()\fR" 4
.IX Item "getcolorcount()"
Calculates the number of colors in an image.
.Sp
The amount of memory used by this is proportional to the number of
colors present in the image, so to avoid using too much memory you can
supply a \fImaxcolors()\fR parameter to limit the memory used.
.Sp
Note: \fIgetcolorcount()\fR treats the image as an 8\-bit per sample image.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`maxcolors\*(C'\fR \- the maximum number of colors to
return.  Default: unlimited.
.IX Xref "maxcolors!getcolorcount"
.RE
.RS 4
.Sp
.Vb 3
\&  if (defined($img\->getcolorcount(maxcolors=>512)) {
\&    print "Less than 512 colors in image\en";
\&  }
.Ve
.RE
.IP "\fIgetcolorusagehash()\fR" 4
.IX Item "getcolorusagehash()"
Calculates a histogram of colors used by the image.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`maxcolors\*(C'\fR \- the maximum number of colors
to return.  Default: unlimited.
.IX Xref "maxcolors!getcolorusagehash"
.RE
.RS 4
.Sp
Returns a reference to a hash where the keys are the raw color as
bytes, and the values are the counts for that color.
.Sp
The alpha channel of the image is ignored.  If the image is gray scale
then the hash keys will each be a single character.
.Sp
.Vb 3
\&  my $colors = $img\->getcolorusagehash;
\&  my $blue_count = $colors\->{pack("CCC", 0, 0, 255)} || 0;
\&  print "#0000FF used $blue_count times\en";
.Ve
.RE
.IP "\fIgetcolorusage()\fR" 4
.IX Item "getcolorusage()"
Calculates color usage counts and returns just the counts.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`maxcolors\*(C'\fR \- the maximum number of colors
to return.  Default: unlimited.
.IX Xref "maxcolors!getcolorusage"
.RE
.RS 4
.Sp
Returns a list of the color frequencies in ascending order.
.Sp
.Vb 2
\&  my @counts = $img\->getcolorusage;
\&  print "The most common color is used $counts[0] times\en";
.Ve
.RE
.SS "Conversion Between Image Types"
.IX Subsection "Conversion Between Image Types"
Warning: if you draw on a paletted image with colors that aren't in
the palette, the image will be internally converted to a normal image.
.IP "\fIto_paletted()\fR" 4
.IX Item "to_paletted()"
You can create a new paletted image from an existing image using the
\&\fIto_paletted()\fR method:
.Sp
.Vb 1
\& $palimg = $img\->to_paletted(\e%opts)
.Ve
.Sp
where \f(CW%opts\fR contains the options specified under \*(L"Quantization options\*(R".
.Sp
.Vb 3
\&  # convert to a paletted image using the web palette
\&  # use the closest color to each pixel
\&  my $webimg = $img\->to_paletted({ make_colors => \*(Aqwebmap\*(Aq });
\&
\&  # convert to a paletted image using a fairly optimal palette
\&  # use an error diffusion dither to try to reduce the average error
\&  my $optimag = $img\->to_paletted({ make_colors => \*(Aqmediancut\*(Aq,
\&                                    translate => \*(Aqerrdiff\*(Aq });
.Ve
.IP "\fIto_rgb8()\fR" 4
.IX Item "to_rgb8()"
You can convert a paletted image (or any image) to an 8\-bit/channel
\&\s-1RGB\s0 image with:
.Sp
.Vb 1
\&  $rgbimg = $img\->to_rgb8;
.Ve
.Sp
No parameters.
.IP "\fIto_rgb16()\fR" 4
.IX Item "to_rgb16()"
Convert a paletted image (or any image) to a 16\-bit/channel \s-1RGB\s0 image.
.Sp
.Vb 1
\&  $rgbimg = $img\->to_rgb16;
.Ve
.Sp
No parameters.
.IP "\fIto_rgb_double()\fR" 4
.IX Item "to_rgb_double()"
Convert a paletted image (or any image) to an double/channel direct
color image.
.Sp
.Vb 1
\&  $rgbimg = $img\->to_rgb_double;
.Ve
.Sp
No parameters.
.IP "\fImasked()\fR" 4
.IX Item "masked()"
Creates a masked image.  A masked image lets you create an image proxy
object that protects parts of the underlying target image.
.Sp
In the discussion below there are 3 image objects involved:
.RS 4
.IP "\(bu" 4
the masked image \- the return value of the \fImasked()\fR method.  Any
writes to this image are written to the target image, assuming the
mask image allows it.
.IP "\(bu" 4
the mask image \- the image that protects writes to the target image.
Supplied as the \f(CW\*(C`mask\*(C'\fR parameter to the \fImasked()\fR method.
.IP "\(bu" 4
the target image \- the image you called the \fImasked()\fR method on.  Any
writes to the masked image end up on this image.
.RE
.RS 4
.Sp
Parameters:
.IP "\(bu" 4
mask \- the mask image.  If not supplied then all pixels in the target
image are writable.  On each write to the masked image, only pixels
that have non-zero in channel 0 of the mask image will be written to
the original image.  Default: none, if not supplied then no masking is
done, but the other parameters are still honored.
.IP "\(bu" 4
left, top \- the offset of writes to the target image.  eg. if you
attempt to set pixel (x,y) in the masked image, then pixel (x+left,
y+top) will be written to in the original image.
.IP "\(bu" 4
bottom, right \- the bottom right of the area in the target available
from the masked image.
.RE
.RS 4
.Sp
Masked images let you control which pixels are modified in an
underlying image.  Where the first channel is completely black in the
mask image, writes to the underlying image are ignored.
.Sp
For example, given a base image called \f(CW$img:\fR
.Sp
.Vb 4
\&  my $mask = Imager\->new(xsize=>$img\->getwidth, ysize=>$img\->getheight,
\&                         channels=>1);
\&  # ... draw something on the mask
\&  my $maskedimg = $img\->masked(mask=>$mask);
\&
\&  # now draw on $maskedimg and it will only draw on areas of $img 
\&  # where $mask is non\-zero in channel 0.
.Ve
.Sp
You can specify the region of the underlying image that is masked
using the left, top, right and bottom options.
.Sp
If you just want a subset of the image, without masking, just specify
the region without specifying a mask.  For example:
.Sp
.Vb 3
\&  # just work with a 100x100 region of $img
\&  my $maskedimg = $img\->masked(left => 100, top=>100,
\&                               right=>200, bottom=>200);
.Ve
.RE
.IP "\fImake_palette()\fR" 4
.IX Item "make_palette()"
This doesn't perform an image conversion, but it can be used to
construct a common palette for use in several images:
.Sp
.Vb 1
\&  my @colors = Imager\->make_palette(\e%opts, @images);
.Ve
.Sp
You must supply at least one image, even if the \f(CW\*(C`make_colors\*(C'\fR
parameter produces a fixed palette.
.Sp
On failure returns no colors and you can check \f(CW\*(C`Imager\->errstr\*(C'\fR.
.SS "Tags"
.IX Subsection "Tags"
Image tags contain meta-data about the image, ie. information not
stored as pixels of the image.
.PP
At the perl level each tag has a name or code and a value, which is an
integer or an arbitrary string.  An image can contain more than one
tag with the same name or code, but having more than one tag with the
same name is discouraged.
.PP
You can retrieve tags from an image using the \fItags()\fR method, you can
get all of the tags in an image, as a list of array references, with
the code or name of the tag followed by the value of the tag.
.IP "\fItags()\fR" 4
.IX Item "tags()"
Retrieve tags from the image.
.Sp
With no parameters, retrieves a list array references, each containing
a name and value: all tags in the image:
.Sp
.Vb 3
\&  # get a list of ( [ name1 => value1 ], [ name2 => value2 ] ... )
\&  my @alltags = $img\->tags;
\&  print $_\->[0], ":", $_\->[1], "\en" for @all_tags;
\&
\&  # or put it in a hash, but this will lose duplicates
\&  my %alltags = map @$_, $img\->tags;
.Ve
.Sp
in scalar context this returns the number of tags:
.Sp
.Vb 1
\&  my $num_tags = $img\->tags;
.Ve
.Sp
or you can get all tags values for the given name:
.Sp
.Vb 1
\&  my @namedtags = $img\->tags(name => $name);
.Ve
.Sp
in scalar context this returns the first tag of that name:
.Sp
.Vb 1
\&  my $firstnamed = $img\->tags(name => $name);
.Ve
.Sp
or a given code:
.Sp
.Vb 1
\&  my @tags = $img\->tags(code=>$code);
.Ve
.IP "\fIaddtag()\fR" 4
.IX Item "addtag()"
You can add tags using the \fIaddtag()\fR method, either by name:
.Sp
.Vb 1
\&  my $index = $img\->addtag(name=>$name, value=>$value);
.Ve
.Sp
or by code:
.Sp
.Vb 1
\&  my $index = $img\->addtag(code=>$code, value=>$value);
.Ve
.IP "\fIdeltag()\fR" 4
.IX Item "deltag()"
You can remove tags with the \fIdeltag()\fR method, either by index:
.Sp
.Vb 1
\&  $img\->deltag(index=>$index);
.Ve
.Sp
or by name:
.Sp
.Vb 1
\&  $img\->deltag(name=>$name);
.Ve
.Sp
or by code:
.Sp
.Vb 1
\&  $img\->deltag(code=>$code);
.Ve
.Sp
In each case \fIdeltag()\fR returns the number of tags deleted.
.IP "\fIsettag()\fR" 4
.IX Item "settag()"
\&\fIsettag()\fR replaces any existing tags with a new tag.  This is
equivalent to calling \fIdeltag()\fR then \fIaddtag()\fR.
.SS "Common Tags"
.IX Subsection "Common Tags"
Many tags are only meaningful for one format.  \s-1GIF\s0 looping information
is pretty useless for \s-1JPEG\s0 for example.  Thus, many tags are set by
only a single reader or used by a single writer.  For a complete list
of format specific tags see Imager::Files.
.PP
Since tags are a relatively new addition their use is not wide spread
but eventually we hope to have all the readers for various formats set
some standard information.
.IP "\(bu" 4
\&\f(CW\*(C`i_xres\*(C'\fR, \f(CW\*(C`i_yres\*(C'\fR
\&\- The spatial resolution of the image in pixels per inch.  If the
image format uses a different scale, eg. pixels per meter, then this
value is converted.  A floating point number stored as a string.
.IX Xref "i_xres tag i_yres tag tags, i_xres tags, i_yres"
.Sp
.Vb 3
\&  # our image was generated as a 300 dpi image
\&  $img\->settag(name => \*(Aqi_xres\*(Aq, value => 300);
\&  $img\->settag(name => \*(Aqi_yres\*(Aq, value => 300);
\&
\&  # 100 pixel/cm for a TIFF image
\&  $img\->settag(name => \*(Aqtiff_resolutionunit\*(Aq, value => 3); # RESUNIT_CENTIMETER
\&  # convert to pixels per inch, Imager will convert it back
\&  $img\->settag(name => \*(Aqi_xres\*(Aq, value => 100 * 2.54);
\&  $img\->settag(name => \*(Aqi_yres\*(Aq, value => 100 * 2.54);
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`i_aspect_only\*(C'\fR \- If this is
non-zero then the values in i_xres and i_yres are treated as a ratio
only.  If the image format does not support aspect ratios then this is
scaled so the smaller value is 72 \s-1DPI\s0.
.IX Xref "i_aspect_only tag tags, i_aspect_only"
.IP "\(bu" 4
\&\f(CW\*(C`i_incomplete\*(C'\fR \- If this tag is
present then the whole image could not be read.  This isn't
implemented for all images yet, and may not be.
.IX Xref "i_incomplete tag tags, i_incomplete"
.IP "\(bu" 4
\&\f(CW\*(C`i_lines_read\*(C'\fR \- If
\&\f(CW\*(C`i_incomplete\*(C'\fR is set then this tag may be set to the number of
scan lines successfully read from the file.  This can be used to decide
whether an image is worth processing.
.IX Xref "i_lines_read tag tags, i_lines_read"
.IP "\(bu" 4
i_format \- The file format this file
was read from.
.IX Xref "i_format tag tags, i_format"
.IP "\(bu" 4
i_background \- used when writing
an image with an alpha channel to a file format that doesn't support
alpha channels.  The \f(CW\*(C`write\*(C'\fR method will convert a normal color
specification like \*(L"#FF0000\*(R" into a color object for you, but if you
set this as a tag you will need to format it like
\&\f(CW\*(C`color(\*(C'\fR\fIred\fR\f(CW\*(C`,\*(C'\fR\fIgreen\fR\f(CW\*(C`,\*(C'\fR\fIblue\fR\f(CW\*(C`)\*(C'\fR, eg color(255,0,0).
.IX Xref "i_background tags, i_background"
.SS "Quantization options"
.IX Subsection "Quantization options"
These options can be specified when calling
\&\*(L"\fIto_paletted()\fR\*(R" in Imager::ImageTypes, \fIwrite_multi()\fR for \s-1GIF\s0 files, when
writing a single image with the \f(CW\*(C`gifquant\*(C'\fR option set to \f(CW\*(C`gen\*(C'\fR, or for
direct calls to \fIi_writegif_gen()\fR and \fIi_writegif_callback()\fR.
.IP "\(bu" 4
\&\f(CW\*(C`colors\*(C'\fR \- An arrayref of colors that are fixed.  Note that some
color generators will ignore this.  If this is supplied it will be
filled with the color table generated for the image.
.IP "\(bu" 4
\&\f(CW\*(C`transp\*(C'\fR \- The type of transparency processing to perform for images
with an alpha channel where the output format does not have a proper
alpha channel (eg. \s-1GIF\s0).  This can be any of:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`none\*(C'\fR \- No transparency processing is done. (default)
.IP "\(bu" 4
\&\f(CW\*(C`threshold\*(C'\fR \- pixels more transparent than \f(CW\*(C`tr_threshold\*(C'\fR are
rendered as transparent.
.IP "\(bu" 4
\&\f(CW\*(C`errdiff\*(C'\fR \- An error diffusion dither is done on the alpha channel.
Note that this is independent of the translation performed on the
color channels, so some combinations may cause undesired artifacts.
.IP "\(bu" 4
\&\f(CW\*(C`ordered\*(C'\fR \- the ordered dither specified by tr_orddith is performed
on the alpha channel.
.RE
.RS 4
.Sp
This will only be used if the image has an alpha channel, and if there
is space in the palette for a transparency color.
.RE
.IP "\(bu" 4
\&\f(CW\*(C`tr_threshold\*(C'\fR \- the highest alpha value at which a pixel will be
made transparent when \f(CW\*(C`transp\*(C'\fR is 'threshold'. (0\-255, default 127)
.IP "\(bu" 4
\&\f(CW\*(C`tr_errdiff\*(C'\fR \- The type of error diffusion to perform on the alpha
channel when \f(CW\*(C`transp\*(C'\fR is \f(CW\*(C`errdiff\*(C'\fR.  This can be any defined error
diffusion type except for custom (see \f(CW\*(C`errdiff\*(C'\fR below).
.IP "\(bu" 4
\&\f(CW\*(C`tr_orddith\*(C'\fR \- The type of ordered dither to perform on the alpha
channel when \f(CW\*(C`transp\*(C'\fR is 'ordered'.  Possible values are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`random\*(C'\fR \- A semi-random map is used.  The map is the same each time.
.IP "\(bu" 4
\&\f(CW\*(C`dot8\*(C'\fR \- 8x8 dot dither.
.IP "\(bu" 4
\&\f(CW\*(C`dot4\*(C'\fR \- 4x4 dot dither
.IP "\(bu" 4
\&\f(CW\*(C`hline\*(C'\fR \- horizontal line dither.
.IP "\(bu" 4
\&\f(CW\*(C`vline\*(C'\fR \- vertical line dither.
.IP "\(bu" 4
\&\f(CW\*(C`/line\*(C'\fR, \f(CW\*(C`slashline\*(C'\fR \- diagonal line dither
.IP "\(bu" 4
\&\f(CW\*(C`\eline\*(C'\fR, \f(CW\*(C`backline\*(C'\fR \- diagonal line dither
.IP "\(bu" 4
\&\f(CW\*(C`tiny\*(C'\fR \- dot matrix dither (currently the default).  This is probably
the best for displays (like web pages).
.IP "\(bu" 4
\&\f(CW\*(C`custom\*(C'\fR \- A custom dither matrix is used \- see \f(CW\*(C`tr_map\*(C'\fR.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`tr_map\*(C'\fR \- When tr_orddith is custom this defines an 8 x 8 matrix of
integers representing the transparency threshold for pixels
corresponding to each position.  This should be a 64 element array
where the first 8 entries correspond to the first row of the matrix.
Values should be between 0 and 255.
.IP "\(bu" 4
\&\f(CW\*(C`make_colors\*(C'\fR \- Defines how the quantization engine will build the
palette(s).  Currently this is ignored if \f(CW\*(C`translate\*(C'\fR is \f(CW\*(C`giflib\*(C'\fR,
but that may change.  Possible values are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`none\*(C'\fR \- only colors supplied in 'colors' are used.
.IP "\(bu" 4
\&\f(CW\*(C`webmap\*(C'\fR \- the web color map is used (need \s-1URL\s0 here.)
.IP "\(bu" 4
\&\f(CW\*(C`addi\*(C'\fR \- The original code for generating the color map (Addi's code) is
used.
.IP "\(bu" 4
\&\f(CW\*(C`mediancut\*(C'\fR \- Uses a median-cut algorithm, faster than \f(CW\*(C`addi\*(C'\fR, but not
as good a result.
.IP "\(bu" 4
\&\f(CW\*(C`mono\*(C'\fR, \f(CW\*(C`monochrome\*(C'\fR \- a fixed black and white palette, suitable for
producing bi-level images (eg. facsimile)
.IP "\(bu" 4
\&\f(CW\*(C`gray\*(C'\fR, \f(CW\*(C`gray4\*(C'\fR, \f(CW\*(C`gray16\*(C'\fR \- make fixed gray palette with 256, 4 or
16 entries respectively.
.RE
.RS 4
.Sp
Other methods may be added in the future.
.RE
.IP "\(bu" 4
\&\f(CW\*(C`colors\*(C'\fR \- an arrayref containing Imager::Color objects, which
represents the starting set of colors to use in translating the
images.  \f(CW\*(C`webmap\*(C'\fR will ignore this.  On return the final colors used
are copied back into this array (which is expanded if necessary.)
.IP "\(bu" 4
\&\f(CW\*(C`max_colors\*(C'\fR \- the maximum number of colors to use in the image.
.IP "\(bu" 4
\&\f(CW\*(C`translate\*(C'\fR \- The method used to translate the \s-1RGB\s0 values in the
source image into the colors selected by make_colors.  Note that
make_colors is ignored when \f(CW\*(C`translate\*(C'\fR is \f(CW\*(C`giflib\*(C'\fR.
.Sp
Possible values are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`giflib\*(C'\fR \- this is a historical equivalent for \f(CW\*(C`closest\*(C'\fR that also
forces \f(CW\*(C`make_colors\*(C'\fR to \f(CW\*(C`mediancut\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`closest\*(C'\fR \- the closest color available is used.
.IP "\(bu" 4
\&\f(CW\*(C`perturb\*(C'\fR \- the pixel color is modified by \f(CW\*(C`perturb\*(C'\fR, and the
closest color is chosen.
.IP "\(bu" 4
\&\f(CW\*(C`errdiff\*(C'\fR \- an error diffusion dither is performed.  If the supplied
(or generated) palette contains only grays the source colors are
converted to gray before error diffusion is performed.
.RE
.RS 4
.Sp
It's possible other \f(CW\*(C`translate\*(C'\fR values will be added.
.RE
.IP "\(bu" 4
\&\f(CW\*(C`errdiff\*(C'\fR \- The type of error diffusion dither to perform.  These
values (except for custom) can also be used in tr_errdif.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`floyd\*(C'\fR \- Floyd-Steinberg dither
.IP "\(bu" 4
\&\f(CW\*(C`jarvis\*(C'\fR \- Jarvis, Judice and Ninke dither
.IP "\(bu" 4
\&\f(CW\*(C`stucki\*(C'\fR \- Stucki dither
.IP "\(bu" 4
\&\f(CW\*(C`custom\*(C'\fR \- custom.  If you use this you must also set \f(CW\*(C`errdiff_width\*(C'\fR,
\&\f(CW\*(C`errdiff_height\*(C'\fR and \f(CW\*(C`errdiff_map\*(C'\fR.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`errdiff_width\*(C'\fR, \f(CW\*(C`errdiff_height\*(C'\fR, \f(CW\*(C`errdiff_orig\*(C'\fR, \f(CW\*(C`errdiff_map\*(C'\fR \-
When \f(CW\*(C`translate\*(C'\fR is \f(CW\*(C`errdiff\*(C'\fR and \f(CW\*(C`errdiff\*(C'\fR is \f(CW\*(C`custom\*(C'\fR these
define a custom error diffusion map.  \f(CW\*(C`errdiff_width\*(C'\fR and
\&\f(CW\*(C`errdiff_height\*(C'\fR define the size of the map in the arrayref in
\&\f(CW\*(C`errdiff_map\*(C'\fR.  \f(CW\*(C`errdiff_orig\*(C'\fR is an integer which indicates the
current pixel position in the top row of the map.
.IP "\(bu" 4
\&\f(CW\*(C`perturb\*(C'\fR \- When translate is \f(CW\*(C`perturb\*(C'\fR this is the magnitude of the
random bias applied to each channel of the pixel before it is looked
up in the color table.
.SH "INITIALIZATION"
.IX Header "INITIALIZATION"
This documents the Imager initialization function, which you will
almost never need to call.
.IP "\fIinit()\fR" 4
.IX Item "init()"
This is a function, not a method.
.Sp
This function is a mess, it can take the following named parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`log\*(C'\fR \- name of a log file to log Imager's actions to.  Not all
actions are logged, but the debugging memory allocator does log
allocations here.  Ignored if Imager has been built without logging
support.  Preferably use the \fIopen_log()\fR method instead.
.IP "\(bu" 4
\&\f(CW\*(C`loglevel\*(C'\fR \- the maximum level of message to log.  Default: 1.
.IP "\(bu" 4
\&\f(CW\*(C`warn_obsolete\*(C'\fR \- if this is non-zero then Imager will warn when you
attempt to use obsoleted parameters or functionality.  This currently
only includes the old \s-1GIF\s0 output options instead of tags.
.IP "\(bu" 4
\&\f(CW\*(C`t1log\*(C'\fR \- if non-zero then T1lib will be configured to produce a log
file.  This will fail if there are any existing T1lib font objects.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&  Imager::init(log => \*(Aqtrace.log\*(Aq, loglevel => 9);
.Ve
.RE
.SH "LOGGING METHODS"
.IX Header "LOGGING METHODS"
Imager can open an internal log to send debugging information to.
This log is extensively used in Imager's tests, but you're unlikely to
use it otherwise.
.PP
If Imager has been built with logging disabled, the methods fail
quietly.
.IP "\fIopen_log()\fR" 4
.IX Item "open_log()"
Open the Imager debugging log file.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`log\*(C'\fR \- the file name to log to.  If this is undef logging information
is sent to the standard error stream.
.IP "\(bu" 4
\&\f(CW\*(C`loglevel\*(C'\fR the level of logging to produce.  Default: 1.
.RE
.RS 4
.Sp
Returns a true value if the log file was opened successfully.
.Sp
.Vb 2
\&  # send debug output to test.log
\&  Imager\->open_log(log => "test.log");
\&
\&  # send debug output to stderr
\&  Imager\->open_log();
.Ve
.RE
.IP "\fIclose_log()\fR" 4
.IX Item "close_log()"
Close the Imager debugging log file and disable debug logging.
.Sp
No parameters.
.Sp
.Vb 1
\&  Imager\->close_log();
.Ve
.IP "\fIlog()\fR" 4
.IX Item "log()"
.Vb 2
\& Imager\->log($message)
\& Imager\->log($message, $level)
.Ve
.Sp
This method does not use named parameters.
.Sp
The default for \f(CW$level\fR is 1.
.Sp
Send a message to the debug log.
.Sp
.Vb 1
\&  Imager\->log("My code got here!");
.Ve
.IP "\fIis_logging()\fR" 4
.IX Item "is_logging()"
Returns a true value if logging is enabled.
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Revision\fR$
.SH "AUTHORS"
.IX Header "AUTHORS"
Tony Cook, Arnar M. Hrafnkelsson
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIImager\fR\|(3), \fIImager::Files\fR\|(3), \fIImager::Draw\fR\|(3),
\&\fIImager::Color\fR\|(3), \fIImager::Fill\fR\|(3), \fIImager::Font\fR\|(3),
\&\fIImager::Transformations\fR\|(3), \fIImager::Engines\fR\|(3), \fIImager::Filters\fR\|(3),
\&\fIImager::Expr\fR\|(3), \fIImager::Matrix2d\fR\|(3), \fIImager::Fountain\fR\|(3)
