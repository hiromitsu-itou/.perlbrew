.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Base 3"
.TH Class::Base 3 "2012-02-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Base \- useful base class for deriving other modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package My::Funky::Module;
\&    use base qw( Class::Base );
\&
\&    # custom initialiser method
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        # copy various params into $self
\&        $self\->params($config, qw( FOO BAR BAZ ))
\&            || return undef;
\&
\&        # to indicate a failure
\&        return $self\->error(\*(Aqbad constructor!\*(Aq) 
\&            if $something_bad;
\&
\&        # or to indicate general happiness and well\-being
\&        return $self;
\&    }
\&
\&    package main;
\&
\&    # new() constructor folds args into hash and calls init()
\&    my $object = My::Funky::Module\->new( foo => \*(Aqbar\*(Aq, ... )
\&          || die My::Funky::Module\->error();
\&
\&    # error() class/object method to get/set errors
\&    $object\->error(\*(Aqsomething has gone wrong\*(Aq);
\&    print $object\->error();
\&
\&    # debugging() method (de\-)activates the debug() method
\&    $object\->debugging(1);
\&
\&    # debug() prints to STDERR if debugging enabled
\&    $object\->debug(\*(AqThe \*(Aq, $animal, \*(Aq sat on the \*(Aq, $place);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consider using Badger::Base instead which is the successor of
this module.
.PP
This module implements a simple base class from which other modules
can be derived, thereby inheriting a number of useful methods such as
\&\f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`init()\*(C'\fR, \f(CW\*(C`params()\*(C'\fR, \f(CW\*(C`clone()\*(C'\fR, \f(CW\*(C`error()\*(C'\fR and
\&\f(CW\*(C`debug()\*(C'\fR.
.PP
For a number of years, I found myself re-writing this module for
practically every Perl project of any significant size.  Or rather, I
would copy the module from the last project and perform a global
search and replace to change the names.  Each time it got a little
more polished and eventually, I decided to Do The Right Thing and
release it as a module in it's own right.
.PP
It doesn't pretend to be an all-encompassing solution for every kind
of object creation problem you might encounter.  In fact, it only
supports blessed hash references that are created using the popular,
but by no means universal convention of calling \f(CW\*(C`new()\*(C'\fR with a list
or reference to a hash array of named parameters.  Constructor failure
is indicated by returning undef and setting the \f(CW$ERROR\fR package
variable in the module's class to contain a relevant message (which
you can also fetch by calling \f(CW\*(C`error()\*(C'\fR as a class method).
.PP
e.g.
.PP
.Vb 4
\&    my $object = My::Module\->new( 
\&        file => \*(Aqmyfile.html\*(Aq,
\&        msg  => \*(AqHello World\*(Aq
\&    ) || die $My::Module::ERROR;
.Ve
.PP
or:
.PP
.Vb 4
\&    my $object = My::Module\->new({
\&        file => \*(Aqmyfile.html\*(Aq,
\&        msg  => \*(AqHello World\*(Aq,
\&    }) || die My::Module\->error();
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method handles the conversion of a list of arguments 
into a hash array and calls the \f(CW\*(C`init()\*(C'\fR method to perform any 
initialisation.  In many cases, it is therefore sufficient to define
a module like so:
.PP
.Vb 3
\&    package My::Module;
\&    use Class::Base;
\&    use base qw( Class::Base );
\&
\&    sub init {
\&        my ($self, $config) = @_;
\&        # copy some config items into $self
\&        $self\->params($config, qw( FOO BAR )) || return undef;
\&        return $self;
\&    }
\&
\&    # ...plus other application\-specific methods
\&
\&    1;
.Ve
.PP
Then you can go right ahead and use it like this:
.PP
.Vb 1
\&    use My::Module;
\&
\&    my $object = My::Module\->new( FOO => \*(Aqthe foo value\*(Aq,
\&                                  BAR => \*(Aqthe bar value\*(Aq )
\&        || die $My::Module::ERROR;
.Ve
.PP
Despite its limitations, Class::Base can be a surprisingly useful
module to have lying around for those times where you just want to
create a regular object based on a blessed hash reference and don't
want to worry too much about duplicating the same old code to bless a
hash, define configuration values, provide an error reporting
mechanism, and so on.  Simply derive your module from \f(CW\*(C`Class::Base\*(C'\fR
and leave it to worry about most of the detail.  And don't forget, you
can always redefine your own \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`error()\*(C'\fR, or other method, if
you don't like the way the Class::Base version works.
.SS "Subclassing Class::Base"
.IX Subsection "Subclassing Class::Base"
This module is what object-oriented afficionados would describe as an
\&\*(L"abstract base class\*(R".  That means that it's not designed to be used
as a stand-alone module, rather as something from which you derive
your own modules.  Like this:
.PP
.Vb 2
\&    package My::Funky::Module
\&    use base qw( Class::Base );
.Ve
.PP
You can then use it like this:
.PP
.Vb 1
\&    use My::Funky::Module;
\&
\&    my $module = My::Funky::Module\->new();
.Ve
.SS "Construction and Initialisation Methods"
.IX Subsection "Construction and Initialisation Methods"
If you want to apply any per-object initialisation, then simply write
an \f(CW\*(C`init()\*(C'\fR method.  This gets called by the \f(CW\*(C`new()\*(C'\fR method which
passes a reference to a hash reference of configuration options.
.PP
.Vb 2
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        ...
\&
\&        return $self;
\&    }
.Ve
.PP
When you create new objects using the \f(CW\*(C`new()\*(C'\fR method you can either
pass a hash reference or list of named arguments.  The \f(CW\*(C`new()\*(C'\fR method
does the right thing to fold named arguments into a hash reference for
passing to the \f(CW\*(C`init()\*(C'\fR method.  Thus, the following are equivalent:
.PP
.Vb 5
\&    # hash reference
\&    my $module = My::Funky::Module\->new({ 
\&        foo => \*(Aqbar\*(Aq, 
\&        wiz => \*(Aqwaz\*(Aq,
\&    });
\&
\&    # list of named arguments (no enclosing \*(Aq{\*(Aq ... \*(Aq}\*(Aq)
\&    my $module = My::Funky::Module\->new(
\&        foo => \*(Aqbar\*(Aq, 
\&        wiz => \*(Aqwaz\*(Aq
\&    );
.Ve
.PP
Within the \f(CW\*(C`init()\*(C'\fR method, you can either handle the configuration
yourself:
.PP
.Vb 2
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        $self\->{ file } = $config\->{ file }
\&            || return $self\->error(\*(Aqno file specified\*(Aq);
\&
\&        return $self;
\&    }
.Ve
.PP
or you can call the \f(CW\*(C`params()\*(C'\fR method to do it for you:
.PP
.Vb 2
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        $self\->params($config, \*(Aqfile\*(Aq)
\&            || return $self\->error(\*(Aqno file specified\*(Aq);
\&
\&        return $self;
\&    }
.Ve
.SS "Error Handling"
.IX Subsection "Error Handling"
The \f(CW\*(C`init()\*(C'\fR method should return \f(CW$self\fR to indicate success or undef
to indicate a failure.  You can use the \f(CW\*(C`error()\*(C'\fR method to report an
error within the \f(CW\*(C`init()\*(C'\fR method.  The \f(CW\*(C`error()\*(C'\fR method returns undef,
so you can use it like this:
.PP
.Vb 2
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        # let\*(Aqs make \*(Aqfoobar\*(Aq a mandatory argument
\&        $self\->{ foobar } = $config\->{ foobar }
\&            || return $self\->error("no foobar argument");
\&
\&        return $self;
\&    }
.Ve
.PP
When you create objects of this class via \f(CW\*(C`new()\*(C'\fR, you should now
check the return value.  If undef is returned then the error message
can be retrieved by calling \f(CW\*(C`error()\*(C'\fR as a class method.
.PP
.Vb 2
\&    my $module = My::Funky::Module\->new()
\&          || die My::Funky::Module\->error();
.Ve
.PP
Alternately, you can inspect the \f(CW$ERROR\fR package variable which will
contain the same error message.
.PP
.Vb 2
\&    my $module = My::Funky::Module\->new()
\&         || die $My::Funky::Module::ERROR;
.Ve
.PP
Of course, being a conscientious Perl programmer, you will want to be
sure that the \f(CW$ERROR\fR package variable is correctly defined.
.PP
.Vb 2
\&    package My::Funky::Module
\&    use base qw( Class::Base );
\&
\&    our $ERROR;
.Ve
.PP
You can also call \f(CW\*(C`error()\*(C'\fR as an object method.  If you pass an
argument then it will be used to set the internal error message for
the object and return undef.  Typically this is used within the module
methods to report errors.
.PP
.Vb 2
\&    sub another_method {
\&        my $self = shift;
\&
\&        ...
\&
\&        # set the object error
\&        return $self\->error(\*(Aqsomething bad happened\*(Aq);
\&    }
.Ve
.PP
If you don't pass an argument then the \f(CW\*(C`error()\*(C'\fR method returns the
current error value.  Typically this is called from outside the object
to determine its status.  For example:
.PP
.Vb 2
\&    my $object = My::Funky::Module\->new()
\&        || die My::Funky::Module\->error();
\&
\&    $object\->another_method()
\&        || die $object\->error();
.Ve
.SS "Debugging Methods"
.IX Subsection "Debugging Methods"
The module implements two methods to assist in writing debugging code:
\&\fIdebug()\fR and \fIdebugging()\fR.  Debugging can be enabled on a per-object or
per-class basis, or as a combination of the two.
.PP
When creating an object, you can set the \f(CW\*(C`DEBUG\*(C'\fR flag (or lower case
\&\f(CW\*(C`debug\*(C'\fR if you prefer) to enable or disable debugging for that one
object.
.PP
.Vb 2
\&    my $object = My::Funky::Module\->new( debug => 1 )
\&          || die My::Funky::Module\->error();
\&
\&    my $object = My::Funky::Module\->new( DEBUG => 1 )
\&          || die My::Funky::Module\->error();
.Ve
.PP
If you don't explicitly specify a debugging flag then it assumes the 
value of the \f(CW$DEBUG\fR package variable in your derived class or 0 if 
that isn't defined.
.PP
You can also switch debugging on or off via the \f(CW\*(C`debugging()\*(C'\fR method.
.PP
.Vb 2
\&    $object\->debugging(0);      # debug off
\&    $object\->debugging(1);      # debug on
.Ve
.PP
The \f(CW\*(C`debug()\*(C'\fR method examines the internal debugging flag (the
\&\f(CW\*(C`_DEBUG\*(C'\fR member within the \f(CW$self\fR hash) and if it finds it set to
any true value then it prints to \s-1STDERR\s0 all the arguments passed to
it.  The output is prefixed by a tag containing the class name of the
object in square brackets (but see the \f(CW\*(C`id()\*(C'\fR method below for
details on how to change that value).
.PP
For example, calling the method as:
.PP
.Vb 1
\&    $object\->debug(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);
.Ve
.PP
prints the following output to \s-1STDERR:\s0
.PP
.Vb 1
\&    [My::Funky::Module] foobar
.Ve
.PP
When called as class methods, \f(CW\*(C`debug()\*(C'\fR and \f(CW\*(C`debugging()\*(C'\fR instead
use the \f(CW$DEBUG\fR package variable in the derived class as a flag to
control debugging.  This variable also defines the default \f(CW\*(C`DEBUG\*(C'\fR
flag for any objects subsequently created via the \fInew()\fR method.
.PP
.Vb 2
\&    package My::Funky::Module
\&    use base qw( Class::Base );
\&
\&    our $ERROR;
\&    our $DEBUG = 0 unless defined $DEBUG;
\&
\&    # some time later, in a module far, far away
\&    package main;
\&
\&    # debugging off (by default)
\&    my $object1 = My::Funky::Module\->new();
\&
\&    # turn debugging on for My::Funky::Module objects
\&    $My::Funky::Module::DEBUG = 1;
\&
\&    # alternate syntax
\&    My::Funky::Module\->debugging(1);
\&
\&    # debugging on (implicitly from $DEBUG package var)
\&    my $object2 = My::Funky::Module\->new();
\&
\&    # debugging off (explicit override)
\&    my $object3 = My::Funky::Module\->new(debug => 0);
.Ve
.PP
If you call \f(CW\*(C`debugging()\*(C'\fR without any arguments then it returns the
value of the internal object flag or the package variable accordingly.
.PP
.Vb 1
\&    print "debugging is turned ", $object\->debugging() ? \*(Aqon\*(Aq : \*(Aqoff\*(Aq;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Class constructor method which expects a reference to a hash array of parameters 
or a list of \f(CW\*(C`name => value\*(C'\fR pairs which are automagically folded into 
a hash reference.  The method blesses a hash reference and then calls the 
\&\f(CW\*(C`init()\*(C'\fR method, passing the reference to the hash array of configuration 
parameters.
.PP
Returns a reference to an object on success or undef on error.  In the latter
case, the \f(CW\*(C`error()\*(C'\fR method can be called as a class method, or the \f(CW$ERROR\fR
package variable (in the derived class' package) can be inspected to return an
appropriate error message.
.PP
.Vb 2
\&    my $object = My::Class\->new( foo => \*(Aqbar\*(Aq )   # params list
\&         || die $My::Class::$ERROR;               # package var
.Ve
.PP
or
.PP
.Vb 2
\&    my $object = My::Class\->new({ foo => \*(Aqbar\*(Aq }) # params hashref
\&          || die My::Class\->error;                # class method
.Ve
.SS "init(\e%config)"
.IX Subsection "init(%config)"
Object initialiser method which is called by the \f(CW\*(C`new()\*(C'\fR method, passing
a reference to a hash array of configuration parameters.  The method may
be derived in a subclass to perform any initialisation required.  It should
return \f(CW$self\fR on success, or \f(CW\*(C`undef\*(C'\fR on error, via a call to the \f(CW\*(C`error()\*(C'\fR
method.
.PP
.Vb 2
\&    package My::Module;
\&    use base qw( Class::Base );
\&
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        # let\*(Aqs make \*(Aqfoobar\*(Aq a mandatory argument
\&        $self\->{ foobar } = $config\->{ foobar }
\&            || return $self\->error("no foobar argument");
\&
\&        return $self;
\&    }
.Ve
.ie n .SS "params($config, @keys)"
.el .SS "params($config, \f(CW@keys\fP)"
.IX Subsection "params($config, @keys)"
The \f(CW\*(C`params()\*(C'\fR method accept a reference to a hash array as the 
first argument containing configuration values such as those passed
to the \f(CW\*(C`init()\*(C'\fR method.  The second argument can be a reference to 
a list of parameter names or a reference to a hash array mapping 
parameter names to default values.  If the second argument is not
a reference then all the remaining arguments are taken as parameter
names.  Thus the method can be called as follows:
.PP
.Vb 2
\&    sub init {
\&        my ($self, $config) = @_;
\&
\&        # either...
\&        $self\->params($config, qw( foo bar ));
\&
\&        # or...
\&        $self\->params($config, [ qw( foo bar ) ]);
\&
\&        # or...
\&        $self\->params($config, { foo => \*(Aqdefault foo value\*(Aq,
\&                                 bar => \*(Aqdefault bar value\*(Aq } );
\&
\&        return $self;
\&    }
.Ve
.PP
The method looks for values in \f(CW$config\fR corresponding to the keys
specified and copies them, if defined, into \f(CW$self\fR.
.PP
Keys can be specified in \s-1UPPER\s0 \s-1CASE\s0 and the method will look for 
either upper or lower case equivalents in the \f(CW$config\fR hash.  Thus
you can call \f(CW\*(C`params()\*(C'\fR from \f(CW\*(C`init()\*(C'\fR like so:
.PP
.Vb 5
\&    sub init {
\&        my ($self, $config) = @_;
\&        $self\->params($config, qw( FOO BAR ))
\&        return $self;
\&    }
.Ve
.PP
but use either case for parameters passed to \f(CW\*(C`new()\*(C'\fR:
.PP
.Vb 3
\&    my $object = My::Module\->new( FOO => \*(Aqthe foo value\*(Aq,
\&                                  BAR => \*(Aqthe bar value\*(Aq )
\&        || die My::Module\->error();
\&
\&    my $object = My::Module\->new( foo => \*(Aqthe foo value\*(Aq,
\&                                  bar => \*(Aqthe bar value\*(Aq )
\&        || die My::Module\->error();
.Ve
.PP
Note however that the internal key within \f(CW$self\fR used to store the
value will be in the case provided in the call to \f(CW\*(C`params()\*(C'\fR (upper
case in this example).  The method doesn't look for upper case
equivalents when they are specified in lower case.
.PP
When called in list context, the method returns a list of all the
values corresponding to the list of keys, some of which may be
undefined (allowing you to determine which values were successfully
set if you need to).  When called in scalar context it returns a 
reference to the same list.
.SS "\fIclone()\fP"
.IX Subsection "clone()"
The \f(CW\*(C`clone()\*(C'\fR method performs a simple shallow copy of the object
hash and creates a new object blessed into the same class.  You may
want to provide your own \f(CW\*(C`clone()\*(C'\fR method to perform a more complex
cloning operation.
.PP
.Vb 1
\&    my $clone = $object\->clone();
.Ve
.SS "error($msg, ...)"
.IX Subsection "error($msg, ...)"
General purpose method for getting and setting error messages.  When 
called as a class method, it returns the value of the \f(CW$ERROR\fR package
variable (in the derived class' package) if called without any arguments,
or sets the same variable when called with one or more arguments.  Multiple
arguments are concatenated together.
.PP
.Vb 3
\&    # set error
\&    My::Module\->error(\*(Aqset the error string\*(Aq);
\&    My::Module\->error(\*(Aqset \*(Aq, \*(Aqthe \*(Aq, \*(Aqerror string\*(Aq);
\&
\&    # get error
\&    print My::Module\->error();
\&    print $My::Module::ERROR;
.Ve
.PP
When called as an object method, it operates on the \f(CW\*(C`_ERROR\*(C'\fR member
of the object, returning it when called without any arguments, or
setting it when called with arguments.
.PP
.Vb 2
\&    # set error
\&    $object\->error(\*(Aqset the error string\*(Aq);
\&
\&    # get error
\&    print $object\->error();
.Ve
.PP
The method returns \f(CW\*(C`undef\*(C'\fR when called with arguments.  This allows it
to be used within object methods as shown:
.PP
.Vb 2
\&    sub my_method {
\&        my $self = shift;
\&
\&        # set error and return undef in one
\&        return $self\->error(\*(Aqbad, bad, error\*(Aq)
\&            if $something_bad;
\&    }
.Ve
.ie n .SS "debug($msg, $msg, ...)"
.el .SS "debug($msg, \f(CW$msg\fP, ...)"
.IX Subsection "debug($msg, $msg, ...)"
Prints all arguments to \s-1STDERR\s0 if the internal \f(CW\*(C`_DEBUG\*(C'\fR flag (when
called as an object method) or \f(CW$DEBUG\fR package variable (when called
as a class method) is set to a true value.  Otherwise does nothing.
The output is prefixed by a string of the form \*(L"[Class::Name]\*(R" where
the name of the class is that returned by the \f(CW\*(C`id()\*(C'\fR method.
.SS "debugging($flag)"
.IX Subsection "debugging($flag)"
Used to get (no arguments) or set ($flag defined) the value of the
internal \f(CW\*(C`_DEBUG\*(C'\fR flag (when called as an object method) or \f(CW$DEBUG\fR
package variable (when called as a class method).
.SS "id($newid)"
.IX Subsection "id($newid)"
The \f(CW\*(C`debug()\*(C'\fR method calls this method to return an identifier for
the object for printing in the debugging message.  By default it
returns the class name of the object (i.e. \f(CW\*(C`ref $self\*(C'\fR), but you can
of course subclass the method to return some other value.  When called
with an argument it uses that value to set its internal \f(CW\*(C`_ID\*(C'\fR field
which will be returned by subsequent calls to \f(CW\*(C`id()\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@kfs.org>
.SH "VERSION"
.IX Header "VERSION"
This is version 0.04 of Class::Base.
.SH "HISTORY"
.IX Header "HISTORY"
This module began life as the Template::Base module distributed as 
part of the Template Toolkit.
.PP
Thanks to Brian Moseley and Matt Sergeant for suggesting various
enhancments, some of which went into version 0.02.
.PP
Version 0.04 was uploaded by Gabor Szabo.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2012 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
