.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MakeMethods::Basic::Global 3"
.TH MakeMethods::Basic::Global 3 "2004-09-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MakeMethods::Basic::Global \- Basic shared methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  package MyObject;
\&  use Class::MakeMethods::Basic::Global (
\&    scalar => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ],
\&    array => \*(Aqmy_list\*(Aq,
\&    hash => \*(Aqmy_index\*(Aq,
\&  );
\&  ....
\&  
\&  # Store and retrieve global values
\&  MyObject\->foo(\*(AqFoobar\*(Aq);
\&  print MyObject\->foo();
\&  
\&  # All instances of your class access the same values
\&  $my_object\->bar(\*(AqBarbados\*(Aq); 
\&  print $other_one\->bar(); 
\&  
\&  # Array accessor
\&  MyObject\->my_list(0 => \*(AqFoozle\*(Aq, 1 => \*(AqBang!\*(Aq);
\&  print MyObject\->my_list(1);
\&  
\&  # Hash accessor
\&  MyObject\->my_index(\*(Aqbroccoli\*(Aq => \*(AqBlah!\*(Aq, \*(Aqfoo\*(Aq => \*(AqFiddle\*(Aq);
\&  print MyObject\->my_index(\*(Aqfoo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Basic::Global subclass of MakeMethods provides basic accessors for data shared by an entire class, sometimes called \*(L"static\*(R" or \*(L"class data.\*(R"
.SS "Calling Conventions"
.IX Subsection "Calling Conventions"
When you \f(CW\*(C`use\*(C'\fR this package, the method names you provide
as arguments cause subroutines to be generated and installed in
your module.
.PP
See \*(L"Calling Conventions\*(R" in Class::MakeMethods::Basic for a summary, or \*(L"\s-1USAGE\s0\*(R" in Class::MakeMethods for full details.
.SS "Declaration Syntax"
.IX Subsection "Declaration Syntax"
To declare methods, pass in pairs of a method-type name followed
by one or more method names. Valid method-type names for this
package are listed in \*(L"\s-1METHOD\s0 \s-1GENERATOR\s0 \s-1TYPES\s0\*(R".
.PP
See \*(L"Declaration Syntax\*(R" in Class::MakeMethods::Basic for more
syntax information.
.SH "METHOD GENERATOR TYPES"
.IX Header "METHOD GENERATOR TYPES"
.SS "scalar \- Shared Accessor"
.IX Subsection "scalar - Shared Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or equivalently, on any object instance.
.IP "\(bu" 4
Stores a global value accessible only through this method.
.IP "\(bu" 4
If called without any arguments returns the current value.
.IP "\(bu" 4
If called with an argument, stores that as the value, and returns it,
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Basic::Hash (
\&    scalar => \*(Aqfoo\*(Aq,
\&  );
\&  ...
\&  
\&  # Store value
\&  MyObject\->foo(\*(AqFoozle\*(Aq);
\&  
\&  # Retrieve value
\&  print MyObject\->foo;
.Ve
.SS "array \- Shared Ref Accessor"
.IX Subsection "array - Shared Ref Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or equivalently, on any object instance.
.IP "\(bu" 4
Stores a global value accessible only through this method.
.IP "\(bu" 4
The value will be a reference to an array (or undef).
.IP "\(bu" 4
If called without any arguments, returns the current array-ref value (or undef).
.IP "\(bu" 4
If called with one argument, uses that argument as an index to retrieve from the referenced array, and returns that value (or undef). If the single argument is an array ref, then a slice of the referenced array is returned.
.IP "\(bu" 4
If called with a list of index-value pairs, stores the value at the given index in the referenced array. If the value was previously undefined, a new array is autovivified. The current value in each position will be overwritten, and later arguments with the same index will override earlier ones. Returns the current array-ref value.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Basic::Hash (
\&    array => \*(Aqbar\*(Aq,
\&  );
\&  ...
\&  
\&  # Set values by position
\&  $obj\->bar(0 => \*(AqFoozle\*(Aq, 1 => \*(AqBang!\*(Aq);
\&  
\&  # Positions may be overwritten, and in any order
\&  $obj\->bar(2 => \*(AqAnd Mash\*(Aq, 1 => \*(AqBlah!\*(Aq);
\&  
\&  # Retrieve value by position
\&  print $obj\->bar(1);
\&  
\&  # Retrieve slice of values by position
\&  print join(\*(Aq, \*(Aq, $obj\->bar( [0, 2] ) );
\&  
\&  # Direct access to referenced array
\&  print scalar @{ $obj\->bar() };
\&  
\&  # Reset the array contents to empty
\&  @{ $obj\->bar() } = ();
.Ve
.SS "hash \- Shared Ref Accessor"
.IX Subsection "hash - Shared Ref Accessor"
For each method name passed, uses a closure to generate a subroutine with the following characteristics:
.IP "\(bu" 4
May be called as a class method, or equivalently, on any object instance.
.IP "\(bu" 4
Stores a global value accessible only through this method.
.IP "\(bu" 4
The value will be a reference to a hash (or undef).
.IP "\(bu" 4
If called without any arguments, returns the current hash-ref value (or undef).
.IP "\(bu" 4
If called with one argument, uses that argument as an index to retrieve from the referenced hash, and returns that value (or undef). If the single argument is an array ref, then a slice of the referenced hash is returned.
.IP "\(bu" 4
If called with a list of key-value pairs, stores the value under the given key in the referenced hash. If the value was previously undefined, a new hash is autovivified. The current value under each key will be overwritten, and later arguments with the same key will override earlier ones. Returns the current hash-ref value.
.PP
Sample declaration and usage:
.PP
.Vb 5
\&  package MyObject;
\&  use Class::MakeMethods::Basic::Hash (
\&    hash => \*(Aqbaz\*(Aq,
\&  );
\&  ...
\&  
\&  # Set values by key
\&  $obj\->baz(\*(Aqfoo\*(Aq => \*(AqFoozle\*(Aq, \*(Aqbar\*(Aq => \*(AqBang!\*(Aq);
\&  
\&  # Values may be overwritten, and in any order
\&  $obj\->baz(\*(Aqbroccoli\*(Aq => \*(AqBlah!\*(Aq, \*(Aqfoo\*(Aq => \*(AqFiddle\*(Aq);
\&  
\&  # Retrieve value by key
\&  print $obj\->baz(\*(Aqfoo\*(Aq);
\&  
\&  # Retrieve slice of values by position
\&  print join(\*(Aq, \*(Aq, $obj\->baz( [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq] ) );
\&  
\&  # Direct access to referenced hash
\&  print keys %{ $obj\->baz() };
\&  
\&  # Reset the hash contents to empty
\&  @{ $obj\->baz() } = ();
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Class::MakeMethods for general information about this distribution.
.PP
See Class::MakeMethods::Basic for more about this family of subclasses.
