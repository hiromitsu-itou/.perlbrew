.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Tutorial::04_BasicCRUD 3"
.TH Catalyst::Manual::Tutorial::04_BasicCRUD 3 "2011-09-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Tutorial::04_BasicCRUD \- Catalyst Tutorial \- Chapter 4: Basic CRUD
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This is \fBChapter 4 of 10\fR for the Catalyst tutorial.
.PP
Tutorial Overview
.IP "1." 4
Introduction
.IP "2." 4
Catalyst Basics
.IP "3." 4
More Catalyst Basics
.IP "4." 4
\&\fB04_Basic \s-1CRUD\s0\fR
.IP "5." 4
Authentication
.IP "6." 4
Authorization
.IP "7." 4
Debugging
.IP "8." 4
Testing
.IP "9." 4
Advanced \s-1CRUD\s0
.IP "10." 4
Appendices
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This chapter of the tutorial builds on the fairly primitive application
created in
Chapter 3 to add
basic support for Create, Read, Update, and Delete (\s-1CRUD\s0) of \f(CW\*(C`Book\*(C'\fR
objects.  Note that the 'list' function in
Chapter 3 already
implements the Read portion of \s-1CRUD\s0 (although Read normally refers to
reading a single object; you could implement full Read functionality
using the techniques introduced below).  This section will focus on the
Create and Delete aspects of \s-1CRUD\s0.  More advanced capabilities,
including full Update functionality, will be addressed in
Chapter 9.
.PP
Although this chapter of the tutorial will show you how to build \s-1CRUD\s0
functionality yourself, another option is to use a \*(L"\s-1CRUD\s0 builder\*(R" type
of tool to automate the process.  You get less control, but it can be
quick and easy.  For example, see Catalyst::Plugin::AutoCRUD,
CatalystX::CRUD, and CatalystX::CRUD::YUI.
.PP
Source code for the tutorial in included in the \fI/home/catalyst/Final\fR
directory of the Tutorial Virtual machine (one subdirectory per
chapter).  There are also instructions for downloading the code in
Catalyst::Manual::Tutorial::01_Intro.
.SH "FORMLESS SUBMISSION"
.IX Header "FORMLESS SUBMISSION"
Our initial attempt at object creation will utilize the \*(L"\s-1URL\s0 arguments\*(R"
feature of Catalyst (we will employ the more common form-based
submission in the sections that follow).
.SS "Include a Create Action in the Books Controller"
.IX Subsection "Include a Create Action in the Books Controller"
Edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and enter the following method:
.PP
.Vb 1
\&    =head2 url_create
\&    
\&    Create a book with the supplied title, rating, and author
\&    
\&    =cut
\&    
\&    sub url_create :Local {
\&        # In addition to self & context, get the title, rating, &
\&        # author_id args from the URL.  Note that Catalyst automatically
\&        # puts extra information after the "/<controller_name>/<action_name/"
\&        # into @_.  The args are separated  by the \*(Aq/\*(Aq char on the URL.
\&        my ($self, $c, $title, $rating, $author_id) = @_;
\&    
\&        # Call create() on the book model object. Pass the table
\&        # columns/field values we want to set as hash values
\&        my $book = $c\->model(\*(AqDB::Book\*(Aq)\->create({
\&                title  => $title,
\&                rating => $rating
\&            });
\&    
\&        # Add a record to the join table for this book, mapping to
\&        # appropriate author
\&        $book\->add_to_book_authors({author_id => $author_id});
\&        # Note: Above is a shortcut for this:
\&        # $book\->create_related(\*(Aqbook_authors\*(Aq, {author_id => $author_id});
\&    
\&        # Assign the Book object to the stash for display and set template
\&        $c\->stash(book     => $book,
\&                  template => \*(Aqbooks/create_done.tt2\*(Aq);
\&    
\&        # Disable caching for this page
\&        $c\->response\->header(\*(AqCache\-Control\*(Aq => \*(Aqno\-cache\*(Aq);
\&    }
.Ve
.PP
Notice that Catalyst takes \*(L"extra slash-separated information\*(R" from the
\&\s-1URL\s0 and passes it as arguments in \f(CW@_\fR (as long as the number of
arguments is not \*(L"fixed\*(R" using an attribute like \f(CW:Args(0)\fR).  The
\&\f(CW\*(C`url_create\*(C'\fR action then uses a simple call to the \s-1DBIC\s0 \f(CW\*(C`create\*(C'\fR
method to add the requested information to the database (with a separate
call to \f(CW\*(C`add_to_book_authors\*(C'\fR to update the join table).  As do
virtually all controller methods (at least the ones that directly handle
user input), it then sets the template that should handle this request.
.PP
Also note that we are explicitly setting a \f(CW\*(C`no\-cache\*(C'\fR \*(L"Cache-Control\*(R"
header to force browsers using the page to get a fresh copy every time.
You could even move this to a \f(CW\*(C`auto\*(C'\fR method in
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR and it would automatically get applied
to every page in the whole application via a single line of code
(remember from Chapter 3, that every \f(CW\*(C`auto\*(C'\fR method gets run in the
Controller hierarchy).
.SS "Include a Template for the 'url_create' Action:"
.IX Subsection "Include a Template for the 'url_create' Action:"
Edit \f(CW\*(C`root/src/books/create_done.tt2\*(C'\fR and then enter:
.PP
.Vb 4
\&    [% # Use the TT Dumper plugin to Data::Dumper variables to the browser   \-%]
\&    [% # Not a good idea for production use, though. :\-)  \*(AqIndent=1\*(Aq is      \-%]
\&    [% # optional, but prevents "massive indenting" of deeply nested objects \-%]
\&    [% USE Dumper(Indent=1) \-%]
\&    
\&    [% # Set the page title.  META can \*(Aqgo back\*(Aq and set values in templates \-%]
\&    [% # that have been processed \*(Aqbefore\*(Aq this template (here it\*(Aqs updating \-%]
\&    [% # the title in the root/src/wrapper.tt2 wrapper template).  Note that \-%]
\&    [% # META only works on simple/static strings (i.e. there is no variable \-%]
\&    [% # interpolation \-\- if you need dynamic/interpolated content in your   \-%]
\&    [% # title, set "$c\->stash(title => $something)" in the controller).     \-%]
\&    [% META title = \*(AqBook Created\*(Aq %]
\&    
\&    [% # Output information about the record that was added.  First title.   \-%]
\&    <p>Added book \*(Aq[% book.title %]\*(Aq
\&    
\&    [% # Then, output the last name of the first author \-%]
\&    by \*(Aq[% book.authors.first.last_name %]\*(Aq
\&    
\&    [% # Then, output the rating for the book that was added \-%]
\&    with a rating of [% book.rating %].</p>
\&    
\&    [% # Provide a link back to the list page.  \*(Aqc.uri_for\*(Aq builds \-%]
\&    [% # a full URI; e.g., \*(Aqhttp://localhost:3000/books/list\*(Aq      \-%]
\&    <p><a href="[% c.uri_for(\*(Aq/books/list\*(Aq) %]">Return to list</a></p>
\&    
\&    [% # Try out the TT Dumper (for development only!) \-%]
\&    <pre>
\&    Dump of the \*(Aqbook\*(Aq variable:
\&    [% Dumper.dump(book) %]
\&    </pre>
.Ve
.PP
The \s-1TT\s0 \f(CW\*(C`USE\*(C'\fR directive allows access to a variety of plugin modules (\s-1TT\s0
plugins, that is, not Catalyst plugins) to add extra functionality to
the base \s-1TT\s0 capabilities.  Here, the plugin allows Data::Dumper
\&\*(L"pretty printing\*(R" of objects and variables.  Other than that, the rest
of the code should be familiar from the examples in Chapter 3.
.SS "Try the 'url_create' Feature"
.IX Subsection "Try the 'url_create' Feature"
Make sure the development server is running with the \*(L"\-r\*(R" restart
option:
.PP
.Vb 1
\&    $ DBIC_TRACE=1 script/myapp_server.pl \-r
.Ve
.PP
Note that new path for \f(CW\*(C`/books/url_create\*(C'\fR appears in the startup debug
output.
.PP
Next, use your browser to enter the following \s-1URL:\s0
.PP
.Vb 1
\&    http://localhost:3000/books/url_create/TCPIP_Illustrated_Vol\-2/5/4
.Ve
.PP
Your browser should display \*(L"Added book 'TCPIP_Illustrated_Vol\-2' by
\&'Stevens' with a rating of 5.\*(R" along with a dump of the new book model
object as it was returned by \s-1DBIC\s0.  You should also see the following
\&\s-1DBIC\s0 debug messages displayed in the development server log messages if
you have \s-1DBIC_TRACE\s0 set:
.PP
.Vb 2
\&    INSERT INTO book (rating, title) VALUES (?, ?): \`5\*(Aq, \`TCPIP_Illustrated_Vol\-2\*(Aq
\&    INSERT INTO book_author (author_id, book_id) VALUES (?, ?): \`4\*(Aq, \`6\*(Aq
.Ve
.PP
The \f(CW\*(C`INSERT\*(C'\fR statements are obviously adding the book and linking it to
the existing record for Richard Stevens.  The \f(CW\*(C`SELECT\*(C'\fR statement
results from \s-1DBIC\s0 automatically fetching the book for the
\&\f(CW\*(C`Dumper.dump(book)\*(C'\fR.
.PP
If you then click the \*(L"Return to list\*(R" link, you should find that there
are now six books shown (if necessary, Shift+Reload or Ctrl+Reload your
browser at the \f(CW\*(C`/books/list\*(C'\fR page).  You should now see the six \s-1DBIC\s0
debug messages similar to the following (where N=1\-6):
.PP
.Vb 3
\&    SELECT author.id, author.first_name, author.last_name 
\&        FROM book_author me  JOIN author author 
\&        ON author.id = me.author_id WHERE ( me.book_id = ? ): \*(AqN\*(Aq
.Ve
.SH "CONVERT TO A CHAINED ACTION"
.IX Header "CONVERT TO A CHAINED ACTION"
Although the example above uses the same \f(CW\*(C`Local\*(C'\fR action type for the
method that we saw in the previous chapter of the tutorial, there is an
alternate approach that allows us to be more specific while also paving
the way for more advanced capabilities.  Change the method declaration
for \f(CW\*(C`url_create\*(C'\fR in \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR you entered above
to match the following:
.PP
.Vb 7
\&    sub url_create :Chained(\*(Aq/\*(Aq) :PathPart(\*(Aqbooks/url_create\*(Aq) :Args(3) {
\&        # In addition to self & context, get the title, rating, &
\&        # author_id args from the URL.  Note that Catalyst automatically
\&        # puts the first 3 arguments worth of extra information after the 
\&        # "/<controller_name>/<action_name/" into @_ because we specified
\&        # "Args(3)".  The args are separated  by the \*(Aq/\*(Aq char on the URL.
\&        my ($self, $c, $title, $rating, $author_id) = @_;
\&    
\&        ...
.Ve
.PP
This converts the method to take advantage of the Chained
action/dispatch type. Chaining lets you have a single \s-1URL\s0 automatically
dispatch to several controller methods, each of which can have precise
control over the number of arguments that it will receive.  A chain can
essentially be thought of having three parts \*(-- a beginning, a middle,
and an end.  The bullets below summarize the key points behind each of
these parts of a chain:
.IP "\(bu" 4
Beginning
.RS 4
.IP "\(bu" 4
\&\fBUse "\f(CB\*(C`:Chained(\*(Aq/\*(Aq)\*(C'\fB" to start a chain\fR
.IP "\(bu" 4
Get arguments through \f(CW\*(C`CaptureArgs()\*(C'\fR
.IP "\(bu" 4
Specify the path to match with \f(CW\*(C`PathPart()\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
Middle
.RS 4
.IP "\(bu" 4
Link to previous part of the chain with \f(CW\*(C`:Chained(\*(Aq_name_\*(Aq)\*(C'\fR
.IP "\(bu" 4
Get arguments through \f(CW\*(C`CaptureArgs()\*(C'\fR
.IP "\(bu" 4
Specify the path to match with \f(CW\*(C`PathPart()\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
End
.RS 4
.IP "\(bu" 4
Link to previous part of the chain with \f(CW\*(C`:Chained(\*(Aq_name_\*(Aq)\*(C'\fR
.IP "\(bu" 4
\&\fBDo \s-1NOT\s0 get arguments through "\f(CB\*(C`CaptureArgs()\*(C'\fB,\*(L" use \*(R"\f(CB\*(C`Args()\*(C'\fB" instead to end a chain\fR
.IP "\(bu" 4
Specify the path to match with \f(CW\*(C`PathPart()\*(C'\fR
.RE
.RS 4
.RE
.PP
In our \f(CW\*(C`url_create\*(C'\fR method above, we have combined all three parts into
a single method: \f(CW\*(C`:Chained(\*(Aq/\*(Aq)\*(C'\fR to start the chain,
\&\f(CW\*(C`:PathPart(\*(Aqbooks/url_create\*(Aq)\*(C'\fR to specify the base \s-1URL\s0 to match, and
\&\f(CW:Args(3)\fR to capture exactly three arguments and to end the chain.
.PP
As we will see shortly, a chain can consist of as many \*(L"links\*(R" as you
wish, with each part capturing some arguments and doing some work along
the way.  We will continue to use the Chained action type in this
chapter of the tutorial and explore slightly more advanced capabilities
with the base method and delete feature below.  But Chained dispatch is
capable of far more.  For additional information, see
\&\*(L"Action types\*(R" in Catalyst::Manual::Intro,
Catalyst::DispatchType::Chained, and the 2006 Advent calendar entry
on the subject: <http://www.catalystframework.org/calendar/2006/10>.
.SS "Try the Chained Action"
.IX Subsection "Try the Chained Action"
If you look back at the development server startup logs from your
initial version of the \f(CW\*(C`url_create\*(C'\fR method (the one using the \f(CW\*(C`:Local\*(C'\fR
attribute), you will notice that it produced output similar to the
following:
.PP
.Vb 10
\&    [debug] Loaded Path actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path                                | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /                                   | /default                             |
\&    | /                                   | /index                               |
\&    | /books                              | /books/index                         |
\&    | /books/list                         | /books/list                          |
\&    | /books/url_create                   | /books/url_create                    |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
When the development server restarts after our conversion to Chained
dispatch, the debug output should change to something along the lines of
the following:
.PP
.Vb 9
\&    [debug] Loaded Path actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path                                | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /                                   | /default                             |
\&    | /                                   | /index                               |
\&    | /books                              | /books/index                         |
\&    | /books/list                         | /books/list                          |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    
\&    [debug] Loaded Chained actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path Spec                           | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /books/url_create/*/*/*             | /books/url_create                    |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
\&\f(CW\*(C`url_create\*(C'\fR has disappeared from the \*(L"Loaded Path actions\*(R" section but
it now shows up under the newly created \*(L"Loaded Chained actions\*(R"
section.  And the \*(L"/*/*/*\*(R" portion clearly shows our requirement for
three arguments.
.PP
As with our non-chained version of \f(CW\*(C`url_create\*(C'\fR, use your browser to
enter the following \s-1URL:\s0
.PP
.Vb 1
\&    http://localhost:3000/books/url_create/TCPIP_Illustrated_Vol\-2/5/4
.Ve
.PP
You should see the same \*(L"Added book 'TCPIP_Illustrated_Vol\-2' by
\&'Stevens' with a rating of 5.\*(R" along with a dump of the new book model
object.  Click the \*(L"Return to list\*(R" link, and you should find that there
are now seven books shown (two copies of \fITCPIP_Illustrated_Vol\-2\fR).
.SS "Refactor to Use a 'base' Method to Start the Chains"
.IX Subsection "Refactor to Use a 'base' Method to Start the Chains"
Let's make a quick update to our initial Chained action to show a little
more of the power of chaining.  First, open
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR in your editor and add the following
method:
.PP
.Vb 1
\&    =head2 base
\&    
\&    Can place common logic to start chained dispatch here
\&    
\&    =cut
\&    
\&    sub base :Chained(\*(Aq/\*(Aq) :PathPart(\*(Aqbooks\*(Aq) :CaptureArgs(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Store the ResultSet in stash so it\*(Aqs available for other methods
\&        $c\->stash(resultset => $c\->model(\*(AqDB::Book\*(Aq));
\&    
\&        # Print a message to the debug log
\&        $c\->log\->debug(\*(Aq*** INSIDE BASE METHOD ***\*(Aq);
\&    }
.Ve
.PP
Here we print a log message and store the \s-1DBIC\s0 ResultSet in
\&\f(CW\*(C`$c\->stash\->{resultset}\*(C'\fR so that it's automatically available
for other actions that chain off \f(CW\*(C`base\*(C'\fR.  If your controller always
needs a book \s-1ID\s0 as its first argument, you could have the base method
capture that argument (with \f(CW:CaptureArgs(1)\fR) and use it to pull the
book object with \f(CW\*(C`\->find($id)\*(C'\fR and leave it in the stash for later
parts of your chains to then act upon. Because we have several actions
that don't need to retrieve a book (such as the \f(CW\*(C`url_create\*(C'\fR we are
working with now), we will instead add that functionality to a common
\&\f(CW\*(C`object\*(C'\fR action shortly.
.PP
As for \f(CW\*(C`url_create\*(C'\fR, let's modify it to first dispatch to \f(CW\*(C`base\*(C'\fR.
Open up \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and edit the declaration for
\&\f(CW\*(C`url_create\*(C'\fR to match the following:
.PP
.Vb 1
\&    sub url_create :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqurl_create\*(Aq) :Args(3) {
.Ve
.PP
Once you save \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR, notice that the
development server will restart and our \*(L"Loaded Chained actions\*(R" section
will changed slightly:
.PP
.Vb 7
\&    [debug] Loaded Chained actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path Spec                           | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /books/url_create/*/*/*             | /books/base (0)                      |
\&    |                                     | => /books/url_create                 |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
The \*(L"Path Spec\*(R" is the same, but now it maps to two Private actions as
we would expect.  The \f(CW\*(C`base\*(C'\fR method is being triggered by the \f(CW\*(C`/books\*(C'\fR
part of the \s-1URL\s0.  However, the processing then continues to the
\&\f(CW\*(C`url_create\*(C'\fR method because this method \*(L"chained\*(R" off \f(CW\*(C`base\*(C'\fR and
specified \f(CW\*(C`:PathPart(\*(Aqurl_create\*(Aq)\*(C'\fR (note that we could have omitted
the \*(L"PathPart\*(R" here because it matches the name of the method, but we
will include it to make the logic as explicit as possible).
.PP
Once again, enter the following \s-1URL\s0 into your browser:
.PP
.Vb 1
\&    http://localhost:3000/books/url_create/TCPIP_Illustrated_Vol\-2/5/4
.Ve
.PP
The same \*(L"Added book 'TCPIP_Illustrated_Vol\-2' by 'Stevens' with a
rating of 5.\*(R" message and a dump of the new book object should appear.
Also notice the extra \*(L"\s-1INSIDE\s0 \s-1BASE\s0 \s-1METHOD\s0\*(R" debug message in the
development server output from the \f(CW\*(C`base\*(C'\fR method.  Click the \*(L"Return to
list\*(R" link, and you should find that there are now eight books shown.
(You may have a larger number of books if you repeated any of the
\&\*(L"create\*(R" actions more than once.  Don't worry about it as long as the
number of books is appropriate for the number of times you added new
books... there should be the original five books added via
\&\f(CW\*(C`myapp01.sql\*(C'\fR plus one additional book for each time you ran one of the
url_create variations above.)
.SH "MANUALLY BUILDING A CREATE FORM"
.IX Header "MANUALLY BUILDING A CREATE FORM"
Although the \f(CW\*(C`url_create\*(C'\fR action in the previous step does begin to
reveal the power and flexibility of both Catalyst and \s-1DBIC\s0, it's
obviously not a very realistic example of how users should be expected
to enter data.  This section begins to address that concern (but just
barely, see Chapter 9
for better options for handling web-based forms).
.SS "Add Method to Display The Form"
.IX Subsection "Add Method to Display The Form"
Edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and add the following method:
.PP
.Vb 1
\&    =head2 form_create
\&    
\&    Display form to collect information for book to create
\&    
\&    =cut
\&    
\&    sub form_create :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqform_create\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Set the TT template to use
\&        $c\->stash(template => \*(Aqbooks/form_create.tt2\*(Aq);
\&    }
.Ve
.PP
This action simply invokes a view containing a form to create a book.
.SS "Add a Template for the Form"
.IX Subsection "Add a Template for the Form"
Open \f(CW\*(C`root/src/books/form_create.tt2\*(C'\fR in your editor and enter:
.PP
.Vb 1
\&    [% META title = \*(AqManual Form Book Create\*(Aq \-%]
\&    
\&    <form method="post" action="[% c.uri_for(\*(Aqform_create_do\*(Aq) %]">
\&    <table>
\&      <tr><td>Title:</td><td><input type="text" name="title"></td></tr>
\&      <tr><td>Rating:</td><td><input type="text" name="rating"></td></tr>
\&      <tr><td>Author ID:</td><td><input type="text" name="author_id"></td></tr>
\&    </table>
\&    <input type="submit" name="Submit" value="Submit">
\&    </form>
.Ve
.PP
Note that we have specified the target of the form data as
\&\f(CW\*(C`form_create_do\*(C'\fR, the method created in the section that follows.
.SS "Add a Method to Process Form Values and Update Database"
.IX Subsection "Add a Method to Process Form Values and Update Database"
Edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and add the following method to
save the form information to the database:
.PP
.Vb 1
\&    =head2 form_create_do
\&    
\&    Take information from form and add to database
\&    
\&    =cut
\&    
\&    sub form_create_do :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqform_create_do\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Retrieve the values from the form
\&        my $title     = $c\->request\->params\->{title}     || \*(AqN/A\*(Aq;
\&        my $rating    = $c\->request\->params\->{rating}    || \*(AqN/A\*(Aq;
\&        my $author_id = $c\->request\->params\->{author_id} || \*(Aq1\*(Aq;
\&    
\&        # Create the book
\&        my $book = $c\->model(\*(AqDB::Book\*(Aq)\->create({
\&                title   => $title,
\&                rating  => $rating,
\&            });
\&        # Handle relationship with author
\&        $book\->add_to_book_authors({author_id => $author_id});
\&        # Note: Above is a shortcut for this:
\&        # $book\->create_related(\*(Aqbook_authors\*(Aq, {author_id => $author_id});
\&    
\&        # Store new model object in stash and set template
\&        $c\->stash(book     => $book,
\&                  template => \*(Aqbooks/create_done.tt2\*(Aq);
\&    }
.Ve
.SS "Test Out The Form"
.IX Subsection "Test Out The Form"
Notice that the server startup log reflects the two new chained methods
that we added:
.PP
.Vb 11
\&    [debug] Loaded Chained actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path Spec                           | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /books/form_create                  | /books/base (0)                      |
\&    |                                     | => /books/form_create                |
\&    | /books/form_create_do               | /books/base (0)                      |
\&    |                                     | => /books/form_create_do             |
\&    | /books/url_create/*/*/*             | /books/base (0)                      |
\&    |                                     | => /books/url_create                 |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
Point your browser to <http://localhost:3000/books/form_create> and
enter \*(L"\s-1TCP/IP\s0 Illustrated, Vol 3\*(R" for the title, a rating of 5, and an
author \s-1ID\s0 of 4.  You should then see the output of the same
\&\f(CW\*(C`create_done.tt2\*(C'\fR template seen in earlier examples.  Finally, click
\&\*(L"Return to list\*(R" to view the full list of books.
.PP
\&\fBNote:\fR Having the user enter the primary key \s-1ID\s0 for the author is
obviously crude; we will address this concern with a drop-down list and
add validation to our forms in
Chapter 9.
.SH "A SIMPLE DELETE FEATURE"
.IX Header "A SIMPLE DELETE FEATURE"
Turning our attention to the Delete portion of \s-1CRUD\s0, this section
illustrates some basic techniques that can be used to remove information
from the database.
.SS "Include a Delete Link in the List"
.IX Subsection "Include a Delete Link in the List"
Edit \f(CW\*(C`root/src/books/list.tt2\*(C'\fR and update it to match the following
(two sections have changed: 1) the additional '<th>Links</th>' table
header, and 2) the five lines for the Delete link near the bottom):
.PP
.Vb 1
\&    [% # This is a TT comment. \-%]
\&    
\&    [%\- # Provide a title \-%]
\&    [% META title = \*(AqBook List\*(Aq \-%]
\&    
\&    [% # Note That the \*(Aq\-\*(Aq at the beginning or end of TT code  \-%]
\&    [% # "chomps" the whitespace/newline at that end of the    \-%]
\&    [% # output (use View Source in browser to see the effect) \-%]
\&    
\&    [% # Some basic HTML with a loop to display books \-%]
\&    <table>
\&    <tr><th>Title</th><th>Rating</th><th>Author(s)</th><th>Links</th></tr>
\&    [% # Display each book in a table row %]
\&    [% FOREACH book IN books \-%]
\&      <tr>
\&        <td>[% book.title %]</td>
\&        <td>[% book.rating %]</td>
\&        <td>
\&          [% # NOTE: See Chapter 4 for a better way to do this!                      \-%]
\&          [% # First initialize a TT variable to hold a list.  Then use a TT FOREACH \-%]
\&          [% # loop in \*(Aqside effect notation\*(Aq to load just the last names of the     \-%]
\&          [% # authors into the list. Note that the \*(Aqpush\*(Aq TT vmethod doesn\*(Aqt return \-%]
\&          [% # a value, so nothing will be printed here.  But, if you have something \-%]
\&          [% # in TT that does return a value and you don\*(Aqt want it printed, you     \-%]
\&          [% # 1) assign it to a bogus value, or                                     \-%]
\&          [% # 2) use the CALL keyword to call it and discard the return value.      \-%]
\&          [% tt_authors = [ ];
\&             tt_authors.push(author.last_name) FOREACH author = book.authors %]
\&          [% # Now use a TT \*(Aqvirtual method\*(Aq to display the author count in parens   \-%]
\&          [% # Note the use of the TT filter "| html" to escape dangerous characters \-%]
\&          ([% tt_authors.size | html %])
\&          [% # Use another TT vmethod to join & print the names & comma separators   \-%]
\&          [% tt_authors.join(\*(Aq, \*(Aq) | html %]
\&        </td>
\&        <td>
\&          [% # Add a link to delete a book %]
\&          <a href="[%
\&            c.uri_for(c.controller.action_for(\*(Aqdelete\*(Aq), [book.id]) %]">Delete</a>
\&        </td>
\&      </tr>
\&    [% END \-%]
\&    </table>
.Ve
.PP
The additional code is obviously designed to add a new column to the
right side of the table with a \f(CW\*(C`Delete\*(C'\fR \*(L"button\*(R" (for simplicity, links
will be used instead of full \s-1HTML\s0 buttons; but, in practice, anything
that modifies data should be handled with a form sending a \s-1POST\s0
request).
.PP
Also notice that we are using a more advanced form of \f(CW\*(C`uri_for\*(C'\fR than we
have seen before.  Here we use \f(CW\*(C`$c\->controller\->action_for\*(C'\fR to
automatically generate a \s-1URI\s0 appropriate for that action based on the
method we want to link to while inserting the \f(CW\*(C`book.id\*(C'\fR value into the
appropriate place.  Now, if you ever change \f(CW\*(C`:PathPart(\*(Aqdelete\*(Aq)\*(C'\fR in
your controller method to something like \f(CW\*(C`:PathPart(\*(Aqkill\*(Aq)\*(C'\fR, then your
links will automatically update without any changes to your .tt2
template file.  As long as the name of your method does not change
(here, \*(L"delete\*(R"), then your links will still be correct.  There are a
few shortcuts and options when using \f(CW\*(C`action_for()\*(C'\fR:
.IP "\(bu" 4
If you are referring to a method in the current controller, you can use
\&\f(CW\*(C`$self\->action_for(\*(Aq_method_name_\*(Aq)\*(C'\fR.
.IP "\(bu" 4
If you are referring to a method in a different controller, you need to
include that controller's name as an argument to \f(CW\*(C`controller()\*(C'\fR, as in
\&\f(CW\*(C`$c\->controller(\*(Aq_controller_name_\*(Aq)\->action_for(\*(Aq_method_name_\*(Aq)\*(C'\fR.
.PP
\&\fBNote:\fR In practice you should \fBnever\fR use a \s-1GET\s0 request to delete a
record \*(-- always use \s-1POST\s0 for actions that will modify data.  We are
doing it here for illustrative and simplicity purposes only.
.SS "Add a Common Method to Retrieve a Book for the Chain"
.IX Subsection "Add a Common Method to Retrieve a Book for the Chain"
As mentioned earlier, since we have a mixture of actions that operate on
a single book \s-1ID\s0 and others that do not, we should not have \f(CW\*(C`base\*(C'\fR
capture the book \s-1ID\s0, find the corresponding book in the database and
save it in the stash for later links in the chain.  However, just
because that logic does not belong in \f(CW\*(C`base\*(C'\fR doesn't mean that we can't
create another location to centralize the book lookup code.  In our
case, we will create a method called \f(CW\*(C`object\*(C'\fR that will store the
specific book in the stash.  Chains that always operate on a single
existing book can chain off this method, but methods such as
\&\f(CW\*(C`url_create\*(C'\fR that don't operate on an existing book can chain directly
off base.
.PP
To add the \f(CW\*(C`object\*(C'\fR method, edit \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and
add the following code:
.PP
.Vb 1
\&    =head2 object
\&    
\&    Fetch the specified book object based on the book ID and store
\&    it in the stash
\&    
\&    =cut
\&    
\&    sub object :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqid\*(Aq) :CaptureArgs(1) {
\&        # $id = primary key of book to delete
\&        my ($self, $c, $id) = @_;
\&    
\&        # Find the book object and store it in the stash
\&        $c\->stash(object => $c\->stash\->{resultset}\->find($id));
\&    
\&        # Make sure the lookup was successful.  You would probably
\&        # want to do something like this in a real app:
\&        #   $c\->detach(\*(Aq/error_404\*(Aq) if !$c\->stash\->{object};
\&        die "Book $id not found!" if !$c\->stash\->{object};
\&    
\&        # Print a message to the debug log
\&        $c\->log\->debug("*** INSIDE OBJECT METHOD for obj id=$id ***");
\&    }
.Ve
.PP
Now, any other method that chains off \f(CW\*(C`object\*(C'\fR will automatically have
the appropriate book waiting for it in \f(CW\*(C`$c\->stash\->{object}\*(C'\fR.
.SS "Add a Delete Action to the Controller"
.IX Subsection "Add a Delete Action to the Controller"
Open \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR in your editor and add the
following method:
.PP
.Vb 1
\&    =head2 delete
\&    
\&    Delete a book
\&    
\&    =cut
\&    
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_author\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Set a status message to be displayed at the top of the view
\&        $c\->stash\->{status_msg} = "Book deleted.";
\&    
\&        # Forward to the list action/method in this controller
\&        $c\->forward(\*(Aqlist\*(Aq);
\&    }
.Ve
.PP
This method first deletes the book object saved by the \f(CW\*(C`object\*(C'\fR method.
However, it also removes the corresponding entry from the \f(CW\*(C`book_author\*(C'\fR
table with a cascading delete.
.PP
Then, rather than forwarding to a \*(L"delete done\*(R" page as we did with the
earlier create example, it simply sets the \f(CW\*(C`status_msg\*(C'\fR to display a
notification to the user as the normal list view is rendered.
.PP
The \f(CW\*(C`delete\*(C'\fR action uses the context \f(CW\*(C`forward\*(C'\fR method to return the
user to the book list.  The \f(CW\*(C`detach\*(C'\fR method could have also been used.
Whereas \f(CW\*(C`forward\*(C'\fR \fIreturns\fR to the original action once it is
completed, \f(CW\*(C`detach\*(C'\fR does \fInot\fR return.  Other than that, the two are
equivalent.
.SS "Try the Delete Feature"
.IX Subsection "Try the Delete Feature"
Once you save the Books controller, the server should automatically
restart.  The \f(CW\*(C`delete\*(C'\fR method should now appear in the \*(L"Loaded Chained
actions\*(R" section of the startup debug output:
.PP
.Vb 10
\&    [debug] Loaded Chained actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path Spec                           | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /books/id/*/delete                  | /books/base (0)                      |
\&    |                                     | \-> /books/object (1)                 |
\&    |                                     | => /books/delete                     |
\&    | /books/form_create                  | /books/base (0)                      |
\&    |                                     | => /books/form_create                |
\&    | /books/form_create_do               | /books/base (0)                      |
\&    |                                     | => /books/form_create_do             |
\&    | /books/url_create/*/*/*             | /books/base (0)                      |
\&    |                                     | => /books/url_create                 |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
Then point your browser to <http://localhost:3000/books/list> and click
the \*(L"Delete\*(R" link next to the first \*(L"TCPIP_Illustrated_Vol\-2\*(R".  A green
\&\*(L"Book deleted\*(R" status message should display at the top of the page,
along with a list of the eight remaining books.  You will also see the
cascading delete operation via the \s-1DBIC_TRACE\s0 output:
.PP
.Vb 2
\&    SELECT me.id, me.title, me.rating FROM book me WHERE ( ( me.id = ? ) ): \*(Aq6\*(Aq
\&    DELETE FROM book WHERE ( id = ? ): \*(Aq6\*(Aq
.Ve
.SS "Fixing a Dangerous \s-1URL\s0"
.IX Subsection "Fixing a Dangerous URL"
Note the \s-1URL\s0 in your browser once you have performed the deletion in the
prior step \*(-- it is still referencing the delete action:
.PP
.Vb 1
\&    http://localhost:3000/books/id/6/delete
.Ve
.PP
What if the user were to press reload with this \s-1URL\s0 still active?  In
this case the redundant delete is harmless (although it does generate an
exception screen, it doesn't perform any undesirable actions on the
application or database), but in other cases this could clearly lead to
trouble.
.PP
We can improve the logic by converting to a redirect.  Unlike
\&\f(CW\*(C`$c\->forward(\*(Aqlist\*(Aq))\*(C'\fR or \f(CW\*(C`$c\->detach(\*(Aqlist\*(Aq))\*(C'\fR that perform a
server-side alteration in the flow of processing, a redirect is a
client-side mechanism that causes the browser to issue an entirely new
request.  As a result, the \s-1URL\s0 in the browser is updated to match the
destination of the redirection \s-1URL\s0.
.PP
To convert the forward used in the previous section to a redirect, open
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and edit the existing \f(CW\*(C`sub delete\*(C'\fR
method to match:
.PP
.Vb 1
\&    =head2 delete
\&    
\&    Delete a book
\&    
\&    =cut
\&    
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_author\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Set a status message to be displayed at the top of the view
\&        $c\->stash\->{status_msg} = "Book deleted.";
\&    
\&        # Redirect the user back to the list page.  Note the use
\&        # of $self\->action_for as earlier in this section (BasicCRUD)
\&        $c\->response\->redirect($c\->uri_for($self\->action_for(\*(Aqlist\*(Aq)));
\&    }
.Ve
.SS "Try the Delete and Redirect Logic"
.IX Subsection "Try the Delete and Redirect Logic"
Point your browser to <http://localhost:3000/books/list> (don't just
hit \*(L"Refresh\*(R" in your browser since we left the \s-1URL\s0 in an invalid state
in the previous section!) and delete the first copy of the remaining two
\&\*(L"TCPIP_Illustrated_Vol\-2\*(R" books. The \s-1URL\s0 in your browser should return
to the <http://localhost:3000/books/list> \s-1URL\s0, so that is an
improvement, but notice that \fIno green \*(L"Book deleted\*(R" status message is
displayed\fR. Because the stash is reset on every request (and a redirect
involves a second request), the \f(CW\*(C`status_msg\*(C'\fR is cleared before it can
be displayed.
.SS "Using 'uri_for' to Pass Query Parameters"
.IX Subsection "Using 'uri_for' to Pass Query Parameters"
There are several ways to pass information across a redirect. One option
is to use the \f(CW\*(C`flash\*(C'\fR technique that we will see in
Chapter 5 of this
tutorial; however, here we will pass the information via query
parameters on the redirect itself.  Open
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and update the existing \f(CW\*(C`sub delete\*(C'\fR
method to match the following:
.PP
.Vb 1
\&    =head2 delete
\&    
\&    Delete a book
\&    
\&    =cut
\&    
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_author\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Redirect the user back to the list page with status msg as an arg
\&        $c\->response\->redirect($c\->uri_for($self\->action_for(\*(Aqlist\*(Aq),
\&            {status_msg => "Book deleted."}));
\&    }
.Ve
.PP
This modification simply leverages the ability of \f(CW\*(C`uri_for\*(C'\fR to include
an arbitrary number of name/value pairs in a hash reference.  Next, we
need to update \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR to handle \f(CW\*(C`status_msg\*(C'\fR as a
query parameter:
.PP
.Vb 10
\&    ...
\&    <div id="content">
\&        [%# Status and error messages %]
\&        <span class="message">[%
\&            status_msg || c.request.params.status_msg | html %]</span>
\&        <span class="error">[% error_msg %]</span>
\&        [%# This is where TT will stick all of your template\*(Aqs contents. \-%]
\&        [% content %]
\&    </div><!\-\- end content \-\->
\&    ...
.Ve
.PP
Although the sample above only shows the \f(CW\*(C`content\*(C'\fR div, leave the rest
of the file intact \*(-- the only change we made to the \f(CW\*(C`wrapper.tt2\*(C'\fR was
to add "\f(CW\*(C`|| c.request.params.status_msg\*(C'\fR" to the
\&\f(CW\*(C`<span class="message">\*(C'\fR line.  Note that we definitely want
the "\f(CW\*(C`| html\*(C'\fR" \s-1TT\s0 filter here since it would be easy for users to
modify the message on the \s-1URL\s0 and possibly inject harmful code into the
application if we left that off.
.SS "Try the Delete and Redirect With Query Param Logic"
.IX Subsection "Try the Delete and Redirect With Query Param Logic"
Point your browser to <http://localhost:3000/books/list> (you should
now be able to safely hit \*(L"refresh\*(R" in your browser). Then delete the
remaining copy of \*(L"TCPIP_Illustrated_Vol\-2\*(R". The green \*(L"Book deleted\*(R"
status message should return.  But notice that you can now hit the
\&\*(L"Reload\*(R" button in your browser and it just redisplays the book list
(and it correctly shows it without the \*(L"Book deleted\*(R" message on
redisplay).
.PP
\&\fB\s-1NOTE:\s0\fR Be sure to check out
Authentication where we
use an improved technique that is better suited to your real world
applications.
.SH "EXPLORING THE POWER OF DBIC"
.IX Header "EXPLORING THE POWER OF DBIC"
In this section we will explore some additional capabilities offered by
DBIx::Class.  Although these features have relatively little to do
with Catalyst per se, you will almost certainly want to take advantage
of them in your applications.
.SS "Add Datetime Columns to Our Existing Books Table"
.IX Subsection "Add Datetime Columns to Our Existing Books Table"
Let's add two columns to our existing \f(CW\*(C`books\*(C'\fR table to track when each
book was added and when each book is updated:
.PP
.Vb 10
\&    $ sqlite3 myapp.db
\&    sqlite> ALTER TABLE book ADD created TIMESTAMP;
\&    sqlite> ALTER TABLE book ADD updated TIMESTAMP;
\&    sqlite> UPDATE book SET created = DATETIME(\*(AqNOW\*(Aq), updated = DATETIME(\*(AqNOW\*(Aq);
\&    sqlite> SELECT * FROM book;
\&    1|CCSP SNRS Exam Certification Guide|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    2|TCP/IP Illustrated, Volume 1|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    3|Internetworking with TCP/IP Vol.1|4|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    4|Perl Cookbook|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    5|Designing with Web Standards|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    9|TCP/IP Illustrated, Vol 3|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    sqlite> .quit
\&    $
.Ve
.PP
Here are the commands without the surrounding sqlite3 prompt and output
in case you want to cut and paste them as a single block (but still
start sqlite3 before you paste these in):
.PP
.Vb 4
\&    ALTER TABLE book ADD created TIMESTAMP;
\&    ALTER TABLE book ADD updated TIMESTAMP;
\&    UPDATE book SET created = DATETIME(\*(AqNOW\*(Aq), updated = DATETIME(\*(AqNOW\*(Aq);
\&    SELECT * FROM book;
.Ve
.PP
This will modify the \f(CW\*(C`books\*(C'\fR table to include the two new fields and
populate those fields with the current time.
.SS "Update DBIx::Class to Automatically Handle the Datetime Columns"
.IX Subsection "Update DBIx::Class to Automatically Handle the Datetime Columns"
Next, we should re-run the \s-1DBIC\s0 helper to update the Result Classes with
the new fields:
.PP
.Vb 8
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static components=TimeStamp dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
\&     exists "/home/catalyst/dev/MyApp/script/../lib/MyApp/Model"
\&     exists "/home/catalyst/dev/MyApp/script/../t"
\&    Dumping manual schema for MyApp::Schema to directory /home/catalyst/dev/MyApp/script/../lib ...
\&    Schema dump completed.
\&     exists "/home/catalyst/dev/MyApp/script/../lib/MyApp/Model/DB.pm"
.Ve
.PP
Notice that we modified our use of the helper slightly: we told it to
include the DBIx::Class::TimeStamp in the \f(CW\*(C`load_components\*(C'\fR line of
the Result Classes.
.PP
If you open \f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR in your editor you should
see that the \f(CW\*(C`created\*(C'\fR and \f(CW\*(C`updated\*(C'\fR fields are now included in the
call to \f(CW\*(C`add_columns()\*(C'\fR. However, also notice that the \f(CW\*(C`many_to_many\*(C'\fR
relationships we manually added below the "\f(CW\*(C`# DO NOT MODIFY...\*(C'\fR" line
were automatically preserved.
.PP
While we \f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR open, let's update it with
some additional information to have \s-1DBIC\s0 automatically handle the
updating of these two fields for us.  Insert the following code at the
bottom of the file (it \fBmust\fR be \fBbelow\fR the "\f(CW\*(C`# DO NOT MODIFY...\*(C'\fR"
line and \fBabove\fR the \f(CW\*(C`1;\*(C'\fR on the last line):
.PP
.Vb 9
\&    #
\&    # Enable automatic date handling
\&    #
\&    _\|_PACKAGE_\|_\->add_columns(
\&        "created",
\&        { data_type => \*(Aqtimestamp\*(Aq, set_on_create => 1 },
\&        "updated",
\&        { data_type => \*(Aqtimestamp\*(Aq, set_on_create => 1, set_on_update => 1 },
\&    );
.Ve
.PP
This will override the definition for these fields that Schema::Loader
placed at the top of the file.  The \f(CW\*(C`set_on_create\*(C'\fR and
\&\f(CW\*(C`set_on_update\*(C'\fR options will cause DBIx::Class to automatically update
the timestamps in these columns whenever a row is created or modified.
.PP
\&\fBNote\fR that adding the lines above will cause the development server to
automatically restart if you are running it with the \*(L"\-r\*(R" option.  In
other words, the development server is smart enough to restart not only
for code under the \f(CW\*(C`MyApp/Controller/\*(C'\fR, \f(CW\*(C`MyApp/Model/\*(C'\fR, and
\&\f(CW\*(C`MyApp/View/\*(C'\fR directories, but also under other directions such as our
\&\*(L"external \s-1DBIC\s0 model\*(R" in \f(CW\*(C`MyApp/Schema/\*(C'\fR.  However, also note that it's
smart enough to \fBnot\fR restart when you edit your \f(CW\*(C`.tt2\*(C'\fR files under
\&\f(CW\*(C`root/\*(C'\fR.
.PP
Then enter the following \s-1URL\s0 into your web browser:
.PP
.Vb 1
\&    http://localhost:3000/books/url_create/TCPIP_Illustrated_Vol\-2/5/4
.Ve
.PP
You should get the same \*(L"Book Created\*(R" screen we saw earlier.  However, if
you now use the sqlite3 command-line tool to dump the \f(CW\*(C`books\*(C'\fR table,
you will see that the new book we added has an appropriate date and time
entered for it (see the last line in the listing below):
.PP
.Vb 8
\&    $ sqlite3 myapp.db "select * from book"
\&    1|CCSP SNRS Exam Certification Guide|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    2|TCP/IP Illustrated, Volume 1|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    3|Internetworking with TCP/IP Vol.1|4|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    4|Perl Cookbook|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    5|Designing with Web Standards|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    9|TCP/IP Illustrated, Vol 3|5|2010\-02\-16 04:15:45|2010\-02\-16 04:15:45
\&    10|TCPIP_Illustrated_Vol\-2|5|2010\-02\-16 04:18:42|2010\-02\-16 04:18:42
.Ve
.PP
Notice in the debug log that the \s-1SQL\s0 \s-1DBIC\s0 generated has changed to
incorporate the datetime logic:
.PP
.Vb 3
\&    INSERT INTO book ( created, rating, title, updated ) VALUES ( ?, ?, ?, ? ): 
\&    \*(Aq2010\-02\-16 04:18:42\*(Aq, \*(Aq5\*(Aq, \*(AqTCPIP_Illustrated_Vol\-2\*(Aq, \*(Aq2010\-02\-16 04:18:42\*(Aq
\&    INSERT INTO book_author ( author_id, book_id ) VALUES ( ?, ? ): \*(Aq4\*(Aq, \*(Aq10\*(Aq
.Ve
.SS "Create a ResultSet Class"
.IX Subsection "Create a ResultSet Class"
An often overlooked but extremely powerful features of \s-1DBIC\s0 is that it
allows you to supply your own subclasses of \f(CW\*(C`DBIx::Class::ResultSet\*(C'\fR.
This can be used to pull complex and unsightly \*(L"query code\*(R" out of your
controllers and encapsulate it in a method of your ResultSet Class.
These \*(L"canned queries\*(R" in your ResultSet Class can then be invoked via a
single call, resulting in much cleaner and easier to read controller
code (or View code, if that's where you want to call it).
.PP
To illustrate the concept with a fairly simple example, let's create a
method that returns books added in the last 10 minutes.  Start by making
a directory where DBIx::Class will look for our ResultSet Class:
.PP
.Vb 1
\&    $ mkdir lib/MyApp/Schema/ResultSet
.Ve
.PP
Then open \f(CW\*(C`lib/MyApp/Schema/ResultSet/Book.pm\*(C'\fR and enter the following:
.PP
.Vb 1
\&    package MyApp::Schema::ResultSet::Book;
\&    
\&    use strict;
\&    use warnings;
\&    use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&    
\&    =head2 created_after
\&    
\&    A predefined search for recently added books
\&    
\&    =cut
\&    
\&    sub created_after {
\&        my ($self, $datetime) = @_;
\&    
\&        my $date_str = $self\->result_source\->schema\->storage
\&                              \->datetime_parser\->format_datetime($datetime);
\&    
\&        return $self\->search({
\&            created => { \*(Aq>\*(Aq => $date_str }
\&        });
\&    }
\&    
\&    1;
.Ve
.PP
Then add the following method to the \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR:
.PP
.Vb 1
\&    =head2 list_recent
\&    
\&    List recently created books
\&    
\&    =cut
\&    
\&    sub list_recent :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqlist_recent\*(Aq) :Args(1) {
\&        my ($self, $c, $mins) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store in the
\&        # stash where they can be accessed by the TT template, but only
\&        # retrieve books created within the last $min number of minutes
\&        $c\->stash(books => [$c\->model(\*(AqDB::Book\*(Aq)
\&                                \->created_after(DateTime\->now\->subtract(minutes => $mins))]);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (action methods respond to user input in
\&        # your controllers).
\&        $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
Now try different values for the \*(L"minutes\*(R" argument (the final number
value) using the \s-1URL\s0 \f(CW\*(C`http://localhost:3000/books/list_recent/_#_\*(C'\fR in
your browser. For example, this would list all books added in the last
fifteen minutes:
.PP
.Vb 1
\&    http://localhost:3000/books/list_recent/15
.Ve
.PP
Depending on how recently you added books, you might want to try a
higher or lower value for the minutes.
.SS "Chaining ResultSets"
.IX Subsection "Chaining ResultSets"
One of the most helpful and powerful features in \f(CW\*(C`DBIx::Class\*(C'\fR is that
it allows you to \*(L"chain together\*(R" a series of queries (note that this
has nothing to do with the \*(L"Chained Dispatch\*(R" for Catalyst that we were
discussing earlier).  Because each ResultSet method returns another
ResultSet, you can take an initial query and immediately feed that into
a second query (and so on for as many queries you need).  Note that no
matter how many ResultSets you chain together, the database itself will
not be hit until you use a method that attempts to access the data. And,
because this technique carries over to the ResultSet Class feature we
implemented in the previous section for our \*(L"canned search\*(R", we can
combine the two capabilities.  For example, let's add an action to our
\&\f(CW\*(C`Books\*(C'\fR controller that lists books that are both recent \fIand\fR have
\&\*(L"\s-1TCP\s0\*(R" in the title.  Open up \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and add
the following method:
.PP
.Vb 1
\&    =head2 list_recent_tcp
\&    
\&    List recently created books
\&    
\&    =cut
\&    
\&    sub list_recent_tcp :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqlist_recent_tcp\*(Aq) :Args(1) {
\&        my ($self, $c, $mins) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store in the
\&        # stash where they can be accessed by the TT template, but only
\&        # retrieve books created within the last $min number of minutes
\&        # AND that have \*(AqTCP\*(Aq in the title
\&        $c\->stash(books => [
\&                $c\->model(\*(AqDB::Book\*(Aq)
\&                    \->created_after(DateTime\->now\->subtract(minutes => $mins))
\&                    \->search({title => {\*(Aqlike\*(Aq, \*(Aq%TCP%\*(Aq}})
\&            ]);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (action methods respond to user input in
\&        # your controllers).
\&        $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
To try this out, enter the following \s-1URL\s0 into your browser:
.PP
.Vb 1
\&    http://localhost:3000/books/list_recent_tcp/100
.Ve
.PP
And you should get a list of books added in the last 100 minutes that
contain the string \*(L"\s-1TCP\s0\*(R" in the title.  However, if you look at all
books within the last 100 minutes, you should get a longer list (again,
you might have to adjust the number of minutes depending on how recently
you added books to your database):
.PP
.Vb 1
\&    http://localhost:3000/books/list_recent/100
.Ve
.PP
Take a look at the \s-1DBIC_TRACE\s0 output in the development server log for
the first \s-1URL\s0 and you should see something similar to the following:
.PP
.Vb 2
\&    SELECT me.id, me.title, me.rating, me.created, me.updated FROM book me 
\&    WHERE ( ( title LIKE ? AND created > ? ) ): \*(Aq%TCP%\*(Aq, \*(Aq2010\-02\-16 02:49:32\*(Aq
.Ve
.PP
However, let's not pollute our controller code with this raw \*(L"\s-1TCP\s0\*(R" query
\&\*(-- it would be cleaner to encapsulate that code in a method on our
ResultSet Class.  To do this, open \f(CW\*(C`lib/MyApp/Schema/ResultSet/Book.pm\*(C'\fR
and add the following method:
.PP
.Vb 1
\&    =head2 title_like
\&    
\&    A predefined search for books with a \*(AqLIKE\*(Aq search in the string
\&    
\&    =cut
\&    
\&    sub title_like {
\&        my ($self, $title_str) = @_;
\&    
\&        return $self\->search({
\&            title => { \*(Aqlike\*(Aq => "%$title_str%" }
\&        });
\&    }
.Ve
.PP
We defined the search string as \f(CW$title_str\fR to make the method more
flexible.  Now update the \f(CW\*(C`list_recent_tcp\*(C'\fR method in
\&\f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR to match the following (we have
replaced the \f(CW\*(C`\->search\*(C'\fR line with the \f(CW\*(C`\->title_like\*(C'\fR line
shown here \*(-- the rest of the method should be the same):
.PP
.Vb 1
\&    =head2 list_recent_tcp
\&    
\&    List recently created books
\&    
\&    =cut
\&    
\&    sub list_recent_tcp :Chained(\*(Aqbase\*(Aq) :PathPart(\*(Aqlist_recent_tcp\*(Aq) :Args(1) {
\&        my ($self, $c, $mins) = @_;
\&    
\&        # Retrieve all of the book records as book model objects and store in the
\&        # stash where they can be accessed by the TT template, but only
\&        # retrieve books created within the last $min number of minutes
\&        # AND that have \*(AqTCP\*(Aq in the title
\&        $c\->stash(books => [
\&                $c\->model(\*(AqDB::Book\*(Aq)
\&                    \->created_after(DateTime\->now\->subtract(minutes => $mins))
\&                    \->title_like(\*(AqTCP\*(Aq)
\&            ]);
\&    
\&        # Set the TT template to use.  You will almost always want to do this
\&        # in your action methods (action methods respond to user input in
\&        # your controllers).
\&        $c\->stash(template => \*(Aqbooks/list.tt2\*(Aq);
\&    }
.Ve
.PP
Try out the \f(CW\*(C`list_recent_tcp\*(C'\fR and \f(CW\*(C`list_recent\*(C'\fR URLs as we did above.
They should work just the same, but our code is obviously cleaner and
more modular, while also being more flexible at the same time.
.SS "Adding Methods to Result Classes"
.IX Subsection "Adding Methods to Result Classes"
In the previous two sections we saw a good example of how we could use
DBIx::Class ResultSet Classes to clean up our code for an entire query
(for example, our \*(L"canned searches\*(R" that filtered the entire query).  We
can do a similar improvement when working with individual rows as well.
Whereas the ResultSet construct is used in \s-1DBIC\s0 to correspond to an
entire query, the Result Class construct is used to represent a row.
Therefore, we can add row-specific \*(L"helper methods\*(R" to our Result
Classes stored in \f(CW\*(C`lib/MyApp/Schema/Result/\*(C'\fR. For example, open
\&\f(CW\*(C`lib/MyApp/Schema/Result/Author.pm\*(C'\fR and add the following method (as
always, it must be above the closing "\f(CW\*(C`1;\*(C'\fR"):
.PP
.Vb 5
\&    #
\&    # Row\-level helper methods
\&    #
\&    sub full_name {
\&        my ($self) = @_;
\&    
\&        return $self\->first_name . \*(Aq \*(Aq . $self\->last_name;
\&    }
.Ve
.PP
This will allow us to conveniently retrieve both the first and last name
for an author in one shot.  Now open \f(CW\*(C`root/src/books/list.tt2\*(C'\fR and
change the definition of \f(CW\*(C`tt_authors\*(C'\fR from this:
.PP
.Vb 4
\&    ...
\&      [% tt_authors = [ ];
\&         tt_authors.push(author.last_name) FOREACH author = book.authors %]
\&    ...
.Ve
.PP
to:
.PP
.Vb 4
\&    ...
\&      [% tt_authors = [ ];
\&         tt_authors.push(author.full_name) FOREACH author = book.authors %]
\&    ...
.Ve
.PP
(Only \f(CW\*(C`author.last_name\*(C'\fR was changed to \f(CW\*(C`author.full_name\*(C'\fR \*(-- the rest
of the file should remain the same.)
.PP
Now go to the standard book list \s-1URL:\s0
.PP
.Vb 1
\&    http://localhost:3000/books/list
.Ve
.PP
The \*(L"Author(s)\*(R" column will now contain both the first and last name.
And, because the concatenation logic was encapsulated inside our Result
Class, it keeps the code inside our \s-1TT\s0 template nice and clean
(remember, we want the templates to be as close to pure \s-1HTML\s0 markup as
possible). Obviously, this capability becomes even more useful as you
use it to remove even more complicated row-specific logic from your
templates!
.SS "Moving Complicated View Code to the Model"
.IX Subsection "Moving Complicated View Code to the Model"
The previous section illustrated how we could use a Result Class method
to print the full names of the authors without adding any extra code to
our view, but it still left us with a fairly ugly mess (see
\&\f(CW\*(C`root/src/books/list.tt2\*(C'\fR):
.PP
.Vb 10
\&    ...
\&    <td>
\&      [% # NOTE: See Chapter 4 for a better way to do this!                      \-%]
\&      [% # First initialize a TT variable to hold a list.  Then use a TT FOREACH \-%]
\&      [% # loop in \*(Aqside effect notation\*(Aq to load just the last names of the     \-%]
\&      [% # authors into the list. Note that the \*(Aqpush\*(Aq TT vmethod does not print \-%]
\&      [% # a value, so nothing will be printed here.  But, if you have something \-%]
\&      [% # in TT that does return a method and you don\*(Aqt want it printed, you    \-%]
\&      [% # can: 1) assign it to a bogus value, or 2) use the CALL keyword to     \-%]
\&      [% # call it and discard the return value.                                 \-%]
\&      [% tt_authors = [ ];
\&         tt_authors.push(author.full_name) FOREACH author = book.authors %]
\&      [% # Now use a TT \*(Aqvirtual method\*(Aq to display the author count in parens   \-%]
\&      [% # Note the use of the TT filter "| html" to escape dangerous characters \-%]
\&      ([% tt_authors.size | html %])
\&      [% # Use another TT vmethod to join & print the names & comma separators   \-%]
\&      [% tt_authors.join(\*(Aq, \*(Aq) | html %]
\&    </td>
\&    ...
.Ve
.PP
Let's combine some of the techniques used earlier in this section to
clean this up.  First, let's add a method to our Book Result Class to
return the number of authors for a book.  Open
\&\f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR and add the following method:
.PP
.Vb 1
\&    =head2 author_count
\&    
\&    Return the number of authors for the current book
\&    
\&    =cut
\&    
\&    sub author_count {
\&        my ($self) = @_;
\&    
\&        # Use the \*(Aqmany_to_many\*(Aq relationship to fetch all of the authors for the current
\&        # and the \*(Aqcount\*(Aq method in DBIx::Class::ResultSet to get a SQL COUNT
\&        return $self\->authors\->count;
\&    }
.Ve
.PP
Next, let's add a method to return a list of authors for a book to the
same \f(CW\*(C`lib/MyApp/Schema/Result/Book.pm\*(C'\fR file:
.PP
.Vb 1
\&    =head2 author_list
\&    
\&    Return a comma\-separated list of authors for the current book
\&    
\&    =cut
\&    
\&    sub author_list {
\&        my ($self) = @_;
\&    
\&        # Loop through all authors for the current book, calling all the \*(Aqfull_name\*(Aq 
\&        # Result Class method for each
\&        my @names;
\&        foreach my $author ($self\->authors) {
\&            push(@names, $author\->full_name);
\&        }
\&    
\&        return join(\*(Aq, \*(Aq, @names);
\&    }
.Ve
.PP
This method loops through each author, using the \f(CW\*(C`full_name\*(C'\fR Result
Class method we added to \f(CW\*(C`lib/MyApp/Schema/Result/Author.pm\*(C'\fR in the
prior section.
.PP
Using these two methods, we can simplify our \s-1TT\s0 code.  Open
\&\f(CW\*(C`root/src/books/list.tt2\*(C'\fR and update the \*(L"Author(s)\*(R" table cell to
match the following:
.PP
.Vb 6
\&    ...
\&    <td>
\&      [% # Print count and author list using Result Class methods \-%]
\&      ([% book.author_count | html %]) [% book.author_list | html %]
\&    </td>
\&    ...
.Ve
.PP
Although most of the code we removed comprised comments, the overall
effect is dramatic... because our view code is so simple, we don't need
huge comments to clue people in to the gist of our code.  The view code
is now self-documenting and readable enough that you could probably get
by with no comments at all.  All of the \*(L"complex\*(R" work is being done in
our Result Class methods (and, because we have broken the code into
nice, modular chunks, the Result Class code is hardly something you
would call complex).
.PP
As we saw in this section, always strive to keep your view \s-1AND\s0
controller code as simple as possible by pulling code out into your
model objects.  Because DBIx::Class can be easily extended in so many
ways, it's an excellent to way accomplish this objective.  It will make
your code cleaner, easier to write, less error-prone, and easier to
debug and maintain.
.PP
Before you conclude this section, hit Refresh in your browser... the
output should be the same even though the backend code has been trimmed
down.
.PP
You can jump to the next chapter of the tutorial here:
Authentication
.SH "AUTHOR"
.IX Header "AUTHOR"
Kennedy Clark, \f(CW\*(C`hkclark@gmail.com\*(C'\fR
.PP
Feel free to contact the author for any errors or suggestions, but the
best way to report issues is via the \s-1CPAN\s0 \s-1RT\s0 Bug system at
https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst\-Manual <https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst-Manual>.
.PP
Copyright 2006\-2011, Kennedy Clark, under the
Creative Commons Attribution Share-Alike License Version 3.0
(http://creativecommons.org/licenses/by\-sa/3.0/us/ <http://creativecommons.org/licenses/by-sa/3.0/us/>).
