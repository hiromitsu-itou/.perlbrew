.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Base::Filter 3"
.TH Test::Base::Filter 3 "2011-04-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Base::Filter \- Default Filter Class for Test::Base
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package MyTestSuite;
\&    use Test::Base \-Base;
\&
\&    ... reusable testing code ...
\&
\&    package MyTestSuite::Filter;
\&    use Test::Base::Filter \-Base;
\&
\&    sub my_filter1 {
\&        ...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Filters are the key to writing effective data driven tests with Test::Base.
Test::Base::Filter is a class containing a large default set of generic
filters. You can easily subclass it to add/override functionality.
.SH "FILTERS"
.IX Header "FILTERS"
This is a list of the default stock filters (in alphabetic order):
.SS "append"
.IX Subsection "append"
list => list
.PP
Append a string to each element of a list.
.PP
.Vb 4
\&    \-\-\- numbers lines chomp append=\-#\en join
\&    one
\&    two
\&    three
.Ve
.SS "array"
.IX Subsection "array"
list => scalar
.PP
Turn a list of values into an anonymous array reference.
.SS "base64_decode"
.IX Subsection "base64_decode"
scalar => scalar
.PP
Decode base64 data. Useful for binary tests.
.SS "base64_encode"
.IX Subsection "base64_encode"
scalar => scalar
.PP
Encode base64 data. Useful for binary tests.
.SS "chomp"
.IX Subsection "chomp"
list => list
.PP
Remove the final newline from each string value in a list.
.SS "chop"
.IX Subsection "chop"
list => list
.PP
Remove the final char from each string value in a list.
.SS "dumper"
.IX Subsection "dumper"
scalar => list
.PP
Take a data structure (presumably from another filter like eval) and use
Data::Dumper to dump it in a canonical fashion.
.SS "escape"
.IX Subsection "escape"
scalar => scalar
.PP
Unescape all backslash escaped chars.
.SS "eval"
.IX Subsection "eval"
scalar => list
.PP
Run Perl's \f(CW\*(C`eval\*(C'\fR command against the data and use the returned value
as the data.
.SS "eval_all"
.IX Subsection "eval_all"
scalar => list
.PP
Run Perl's \f(CW\*(C`eval\*(C'\fR command against the data and return a list of 4
values:
.PP
.Vb 4
\&    1) The return value
\&    2) The error in $@
\&    3) Captured STDOUT
\&    4) Captured STDERR
.Ve
.SS "eval_stderr"
.IX Subsection "eval_stderr"
scalar => scalar
.PP
Run Perl's \f(CW\*(C`eval\*(C'\fR command against the data and return the
captured \s-1STDERR\s0.
.SS "eval_stdout"
.IX Subsection "eval_stdout"
scalar => scalar
.PP
Run Perl's \f(CW\*(C`eval\*(C'\fR command against the data and return the
captured \s-1STDOUT\s0.
.SS "exec_perl_stdout"
.IX Subsection "exec_perl_stdout"
list => scalar
.PP
Input Perl code is written to a temp file and run. \s-1STDOUT\s0 is captured and
returned.
.SS "flatten"
.IX Subsection "flatten"
scalar => list
.PP
Takes a hash or array ref and flattens it to a list.
.SS "get_url"
.IX Subsection "get_url"
scalar => scalar
.PP
The text is chomped and considered to be a url. Then LWP::Simple::get is
used to fetch the contents of the url.
.SS "hash"
.IX Subsection "hash"
list => scalar
.PP
Turn a list of key/value pairs into an anonymous hash reference.
.SS "head[=number]"
.IX Subsection "head[=number]"
list => list
.PP
Takes a list and returns a number of the elements from the front of it. The
default number is one.
.SS "join"
.IX Subsection "join"
list => scalar
.PP
Join a list of strings into a scalar.
.SS "Join"
.IX Subsection "Join"
Join the list of strings inside a list of array refs and return the
strings in place of the array refs.
.SS "lines"
.IX Subsection "lines"
scalar => list
.PP
Break the data into an anonymous array of lines. Each line (except
possibly the last one if the \f(CW\*(C`chomp\*(C'\fR filter came first) will have a
newline at the end.
.SS "norm"
.IX Subsection "norm"
scalar => scalar
.PP
Normalize the data. Change non-Unix line endings to Unix line endings.
.SS "prepend=string"
.IX Subsection "prepend=string"
list => list
.PP
Prepend a string onto each of a list of strings.
.SS "read_file"
.IX Subsection "read_file"
scalar => scalar
.PP
Read the file named by the current content and return the file's content.
.SS "regexp[=xism]"
.IX Subsection "regexp[=xism]"
scalar => scalar
.PP
The \f(CW\*(C`regexp\*(C'\fR filter will turn your data section into a regular
expression object. You can pass in extra flags after an equals sign.
.PP
If the text contains more than one line and no flags are specified, then
the 'xism' flags are assumed.
.SS "reverse"
.IX Subsection "reverse"
list => list
.PP
Reverse the elements of a list.
.SS "Reverse"
.IX Subsection "Reverse"
list => list
.PP
Reverse the list of strings inside a list of array refs.
.SS "slice=x[,y]"
.IX Subsection "slice=x[,y]"
list => list
.PP
Returns the element number x through element number y of a list.
.SS "sort"
.IX Subsection "sort"
list => list
.PP
Sorts the elements of a list in character sort order.
.SS "Sort"
.IX Subsection "Sort"
list => list
.PP
Sort the list of strings inside a list of array refs.
.SS "split[=string|pattern]"
.IX Subsection "split[=string|pattern]"
scalar => list
.PP
Split a string in into a list. Takes a optional string or regexp as a
parameter. Defaults to /\es+/. Same as Perl \f(CW\*(C`split\*(C'\fR.
.SS "Split[=string|pattern]"
.IX Subsection "Split[=string|pattern]"
list => list
.PP
Split each of a list of strings and turn them into array refs.
.SS "strict"
.IX Subsection "strict"
scalar => scalar
.PP
Prepend the string:
.PP
.Vb 2
\&    use strict; 
\&    use warnings;
.Ve
.PP
to the block's text.
.SS "tail[=number]"
.IX Subsection "tail[=number]"
list => list
.PP
Return a number of elements from the end of a list. The default
number is one.
.SS "trim"
.IX Subsection "trim"
list => list
.PP
Remove extra blank lines from the beginning and end of the data. This
allows you to visually separate your test data with blank lines.
.SS "unchomp"
.IX Subsection "unchomp"
list => list
.PP
Add a newline to each string value in a list.
.SS "write_file[=filename]"
.IX Subsection "write_file[=filename]"
scalar => scalar
.PP
Write the content of the section to the named file. Return the filename.
.SS "yaml"
.IX Subsection "yaml"
scalar => list
.PP
Apply the YAML::Load function to the data block and use the resultant
structure. Requires \s-1YAML\s0.pm.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy dA\*~Xt Net <ingy@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006, 2011. Ingy dA\*~Xt Net. All rights reserved.
Copyright (c) 2005. Brian Ingerson. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See http://www.perl.com/perl/misc/Artistic.html
