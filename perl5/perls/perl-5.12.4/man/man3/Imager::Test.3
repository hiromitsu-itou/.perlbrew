.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::Test 3"
.TH Imager::Test 3 "2011-11-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Test \- common functions used in testing Imager
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Imager::Test \*(Aqdiff_text_with_nul\*(Aq;
\&  diff_text_with_nul($test_name, $text1, $text2, @string_options);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a repository of functions used in testing Imager.
.PP
Some functions will only be useful in testing Imager itself, while
others should be useful in testing modules that use Imager.
.PP
No functions are exported by default.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Test functions"
.IX Subsection "Test functions"
.ie n .IP "is_color1($color, $grey, $comment)" 4
.el .IP "is_color1($color, \f(CW$grey\fR, \f(CW$comment\fR)" 4
.IX Item "is_color1($color, $grey, $comment)"
Tests if the first channel of \f(CW$color\fR matches \f(CW$grey\fR.
.ie n .IP "is_color3($color, $red, $green, $blue, $comment)" 4
.el .IP "is_color3($color, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$comment\fR)" 4
.IX Item "is_color3($color, $red, $green, $blue, $comment)"
Tests if \f(CW$color\fR matches the given ($red, \f(CW$green\fR, \f(CW$blue\fR)
.ie n .IP "is_color4($color, $red, $green, $blue, $alpha, $comment)" 4
.el .IP "is_color4($color, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR, \f(CW$comment\fR)" 4
.IX Item "is_color4($color, $red, $green, $blue, $alpha, $comment)"
Tests if \f(CW$color\fR matches the given ($red, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)
.ie n .IP "is_fcolor1($fcolor, $grey, $comment)" 4
.el .IP "is_fcolor1($fcolor, \f(CW$grey\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor1($fcolor, $grey, $comment)"
.PD 0
.ie n .IP "is_fcolor1($fcolor, $grey, $epsilon, $comment)" 4
.el .IP "is_fcolor1($fcolor, \f(CW$grey\fR, \f(CW$epsilon\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor1($fcolor, $grey, $epsilon, $comment)"
.PD
Tests if \f(CW$fcolor\fR's first channel is within \f(CW$epsilon\fR of ($grey).  For
the first form \f(CW$epsilon\fR is taken as 0.001.
.ie n .IP "is_fcolor3($fcolor, $red, $green, $blue, $comment)" 4
.el .IP "is_fcolor3($fcolor, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor3($fcolor, $red, $green, $blue, $comment)"
.PD 0
.ie n .IP "is_fcolor3($fcolor, $red, $green, $blue, $epsilon, $comment)" 4
.el .IP "is_fcolor3($fcolor, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$epsilon\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor3($fcolor, $red, $green, $blue, $epsilon, $comment)"
.PD
Tests if \f(CW$fcolor\fR's channels are within \f(CW$epsilon\fR of ($red, \f(CW$green\fR,
\&\f(CW$blue\fR).  For the first form \f(CW$epsilon\fR is taken as 0.001.
.ie n .IP "is_fcolor4($fcolor, $red, $green, $blue, $alpha, $comment)" 4
.el .IP "is_fcolor4($fcolor, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor4($fcolor, $red, $green, $blue, $alpha, $comment)"
.PD 0
.ie n .IP "is_fcolor4($fcolor, $red, $green, $blue, $alpha, $epsilon, $comment)" 4
.el .IP "is_fcolor4($fcolor, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR, \f(CW$epsilon\fR, \f(CW$comment\fR)" 4
.IX Item "is_fcolor4($fcolor, $red, $green, $blue, $alpha, $epsilon, $comment)"
.PD
Tests if \f(CW$fcolor\fR's channels are within \f(CW$epsilon\fR of ($red, \f(CW$green\fR,
\&\f(CW$blue\fR, \f(CW$alpha\fR).  For the first form \f(CW$epsilon\fR is taken as 0.001.
.ie n .IP "is_image($im1, $im2, $comment)" 4
.el .IP "is_image($im1, \f(CW$im2\fR, \f(CW$comment\fR)" 4
.IX Item "is_image($im1, $im2, $comment)"
Tests if the 2 images have the same content.  Both images must be
defined, have the same width, height, channels and the same color in
each pixel.  The color comparison is done at 8\-bits per pixel.  The
color representation such as direct vs paletted, bits per sample are
not checked.  Equivalent to is_image_similar($im1, \f(CW$im2\fR, 0, \f(CW$comment\fR).
.ie n .IP "is_imaged($im, $im2, $comment)" 4
.el .IP "is_imaged($im, \f(CW$im2\fR, \f(CW$comment\fR)" 4
.IX Item "is_imaged($im, $im2, $comment)"
.PD 0
.ie n .IP "is_imaged($im, $im2, $epsilon, $comment)" 4
.el .IP "is_imaged($im, \f(CW$im2\fR, \f(CW$epsilon\fR, \f(CW$comment\fR)" 4
.IX Item "is_imaged($im, $im2, $epsilon, $comment)"
.PD
Tests if the two images have the same content at the double/sample
level.  \f(CW$epsilon\fR defaults to the platform \s-1DBL_EPSILON\s0 multiplied by
four.
.ie n .IP "is_image_similar($im1, $im2, $maxdiff, $comment)" 4
.el .IP "is_image_similar($im1, \f(CW$im2\fR, \f(CW$maxdiff\fR, \f(CW$comment\fR)" 4
.IX Item "is_image_similar($im1, $im2, $maxdiff, $comment)"
Tests if the 2 images have similar content.  Both images must be
defined, have the same width, height and channels.  The cum of the
squares of the differences of each sample are calculated and must be
less than or equal to \fI\f(CI$maxdiff\fI\fR for the test to pass.  The color
comparison is done at 8\-bits per pixel.  The color representation such
as direct vs paletted, bits per sample are not checked.
.ie n .IP "isnt_image($im1, $im2, $comment)" 4
.el .IP "isnt_image($im1, \f(CW$im2\fR, \f(CW$comment\fR)" 4
.IX Item "isnt_image($im1, $im2, $comment)"
Tests that the two images are different.  For regressions tests where
something (like text output of \*(L"0\*(R") produced no change, but should
have produced a change.
.ie n .IP "test_colorf_gpix($im, $x, $y, $expected, $epsilon, $comment)" 4
.el .IP "test_colorf_gpix($im, \f(CW$x\fR, \f(CW$y\fR, \f(CW$expected\fR, \f(CW$epsilon\fR, \f(CW$comment\fR)" 4
.IX Item "test_colorf_gpix($im, $x, $y, $expected, $epsilon, $comment)"
Retrieves the pixel ($x,$y) from the low-level image \f(CW$im\fR and compares
it to the floating point color \f(CW$expected\fR, with a tolerance of epsilon.
.ie n .IP "test_color_gpix($im, $x, $y, $expected, $comment)" 4
.el .IP "test_color_gpix($im, \f(CW$x\fR, \f(CW$y\fR, \f(CW$expected\fR, \f(CW$comment\fR)" 4
.IX Item "test_color_gpix($im, $x, $y, $expected, $comment)"
Retrieves the pixel ($x,$y) from the low-level image \f(CW$im\fR and compares
it to the floating point color \f(CW$expected\fR.
.ie n .IP "test_colorf_glin($im, $x, $y, $pels, $comment)" 4
.el .IP "test_colorf_glin($im, \f(CW$x\fR, \f(CW$y\fR, \f(CW$pels\fR, \f(CW$comment\fR)" 4
.IX Item "test_colorf_glin($im, $x, $y, $pels, $comment)"
Retrieves the floating point pixels ($x, \f(CW$y\fR)\-[$x+@$pels, \f(CW$y\fR] from the
low level image \f(CW$im\fR and compares them against @$pels.
.ie n .IP "is_color_close3($color, $red, $green, $blue, $tolerance, $comment)" 4
.el .IP "is_color_close3($color, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$tolerance\fR, \f(CW$comment\fR)" 4
.IX Item "is_color_close3($color, $red, $green, $blue, $tolerance, $comment)"
Tests if \f(CW$color\fR's first three channels are within \f(CW$tolerance\fR of ($red,
\&\f(CW$green\fR, \f(CW$blue\fR).
.SS "Test suite functions"
.IX Subsection "Test suite functions"
Functions that perform one or more tests, typically used to test
various parts of Imager's implementation.
.IP "image_bounds_checks($im)" 4
.IX Item "image_bounds_checks($im)"
Attempts to write to various pixel positions outside the edge of the
image to ensure that it fails in those locations.
.Sp
Any new image type should pass these tests.  Does 16 separate tests.
.ie n .IP "mask_tests($im, $epsilon)" 4
.el .IP "mask_tests($im, \f(CW$epsilon\fR)" 4
.IX Item "mask_tests($im, $epsilon)"
Perform a standard set of mask tests on the \s-1OO\s0 image \f(CW$im\fR.  Does 24
separate tests.
.ie n .IP "diff_text_with_nul($test_name, $text1, $text2, @options)" 4
.el .IP "diff_text_with_nul($test_name, \f(CW$text1\fR, \f(CW$text2\fR, \f(CW@options\fR)" 4
.IX Item "diff_text_with_nul($test_name, $text1, $text2, @options)"
Creates 2 test images and writes \f(CW$text1\fR to the first image and \f(CW$text2\fR
to the second image with the \fIstring()\fR method.  Each call adds 3
\&\f(CW\*(C`ok\*(C'\fR/\f(CW\*(C`not ok\*(C'\fR to the output of the test script.
.Sp
Extra options that should be supplied include the font and either a
color or channel parameter.
.Sp
This was explicitly created for regression tests on #21770.
.SS "Helper functions"
.IX Subsection "Helper functions"
.IP "\fItest_image_raw()\fR" 4
.IX Item "test_image_raw()"
Returns a 150x150x3 Imager::ImgRaw test image.
.IP "\fItest_image()\fR" 4
.IX Item "test_image()"
Returns a 150x150x3 8\-bit/sample \s-1OO\s0 test image. Name: \f(CW\*(C`basic\*(C'\fR.
.IP "\fItest_image_16()\fR" 4
.IX Item "test_image_16()"
Returns a 150x150x3 16\-bit/sample \s-1OO\s0 test image. Name: \f(CW\*(C`basic16\*(C'\fR
.IP "\fItest_image_double()\fR" 4
.IX Item "test_image_double()"
Returns a 150x150x3 double/sample \s-1OO\s0 test image. Name: \f(CW\*(C`basic_double\*(C'\fR.
.IP "\fItest_image_gray()\fR" 4
.IX Item "test_image_gray()"
Returns a 150x150 single channel \s-1OO\s0 test image. Name: \f(CW\*(C`gray\*(C'\fR.
.IP "\fItest_image_gray_16()\fR" 4
.IX Item "test_image_gray_16()"
Returns a 150x150 16\-bit/sample single channel \s-1OO\s0 test image. Name:
\&\f(CW\*(C`gray16\*(C'\fR.
.IP "\fItest_image_mono()\fR" 4
.IX Item "test_image_mono()"
Returns a 150x150 bilevel image that passes the \fIis_bilevel()\fR test.
Name: \f(CW\*(C`mono\*(C'\fR.
.IP "test_image_named($name)" 4
.IX Item "test_image_named($name)"
Return one of the other test images above based on name.
.ie n .IP "color_cmp($c1, $c2)" 4
.el .IP "color_cmp($c1, \f(CW$c2\fR)" 4
.IX Item "color_cmp($c1, $c2)"
Performs an ordering of 3\-channel colors (like <=>).
.ie n .IP "colorf_cmp($c1, $c2)" 4
.el .IP "colorf_cmp($c1, \f(CW$c2\fR)" 4
.IX Item "colorf_cmp($c1, $c2)"
Performs an ordering of 3\-channel floating point colors (like <=>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tony@develop\-help.com>
