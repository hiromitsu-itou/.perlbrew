.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tree::Simple::Visitor 3"
.TH Tree::Simple::Visitor 3 "2012-02-01" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree::Simple::Visitor \- Visitor object for Tree::Simple objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Tree::Simple;
\&  use Tree::Simple::Visitor;
\&  
\&  # create a visitor instance
\&  my $visitor = Tree::Simple::Visitor\->new();                                                    
\&  
\&  # create a tree to visit
\&  my $tree = Tree::Simple\->new(Tree::Simple\->ROOT)
\&                         \->addChildren(
\&                             Tree::Simple\->new("1.0"),
\&                             Tree::Simple\->new("2.0")
\&                                         \->addChild(
\&                                             Tree::Simple\->new("2.1.0")
\&                                             ),
\&                             Tree::Simple\->new("3.0")
\&                             );
\&
\&  # by default this will collect all the 
\&  # node values in depth\-first order into 
\&  # our results 
\&  $tree\->accept($visitor);        
\&  
\&  # get our results and print them
\&  print join ", ", $visitor\->getResults();  # prints "1.0, 2.0, 2.1.0, 3.0" 
\&  
\&  # for more complex node objects, you can specify 
\&  # a node filter which will be used to extract the
\&  # information desired from each node
\&  $visitor\->setNodeFilter(sub { 
\&                my ($t) = @_;
\&                return $t\->getNodeValue()\->description();
\&                });  
\&                  
\&  # NOTE: this object has changed, but it still remains
\&  # backwards compatible to the older version, see the
\&  # DESCRIPTION section below for more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object has been revised into what I think is more intelligent approach to Visitor objects. This is now a more suitable base class for building your own Visitors. It is also the base class for the visitors found in the \fBTree::Simple::VisitorFactory\fR distribution, which includes a number of useful pre-built Visitors.
.PP
While I have changed a number of things about this module, I have kept it backwards compatible to the old way of using it. So the original example code still works:
.PP
.Vb 6
\&  my @accumulator;
\&  my $visitor = Tree::Simple::Visitor\->new(sub {
\&                        my ($tree) = @_;  
\&                        push @accumlator, $tree\->getNodeValue();
\&                        }, 
\&                        Tree::Simple::Visitor\->RECURSIVE);
\&                                                         
\&  $tree\->accept($visitor);                                                                                                                                                              
\&  
\&  print join ", ", @accumulator;  # prints "1.0, 2.0, 2.1.0, 3.0"
.Ve
.PP
But is better expressed as this:
.PP
.Vb 3
\&  my $visitor = Tree::Simple::Visitor\->new();                                                    
\&  $tree\->accept($visitor);        
\&  print join ", ", $visitor\->getResults();  # prints "1.0, 2.0, 2.1.0, 3.0"
.Ve
.PP
This object is still pretty much a wrapper around the Tree::Simple \f(CW\*(C`traverse\*(C'\fR method, and can be thought of as a depth-first traversal Visitor object.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "\fBnew ($func, \fB$depth\fB)\fR" 4
.el .IP "\fBnew ($func, \f(CB$depth\fB)\fR" 4
.IX Item "new ($func, $depth)"
The new style interface means that all arguments to the constructor are now optional. As a means of defining the usage of the old and new, when no arguments are sent to the constructor, it is assumed that the new style interface is being used. In the new style, the \f(CW$depth\fR is always assumed to be equivalent to \f(CW\*(C`RECURSIVE\*(C'\fR and the \f(CW$func\fR argument can be set with \f(CW\*(C`setNodeFilter\*(C'\fR instead. This is the recommended way of doing things now. If you have been using the old way, it is still there, and I will maintain backwards compatability for a few more version before removing it entirely. If you are using this module (and I don't even know if anyone actually is) you have been warned. Please contact me if this will be a problem.
.Sp
The old style constructor documentation is retained her for reference:
.Sp
The first argument to the constructor is a code reference to a function which expects a \fBTree::Simple\fR object as its only argument. The second argument is optional, it can be used to set the depth to which the function is applied. If no depth is set, the function is applied to the current \fBTree::Simple\fR instance. If \f(CW$depth\fR is set to \f(CW\*(C`CHILDREN_ONLY\*(C'\fR, then the function will be applied to the current \fBTree::Simple\fR instance and all its immediate children. If \f(CW$depth\fR is set to \f(CW\*(C`RECURSIVE\*(C'\fR, then the function will be applied to the current \fBTree::Simple\fR instance and all its immediate children, and all of their children recursively on down the tree. If no \f(CW$depth\fR is passed to the constructor, then the function will only be applied to the current \fBTree::Simple\fR object and none of its children.
.IP "\fBincludeTrunk ($boolean)\fR" 4
.IX Item "includeTrunk ($boolean)"
Based upon the value of \f(CW$boolean\fR, this will tell the visitor to collect the trunk of the tree as well. It is defaulted to false (\f(CW0\fR) in the new style interface, but is defaulted to true (\f(CW1\fR) in the old style interface.
.IP "\fBgetNodeFilter\fR" 4
.IX Item "getNodeFilter"
This method returns the \s-1CODE\s0 reference set with \f(CW\*(C`setNodeFilter\*(C'\fR argument.
.IP "\fBclearNodeFilter\fR" 4
.IX Item "clearNodeFilter"
This method clears node filter field.
.IP "\fBsetNodeFilter ($filter_function)\fR" 4
.IX Item "setNodeFilter ($filter_function)"
This method accepts a \s-1CODE\s0 reference as its \f(CW$filter_function\fR argument. This code reference is used to filter the tree nodes as they are collected. This can be used to customize output, or to gather specific information from a more complex tree node. The filter function should accept a single argument, which is the current Tree::Simple object.
.IP "\fBgetResults\fR" 4
.IX Item "getResults"
This method returns the accumulated results of the application of the node filter to the tree.
.IP "\fBsetResults\fR" 4
.IX Item "setResults"
This method should not really be used outside of this class, as it just would not make any sense to. It is included in this class and in this documenation to facilitate subclassing of this class for your own needs. If you desire to clear the results, then you can simply call \f(CW\*(C`setResults\*(C'\fR with no argument.
.IP "\fBvisit ($tree)\fR" 4
.IX Item "visit ($tree)"
The \f(CW\*(C`visit\*(C'\fR method accepts a \fBTree::Simple\fR and applies the function set in \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`setNodeFilter\*(C'\fR appropriately. The results of this application can be retrieved with \f(CW\*(C`getResults\*(C'\fR
.SH "CONSTANTS"
.IX Header "CONSTANTS"
These constants are part of the old-style interface, and therefore will eventually be deprecated.
.IP "\fB\s-1RECURSIVE\s0\fR" 4
.IX Item "RECURSIVE"
If passed this constant in the constructor, the function will be applied recursively down the hierarchy of \fBTree::Simple\fR objects.
.IP "\fB\s-1CHILDREN_ONLY\s0\fR" 4
.IX Item "CHILDREN_ONLY"
If passed this constant in the constructor, the function will be applied to the immediate children of the \fBTree::Simple\fR object.
.SH "BUGS"
.IX Header "BUGS"
None that I am aware of. The code is pretty thoroughly tested (see \fB\s-1CODE\s0 \s-1COVERAGE\s0\fR section in \fBTree::Simple\fR) and is based on an (non-publicly released) module which I had used in production systems for about 2 years without incident. Of course, if you find a bug, let me know, and I will be sure to fix it.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I have written a set of pre-built Visitor objects, available on \s-1CPAN\s0 as \fBTree::Simple::VisitorFactory\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
stevan little, <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004\-2006 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
