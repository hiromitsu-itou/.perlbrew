.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::View::TT 3"
.TH Catalyst::View::TT 3 "2011-07-17" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::View::TT \- Template View Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
# use the helper to create your View
.PP
.Vb 1
\&    myapp_create.pl view Web TT
.Ve
.PP
# add custom configration in View/Web.pm
.PP
.Vb 10
\&    _\|_PACKAGE_\|_\->config(
\&        # any TT configuration items go here
\&        INCLUDE_PATH => [
\&          MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqsrc\*(Aq ),
\&          MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqlib\*(Aq ),
\&        ],
\&        TEMPLATE_EXTENSION => \*(Aq.tt\*(Aq,
\&        CATALYST_VAR => \*(Aqc\*(Aq,
\&        TIMER        => 0,
\&        # Not set by default
\&        PRE_PROCESS        => \*(Aqconfig/main\*(Aq,
\&        WRAPPER            => \*(Aqsite/wrapper\*(Aq,
\&        render_die => 1, # Default for new apps, see render method docs
\&        expose_methods => [qw/method_in_view_class/],
\&    );
.Ve
.PP
# render view from lib/MyApp.pm or lib/MyApp::Controller::SomeController.pm
.PP
.Vb 6
\&    sub message : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{template} = \*(Aqmessage.tt2\*(Aq;
\&        $c\->stash\->{message}  = \*(AqHello World!\*(Aq;
\&        $c\->forward( $c\->view(\*(AqWeb\*(Aq) );
\&    }
.Ve
.PP
# access variables from template
.PP
.Vb 1
\&    The message is: [% message %].
\&
\&    # example when CATALYST_VAR is set to \*(AqCatalyst\*(Aq
\&    Context is [% Catalyst %]
\&    The base is [% Catalyst.req.base %]
\&    The name is [% Catalyst.config.name %]
\&
\&    # example when CATALYST_VAR isn\*(Aqt set
\&    Context is [% c %]
\&    The base is [% base %]
\&    The name is [% name %]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Catalyst view class for the Template Toolkit.
Your application should defined a view class which is a subclass of
this module. Throughout this manual it will be assumed that your application
is named \fIMyApp\fR and you are creating a \s-1TT\s0 view named \fIWeb\fR; these names
are placeholders and should always be replaced with whatever name you've
chosen for your application and your view. The easiest way to create a \s-1TT\s0
view class is through the \fImyapp_create.pl\fR script that is created along
with the application:
.PP
.Vb 1
\&    $ script/myapp_create.pl view Web TT
.Ve
.PP
This creates a \fIMyApp::View::Web.pm\fR module in the \fIlib\fR directory (again,
replacing \f(CW\*(C`MyApp\*(C'\fR with the name of your application) which looks
something like this:
.PP
.Vb 1
\&    package FooBar::View::Web;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base \*(AqCatalyst::View::TT\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config(DEBUG => \*(Aqall\*(Aq);
.Ve
.PP
Now you can modify your action handlers in the main application and/or
controllers to forward to your view class.  You might choose to do this
in the \fIend()\fR method, for example, to automatically forward all actions
to the \s-1TT\s0 view class.
.PP
.Vb 1
\&    # In MyApp or MyApp::Controller::SomeController
\&
\&    sub end : Private {
\&        my( $self, $c ) = @_;
\&        $c\->forward( $c\->view(\*(AqWeb\*(Aq) );
\&    }
.Ve
.PP
But if you are using the standard auto-generated end action, you don't even need
to do this!
.PP
.Vb 2
\&    # in MyApp::Controller::Root
\&    sub end : ActionClass(\*(AqRenderView\*(Aq) {} # no need to change this line
\&
\&    # in MyApp.pm
\&    _\|_PACKAGE_\|_\->config(
\&        ...
\&        default_view => \*(AqWeb\*(Aq,
\&    );
.Ve
.PP
This will Just Work.  And it has the advantages that:
.IP "\(bu" 4
If you want to use a different view for a given request, just set 
<< \f(CW$c\fR\->stash\->{current_view} >>.  (See Catalyst's \f(CW\*(C`$c\->view\*(C'\fR method
for details.
.IP "\(bu" 4
<< \f(CW$c\fR\->res\->redirect >> is handled by default.  If you just forward to 
\&\f(CW\*(C`View::Web\*(C'\fR in your \f(CW\*(C`end\*(C'\fR routine, you could break this by sending additional
content.
.PP
See Catalyst::Action::RenderView for more details.
.SS "\s-1CONFIGURATION\s0"
.IX Subsection "CONFIGURATION"
There are a three different ways to configure your view class.  The
first way is to call the \f(CW\*(C`config()\*(C'\fR method in the view subclass.  This
happens when the module is first loaded.
.PP
.Vb 1
\&    package MyApp::View::Web;
\&
\&    use strict;
\&    use base \*(AqCatalyst::View::TT\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config({
\&        INCLUDE_PATH => [
\&            MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqtemplates\*(Aq, \*(Aqlib\*(Aq ),
\&            MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqtemplates\*(Aq, \*(Aqsrc\*(Aq ),
\&        ],
\&        PRE_PROCESS  => \*(Aqconfig/main\*(Aq,
\&        WRAPPER      => \*(Aqsite/wrapper\*(Aq,
\&    });
.Ve
.PP
You may also override the configuration provided in the view class by adding
a 'View::Web' section to your application config (either in the application
main class, or in your configuration file). This should be reserved for
deployment-specific concerns. For example:
.PP
.Vb 1
\&    # MyApp_local.conf (Config::General format)
\&
\&    <View Web>
\&      WRAPPER "custom_wrapper"
\&      INCLUDE_PATH _\|_path_to(\*(Aqroot/templates/custom_site\*(Aq)_\|_
\&      INCLUDE_PATH _\|_path_to(\*(Aqroot/templates\*(Aq)_\|_
\&    </View>
.Ve
.PP
might be used as part of a simple way to deploy different instances of the
same application with different themes.
.SS "\s-1DYNAMIC\s0 \s-1INCLUDE_PATH\s0"
.IX Subsection "DYNAMIC INCLUDE_PATH"
Sometimes it is desirable to modify \s-1INCLUDE_PATH\s0 for your templates at run time.
.PP
Additional paths can be added to the start of \s-1INCLUDE_PATH\s0 via the stash as
follows:
.PP
.Vb 2
\&    $c\->stash\->{additional_template_paths} =
\&        [$c\->config\->{root} . \*(Aq/test_include_path\*(Aq];
.Ve
.PP
If you need to add paths to the end of \s-1INCLUDE_PATH\s0, there is also an
\&\fIinclude_path()\fR accessor available:
.PP
.Vb 1
\&    push( @{ $c\->view(\*(AqWeb\*(Aq)\->include_path }, qw/path/ );
.Ve
.PP
Note that if you use \fIinclude_path()\fR to add extra paths to \s-1INCLUDE_PATH\s0, you
\&\s-1MUST\s0 check for duplicate paths. Without such checking, the above code will add
\&\*(L"path\*(R" to \s-1INCLUDE_PATH\s0 at every request, causing a memory leak.
.PP
A safer approach is to use \fIinclude_path()\fR to overwrite the array of paths
rather than adding to it. This eliminates both the need to perform duplicate
checking and the chance of a memory leak:
.PP
.Vb 1
\&    @{ $c\->view(\*(AqWeb\*(Aq)\->include_path } = qw/path another_path/;
.Ve
.PP
If you are calling \f(CW\*(C`render\*(C'\fR directly then you can specify dynamic paths by
having a \f(CW\*(C`additional_template_paths\*(C'\fR key with a value of additonal directories
to search. See \*(L"\s-1CAPTURING\s0 \s-1TEMPLATE\s0 \s-1OUTPUT\s0\*(R" for an example showing this.
.SS "\s-1RENDERING\s0 \s-1VIEWS\s0"
.IX Subsection "RENDERING VIEWS"
The view plugin renders the template specified in the \f(CW\*(C`template\*(C'\fR
item in the stash.
.PP
.Vb 5
\&    sub message : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{template} = \*(Aqmessage.tt2\*(Aq;
\&        $c\->forward( $c\->view(\*(AqWeb\*(Aq) );
\&    }
.Ve
.PP
If a stash item isn't defined, then it instead uses the
stringification of the action dispatched to (as defined by \f(CW$c\fR\->action)
in the above example, this would be \f(CW\*(C`message\*(C'\fR, but because the default
is to append '.tt', it would load \f(CW\*(C`root/message.tt\*(C'\fR.
.PP
The items defined in the stash are passed to the Template Toolkit for
use as template variables.
.PP
.Vb 6
\&    sub default : Private {
\&        my ( $self, $c ) = @_;
\&        $c\->stash\->{template} = \*(Aqmessage.tt2\*(Aq;
\&        $c\->stash\->{message}  = \*(AqHello World!\*(Aq;
\&        $c\->forward( $c\->view(\*(AqWeb\*(Aq) );
\&    }
.Ve
.PP
A number of other template variables are also added:
.PP
.Vb 3
\&    c      A reference to the context object, $c
\&    base   The URL base, from $c\->req\->base()
\&    name   The application name, from $c\->config\->{ name }
.Ve
.PP
These can be accessed from the template in the usual way:
.PP
<message.tt2>:
.PP
.Vb 3
\&    The message is: [% message %]
\&    The base is [% base %]
\&    The name is [% name %]
.Ve
.PP
The output generated by the template is stored in \f(CW\*(C`$c\->response\->body\*(C'\fR.
.SS "\s-1CAPTURING\s0 \s-1TEMPLATE\s0 \s-1OUTPUT\s0"
.IX Subsection "CAPTURING TEMPLATE OUTPUT"
If you wish to use the output of a template for some other purpose than
displaying in the response, e.g. for sending an email, this is possible using
Catalyst::Plugin::Email and the render method:
.PP
.Vb 2
\&  sub send_email : Local {
\&    my ($self, $c) = @_;
\&
\&    $c\->email(
\&      header => [
\&        To      => \*(Aqme@localhost\*(Aq,
\&        Subject => \*(AqA TT Email\*(Aq,
\&      ],
\&      body => $c\->view(\*(AqWeb\*(Aq)\->render($c, \*(Aqemail.tt\*(Aq, {
\&        additional_template_paths => [ $c\->config\->{root} . \*(Aq/email_templates\*(Aq],
\&        email_tmpl_param1 => \*(Aqfoo\*(Aq
\&        }
\&      ),
\&    );
\&  # Redirect or display a message
\&  }
.Ve
.SS "\s-1TEMPLATE\s0 \s-1PROFILING\s0"
.IX Subsection "TEMPLATE PROFILING"
See \f(CW\*(C`TIMER\*(C'\fR property of the config method.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.SS "new"
.IX Subsection "new"
The constructor for the \s-1TT\s0 view. Sets up the template provider,
and reads the application config.
.SS "process($c)"
.IX Subsection "process($c)"
Renders the template specified in \f(CW\*(C`$c\->stash\->{template}\*(C'\fR or
\&\f(CW\*(C`$c\->action\*(C'\fR (the private name of the matched action).  Calls render to
perform actual rendering. Output is stored in \f(CW\*(C`$c\->response\->body\*(C'\fR.
.PP
It is possible to forward to the process method of a \s-1TT\s0 view from inside
Catalyst like this:
.PP
.Vb 1
\&    $c\->forward(\*(AqView::Web\*(Aq);
.Ve
.PP
N.B. This is usually done automatically by Catalyst::Action::RenderView.
.ie n .SS "render($c, $template, \e%args)"
.el .SS "render($c, \f(CW$template\fP, \e%args)"
.IX Subsection "render($c, $template, %args)"
Renders the given template and returns output. Throws a Template::Exception
object upon error.
.PP
The template variables are set to \f(CW%$args\fR if \f(CW$args\fR is a hashref, or
\&\f(CW\*(C`$c\->stash\*(C'\fR otherwise. In either case the variables are augmented with
\&\f(CW\*(C`base\*(C'\fR set to \f(CW\*(C`$c\->req\->base\*(C'\fR, \f(CW\*(C`c\*(C'\fR to \f(CW$c\fR, and \f(CW\*(C`name\*(C'\fR to
\&\f(CW\*(C`$c\->config\->{name}\*(C'\fR. Alternately, the \f(CW\*(C`CATALYST_VAR\*(C'\fR configuration item
can be defined to specify the name of a template variable through which the
context reference (\f(CW$c\fR) can be accessed. In this case, the \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`base\*(C'\fR, and
\&\f(CW\*(C`name\*(C'\fR variables are omitted.
.PP
\&\f(CW$template\fR can be anything that Template::process understands how to
process, including the name of a template file or a reference to a test string.
See Template::process for a full list of supported formats.
.PP
To use the render method outside of your Catalyst app, just pass a undef context.
This can be useful for tests, for instance.
.PP
It is possible to forward to the render method of a \s-1TT\s0 view from inside Catalyst
to render page fragments like this:
.PP
.Vb 1
\&    my $fragment = $c\->forward("View::Web", "render", $template_name, $c\->stash\->{fragment_data});
.Ve
.PP
\fIBackwards compatibility note\fR
.IX Subsection "Backwards compatibility note"
.PP
The render method used to just return the Template::Exception object, rather
than just throwing it. This is now deprecated and instead the render method
will throw an exception for new applications.
.PP
This behaviour can be activated (and is activated in the default skeleton
configuration) by using \f(CW\*(C`render_die => 1\*(C'\fR. If you rely on the legacy
behaviour then a warning will be issued.
.PP
To silence this warning, set \f(CW\*(C`render_die => 0\*(C'\fR, but it is recommended
you adjust your code so that it works with \f(CW\*(C`render_die => 1\*(C'\fR.
.PP
In a future release, \f(CW\*(C`render_die => 1\*(C'\fR will become the default if
unspecified.
.SS "template_vars"
.IX Subsection "template_vars"
Returns a list of keys/values to be used as the catalyst variables in the
template.
.SS "config"
.IX Subsection "config"
This method allows your view subclass to pass additional settings to
the \s-1TT\s0 configuration hash, or to set the options as below:
.SS "paths"
.IX Subsection "paths"
The list of paths \s-1TT\s0 will look for templates in.
.SS "expose_methods"
.IX Subsection "expose_methods"
The list of methods in your View class which should be made available to the templates.
.PP
For example:
.PP
.Vb 1
\&  expose_methods => [qw/uri_for_css/],
\&
\&  ...
\&
\&  sub uri_for_css {
\&    my ($self, $c, $filename) = @_;
\&
\&    # additional complexity like checking file exists here
\&
\&    return $c\->uri_for(\*(Aq/static/css/\*(Aq . $filename);
\&  }
.Ve
.PP
Then in the template:
.PP
.Vb 1
\&  [% uri_for_css(\*(Aqhome.css\*(Aq) %]
.Ve
.ie n .SS """CATALYST_VAR"""
.el .SS "\f(CWCATALYST_VAR\fP"
.IX Subsection "CATALYST_VAR"
Allows you to change the name of the Catalyst context object. If set, it will also
remove the base and name aliases, so you will have access them through <context>.
.PP
For example, if \s-1CATALYST_VAR\s0 has been set to \*(L"Catalyst\*(R", a template might
contain:
.PP
.Vb 2
\&    The base is [% Catalyst.req.base %]
\&    The name is [% Catalyst.config.name %]
.Ve
.ie n .SS """TIMER"""
.el .SS "\f(CWTIMER\fP"
.IX Subsection "TIMER"
If you have configured Catalyst for debug output, and turned on the \s-1TIMER\s0 setting,
\&\f(CW\*(C`Catalyst::View::TT\*(C'\fR will enable profiling of template processing
(using Template::Timer). This will embed \s-1HTML\s0 comments in the
output from your templates, such as:
.PP
.Vb 5
\&    <!\-\- TIMER START: process mainmenu/mainmenu.ttml \-\->
\&    <!\-\- TIMER START: include mainmenu/cssindex.tt \-\->
\&    <!\-\- TIMER START: process mainmenu/cssindex.tt \-\->
\&    <!\-\- TIMER END: process mainmenu/cssindex.tt (0.017279 seconds) \-\->
\&    <!\-\- TIMER END: include mainmenu/cssindex.tt (0.017401 seconds) \-\->
\&
\&    ....
\&
\&    <!\-\- TIMER END: process mainmenu/footer.tt (0.003016 seconds) \-\->
.Ve
.ie n .SS """TEMPLATE_EXTENSION"""
.el .SS "\f(CWTEMPLATE_EXTENSION\fP"
.IX Subsection "TEMPLATE_EXTENSION"
a sufix to add when looking for templates bases on the \f(CW\*(C`match\*(C'\fR method in Catalyst::Request.
.PP
For example:
.PP
.Vb 2
\&  package MyApp::Controller::Test;
\&  sub test : Local { .. }
.Ve
.PP
Would by default look for a template in <root>/test/test. If you set \s-1TEMPLATE_EXTENSION\s0 to '.tt', it will look for
<root>/test/test.tt.
.ie n .SS """PROVIDERS"""
.el .SS "\f(CWPROVIDERS\fP"
.IX Subsection "PROVIDERS"
Allows you to specify the template providers that \s-1TT\s0 will use.
.PP
.Vb 10
\&    MyApp\->config({
\&        name     => \*(AqMyApp\*(Aq,
\&        root     => MyApp\->path_to(\*(Aqroot\*(Aq),
\&        \*(AqView::Web\*(Aq => {
\&            PROVIDERS => [
\&                {
\&                    name    => \*(AqDBI\*(Aq,
\&                    args    => {
\&                        DBI_DSN => \*(Aqdbi:DB2:books\*(Aq,
\&                        DBI_USER=> \*(Aqfoo\*(Aq
\&                    }
\&                }, {
\&                    name    => \*(Aq_file_\*(Aq,
\&                    args    => {}
\&                }
\&            ]
\&        },
\&    });
.Ve
.PP
The 'name' key should correspond to the class name of the provider you
want to use.  The _file_ name is a special case that represents the default
\&\s-1TT\s0 file-based provider.  By default the name is will be prefixed with
\&'Template::Provider::'.  You can fully qualify the name by using a unary
plus:
.PP
.Vb 1
\&    name => \*(Aq+MyApp::Provider::Foo\*(Aq
.Ve
.PP
You can also specify the 'copy_config' key as an arrayref, to copy those keys
from the general config, into the config for the provider:
.PP
.Vb 7
\&    DEFAULT_ENCODING    => \*(Aqutf\-8\*(Aq,
\&    PROVIDERS => [
\&        {
\&            name    => \*(AqEncoding\*(Aq,
\&            copy_config => [qw(DEFAULT_ENCODING INCLUDE_PATH)]
\&        }
\&    ]
.Ve
.PP
This can prove useful when you want to use the additional_template_paths hack
in your own provider, or if you need to use Template::Provider::Encoding
.ie n .SS """CLASS"""
.el .SS "\f(CWCLASS\fP"
.IX Subsection "CLASS"
Allows you to specify a custom class to use as the template class instead of
Template.
.PP
.Vb 1
\&    package MyApp::View::Web;
\&
\&    use strict;
\&    use base \*(AqCatalyst::View::TT\*(Aq;
\&
\&    use Template::AutoFilter;
\&
\&    _\|_PACKAGE_\|_\->config({
\&        CLASS => \*(AqTemplate::AutoFilter\*(Aq,
\&    });
.Ve
.PP
This is useful if you want to use your own subclasses of Template, so you
can, for example, prevent \s-1XSS\s0 by automatically filtering all output through
\&\f(CW\*(C`| html\*(C'\fR.
.SS "\s-1HELPERS\s0"
.IX Subsection "HELPERS"
The Catalyst::Helper::View::TT and
Catalyst::Helper::View::TTSite helper modules are provided to create
your view module.  There are invoked by the \fImyapp_create.pl\fR script:
.PP
.Vb 1
\&    $ script/myapp_create.pl view Web TT
\&
\&    $ script/myapp_create.pl view Web TTSite
.Ve
.PP
The Catalyst::Helper::View::TT module creates a basic \s-1TT\s0 view
module.  The Catalyst::Helper::View::TTSite module goes a little
further.  It also creates a default set of templates to get you
started.  It also configures the view module to locate the templates
automatically.
.SH "NOTES"
.IX Header "NOTES"
If you are using the \s-1CGI\s0 module inside your templates, you will
experience that the Catalyst server appears to hang while rendering
the web page. This is due to the debug mode of \s-1CGI\s0 (which is
waiting for input in the terminal window). Turning off the
debug mode using the \*(L"\-no_debug\*(R" option solves the
problem, eg.:
.PP
.Vb 1
\&    [% USE CGI(\*(Aq\-no_debug\*(Aq) %]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst, Catalyst::Helper::View::TT,
Catalyst::Helper::View::TTSite, Template::Manual
.SH "AUTHORS"
.IX Header "AUTHORS"
Sebastian Riedel, \f(CW\*(C`sri@cpan.org\*(C'\fR
.PP
Marcus Ramberg, \f(CW\*(C`mramberg@cpan.org\*(C'\fR
.PP
Jesse Sheidlower, \f(CW\*(C`jester@panix.com\*(C'\fR
.PP
Andy Wardley, \f(CW\*(C`abw@cpan.org\*(C'\fR
.PP
Luke Saunders, \f(CW\*(C`luke.saunders@gmail.com\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software. You can redistribute it and/or modify it
under the same terms as Perl itself.
