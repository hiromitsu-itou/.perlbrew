.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "URI::Find 3"
.TH URI::Find 3 "2012-02-08" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI::Find \- Find URIs in arbitrary text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  require URI::Find;
\&
\&  my $finder = URI::Find\->new(\e&callback);
\&
\&  $how_many_found = $finder\->find(\e$text);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module does one thing: Finds URIs and URLs in plain text.  It finds
them quickly and it finds them \fBall\fR (or what \s-1URI::URL\s0 considers a \s-1URI\s0
to be.)  It only finds URIs which include a scheme (http:// or the
like), for something a bit less strict have a look at
URI::Find::Schemeless.
.PP
For a command-line interface, urifind is provided.
.SS "Public Methods"
.IX Subsection "Public Methods"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $finder = URI::Find\->new(\e&callback);
.Ve
.Sp
Creates a new URI::Find object.
.Sp
&callback is a function which is called on each \s-1URI\s0 found.  It is
passed two arguments, the first is a \s-1URI::URL\s0 object representing the
\&\s-1URI\s0 found.  The second is the original text of the \s-1URI\s0 found.  The
return value of the callback will replace the original \s-1URI\s0 in the
text.
.IP "\fBfind\fR" 4
.IX Item "find"
.Vb 1
\&  my $how_many_found = $finder\->find(\e$text);
.Ve
.Sp
\&\f(CW$text\fR is a string to search and possibly modify with your callback.
.Sp
Alternatively, \f(CW\*(C`find\*(C'\fR can be called with a replacement function for
the rest of the text:
.Sp
.Vb 3
\&  use CGI qw(escapeHTML);
\&  # ...
\&  my $how_many_found = $finder\->find(\e$text, \e&escapeHTML);
.Ve
.Sp
will not only call the callback function for every \s-1URL\s0 found (and
perform the replacement instructions therein), but also run the rest
of the text through \f(CW\*(C`escapeHTML()\*(C'\fR. This makes it easier to turn
plain text which contains URLs into \s-1HTML\s0 (see example below).
.SS "Protected Methods"
.IX Subsection "Protected Methods"
I got a bunch of mail from people asking if I'd add certain features
to URI::Find.  Most wanted the search to be less restrictive, do more
heuristics, etc...  Since many of the requests were contradictory, I'm
letting people create their own custom subclasses to do what they
want.
.PP
The following are methods internal to URI::Find which a subclass can
override to change the way URI::Find acts.  They are only to be called
\&\fBinside\fR a URI::Find subclass.  Users of this module are \s-1NOT\s0 to use
these methods.
.IP "\fBuri_re\fR" 4
.IX Item "uri_re"
.Vb 1
\&  my $uri_re = $self\->uri_re;
.Ve
.Sp
Returns the regex for finding absolute, schemed URIs
(http://www.foo.com and such).  This, combined with
\&\fIschemeless_uri_re()\fR is what finds candidate URIs.
.Sp
Usually this method does not have to be overridden.
.IP "\fBschemeless_uri_re\fR" 4
.IX Item "schemeless_uri_re"
.Vb 1
\&  my $schemeless_re = $self\->schemeless_uri_re;
.Ve
.Sp
Returns the regex for finding schemeless URIs (www.foo.com and such) and
other things which might be URIs.  By default this will match nothing
(though it used to try to find schemeless URIs which started with \f(CW\*(C`www\*(C'\fR
and \f(CW\*(C`ftp\*(C'\fR).
.Sp
Many people will want to override this method.  See URI::Find::Schemeless
for a subclass does a reasonable job of finding URIs which might be missing
the scheme.
.IP "\fBuric_set\fR" 4
.IX Item "uric_set"
.Vb 1
\&  my $uric_set = $self\->uric_set;
.Ve
.Sp
Returns a set matching the 'uric' set defined in \s-1RFC\s0 2396 suitable for
putting into a character set ([]) in a regex.
.Sp
You almost never have to override this.
.IP "\fBcruft_set\fR" 4
.IX Item "cruft_set"
.Vb 1
\&  my $cruft_set = $self\->cruft_set;
.Ve
.Sp
Returns a set of characters which are considered garbage.  Used by
\&\fIdecruft()\fR.
.IP "\fBdecruft\fR" 4
.IX Item "decruft"
.Vb 1
\&  my $uri = $self\->decruft($uri);
.Ve
.Sp
Sometimes garbage characters like periods and parenthesis get
accidentally matched along with the \s-1URI\s0.  In order for the \s-1URI\s0 to be
properly identified, it must sometimes be \*(L"decrufted\*(R", the garbage
characters stripped.
.Sp
This method takes a candidate \s-1URI\s0 and strips off any cruft it finds.
.IP "\fBrecruft\fR" 4
.IX Item "recruft"
.Vb 1
\&  my $uri = $self\->recruft($uri);
.Ve
.Sp
This method puts back the cruft taken off with \fIdecruft()\fR.  This is necessary
because the cruft is destructively removed from the string before invoking
the user's callback, so it has to be put back afterwards.
.IP "\fBschemeless_to_schemed\fR" 4
.IX Item "schemeless_to_schemed"
.Vb 1
\&  my $schemed_uri = $self\->schemeless_to_schemed($schemeless_uri);
.Ve
.Sp
This takes a schemeless \s-1URI\s0 and returns an absolute, schemed \s-1URI\s0.  The
standard implementation supplies ftp:// for URIs which start with ftp.,
and http:// otherwise.
.IP "\fBis_schemed\fR" 4
.IX Item "is_schemed"
.Vb 1
\&  $obj\->is_schemed($uri);
.Ve
.Sp
Returns whether or not the given \s-1URI\s0 is schemed or schemeless.  True for
schemed, false for schemeless.
.IP "\fIbadinvo\fR" 4
.IX Item "badinvo"
.Vb 1
\&  _\|_PACKAGE_\|_\->badinvo($extra_levels, $msg)
.Ve
.Sp
This is used to complain about bogus subroutine/method invocations.
The args are optional.
.SS "Old Functions"
.IX Subsection "Old Functions"
The old \fIfind_uri()\fR function is still around and it works, but its
deprecated.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Store a list of all URIs (normalized) in the document.
.PP
.Vb 6
\&  my @uris;
\&  my $finder = URI::Find\->new(sub {
\&      my($uri) = shift;
\&      push @uris, $uri;
\&  });
\&  $finder\->find(\e$text);
.Ve
.PP
Print the original \s-1URI\s0 text found and the normalized representation.
.PP
.Vb 6
\&  my $finder = URI::Find\->new(sub {
\&      my($uri, $orig_uri) = @_;
\&      print "The text \*(Aq$orig_uri\*(Aq represents \*(Aq$uri\*(Aq\en";
\&      return $orig_uri;
\&  });
\&  $finder\->find(\e$text);
.Ve
.PP
Check each \s-1URI\s0 in document to see if it exists.
.PP
.Vb 1
\&  use LWP::Simple;
\&
\&  my $finder = URI::Find\->new(sub {
\&      my($uri, $orig_uri) = @_;
\&      if( head $uri ) {
\&          print "$orig_uri is okay\en";
\&      }
\&      else {
\&          print "$orig_uri cannot be found\en";
\&      }
\&      return $orig_uri;
\&  });
\&  $finder\->find(\e$text);
.Ve
.PP
Turn plain text into \s-1HTML\s0, with each \s-1URI\s0 found wrapped in an \s-1HTML\s0 anchor.
.PP
.Vb 2
\&  use CGI qw(escapeHTML);
\&  use URI::Find;
\&
\&  my $finder = URI::Find\->new(sub {
\&      my($uri, $orig_uri) = @_;
\&      return qq|<a href="$uri">$orig_uri</a>|;
\&  });
\&  $finder\->find(\e$text, \e&escapeHTML);
\&  print "<pre>$text</pre>";
.Ve
.SH "NOTES"
.IX Header "NOTES"
Will not find URLs with Internationalized Domain Names or pretty much
any non-ascii stuff in them.  See
<http://rt.cpan.org/Ticket/Display.html?id=44226>
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> with insight from Uri Gutman,
Greg Bacon, Jeff Pinyan, Roderick Schertler and others.
.PP
Roderick Schertler <roderick@argon.org> maintained versions 0.11 to 0.16.
.PP
Darren Chamberlain wrote urifind.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2000, 2009\-2010 by Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or 
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perlfoundation.org/artistic_license_1_0\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
urifind, URI::Find::Schemeless, \s-1URI::URL\s0, \s-1URI\s0,
\&\s-1RFC\s0 3986 Appendix C
