.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Plugin::Authentication 3"
.TH Catalyst::Plugin::Authentication 3 "2011-07-29" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Plugin::Authentication \- Infrastructure plugin for the Catalyst
authentication framework.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Catalyst qw/
\&        Authentication
\&    /;
\&
\&    # later on ...
\&    $c\->authenticate({ username => \*(Aqmyusername\*(Aq,
\&                       password => \*(Aqmypassword\*(Aq });
\&    my $age = $c\->user\->get(\*(Aqage\*(Aq);
\&    $c\->logout;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The authentication plugin provides generic user support for Catalyst apps. It
is the basis for both authentication (checking the user is who they claim to
be), and authorization (allowing the user to do what the system authorises
them to do).
.PP
Using authentication is split into two parts. A Store is used to actually
store the user information, and can store any amount of data related to the
user. Credentials are used to verify users, using information from the store,
given data from the frontend. A Credential and a Store are paired to form a
\&'Realm'. A Catalyst application using the authentication framework must have
at least one realm, and may have several.
.PP
To implement authentication in a Catalyst application you need to add this
module, and specify at least one realm in the configuration.
.PP
Authentication data can also be stored in a session, if the application
is using the Catalyst::Plugin::Session module.
.PP
\&\fB\s-1NOTE\s0\fR in version 0.10 of this module, the interface to this module changed.
Please see \*(L"\s-1COMPATIBILITY\s0 \s-1ROUTINES\s0\*(R" for more information.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
.SS "The Authentication/Authorization Process"
.IX Subsection "The Authentication/Authorization Process"
Web applications typically need to identify a user \- to tell the user apart
from other users. This is usually done in order to display private information
that is only that user's business, or to limit access to the application so
that only certain entities can access certain parts.
.PP
This process is split up into several steps. First you ask the user to identify
themselves. At this point you can't be sure that the user is really who they
claim to be.
.PP
Then the user tells you who they are, and backs this claim with some piece of
information that only the real user could give you. For example, a password is
a secret that is known to both the user and you. When the user tells you this
password you can assume they're in on the secret and can be trusted (ignore
identity theft for now). Checking the password, or any other proof is called
\&\fBcredential verification\fR.
.PP
By this time you know exactly who the user is \- the user's identity is
\&\fBauthenticated\fR. This is where this module's job stops, and your application
or other plugins step in.
.PP
The next logical step is \fBauthorization\fR, the process of deciding what a user
is (or isn't) allowed to do. For example, say your users are split into two
main groups \- regular users and administrators. You want to verify that the
currently logged in user is indeed an administrator before performing the
actions in an administrative part of your application. These decisions may be
made within your application code using just the information available after
authentication, or it may be facilitated by a number of plugins.
.SS "The Components In This Framework"
.IX Subsection "The Components In This Framework"
\fIRealms\fR
.IX Subsection "Realms"
.PP
Configuration of the Catalyst::Plugin::Authentication framework is done in
terms of realms. In simplest terms, a realm is a pairing of a Credential
verifier and a User storage (Store) backend. As of version 0.10003, realms are
now objects that you can create and customize.
.PP
An application can have any number of Realms, each of which operates
independent of the others. Each realm has a name, which is used to identify it
as the target of an authentication request. This name can be anything, such as
\&'users' or 'members'. One realm must be defined as the default_realm, which is
used when no realm name is specified. More information about configuring
realms is available in the configuration section.
.PP
\fICredential Verifiers\fR
.IX Subsection "Credential Verifiers"
.PP
When user input is transferred to the Catalyst application
(typically via form inputs) the application may pass this information
into the authentication system through the \f(CW\*(C`$c\->authenticate()\*(C'\fR
method.  From there, it is passed to the appropriate Credential
verifier.
.PP
These plugins check the data, and ensure that it really proves the user is who
they claim to be.
.PP
Credential verifiers compatible with versions of this module 0.10x and
upwards should be in the namespace
\&\f(CW\*(C`Catalyst::Authentication::Credential\*(C'\fR.
.PP
\fIStorage Backends\fR
.IX Subsection "Storage Backends"
.PP
The authentication data also identifies a user, and the Storage backend modules
use this data to locate and return a standardized object-oriented
representation of a user.
.PP
When a user is retrieved from a store it is not necessarily authenticated.
Credential verifiers accept a set of authentication data and use this
information to retrieve the user from the store they are paired with.
.PP
Storage backends compatible with versions of this module 0.10x and
upwards should be in the namespace
\&\f(CW\*(C`Catalyst::Authentication::Store\*(C'\fR.
.PP
\fIThe Core Plugin\fR
.IX Subsection "The Core Plugin"
.PP
This plugin on its own is the glue, providing realm configuration, session
integration, and other goodness for the other plugins.
.PP
\fIOther Plugins\fR
.IX Subsection "Other Plugins"
.PP
More layers of plugins can be stacked on top of the authentication code. For
example, Catalyst::Plugin::Session::PerUser provides an abstraction of
browser sessions that is more persistent per user.
Catalyst::Plugin::Authorization::Roles provides an accepted way to separate
and group users into categories, and then check which categories the current
user belongs to.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Let's say we were storing users in a simple Perl hash. Users are
verified by supplying a password which is matched within the hash.
.PP
This means that our application will begin like this:
.PP
.Vb 1
\&    package MyApp;
\&
\&    use Catalyst qw/
\&        Authentication
\&    /;
\&
\&    _\|_PACKAGE_\|_\->config( \*(AqPlugin::Authentication\*(Aq =>
\&                {
\&                    default => {
\&                        credential => {
\&                            class => \*(AqPassword\*(Aq,
\&                            password_field => \*(Aqpassword\*(Aq,
\&                            password_type => \*(Aqclear\*(Aq
\&                        },
\&                        store => {
\&                            class => \*(AqMinimal\*(Aq,
\&                            users => {
\&                                bob => {
\&                                    password => "s00p3r",
\&                                    editor => \*(Aqyes\*(Aq,
\&                                    roles => [qw/edit delete/],
\&                                },
\&                                william => {
\&                                    password => "s3cr3t",
\&                                    roles => [qw/comment/],
\&                                }
\&                            }
\&                        }
\&                    }
\&                }
\&    );
.Ve
.PP
This tells the authentication plugin what realms are available, which
credential and store modules are used, and the configuration of each. With
this code loaded, we can now attempt to authenticate users.
.PP
To show an example of this, let's create an authentication controller:
.PP
.Vb 1
\&    package MyApp::Controller::Auth;
\&
\&    sub login : Local {
\&        my ( $self, $c ) = @_;
\&
\&        if (    my $user     = $c\->req\->params\->{user}
\&            and my $password = $c\->req\->params\->{password} )
\&        {
\&            if ( $c\->authenticate( { username => $user,
\&                                     password => $password } ) ) {
\&                $c\->res\->body( "hello " . $c\->user\->get("name") );
\&            } else {
\&                # login incorrect
\&            }
\&        }
\&        else {
\&            # invalid form input
\&        }
\&    }
.Ve
.PP
This code should be self-explanatory. If all the necessary fields are supplied,
call the \f(CW\*(C`authenticate\*(C'\fR method on the context object. If it succeeds the
user is logged in.
.PP
The credential verifier will attempt to retrieve the user whose
details match the authentication information provided to
\&\f(CW\*(C`$c\->authenticate()\*(C'\fR. Once it fetches the user the password is
checked and if it matches the user will be \fBauthenticated\fR and
\&\f(CW\*(C`$c\->user\*(C'\fR will contain the user object retrieved from the store.
.PP
In the above case, the default realm is checked, but we could just as easily
check an alternate realm. If this were an admin login, for example, we could
authenticate on the admin realm by simply changing the \f(CW\*(C`$c\->authenticate()\*(C'\fR
call:
.PP
.Vb 4
\&    if ( $c\->authenticate( { username => $user,
\&                             password => $password }, \*(Aqadmin\*(Aq ) ) {
\&        $c\->res\->body( "hello " . $c\->user\->get("name") );
\&    } ...
.Ve
.PP
Now suppose we want to restrict the ability to edit to a user with an
\&'editor' value of yes.
.PP
The restricted action might look like this:
.PP
.Vb 2
\&    sub edit : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->detach("unauthorized")
\&          unless $c\->user_exists
\&          and $c\->user\->get(\*(Aqeditor\*(Aq) eq \*(Aqyes\*(Aq;
\&
\&        # do something restricted here
\&    }
.Ve
.PP
(Note that if you have multiple realms, you can use
\&\f(CW\*(C`$c\->user_in_realm(\*(Aqrealmname\*(Aq)\*(C'\fR in place of
\&\f(CW\*(C`$c\->user_exists();\*(C'\fR This will essentially perform the same
verification as user_exists, with the added requirement that if there
is a user, it must have come from the realm specified.)
.PP
The above example is somewhat similar to role based access control.
Catalyst::Authentication::Store::Minimal treats the roles field as
an array of role names. Let's leverage this. Add the role authorization
plugin:
.PP
.Vb 4
\&    use Catalyst qw/
\&        ...
\&        Authorization::Roles
\&    /;
\&
\&    sub edit : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->detach("unauthorized") unless $c\->check_user_roles("edit");
\&
\&        # do something restricted here
\&    }
.Ve
.PP
This is somewhat simpler and will work if you change your store, too, since the
role interface is consistent.
.PP
Let's say your app grows, and you now have 10,000 users. It's no longer
efficient to maintain a hash of users, so you move this data to a database.
You can accomplish this simply by installing the DBIx::Class Store and
changing your config:
.PP
.Vb 10
\&    _\|_PACKAGE_\|_\->config( \*(AqPlugin::Authentication\*(Aq =>
\&                    {
\&                        default_realm => \*(Aqmembers\*(Aq,
\&                        members => {
\&                            credential => {
\&                                class => \*(AqPassword\*(Aq,
\&                                password_field => \*(Aqpassword\*(Aq,
\&                                password_type => \*(Aqclear\*(Aq
\&                            },
\&                            store => {
\&                                class => \*(AqDBIx::Class\*(Aq,
\&                                user_model => \*(AqMyApp::Users\*(Aq,
\&                                role_column => \*(Aqroles\*(Aq,
\&                            }
\&                        }
\&                    }
\&    );
.Ve
.PP
The authentication system works behind the scenes to load your data from the
new source. The rest of your application is completely unchanged.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.Vb 4
\&    # example
\&    _\|_PACKAGE_\|_\->config( \*(AqPlugin::Authentication\*(Aq =>
\&                {
\&                    default_realm => \*(Aqmembers\*(Aq,
\&
\&                    members => {
\&                        credential => {
\&                            class => \*(AqPassword\*(Aq,
\&                            password_field => \*(Aqpassword\*(Aq,
\&                            password_type => \*(Aqclear\*(Aq
\&                        },
\&                        store => {
\&                            class => \*(AqDBIx::Class\*(Aq,
\&                            user_model => \*(AqMyApp::Users\*(Aq,
\&                            role_column => \*(Aqroles\*(Aq,
\&                        }
\&                    },
\&                    admins => {
\&                        credential => {
\&                            class => \*(AqPassword\*(Aq,
\&                            password_field => \*(Aqpassword\*(Aq,
\&                            password_type => \*(Aqclear\*(Aq
\&                        },
\&                        store => {
\&                            class => \*(Aq+MyApp::Authentication::Store::NetAuth\*(Aq,
\&                            authserver => \*(Aq192.168.10.17\*(Aq
\&                        }
\&                    }
\&                }
\&    );
.Ve
.PP
\&\s-1NOTE:\s0 Until version 0.10008 of this module, you would need to put all the
realms inside a \*(L"realms\*(R" key in the configuration. Please see
\&\*(L"\s-1COMPATIBILITY\s0 \s-1CONFIGURATION\s0\*(R" for more information
.IP "use_session" 4
.IX Item "use_session"
Whether or not to store the user's logged in state in the session, if the
application is also using Catalyst::Plugin::Session. This
value is set to true per default.
.Sp
However, even if use_session is disabled, if any code touches \f(CW$c\fR\->session, a session
object will be auto-vivified and session Cookies will be sent in the headers. To
prevent accidental session creation, check if a session already exists with
if ($c\->sessionid) { ... }. If the session doesn't exist, then don't place
anything in the session to prevent an unecessary session from being created.
.IP "default_realm" 4
.IX Item "default_realm"
This defines which realm should be used as when no realm is provided to methods
that require a realm such as authenticate or find_user.
.IP "realm refs" 4
.IX Item "realm refs"
The Plugin::Authentication config hash contains the series of realm
configurations you want to use for your app. The only rule here is
that there must be at least one. A realm consists of a name, which is used
to reference the realm, a credential and a store.  You may also put your
realm configurations within a subelement called 'realms' if you desire to
separate them from the remainder of your configuration.  Note that if you use
a 'realms' subelement, you must put \s-1ALL\s0 of your realms within it.
.Sp
You can also specify a realm class to instantiate instead of the default
Catalyst::Authentication::Realm class using the 'class' element within the
realm config.
.Sp
Each realm config contains two hashes, one called 'credential' and one called
\&'store', each of which provide configuration details to the respective modules.
The contents of these hashes is specific to the module being used, with the
exception of the 'class' element, which tells the core Authentication module the
classname to instantiate.
.Sp
The 'class' element follows the standard Catalyst mechanism of class
specification. If a class is prefixed with a +, it is assumed to be a complete
class name. Otherwise it is considered to be a portion of the class name. For
credentials, the classname '\fBPassword\fR', for example, is expanded to
Catalyst::Authentication::Credential::\fBPassword\fR. For stores, the
classname '\fBstorename\fR' is expanded to:
Catalyst::Authentication::Store::\fBstorename\fR.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$c\->authenticate( $userinfo [, $realm ])"
.el .SS "\f(CW$c\fP\->authenticate( \f(CW$userinfo\fP [, \f(CW$realm\fP ])"
.IX Subsection "$c->authenticate( $userinfo [, $realm ])"
Attempts to authenticate the user using the information in the \f(CW$userinfo\fR hash
reference using the realm \f(CW$realm\fR. \f(CW$realm\fR may be omitted, in which case the
default realm is checked.
.ie n .SS "$c\->user( )"
.el .SS "\f(CW$c\fP\->user( )"
.IX Subsection "$c->user( )"
Returns the currently logged in user, or undef if there is none.
Normally the user is re-retrieved from the store.
For Catalyst::Authentication::Store::DBIx::Class the user is re-restored 
using the primary key of the user table. 
Thus \fBuser\fR can throw an error even though \fBuser_exists\fR
returned true.
.ie n .SS "$c\->user_exists( )"
.el .SS "\f(CW$c\fP\->user_exists( )"
.IX Subsection "$c->user_exists( )"
Returns true if a user is logged in right now. The difference between
\&\fBuser_exists\fR and \fBuser\fR is that user_exists will return true if a user is logged
in, even if it has not been yet retrieved from the storage backend. If you only
need to know if the user is logged in, depending on the storage mechanism this
can be much more efficient.
\&\fBuser_exists\fR only looks into the session while \fBuser\fR is trying to restore the user.
.ie n .SS "$c\->user_in_realm( $realm )"
.el .SS "\f(CW$c\fP\->user_in_realm( \f(CW$realm\fP )"
.IX Subsection "$c->user_in_realm( $realm )"
Works like user_exists, except that it only returns true if a user is both
logged in right now and was retrieved from the realm provided.
.ie n .SS "$c\->logout( )"
.el .SS "\f(CW$c\fP\->logout( )"
.IX Subsection "$c->logout( )"
Logs the user out. Deletes the currently logged in user from \f(CW\*(C`$c\->user\*(C'\fR
and the session.  It does not delete the session.
.ie n .SS "$c\->find_user( $userinfo, $realm )"
.el .SS "\f(CW$c\fP\->find_user( \f(CW$userinfo\fP, \f(CW$realm\fP )"
.IX Subsection "$c->find_user( $userinfo, $realm )"
Fetch a particular users details, matching the provided user info, from the realm
specified in \f(CW$realm\fR.
.PP
.Vb 2
\&    $user = $c\->find_user({ id => $id });
\&    $c\->set_authenticated($user); # logs the user in and calls persist_user
.Ve
.SS "\fIpersist_user()\fP"
.IX Subsection "persist_user()"
Under normal circumstances the user data is only saved to the session during
initial authentication.  This call causes the auth system to save the
currently authenticated user's data across requests.  Useful if you have
changed the user data and want to ensure that future requests reflect the
most current data.  Assumes that at the time of this call, \f(CW$c\fR\->user
contains the most current data.
.SS "\fIfind_realm_for_persisted_user()\fP"
.IX Subsection "find_realm_for_persisted_user()"
Private method, do not call from user code!
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These methods are for Catalyst::Plugin::Authentication \fB\s-1INTERNAL\s0 \s-1USE\s0\fR only.
Please do not use them in your own code, whether application or credential /
store modules. If you do, you will very likely get the nasty shock of having
to fix / rewrite your code when things change. They are documented here only
for reference.
.ie n .SS "$c\->set_authenticated( $user, $realmname )"
.el .SS "\f(CW$c\fP\->set_authenticated( \f(CW$user\fP, \f(CW$realmname\fP )"
.IX Subsection "$c->set_authenticated( $user, $realmname )"
Marks a user as authenticated. This is called from within the authenticate
routine when a credential returns a user. \f(CW$realmname\fR defaults to 'default'.
You can use find_user to get \f(CW$user\fR
.ie n .SS "$c\->auth_restore_user( $user, $realmname )"
.el .SS "\f(CW$c\fP\->auth_restore_user( \f(CW$user\fP, \f(CW$realmname\fP )"
.IX Subsection "$c->auth_restore_user( $user, $realmname )"
Used to restore a user from the session. In most cases this is called without
arguments to restore the user via the session. Can be called with arguments
when restoring a user from some other method.  Currently not used in this way.
.ie n .SS "$c\->auth_realms( )"
.el .SS "\f(CW$c\fP\->auth_realms( )"
.IX Subsection "$c->auth_realms( )"
Returns a hashref containing realmname \-> realm instance pairs. Realm
instances contain an instantiated store and credential object as the 'store'
and 'credential' elements, respectively
.ie n .SS "$c\->get_auth_realm( $realmname )"
.el .SS "\f(CW$c\fP\->get_auth_realm( \f(CW$realmname\fP )"
.IX Subsection "$c->get_auth_realm( $realmname )"
Retrieves the realm instance for the realmname provided.
.ie n .SS "$c\->update_user_in_session"
.el .SS "\f(CW$c\fP\->update_user_in_session"
.IX Subsection "$c->update_user_in_session"
This was a short-lived method to update user information \- you should use persist_user instead.
.ie n .SS "$c\->setup_auth_realm( )"
.el .SS "\f(CW$c\fP\->setup_auth_realm( )"
.IX Subsection "$c->setup_auth_realm( )"
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
.ie n .SS "$c\->setup( )"
.el .SS "\f(CW$c\fP\->setup( )"
.IX Subsection "$c->setup( )"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This list might not be up to date.  Below are modules known to work with the updated
\&\s-1API\s0 of 0.10 and are therefore compatible with realms.
.SS "Realms"
.IX Subsection "Realms"
Catalyst::Authentication::Realm
.SS "User Storage Backends"
.IX Subsection "User Storage Backends"
.IP "Catalyst::Authentication::Store::Minimal" 4
.IX Item "Catalyst::Authentication::Store::Minimal"
.PD 0
.IP "Catalyst::Authentication::Store::DBIx::Class" 4
.IX Item "Catalyst::Authentication::Store::DBIx::Class"
.IP "Catalyst::Authentication::Store::LDAP" 4
.IX Item "Catalyst::Authentication::Store::LDAP"
.IP "Catalyst::Authentication::Store::RDBO" 4
.IX Item "Catalyst::Authentication::Store::RDBO"
.IP "Catalyst::Authentication::Store::Model::KiokuDB" 4
.IX Item "Catalyst::Authentication::Store::Model::KiokuDB"
.IP "Catalyst::Authentication::Store::Jifty::DBI" 4
.IX Item "Catalyst::Authentication::Store::Jifty::DBI"
.IP "Catalyst::Authentication::Store::Htpasswd" 4
.IX Item "Catalyst::Authentication::Store::Htpasswd"
.PD
.SS "Credential verification"
.IX Subsection "Credential verification"
.IP "Catalyst::Authentication::Credential::Password" 4
.IX Item "Catalyst::Authentication::Credential::Password"
.PD 0
.IP "Catalyst::Authentication::Credential::HTTP" 4
.IX Item "Catalyst::Authentication::Credential::HTTP"
.IP "Catalyst::Authentication::Credential::OpenID" 4
.IX Item "Catalyst::Authentication::Credential::OpenID"
.IP "Catalyst::Authentication::Credential::Authen::Simple" 4
.IX Item "Catalyst::Authentication::Credential::Authen::Simple"
.IP "Catalyst::Authentication::Credential::Flickr" 4
.IX Item "Catalyst::Authentication::Credential::Flickr"
.IP "Catalyst::Authentication::Credential::Testing" 4
.IX Item "Catalyst::Authentication::Credential::Testing"
.IP "Catalyst::Authentication::Credential::AuthTkt" 4
.IX Item "Catalyst::Authentication::Credential::AuthTkt"
.IP "Catalyst::Authentication::Credential::Kerberos" 4
.IX Item "Catalyst::Authentication::Credential::Kerberos"
.PD
.SS "Authorization"
.IX Subsection "Authorization"
Catalyst::Plugin::Authorization::ACL,
Catalyst::Plugin::Authorization::Roles
.SS "Internals Documentation"
.IX Subsection "Internals Documentation"
Catalyst::Plugin::Authentication::Internals
.SS "Misc"
.IX Subsection "Misc"
Catalyst::Plugin::Session,
Catalyst::Plugin::Session::PerUser
.SH "DON'T SEE ALSO"
.IX Header "DON'T SEE ALSO"
This module along with its sub plugins deprecate a great number of other
modules. These include Catalyst::Plugin::Authentication::Simple,
Catalyst::Plugin::Authentication::CDBI.
.SH "INCOMPATABILITIES"
.IX Header "INCOMPATABILITIES"
The realms-based configuration and functionality of the 0.10 update
of Catalyst::Plugin::Authentication required a change in the \s-1API\s0 used by
credentials and stores.  It has a compatibility mode which allows use of
modules that have not yet been updated. This, however, completely mimics the
older api and disables the new realm-based features. In other words you cannot
mix the older credential and store modules with realms, or realm-based
configs. The changes required to update modules are relatively minor and are
covered in Catalyst::Plugin::Authentication::Internals.  We hope that most
modules will move to the compatible list above very quickly.
.SH "COMPATIBILITY CONFIGURATION"
.IX Header "COMPATIBILITY CONFIGURATION"
Until version 0.10008 of this module, you needed to put all the
realms inside a \*(L"realms\*(R" key in the configuration.
.PP
.Vb 11
\&    # example
\&    _\|_PACKAGE_\|_\->config( \*(AqPlugin::Authentication\*(Aq =>
\&                {
\&                    default_realm => \*(Aqmembers\*(Aq,
\&                    realms => {
\&                        members => {
\&                            ...
\&                        },
\&                    },
\&                }
\&    );
.Ve
.PP
If you use the old, deprecated \f(CW\*(C`_\|_PACKAGE_\|_\->config( \*(Aqauthentication\*(Aq )\*(C'\fR
configuration key, then the realms key is still required.
.SH "COMPATIBILITY ROUTINES"
.IX Header "COMPATIBILITY ROUTINES"
In version 0.10 of Catalyst::Plugin::Authentication, the \s-1API\s0
changed. For app developers, this change is fairly minor, but for
Credential and Store authors, the changes are significant.
.PP
Please see the documentation in version 0.09 of
Catalyst::Plugin::Authentication for a better understanding of how the old \s-1API\s0
functioned.
.PP
The items below are still present in the plugin, though using them is
deprecated. They remain only as a transition tool, for those sites which can
not yet be upgraded to use the new system due to local customizations or use
of Credential / Store modules that have not yet been updated to work with the
new \s-1API\s0.
.PP
These routines should not be used in any application using realms
functionality or any of the methods described above. These are for reference
purposes only.
.ie n .SS "$c\->login( )"
.el .SS "\f(CW$c\fP\->login( )"
.IX Subsection "$c->login( )"
This method is used to initiate authentication and user retrieval. Technically
this is part of the old Password credential module and it still resides in the
Password class. It is
included here for reference only.
.ie n .SS "$c\->default_auth_store( )"
.el .SS "\f(CW$c\fP\->default_auth_store( )"
.IX Subsection "$c->default_auth_store( )"
Return the store whose name is 'default'.
.PP
This is set to \f(CW\*(C`$c\->config( \*(AqPlugin::Authentication\*(Aq => { store => # Store} )\*(C'\fR if that value exists,
or by using a Store plugin:
.PP
.Vb 2
\&    # load the Minimal authentication store.
\&    use Catalyst qw/Authentication Authentication::Store::Minimal/;
.Ve
.PP
Sets the default store to
Catalyst::Plugin::Authentication::Store::Minimal.
.ie n .SS "$c\->get_auth_store( $name )"
.el .SS "\f(CW$c\fP\->get_auth_store( \f(CW$name\fP )"
.IX Subsection "$c->get_auth_store( $name )"
Return the store whose name is \f(CW$name\fR.
.ie n .SS "$c\->get_auth_store_name( $store )"
.el .SS "\f(CW$c\fP\->get_auth_store_name( \f(CW$store\fP )"
.IX Subsection "$c->get_auth_store_name( $store )"
Return the name of the store \f(CW$store\fR.
.ie n .SS "$c\->auth_stores( )"
.el .SS "\f(CW$c\fP\->auth_stores( )"
.IX Subsection "$c->auth_stores( )"
A hash keyed by name, with the stores registered in the app.
.ie n .SS "$c\->register_auth_stores( %stores_by_name )"
.el .SS "\f(CW$c\fP\->register_auth_stores( \f(CW%stores_by_name\fP )"
.IX Subsection "$c->register_auth_stores( %stores_by_name )"
Register stores into the application.
.ie n .SS "$c\->auth_store_names( )"
.el .SS "\f(CW$c\fP\->auth_store_names( )"
.IX Subsection "$c->auth_store_names( )"
.ie n .SS "$c\->get_user( )"
.el .SS "\f(CW$c\fP\->get_user( )"
.IX Subsection "$c->get_user( )"
.SH "AUTHORS"
.IX Header "AUTHORS"
Yuval Kogman, \f(CW\*(C`nothingmuch@woobling.org\*(C'\fR
.PP
Jay Kuri, \f(CW\*(C`jayk@cpan.org\*(C'\fR
.PP
Jess Robinson
.PP
David Kamholz
.PP
Tomas Doran (t0m), \f(CW\*(C`bobtfish@bobtfish.net\*(C'\fR
.PP
kmx
.PP
Nigel Metheringham
.PP
Florian Ragwitz \f(CW\*(C`rafl@debian.org\*(C'\fR
.PP
Stephan Jauernick \f(CW\*(C`stephanj@cpan.org\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2005 \- 2009
the Catalyst::Plugin::Authentication \*(L"\s-1AUTHORS\s0\*(R"
as listed above.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
