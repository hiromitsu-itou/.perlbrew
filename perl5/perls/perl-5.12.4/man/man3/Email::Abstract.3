.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Email::Abstract 3"
.TH Email::Abstract 3 "2011-02-19" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::Abstract \- unified interface to mail representations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  my $message = Mail::Message\->read($rfc822)
\&             || Email::Simple\->new($rfc822)
\&             || Mail::Internet\->new([split /\en/, $rfc822])
\&             || ...
\&             || $rfc822;
\&
\&  my $email = Email::Abstract\->new($message);
\&
\&  my $subject = $email\->get_header("Subject");
\&  $email\->set_header(Subject => "My new subject");
\&
\&  my $body = $email\->get_body;
\&
\&  $rfc822 = $email\->as_string;
\&
\&  my $mail_message = $email\->cast("Mail::Message");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Email::Abstract\*(C'\fR provides module writers with the ability to write
simple, representation-independent mail handling code. For instance, in the
cases of \f(CW\*(C`Mail::Thread\*(C'\fR or \f(CW\*(C`Mail::ListDetector\*(C'\fR, a key part of the code
involves reading the headers from a mail object. Where previously one would
either have to specify the mail class required, or to build a new object from
scratch, \f(CW\*(C`Email::Abstract\*(C'\fR can be used to perform certain simple operations on
an object regardless of its underlying representation.
.PP
\&\f(CW\*(C`Email::Abstract\*(C'\fR currently supports \f(CW\*(C`Mail::Internet\*(C'\fR, \f(CW\*(C`MIME::Entity\*(C'\fR,
\&\f(CW\*(C`Mail::Message\*(C'\fR, \f(CW\*(C`Email::Simple\*(C'\fR and \f(CW\*(C`Email::MIME\*(C'\fR.  Other representations
are encouraged to create their own \f(CW\*(C`Email::Abstract::*\*(C'\fR class by copying
\&\f(CW\*(C`Email::Abstract::EmailSimple\*(C'\fR.  All modules installed under the
\&\f(CW\*(C`Email::Abstract\*(C'\fR hierarchy will be automatically picked up and used.
.SH "METHODS"
.IX Header "METHODS"
All of these methods may be called either as object methods or as class
methods.  When called as class methods, the email object (of any class
supported by Email::Abstract) must be prepended to the list of arguments, like
so:
.PP
.Vb 1
\&  my $return = Email::Abstract\->method($message, @args);
.Ve
.PP
This is provided primarily for backwards compatibility.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $email = Email::Abstract\->new($message);
.Ve
.PP
Given a message, either as a string or as an object for which an adapter is
installed, this method will return a Email::Abstract object wrapping the
message.
.PP
If the message is given as a string, it will be used to construct an object,
which will then be wrapped.
.SS "get_header"
.IX Subsection "get_header"
.Vb 1
\&  my $header  = $email\->get_header($header_name);
\&
\&  my @headers = $email\->get_header($header_name);
.Ve
.PP
This returns the values for the given header.  In scalar context, it returns
the first value.
.SS "set_header"
.IX Subsection "set_header"
.Vb 1
\&  $email\->set_header($header => @values);
.Ve
.PP
This sets the \f(CW$header\fR header to the given one or more values.
.SS "get_body"
.IX Subsection "get_body"
.Vb 1
\&  my $body = $email\->get_body;
.Ve
.PP
This returns the body as a string.
.SS "set_body"
.IX Subsection "set_body"
.Vb 1
\&  $email\->set_body($string);
.Ve
.PP
This changes the body of the email to the given string.
.PP
\&\fB\s-1WARNING\s0!\fR  You probably don't want to call this method, despite what you may
think.  Email message bodies are complicated, and rely on things like content
type, encoding, and various \s-1MIME\s0 requirements.  If you call \f(CW\*(C`set_body\*(C'\fR on a
message more complicated than a single-part seven-bit plain-text message, you
are likely to break something.  If you need to do this sort of thing, you
should probably use a specific message class from end to end.
.PP
This method is left in place for backwards compatibility.
.SS "as_string"
.IX Subsection "as_string"
.Vb 1
\&  my $string = $email\->as_string;
.Ve
.PP
This returns the whole email as a decoded string.
.SS "cast"
.IX Subsection "cast"
.Vb 1
\&  my $mime_entity = $email\->cast(\*(AqMIME::Entity\*(Aq);
.Ve
.PP
This method will convert a message from one message class to another.  It will
throw an exception if no adapter for the target class is known, or if the
adapter does not provide a \f(CW\*(C`construct\*(C'\fR method.
.SS "object"
.IX Subsection "object"
.Vb 1
\&  my $message = $email\->object;
.Ve
.PP
This method returns the message object wrapped by Email::Abstract.  If called
as a class method, it returns false.
.PP
Note that, because strings are converted to message objects before wrapping,
this method will return an object when the Email::Abstract was constructed from
a string.
.SH "PERL EMAIL PROJECT"
.IX Header "PERL EMAIL PROJECT"
This module is maintained by the Perl Email Project
.PP
<http://emailproject.perl.org/wiki/Email::Abstract>
.SH "AUTHOR"
.IX Header "AUTHOR"
Casey West, <\fIcasey@geeknest.com\fR>
.PP
Simon Cozens, <\fIsimon@cpan.org\fR>
.PP
Ricardo \s-1SIGNES\s0, <\fIrjbs@cpan.org\fR>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004 by Simon Cozens
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
