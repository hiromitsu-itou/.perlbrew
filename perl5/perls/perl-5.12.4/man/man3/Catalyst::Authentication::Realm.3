.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Realm 3"
.TH Catalyst::Authentication::Realm 3 "2011-07-29" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Authentication::Realm \- Base class for realm objects.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.IP "class" 4
.IX Item "class"
By default this class is used by
Catalyst::Plugin::Authentication for all
realms. The class parameter allows you to choose a different class to use for
this realm. Creating a new Realm class can allow for authentication methods
that fall outside the normal credential/store methodology.
.IP "auto_create_user" 4
.IX Item "auto_create_user"
Set this to true if you wish this realm to auto-create user accounts when the
user doesn't exist (most useful for remote authentication schemes).
.IP "auto_update_user" 4
.IX Item "auto_update_user"
Set this to true if you wish this realm to auto-update user accounts after
authentication (most useful for remote authentication schemes).
.IP "use_session" 4
.IX Item "use_session"
Sets session usage for this particular realm \- overriding the global use_sesion setting.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new( $realmname, $config, $app )"
.el .SS "new( \f(CW$realmname\fP, \f(CW$config\fP, \f(CW$app\fP )"
.IX Subsection "new( $realmname, $config, $app )"
Instantiantes this realm, plus the specified store and credential classes.
.SS "store( )"
.IX Subsection "store( )"
Returns an instance of the store object for this realm.
.SS "credential( )"
.IX Subsection "credential( )"
Returns an instance of the credential object for this realm.
.ie n .SS "find_user( $authinfo, $c )"
.el .SS "find_user( \f(CW$authinfo\fP, \f(CW$c\fP )"
.IX Subsection "find_user( $authinfo, $c )"
Retrieves the user given the authentication information provided.  This 
is most often called from the credential.  The default realm class simply
delegates this call the store object.  If enabled, auto-creation and 
auto-updating of users is also handled here.
.ie n .SS "authenticate( $c, $authinfo)"
.el .SS "authenticate( \f(CW$c\fP, \f(CW$authinfo\fP)"
.IX Subsection "authenticate( $c, $authinfo)"
Performs the authentication process for the current realm.  The default 
realm class simply delegates this to the credential and sets 
the authenticated user on success.  Returns the authenticated user object;
.SH "USER PERSISTENCE"
.IX Header "USER PERSISTENCE"
The Realm class allows complete control over the persistance of users
between requests.  By default the realm attempts to use the Catalyst
session system to accomplish this.  By overriding the methods below
in a custom Realm class, however, you can handle user persistance in
any way you see fit.
.ie n .SS "persist_user($c, $user)"
.el .SS "persist_user($c, \f(CW$user\fP)"
.IX Subsection "persist_user($c, $user)"
persist_user is the entry point for saving user information between requests
in most cases this will utilize the session.  By default this uses the 
catalyst session system to store the user by calling for_session on the
active store.  The user object must be a subclass of 
Catalyst::Authentication::User.  If you have updated the user object, you 
must call persist_user again to ensure that the persisted user object reflects
your updates.
.SS "remove_persisted_user($c)"
.IX Subsection "remove_persisted_user($c)"
Removes any persisted user data.  By default, removes the user from the session.
.ie n .SS "user_is_restorable( $c )"
.el .SS "user_is_restorable( \f(CW$c\fP )"
.IX Subsection "user_is_restorable( $c )"
Returns whether there is a persisted user that may be restored.  Returns
a token used to restore the user.  With the default session persistance
it returns the raw frozen user information.
.SS "restore_user($c, [$frozen_user])"
.IX Subsection "restore_user($c, [$frozen_user])"
Restores the user from the given frozen_user parameter, or if not provided,
using the response from \f(CW$self\fR\->\fIuser_is_restorable()\fR;  Uses \f(CW$self\fR\->\fIfrom_session()\fR
to decode the frozen user.
.SS "failed_user_restore($c)"
.IX Subsection "failed_user_restore($c)"
If there is a session to restore, but the restore fails for any reason then this method 
is called. This method supplied just removes the persisted user, but can be overridden
if required to have more complex logic (e.g. finding a the user by their 'old' username).
.ie n .SS "from_session($c, $frozenuser )"
.el .SS "from_session($c, \f(CW$frozenuser\fP )"
.IX Subsection "from_session($c, $frozenuser )"
Decodes the frozenuser information provided and returns an instantiated 
user object.  By default, this call is delegated to \f(CW$store\fR\->\fIfrom_session()\fR.
.ie n .SS "save_user_in_session($c, $user)"
.el .SS "save_user_in_session($c, \f(CW$user\fP)"
.IX Subsection "save_user_in_session($c, $user)"
\&\s-1DEPRECATED\s0.  Use persist_user instead.  (this simply calls persist_user)
