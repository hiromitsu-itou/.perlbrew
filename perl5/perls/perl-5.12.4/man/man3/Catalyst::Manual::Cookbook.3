.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Cookbook 3"
.TH Catalyst::Manual::Cookbook 3 "2011-09-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Cookbook \- Cooking with Catalyst
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Yummy code like your mum used to bake!
.SH "RECIPES"
.IX Header "RECIPES"
.SH "Basics"
.IX Header "Basics"
These recipes cover some basic stuff that is worth knowing for
Catalyst developers.
.SS "Delivering a Custom Error Page"
.IX Subsection "Delivering a Custom Error Page"
By default, Catalyst will display its own error page whenever it
encounters an error in your application. When running under \f(CW\*(C`\-Debug\*(C'\fR
mode, the error page is a useful screen including the error message
and Data::Dump output of the relevant parts of the \f(CW$c\fR context
object.  When not in \f(CW\*(C`\-Debug\*(C'\fR, users see a simple \*(L"Please come back
later\*(R" screen.
.PP
To use a custom error page, use a special \f(CW\*(C`end\*(C'\fR method to
short-circuit the error processing. The following is an example; you
might want to adjust it further depending on the needs of your
application (for example, any calls to \f(CW\*(C`fillform\*(C'\fR will probably need
to go into this \f(CW\*(C`end\*(C'\fR method; see Catalyst::Plugin::FillInForm).
.PP
.Vb 2
\&    sub end : Private {
\&        my ( $self, $c ) = @_;
\&
\&        if ( scalar @{ $c\->error } ) {
\&            $c\->stash\->{errors}   = $c\->error;
\&            for my $error ( @{ $c\->error } ) {
\&                $c\->log\->error($error);
\&            }
\&            $c\->stash\->{template} = \*(Aqerrors.tt\*(Aq;
\&            $c\->forward(\*(AqMyApp::View::TT\*(Aq);
\&            $c\->clear_errors;
\&        }
\&
\&        return 1 if $c\->response\->status =~ /^3\ed\ed$/;
\&        return 1 if $c\->response\->body;
\&
\&        unless ( $c\->response\->content_type ) {
\&            $c\->response\->content_type(\*(Aqtext/html; charset=utf\-8\*(Aq);
\&        }
\&
\&        $c\->forward(\*(AqMyApp::View::TT\*(Aq);
\&    }
.Ve
.PP
You can manually set errors in your code to trigger this page by calling
.PP
.Vb 1
\&    $c\->error( \*(AqYou broke me!\*(Aq );
.Ve
.SS "Disable statistics"
.IX Subsection "Disable statistics"
Just add this line to your application class if you don't want those
nifty statistics in your debug messages.
.PP
.Vb 1
\&    sub Catalyst::Log::info { }
.Ve
.SS "Enable debug status in the environment"
.IX Subsection "Enable debug status in the environment"
Normally you enable the debugging info by adding the \f(CW\*(C`\-Debug\*(C'\fR flag to
your \f(CW\*(C`use Catalyst\*(C'\fR statement . However, you can also enable it using
environment variable, so you can (for example) get debug info without
modifying your application scripts. Just set \f(CW\*(C`CATALYST_DEBUG\*(C'\fR or
\&\f(CW\*(C`<MYAPP>_DEBUG\*(C'\fR to a true value.
.SS "Sessions"
.IX Subsection "Sessions"
When you have your users identified, you will want to somehow remember
that fact, to save them from having to identify themselves for every
single page. One way to do this is to send the username and password
parameters in every single page, but that's ugly, and won't work for
static pages.
.PP
Sessions are a method of saving data related to some transaction, and
giving the whole collection a single \s-1ID\s0. This \s-1ID\s0 is then given to the
user to return to us on every page they visit while logged in. The
usual way to do this is using a browser cookie.
.PP
Catalyst uses two types of plugins to represent sessions:
.PP
\fIState\fR
.IX Subsection "State"
.PP
A State module is used to keep track of the state of the session
between the users browser, and your application.
.PP
A common example is the Cookie state module, which sends the browser a
cookie containing the session \s-1ID\s0. It will use default value for the
cookie name and domain, so will \*(L"just work\*(R" when used.
.PP
\fIStore\fR
.IX Subsection "Store"
.PP
A Store module is used to hold all the data relating to your session,
for example the users \s-1ID\s0, or the items for their shopping cart. You
can store data in memory (FastMmap), in a file (File) or in a database
(\s-1DBI\s0).
.PP
\fIAuthentication magic\fR
.IX Subsection "Authentication magic"
.PP
If you have included the session modules in your application, the
Authentication modules will automagically use your session to save and
retrieve the user data for you.
.PP
\fIUsing a session\fR
.IX Subsection "Using a session"
.PP
Once the session modules are loaded, the session is available as \f(CW\*(C`$c\->session\*(C'\fR, and can be writen to and read from as a simple hash
reference.
.PP
\fI\s-1EXAMPLE\s0\fR
.IX Subsection "EXAMPLE"
.PP
.Vb 3
\&  package MyApp;
\&  use Moose;
\&  use namespace::autoclean;
\&
\&  use Catalyst  qw/
\&                         Session
\&                         Session::Store::FastMmap
\&                         Session::State::Cookie
\&                   /;
\&  extends \*(AqCatalyst\*(Aq;
\&  _\|_PACKAGE_\|_\->setup;
\&
\&  package MyApp::Controller::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  BEGIN { extends \*(AqCatalyst::Controller\*(Aq };
\&  ## Write data into the session
\&
\&  sub add_item : Local {
\&     my ( $self, $c ) = @_;
\&
\&     my $item_id = $c\->req\->params\->{item};
\&
\&     push @{ $c\->session\->{items} }, $item_id;
\&
\&  }
\&
\&  ## A page later we retrieve the data from the session:
\&
\&  sub get_items : Local {
\&     my ( $self, $c ) = @_;
\&
\&     $c\->stash\->{items_to_display} = $c\->session\->{items};
\&
\&  }
.Ve
.PP
\fIMore information\fR
.IX Subsection "More information"
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session <http://search.cpan.org/dist/Catalyst-Plugin-Session>
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session\-State\-Cookie <http://search.cpan.org/dist/Catalyst-Plugin-Session-State-Cookie>
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session\-State\-URI <http://search.cpan.org/dist/Catalyst-Plugin-Session-State-URI>
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session\-Store\-FastMmap <http://search.cpan.org/dist/Catalyst-Plugin-Session-Store-FastMmap>
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session\-Store\-File <http://search.cpan.org/dist/Catalyst-Plugin-Session-Store-File>
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Session\-Store\-DBI <http://search.cpan.org/dist/Catalyst-Plugin-Session-Store-DBI>
.SS "Configure your application"
.IX Subsection "Configure your application"
You configure your application with the \f(CW\*(C`config\*(C'\fR method in your
application class. This can be hard-coded, or brought in from a
separate configuration file.
.PP
\fIUsing Config::General\fR
.IX Subsection "Using Config::General"
.PP
Config::General is a method for creating flexible
and readable configuration files. It's a great way to keep your
Catalyst application configuration in one easy-to-understand location.
.PP
Now create \f(CW\*(C`myapp.conf\*(C'\fR in your application home:
.PP
.Vb 1
\&  name     MyApp
\&
\&  # session; perldoc Catalyst::Plugin::Session::FastMmap
\&  <Session>
\&    expires 3600
\&    rewrite 0
\&    storage /tmp/myapp.session
\&  </Session>
\&
\&  # emails; perldoc Catalyst::Plugin::Email
\&  # this passes options as an array :(
\&  Mail SMTP
\&  Mail localhost
.Ve
.PP
This is equivalent to:
.PP
.Vb 10
\&  # configure base package
\&  _\|_PACKAGE_\|_\->config( name => MyApp );
\&  # configure authentication
\&  _\|_PACKAGE_\|_\->config(
\&        \*(AqPlugin::Authentication\*(Aq => {
\&            user_class => \*(AqMyApp::Model::MyDB::Customer\*(Aq,
\&            ...
\&        },
\&  _;
\&  # configure sessions
\&  _\|_PACKAGE_\|_\->config(
\&    session => {
\&        expires => 3600,
\&        ...
\&    },
\&  );
\&  # configure email sending
\&  _\|_PACKAGE_\|_\->config( email => [qw/SMTP localhost/] );
.Ve
.PP
Catalyst explains precedence of multiple sources for configuration
values, how to access the values in your components, and many 'base'
config variables used internally.
.PP
See also Config::General.
.SH "Skipping your VCS's directories"
.IX Header "Skipping your VCS's directories"
Catalyst uses Module::Pluggable to load Models, Views, and Controllers.
Module::Pluggable will scan through all directories and load modules
it finds.  Sometimes you might want to skip some of these directories,
for example when your version control system makes a subdirectory with
meta-information in every version-controlled directory.  While
Catalyst skips subversion and \s-1CVS\s0 directories already, there are other
source control systems.  Here is the configuration you need to add
their directories to the list to skip.
.PP
You can make Catalyst skip these directories using the Catalyst config:
.PP
.Vb 5
\&  # Configure the application
\&  _\|_PACKAGE_\|_\->config(
\&      name => \*(AqMyApp\*(Aq,
\&      setup_components => { except => qr/SCCS/ },
\&  );
.Ve
.PP
See the Module::Pluggable manual page for more information on \fBexcept\fR
and other options.
.SH "Users and Access Control"
.IX Header "Users and Access Control"
Most multiuser, and some single-user web applications require that
users identify themselves, and the application is often required to
define those roles.  The recipes below describe some ways of doing
this.
.SS "Authentication (logging in)"
.IX Subsection "Authentication (logging in)"
This is extensively covered in other documentation; see in particular
Catalyst::Plugin::Authentication and the Authentication chapter
of the Tutorial at Catalyst::Manual::Tutorial::06_Authorization.
.SS "Pass-through login (and other actions)"
.IX Subsection "Pass-through login (and other actions)"
An easy way of having assorted actions that occur during the processing
of a request that are orthogonal to its actual purpose \- logins, silent
commands etc. Provide actions for these, but when they're required for
something else fill e.g. a form variable _\|_login and have a sub begin
like so:
.PP
.Vb 8
\&    sub begin : Private {
\&      my ($self, $c) = @_;
\&      foreach my $action (qw/login docommand foo bar whatever/) {
\&        if ($c\->req\->params\->{"_\|_${action}"}) {
\&          $c\->forward($action);
\&        }
\&      }
\&    }
.Ve
.SS "Authentication/Authorization"
.IX Subsection "Authentication/Authorization"
This is done in several steps:
.IP "Verification" 4
.IX Item "Verification"
Getting the user to identify themselves, by giving you some piece of
information known only to you and the user. Then you can assume that
the user is who they say they are. This is called \fBcredential
verification\fR.
.IP "Authorization" 4
.IX Item "Authorization"
Making sure the user only accesses functions you want them to
access. This is done by checking the verified user's data against your
internal list of groups, or allowed persons for the current page.
.PP
\fIModules\fR
.IX Subsection "Modules"
.PP
The Catalyst Authentication system is made up of many interacting
modules, to give you the most flexibility possible.
.PP
Credential verifiers
.IX Subsection "Credential verifiers"
.PP
A Credential module tables the user input, and passes it to a Store,
or some other system, for verification. Typically, a user object is
created by either this module or the Store and made accessible by a
\&\f(CW\*(C`$c\->user\*(C'\fR call.
.PP
Examples:
.PP
.Vb 3
\& Password \- Simple username/password checking.
\& HTTPD    \- Checks using basic HTTP auth.
\& TypeKey  \- Check using the typekey system.
.Ve
.PP
\fIStorage backends\fR
.IX Subsection "Storage backends"
.PP
A Storage backend contains the actual data representing the users. It
is queried by the credential verifiers. Updating the store is not done
within this system; you will need to do it yourself.
.PP
Examples:
.PP
.Vb 2
\& DBIC     \- Storage using a database via DBIx::Class.
\& Minimal  \- Storage using a simple hash (for testing).
.Ve
.PP
\fIUser objects\fR
.IX Subsection "User objects"
.PP
A User object is created by either the storage backend or the
credential verifier, and is filled with the retrieved user information.
.PP
Examples:
.PP
.Vb 1
\& Hash     \- A simple hash of keys and values.
.Ve
.PP
\fI\s-1ACL\s0 authorization\fR
.IX Subsection "ACL authorization"
.PP
\&\s-1ACL\s0 stands for Access Control List. The \s-1ACL\s0 plugin allows you to
regulate access on a path-by-path basis, by listing which users, or
roles, have access to which paths.
.PP
\fIRoles authorization\fR
.IX Subsection "Roles authorization"
.PP
Authorization by roles is for assigning users to groups, which can
then be assigned to ACLs, or just checked when needed.
.PP
\fILogging in\fR
.IX Subsection "Logging in"
.PP
When you have chosen your modules, all you need to do is call the \f(CW\*(C`$c\->authenticate\*(C'\fR method. If called with no parameters, it will try to find
suitable parameters, such as \fBusername\fR and \fBpassword\fR, or you can
pass it these values.
.PP
\fIChecking roles\fR
.IX Subsection "Checking roles"
.PP
Role checking is done by using the \f(CW\*(C`$c\->check_user_roles\*(C'\fR method.
This will check using the currently logged-in user (via \f(CW\*(C`$c\->user\*(C'\fR). You pass it the name of a role to check, and it returns true if
the user is a member.
.PP
\fI\s-1EXAMPLE\s0\fR
.IX Subsection "EXAMPLE"
.PP
.Vb 8
\&  package MyApp;
\&  use Moose;
\&  use namespace::autoclean;
\&  extends qw/Catalyst/;
\&  use Catalyst qw/
\&    Authentication
\&    Authorization::Roles
\&  /;
\&
\&  _\|_PACKAGE_\|_\->config(
\&     authentication => {
\&         default_realm => \*(Aqtest\*(Aq,
\&         realms => {
\&             test => {
\&                 credential => {
\&                     class          => \*(AqPassword\*(Aq,
\&                     password_field => \*(Aqpassword\*(Aq,
\&                     password_type  => \*(Aqself_check\*(Aq,
\&                 },
\&                 store => {
\&                     class => \*(AqHtpasswd\*(Aq,
\&                     file => \*(Aqhtpasswd\*(Aq,
\&                 },
\&             },
\&         },
\&     },
\&  );
\&
\&  package MyApp::Controller::Root;
\&  use Moose;
\&  use namespace::autoclean;
\&
\&  BEGIN { extends \*(AqCatalyst::Controller\*(Aq }
\&
\&  _\|_PACKAGE_\|_\->config(namespace => \*(Aq\*(Aq);
\&
\&  sub login : Local {
\&     my ($self, $c) = @_;
\&
\&     if ( my $user = $c\->req\->params\->{user}
\&         and my $password = $c\->req\->param\->{password} )
\&     {
\&         if ( $c\->authenticate( username => $user, password => $password ) ) {
\&              $c\->res\->body( "hello " . $c\->user\->name );
\&         } else {
\&            # login incorrect
\&         }
\&     }
\&     else {
\&         # invalid form input
\&     }
\&  }
\&
\&  sub restricted : Local {
\&     my ( $self, $c ) = @_;
\&
\&     $c\->detach("unauthorized")
\&       unless $c\->check_user_roles( "admin" );
\&
\&     # do something restricted here
\&  }
.Ve
.PP
\fIUsing authentication in a testing environment\fR
.IX Subsection "Using authentication in a testing environment"
.PP
Ideally, to write tests for authentication/authorization code one would
first set up a test database with known data, then use
Test::WWW::Mechanize::Catalyst to simulate a user logging
in. Unfortunately this can be rather awkward, which is why it's a good
thing that the authentication framework is so flexible.
.PP
Instead of using a test database, one can simply change the
authentication store to something a bit easier to deal with in a
testing environment. Additionally, this has the advantage of not
modifying one's database, which can be problematic if one forgets to
use the testing instead of production database.
.PP
Alternatively, if you want to authenticate real users, but not have to
worry about their passwords, you can use
Catalyst::Authentication::Credential::Testing to force all users to
authenticate with a global password.
.PP
\fIMore information\fR
.IX Subsection "More information"
.PP
Catalyst::Plugin::Authentication has a longer explanation.
.SS "Authorization"
.IX Subsection "Authorization"
\fIIntroduction\fR
.IX Subsection "Introduction"
.PP
Authorization is the step that comes after
authentication. Authentication establishes that the user agent is really
representing the user we think it's representing, and then authorization
determines what this user is allowed to do.
.PP
\fIRole Based Access Control\fR
.IX Subsection "Role Based Access Control"
.PP
Under role based access control each user is allowed to perform any
number of roles. For example, at a zoo no one but specially trained
personnel can enter the moose cage (Mynd you, mA\*~XA\*~Xse bites kan be
pretty nasti!). For example:
.PP
.Vb 1
\&    package Zoo::Controller::MooseCage;
\&
\&    sub feed_moose : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->model( "Moose" )\->eat( $c\->req\->params\->{food} );
\&    }
.Ve
.PP
With this action, anyone can just come into the moose cage and feed
the moose, which is a very dangerous thing. We need to restrict this
action, so that only a qualified moose feeder can perform that action.
.PP
The Authorization::Roles plugin lets us perform role based access
control checks. Let's load it:
.PP
.Vb 5
\&    use parent qw/Catalyst/;
\&    use Catalyst qw/
\&                    Authentication
\&                    Authorization::Roles
\&                  /;
.Ve
.PP
And now our action should look like this:
.PP
.Vb 2
\&    sub feed_moose : Local {
\&        my ( $self, $c ) = @_;
\&
\&        if ( $c\->check_roles( "moose_feeder" ) ) {
\&            $c\->model( "Moose" )\->eat( $c\->req\->params\->{food} );
\&        } else {
\&            $c\->stash\->{error} = "unauthorized";
\&        }
\&    }
.Ve
.PP
This checks \f(CW\*(C`$c\->user\*(C'\fR, and only if the user has \fBall\fR the roles
in the list, a true value is returned.
.PP
\&\f(CW\*(C`check_roles\*(C'\fR has a sister method, \f(CW\*(C`assert_roles\*(C'\fR, which throws an
exception if any roles are missing.
.PP
Some roles that might actually make sense in, say, a forum application:
.IP "\(bu" 4
administrator
.IP "\(bu" 4
moderator
.PP
each with a distinct task (system administration versus content
administration).
.PP
\fIAccess Control Lists\fR
.IX Subsection "Access Control Lists"
.PP
Checking for roles all the time can be tedious and error prone.
.PP
The Authorization::ACL plugin lets us declare where we'd like checks
to be done automatically for us.
.PP
For example, we may want to completely block out anyone who isn't a
\&\f(CW\*(C`moose_feeder\*(C'\fR from the entire \f(CW\*(C`MooseCage\*(C'\fR controller:
.PP
.Vb 1
\&    Zoo\->deny_access_unless( "/moose_cage", [qw/moose_feeder/] );
.Ve
.PP
The role list behaves in the same way as \f(CW\*(C`check_roles\*(C'\fR. However, the
\&\s-1ACL\s0 plugin isn't limited to just interacting with the Roles plugin. We
can use a code reference instead. For example, to allow either moose
trainers or moose feeders into the moose cage, we can create a more
complex check:
.PP
.Vb 4
\&    Zoo\->deny_access_unless( "/moose_cage", sub {
\&        my $c = shift;
\&        $c\->check_roles( "moose_trainer" ) || $c\->check_roles( "moose_feeder" );
\&    });
.Ve
.PP
The more specific a role, the earlier it will be checked. Let's say
moose feeders are now restricted to only the \f(CW\*(C`feed_moose\*(C'\fR action,
while moose trainers get access everywhere:
.PP
.Vb 2
\&    Zoo\->deny_access_unless( "/moose_cage", [qw/moose_trainer/] );
\&    Zoo\->allow_access_if( "/moose_cage/feed_moose", [qw/moose_feeder/]);
.Ve
.PP
When the \f(CW\*(C`feed_moose\*(C'\fR action is accessed the second check will be
made. If the user is a \f(CW\*(C`moose_feeder\*(C'\fR, then access will be
immediately granted. Otherwise, the next rule in line will be tested \-
the one checking for a \f(CW\*(C`moose_trainer\*(C'\fR.  If this rule is not
satisfied, access will be immediately denied.
.PP
Rules applied to the same path will be checked in the order they were
added.
.PP
Lastly, handling access denial events is done by creating an
\&\f(CW\*(C`access_denied\*(C'\fR private action:
.PP
.Vb 3
\&    sub access_denied : Private {
\&        my ( $self, $c, $action ) = @_;
\&    }
.Ve
.PP
This action works much like auto, in that it is inherited across
namespaces (not like object oriented code). This means that the
\&\f(CW\*(C`access_denied\*(C'\fR action which is \fBnearest\fR to the action which was
blocked will be triggered.
.PP
If this action does not exist, an error will be thrown, which you can
clean up in your \f(CW\*(C`end\*(C'\fR private action instead.
.PP
Also, it's important to note that if you restrict access to \*(L"/\*(R" then
\&\f(CW\*(C`end\*(C'\fR, \f(CW\*(C`default\*(C'\fR, etc. will also be restricted.
.PP
.Vb 1
\&   MyApp\->acl_allow_root_internals;
.Ve
.PP
will create rules that permit access to \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`begin\*(C'\fR, and \f(CW\*(C`auto\*(C'\fR in the
root of your app (but not in any other controller).
.SH "Models"
.IX Header "Models"
Models are where application data belongs.  Catalyst is extremely
flexible with the kind of models that it can use.  The recipes here
are just the start.
.SS "Using existing \s-1DBIC\s0 (etc.) classes with Catalyst"
.IX Subsection "Using existing DBIC (etc.) classes with Catalyst"
Many people have existing Model classes that they would like to use
with Catalyst (or, conversely, they want to write Catalyst models that
can be used outside of Catalyst, e.g.  in a cron job). It's trivial to
write a simple component in Catalyst that slurps in an outside Model:
.PP
.Vb 1
\&    package MyApp::Model::DB;
\&
\&    use base qw/Catalyst::Model::DBIC::Schema/;
\&
\&    _\|_PACKAGE_\|_\->config(
\&        schema_class => \*(AqSome::DBIC::Schema\*(Aq,
\&        connect_info => [\*(Aqdbi:SQLite:foo.db\*(Aq, \*(Aq\*(Aq, \*(Aq\*(Aq, {AutoCommit=>1}],
\&    );
\&
\&    1;
.Ve
.PP
and that's it! Now \f(CW\*(C`Some::DBIC::Schema\*(C'\fR is part of your
Cat app as \f(CW\*(C`MyApp::Model::DB\*(C'\fR.
.SS "DBIx::Class as a Catalyst Model"
.IX Subsection "DBIx::Class as a Catalyst Model"
See Catalyst::Model::DBIC::Schema.
.SS "Create accessors to preload static data once per server instance"
.IX Subsection "Create accessors to preload static data once per server instance"
When you have data that you want to load just once from the model at
startup, instead of for each request, use mk_group_accessors to
create accessors and tie them to resultsets in your package that
inherits from DBIx::Class::Schema:
.PP
.Vb 6
\&    package My::Schema;
\&    use base qw/DBIx::Class::Schema/;
\&    _\|_PACKAGE_\|_\->register_class(\*(AqRESULTSOURCEMONIKER\*(Aq,
\&                                \*(AqMy::Schema::RESULTSOURCE\*(Aq);
\&    _\|_PACKAGE_\|_\->mk_group_accessors(\*(Aqsimple\*(Aq =>
\&                                qw(ACCESSORNAME1 ACCESSORNAME2 ACCESSORNAMEn));
\&
\&    sub connection {
\&        my ($self, @rest) = @_;
\&        $self\->next::method(@rest);
\&        # $self is now a live My::Schema object, complete with DB connection
\&
\&        $self\->ACCESSORNAME1([ $self\->resultset(\*(AqRESULTSOURCEMONIKER\*(Aq)\->all ]);
\&        $self\->ACCESSORNAME2([ $self\->resultset(\*(AqRESULTSOURCEMONIKER\*(Aq)\->search({ COLUMN => { \*(Aq<\*(Aq => \*(Aq30\*(Aq } })\->all ]);
\&        $self\->ACCESSORNAMEn([ $self\->resultset(\*(AqRESULTSOURCEMONIKER\*(Aq)\->find(1) ]);
\&    }
\&
\&    1;
.Ve
.PP
and now in the controller, you can now access any of these without a
per-request fetch:
.PP
.Vb 1
\&    $c\->stash\->{something} = $c\->model(\*(AqMy::Schema\*(Aq)\->schema\->ACCESSORNAME;
.Ve
.SS "\s-1XMLRPC\s0"
.IX Subsection "XMLRPC"
Unlike \s-1SOAP\s0, \s-1XMLRPC\s0 is a very simple (and elegant) web-services
protocol, exchanging small \s-1XML\s0 messages like these:
.PP
Request:
.PP
.Vb 9
\&    POST /api HTTP/1.1
\&    TE: deflate,gzip;q=0.3
\&    Connection: TE, close
\&    Accept: text/xml
\&    Accept: multipart/*
\&    Host: 127.0.0.1:3000
\&    User\-Agent: SOAP::Lite/Perl/0.60
\&    Content\-Length: 192
\&    Content\-Type: text/xml
\&
\&    <?xml version="1.0" encoding="UTF\-8"?>
\&    <methodCall>
\&        <methodName>add</methodName>
\&        <params>
\&            <param><value><int>1</int></value></param>
\&            <param><value><int>2</int></value></param>
\&        </params>
\&    </methodCall>
.Ve
.PP
Response:
.PP
.Vb 6
\&    Connection: close
\&    Date: Tue, 20 Dec 2005 07:45:55 GMT
\&    Content\-Length: 133
\&    Content\-Type: text/xml
\&    Status: 200
\&    X\-Catalyst: 5.70
\&
\&    <?xml version="1.0" encoding="us\-ascii"?>
\&    <methodResponse>
\&        <params>
\&            <param><value><int>3</int></value></param>
\&        </params>
\&    </methodResponse>
.Ve
.PP
Now follow these few steps to implement the application:
.PP
1. Install Catalyst (5.61 or later), Catalyst::Plugin::XMLRPC (0.06 or
later) and SOAP::Lite (for XMLRPCsh.pl).
.PP
2. Create an application framework:
.PP
.Vb 3
\&    % catalyst.pl MyApp
\&    ...
\&    % cd MyApp
.Ve
.PP
3. Add the \s-1XMLRPC\s0 plugin to MyApp.pm
.PP
.Vb 1
\&    use Catalyst qw/\-Debug Static::Simple XMLRPC/;
.Ve
.PP
4. Add an \s-1API\s0 controller
.PP
.Vb 1
\&    % ./script/myapp_create.pl controller API
.Ve
.PP
5. Add a \s-1XMLRPC\s0 redispatch method and an add method with Remote
attribute to lib/MyApp/Controller/API.pm
.PP
.Vb 4
\&    sub default :Path {
\&        my ( $self, $c ) = @_;
\&        $c\->xmlrpc;
\&    }
\&
\&    sub add : Remote {
\&        my ( $self, $c, $a, $b ) = @_;
\&        return $a + $b;
\&    }
.Ve
.PP
The default action is the entry point for each \s-1XMLRPC\s0 request. It will
redispatch every request to methods with Remote attribute in the same
class.
.PP
The \f(CW\*(C`add\*(C'\fR method is not a traditional action; it has no private or
public path. Only the \s-1XMLRPC\s0 dispatcher knows it exists.
.PP
6. That's it! You have built your first web service. Let's test it with
XMLRPCsh.pl (part of SOAP::Lite):
.PP
.Vb 7
\&    % ./script/myapp_server.pl
\&    ...
\&    % XMLRPCsh.pl http://127.0.0.1:3000/api
\&    Usage: method[(parameters)]
\&    > add( 1, 2 )
\&    \-\-\- XMLRPC RESULT \-\-\-
\&    \*(Aq3\*(Aq
.Ve
.PP
\fITip\fR
.IX Subsection "Tip"
.PP
Your return data type is usually auto-detected, but you can easily
enforce a specific one.
.PP
.Vb 4
\&    sub add : Remote {
\&        my ( $self, $c, $a, $b ) = @_;
\&        return RPC::XML::int\->new( $a + $b );
\&    }
.Ve
.SH "Views"
.IX Header "Views"
Views pertain to the display of your application.  As with models,
Catalyst is uncommonly flexible.  The recipes below are just a start.
.SS "Catalyst::View::TT"
.IX Subsection "Catalyst::View::TT"
One of the first things you probably want to do when starting a new
Catalyst application is set up your View. Catalyst doesn't care how you
display your data; you can choose to generate \s-1HTML\s0, \s-1PDF\s0 files, or plain
text if you wanted.
.PP
Most Catalyst applications use a template system to generate their \s-1HTML\s0,
and though there are several template systems available,
Template Toolkit is probably the most popular.
.PP
Once again, the Catalyst developers have done all the hard work, and
made things easy for the rest of us. Catalyst::View::TT provides the
interface to Template Toolkit, and provides Helpers which let us set it
up that much more easily.
.PP
\fICreating your View\fR
.IX Subsection "Creating your View"
.PP
Catalyst::View::TT provides two different helpers for us to use: \s-1TT\s0 and
TTSite.
.PP
\s-1TT\s0
.IX Subsection "TT"
.PP
Create a basic Template Toolkit View using the provided helper script:
.PP
.Vb 1
\&    script/myapp_create.pl view TT TT
.Ve
.PP
This will create lib/MyApp/View/MyView.pm, which is going to be pretty
empty to start. However, it sets everything up that you need to get
started. You can now define which template you want and forward to your
view. For instance:
.PP
.Vb 2
\&    sub hello : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->stash\->{template} = \*(Aqhello.tt\*(Aq;
\&
\&        $c\->forward( $c\->view(\*(AqTT\*(Aq) );
\&    }
.Ve
.PP
In practice you wouldn't do the forwarding manually, but would
use Catalyst::Action::RenderView.
.PP
TTSite
.IX Subsection "TTSite"
.PP
Although the \s-1TT\s0 helper does create a functional, working view, you may
find yourself having to create the same template files and changing the
same options every time you create a new application. The TTSite helper
saves us even more time by creating the basic templates and setting some
common options for us.
.PP
Once again, you can use the helper script:
.PP
.Vb 1
\&    script/myapp_create.pl view TT TTSite
.Ve
.PP
This time, the helper sets several options for us in the generated View.
.PP
.Vb 11
\&    _\|_PACKAGE_\|_\->config({
\&        CATALYST_VAR => \*(AqCatalyst\*(Aq,
\&        INCLUDE_PATH => [
\&            MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqsrc\*(Aq ),
\&            MyApp\->path_to( \*(Aqroot\*(Aq, \*(Aqlib\*(Aq )
\&        ],
\&        PRE_PROCESS  => \*(Aqconfig/main\*(Aq,
\&        WRAPPER      => \*(Aqsite/wrapper\*(Aq,
\&        ERROR        => \*(Aqerror.tt2\*(Aq,
\&        TIMER        => 0
\&    });
.Ve
.IP "\(bu" 4
\&\s-1INCLUDE_PATH\s0 defines the directories that Template Toolkit should search
for the template files.
.IP "\(bu" 4
\&\s-1PRE_PROCESS\s0 is used to process configuration options which are common to
every template file.
.IP "\(bu" 4
\&\s-1WRAPPER\s0 is a file which is processed with each template, usually used to
easily provide a common header and footer for every page.
.PP
In addition to setting these options, the TTSite helper also created the
template and config files for us! In the 'root' directory, you'll notice
two new directories: src and lib.
.PP
Several configuration files in root/lib/config are called by \s-1PRE_PROCESS\s0.
.PP
The files in root/lib/site are the site-wide templates, called by
\&\s-1WRAPPER\s0, and display the html framework, control the layout, and provide
the templates for the header and footer of your page. Using the template
organization provided makes it much easier to standardize pages and make
changes when they are (inevitably) needed.
.PP
The template files that you will create for your application will go
into root/src, and you don't need to worry about putting the the <html>
or <head> sections; just put in the content. The \s-1WRAPPER\s0 will the rest
of the page around your template for you.
.PP
\fI\f(CI$c\fI\->stash\fR
.IX Subsection "$c->stash"
.PP
Of course, having the template system include the header and footer for
you isn't all that we want our templates to do. We need to be able to
put data into our templates, and have it appear where and how we want
it, right? That's where the stash comes in.
.PP
In our controllers, we can add data to the stash, and then access it
from the template. For instance:
.PP
.Vb 2
\&    sub hello : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->stash\->{name} = \*(AqAdam\*(Aq;
\&
\&        $c\->stash\->{template} = \*(Aqhello.tt\*(Aq;
\&
\&        $c\->forward( $c\->view(\*(AqTT\*(Aq) );
\&    }
.Ve
.PP
Then, in hello.tt:
.PP
.Vb 1
\&    <strong>Hello, [% name %]!</strong>
.Ve
.PP
When you view this page, it will display \*(L"Hello, Adam!\*(R"
.PP
All of the information in your stash is available, by its name/key, in
your templates. And your data don't have to be plain, old, boring
scalars. You can pass array references and hash references, too.
.PP
In your controller:
.PP
.Vb 2
\&    sub hello : Local {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->stash\->{names} = [ \*(AqAdam\*(Aq, \*(AqDave\*(Aq, \*(AqJohn\*(Aq ];
\&
\&        $c\->stash\->{template} = \*(Aqhello.tt\*(Aq;
\&
\&        $c\->forward( $c\->view(\*(AqTT\*(Aq) );
\&    }
.Ve
.PP
In hello.tt:
.PP
.Vb 3
\&    [% FOREACH name IN names %]
\&        <strong>Hello, [% name %]!</strong><br />
\&    [% END %]
.Ve
.PP
This allowed us to loop through each item in the arrayref, and display a
line for each name that we have.
.PP
This is the most basic usage, but Template Toolkit is quite powerful,
and allows you to truly keep your presentation logic separate from the
rest of your application.
.PP
\fI\f(CI$c\fI\->\fIuri_for()\fI\fR
.IX Subsection "$c->uri_for()"
.PP
One of my favorite things about Catalyst is the ability to move an
application around without having to worry that everything is going to
break. One of the areas that used to be a problem was with the http
links in your template files. For example, suppose you have an
application installed at http://www.domain.com/Calendar. The links point
to \*(L"/Calendar\*(R", \*(L"/Calendar/2005\*(R", \*(L"/Calendar/2005/10\*(R", etc.  If you move
the application to be at http://www.mydomain.com/Tools/Calendar, then
all of those links will suddenly break.
.PP
That's where \f(CW$c\fR\->\fIuri_for()\fR comes in. This function will merge its
parameters with either the base location for the app, or its current
namespace. Let's take a look at a couple of examples.
.PP
In your template, you can use the following:
.PP
.Vb 1
\&    <a href="[% c.uri_for(\*(Aq/login\*(Aq) %]">Login Here</a>
.Ve
.PP
Although the parameter starts with a forward slash, this is relative
to the application root, not the webserver root. This is important to
remember. So, if your application is installed at
http://www.domain.com/Calendar, then the link would be
http://www.mydomain.com/Calendar/Login. If you move your application
to a different domain or path, then that link will still be correct.
.PP
Likewise,
.PP
.Vb 1
\&    <a href="[% c.uri_for(\*(Aq2005\*(Aq,\*(Aq10\*(Aq, \*(Aq24\*(Aq) %]">October, 24 2005</a>
.Ve
.PP
The first parameter does \s-1NOT\s0 have a forward slash, and so it will be
relative to the current namespace. If the application is installed at
http://www.domain.com/Calendar. and if the template is called from
MyApp::Controller::Display, then the link would become
http://www.domain.com/Calendar/Display/2005/10/24.
.PP
If you want to link to a parent uri of your current namespace you can
prefix the arguments with multiple '../':
.PP
.Vb 1
\&    <a href="[% c.uri_for(\*(Aq../../view\*(Aq, stashed_object.id) %]">User view</a>
.Ve
.PP
Once again, this allows you to move your application around without
having to worry about broken links. But there's something else, as
well. Since the links are generated by uri_for, you can use the same
template file by several different controllers, and each controller
will get the links that its supposed to. Since we believe in Don't
Repeat Yourself, this is particularly helpful if you have common
elements in your site that you want to keep in one file.
.PP
Further Reading:
.PP
<http://search.cpan.org/perldoc?Catalyst>
.PP
<http://search.cpan.org/perldoc?Catalyst%3A%3AView%3A%3ATT>
.PP
<http://search.cpan.org/perldoc?Template>
.SS "Adding \s-1RSS\s0 feeds"
.IX Subsection "Adding RSS feeds"
Adding \s-1RSS\s0 feeds to your Catalyst applications is simple. We'll see two
different approaches here, but the basic premise is that you forward to
the normal view action first to get the objects, then handle the output
differently.
.PP
\fIUsing XML::Feed\fR
.IX Subsection "Using XML::Feed"
.PP
Assuming we have a \f(CW\*(C`view\*(C'\fR action that populates
\&'entries' with some DBIx::Class iterator, the code would look something
like this:
.PP
.Vb 3
\&    sub rss : Local {
\&        my ($self,$c) = @_;
\&        $c\->forward(\*(Aqview\*(Aq); # get the entries
\&
\&        my $feed = XML::Feed\->new(\*(AqRSS\*(Aq);
\&        $feed\->title( $c\->config\->{name} . \*(Aq RSS Feed\*(Aq );
\&        $feed\->link( $c\->req\->base ); # link to the site.
\&        $feed\->description(\*(AqCatalyst advent calendar\*(Aq); Some description
\&
\&        # Process the entries
\&        while( my $entry = $c\->stash\->{entries}\->next ) {
\&            my $feed_entry = XML::Feed::Entry\->new(\*(AqRSS\*(Aq);
\&            $feed_entry\->title($entry\->title);
\&            $feed_entry\->link( $c\->uri_for($entry\->link) );
\&            $feed_entry\->issued( DateTime\->from_epoch(epoch => $entry\->created) );
\&            $feed\->add_entry($feed_entry);
\&        }
\&        $c\->res\->body( $feed\->as_xml );
\&   }
.Ve
.PP
With this approach you're
pretty sure to get something that validates.
.PP
Note that for both of the above approaches, you'll need to set the
content type like this:
.PP
.Vb 1
\&    $c\->res\->content_type(\*(Aqapplication/rss+xml\*(Aq);
.Ve
.PP
\fIFinal words\fR
.IX Subsection "Final words"
.PP
You could generalize the second variant easily by replacing '\s-1RSS\s0' with a
variable, so you can generate Atom feeds with the same code.
.PP
Now, go ahead and make \s-1RSS\s0 feeds for all your stuff. The world *needs*
updates on your goldfish!
.SS "Forcing the browser to download content"
.IX Subsection "Forcing the browser to download content"
Sometimes you need your application to send content for download. For
example, you can generate a comma-separated values (\s-1CSV\s0) file for your
users to download and import into their spreadsheet program.
.PP
Let's say you have an \f(CW\*(C`Orders\*(C'\fR controller which generates a \s-1CSV\s0 file
in the \f(CW\*(C`export\*(C'\fR action (i.e., \f(CW\*(C`http://localhost:3000/orders/export\*(C'\fR):
.PP
.Vb 2
\&    sub export : Local Args(0) {
\&        my ( $self, $c ) = @_;
\&
\&        # In a real application, you\*(Aqd generate this from the database
\&        my $csv = "1,5.99\en2,29.99\en3,3.99\en";
\&
\&        $c\->res\->content_type(\*(Aqtext/comma\-separated\-values\*(Aq);
\&        $c\->res\->body($csv);
\&    }
.Ve
.PP
Normally the browser uses the last part of the \s-1URI\s0 to generate a
filename for data it cannot display. In this case your browser would
likely ask you to save a file named \f(CW\*(C`export\*(C'\fR.
.PP
Luckily you can have the browser download the content with a specific
filename by setting the \f(CW\*(C`Content\-Disposition\*(C'\fR header:
.PP
.Vb 2
\&    my $filename = \*(AqImportant Orders.csv\*(Aq;
\&    $c\->res\->header(\*(AqContent\-Disposition\*(Aq, qq[attachment; filename="$filename"]);
.Ve
.PP
Note the use of quotes around the filename; this ensures that any
spaces in the filename are handled by the browser.
.PP
Put this right before calling \f(CW\*(C`$c\->res\->body\*(C'\fR and your browser
will download a file named \f(CW\*(C`Important Orders.csv\*(C'\fR instead of
\&\f(CW\*(C`export\*(C'\fR.
.PP
You can also use this to have the browser download content which it
normally displays, such as \s-1JPEG\s0 images or even \s-1HTML\s0. Just be sure to
set the appropriate content type and disposition.
.SH "Controllers"
.IX Header "Controllers"
Controllers are the main point of communication between the web server
and your application.  Here we explore some aspects of how they work.
.SS "Action Types"
.IX Subsection "Action Types"
\fIIntroduction\fR
.IX Subsection "Introduction"
.PP
A Catalyst application is driven by one or more Controller
modules. There are a number of ways that Catalyst can decide which of
the methods in your controller modules it should call. Controller
methods are also called actions, because they determine how your
catalyst application should (re\-)act to any given \s-1URL\s0. When the
application is started up, catalyst looks at all your actions, and
decides which URLs they map to.
.PP
\fIType attributes\fR
.IX Subsection "Type attributes"
.PP
Each action is a normal method in your controller, except that it has an
attribute
attached. These can be one of several types.
.PP
Assume our Controller module starts with the following package declaration:
.PP
.Vb 1
\& package MyApp::Controller::Buckets;
.Ve
.PP
and we are running our application on localhost, port 3000 (the test
server default).
.IP "Path" 4
.IX Item "Path"
A Path attribute also takes an argument, this can be either a relative
or an absolute path. A relative path will be relative to the
controller namespace, an absolute path will represent an exact
matching \s-1URL\s0.
.Sp
.Vb 1
\& sub my_handles : Path(\*(Aqhandles\*(Aq) { .. }
.Ve
.Sp
becomes
.Sp
.Vb 1
\& http://localhost:3000/buckets/handles
.Ve
.Sp
and
.Sp
.Vb 1
\& sub my_handles : Path(\*(Aq/handles\*(Aq) { .. }
.Ve
.Sp
becomes
.Sp
.Vb 1
\& http://localhost:3000/handles
.Ve
.Sp
See also: Catalyst::DispatchType::Path
.IP "Local" 4
.IX Item "Local"
When using a Local attribute, no parameters are needed, instead, the
name of the action is matched in the \s-1URL\s0. The namespaces created by
the name of the controller package is always part of the \s-1URL\s0.
.Sp
.Vb 1
\& sub my_handles : Local { .. }
.Ve
.Sp
becomes
.Sp
.Vb 1
\& http://localhost:3000/buckets/my_handles
.Ve
.IP "Global" 4
.IX Item "Global"
A Global attribute is similar to a Local attribute, except that the
namespace of the controller is ignored, and matching starts at root.
.Sp
.Vb 1
\& sub my_handles : Global { .. }
.Ve
.Sp
becomes
.Sp
.Vb 1
\& http://localhost:3000/my_handles
.Ve
.IP "Regex" 4
.IX Item "Regex"
By now you should have figured that a Regex attribute is just what it
sounds like. This one takes a regular expression, and matches starting
from root. These differ from the rest as they can match multiple URLs.
.Sp
.Vb 1
\& sub my_handles : Regex(\*(Aq^handles\*(Aq) { .. }
.Ve
.Sp
matches
.Sp
.Vb 1
\& http://localhost:3000/handles
.Ve
.Sp
and
.Sp
.Vb 1
\& http://localhost:3000/handles_and_other_parts
.Ve
.Sp
etc.
.Sp
See also: Catalyst::DispatchType::Regex
.IP "LocalRegex" 4
.IX Item "LocalRegex"
A LocalRegex is similar to a Regex, except it only matches below the current
controller namespace.
.Sp
.Vb 1
\& sub my_handles : LocalRegex(^handles\*(Aq) { .. }
.Ve
.Sp
matches
.Sp
.Vb 1
\& http://localhost:3000/buckets/handles
.Ve
.Sp
and
.Sp
.Vb 1
\& http://localhost:3000/buckets/handles_and_other_parts
.Ve
.Sp
etc.
.IP "Chained" 4
.IX Item "Chained"
See Catalyst::DispatchType::Chained for a description of how the chained
dispatch type works.
.IP "Private" 4
.IX Item "Private"
Last but not least, there is the Private attribute, which allows you
to create your own internal actions, which can be forwarded to, but
won't be matched as URLs.
.Sp
.Vb 1
\& sub my_handles : Private { .. }
.Ve
.Sp
becomes nothing at all..
.Sp
Catalyst also predefines some special Private actions, which you can
override, these are:
.RS 4
.IP "default" 4
.IX Item "default"
The default action will be called, if no other matching action is
found. If you don't have one of these in your namespace, or any sub
part of your namespace, you'll get an error page instead. If you want
to find out where it was the user was trying to go, you can look in
the request object using \f(CW\*(C`$c\->req\->path\*(C'\fR.
.Sp
.Vb 1
\& sub default :Path { .. }
.Ve
.Sp
works for all unknown URLs, in this controller namespace, or every one
if put directly into MyApp.pm.
.IP "index" 4
.IX Item "index"
The index action is called when someone tries to visit the exact
namespace of your controller. If index, default and matching Path
actions are defined, then index will be used instead of default and
Path.
.Sp
.Vb 1
\& sub index :Path :Args(0) { .. }
.Ve
.Sp
becomes
.Sp
.Vb 1
\& http://localhost:3000/buckets
.Ve
.IP "begin" 4
.IX Item "begin"
The begin action is called at the beginning of every request involving
this namespace directly, before other matching actions are called. It
can be used to set up variables/data for this particular part of your
app. A single begin action is called, its always the one most relevant
to the current namespace.
.Sp
.Vb 1
\& sub begin : Private { .. }
.Ve
.Sp
is called once when
.Sp
.Vb 1
\& http://localhost:3000/bucket/(anything)?
.Ve
.Sp
is visited.
.IP "end" 4
.IX Item "end"
Like begin, this action is always called for the namespace it is in,
after every other action has finished. It is commonly used to forward
processing to the View component. A single end action is called, its
always the one most relevant to the current namespace.
.Sp
.Vb 1
\& sub end : Private { .. }
.Ve
.Sp
is called once after any actions when
.Sp
.Vb 1
\& http://localhost:3000/bucket/(anything)?
.Ve
.Sp
is visited.
.IP "auto" 4
.IX Item "auto"
Lastly, the auto action is magic in that \fBevery\fR auto action in the
chain of paths up to and including the ending namespace, will be
called. (In contrast, only one of the begin/end/default actions will
be called, the relevant one).
.Sp
.Vb 2
\& package MyApp::Controller::Root;
\& sub auto : Private { .. }
.Ve
.Sp
and
.Sp
.Vb 1
\& sub auto : Private { .. }
.Ve
.Sp
will both be called when visiting
.Sp
.Vb 1
\& http://localhost:3000/bucket/(anything)?
.Ve
.RE
.RS 4
.RE
.PP
\fIA word of warning\fR
.IX Subsection "A word of warning"
.PP
You can put root actions in your main MyApp.pm file, but this is deprecated,
please put your actions into your Root controller.
.PP
\fIFlowchart\fR
.IX Subsection "Flowchart"
.PP
A graphical flowchart of how the dispatcher works can be found on the wiki at
http://dev.catalyst.perl.org/attachment/wiki/WikiStart/catalyst\-flow.png <http://dev.catalyst.perl.org/attachment/wiki/WikiStart/catalyst-flow.png>.
.SS "\s-1DRY\s0 Controllers with Chained actions"
.IX Subsection "DRY Controllers with Chained actions"
Imagine that you would like the following paths in your application:
.IP "\fB/cd/<\s-1ID\s0>/track/<\s-1ID\s0>\fR" 4
.IX Item "/cd/<ID>/track/<ID>"
Displays info on a particular track.
.Sp
In the case of a multi-volume \s-1CD\s0, this is the track sequence.
.IP "\fB/cd/<\s-1ID\s0>/volume/<\s-1ID\s0>/track/<\s-1ID\s0>\fR" 4
.IX Item "/cd/<ID>/volume/<ID>/track/<ID>"
Displays info on a track on a specific volume.
.PP
Here is some example code, showing how to do this with chained controllers:
.PP
.Vb 2
\&    package CD::Controller;
\&    use base qw/Catalyst::Controller/;
\&
\&    sub root : Chained(\*(Aq/\*(Aq) PathPart(\*(Aq/cd\*(Aq) CaptureArgs(1) {
\&        my ($self, $c, $cd_id) = @_;
\&        $c\->stash\->{cd_id} = $cd_id;
\&        $c\->stash\->{cd} = $self\->model(\*(AqCD\*(Aq)\->find_by_id($cd_id);
\&    }
\&
\&    sub trackinfo : Chained(\*(Aqtrack\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) RenderView {
\&        my ($self, $c) = @_;
\&    }
\&
\&    package CD::Controller::ByTrackSeq;
\&    use base qw/CD::Controller/;
\&
\&    sub track : Chained(\*(Aqroot\*(Aq) PathPart(\*(Aqtrack\*(Aq) CaptureArgs(1) {
\&        my ($self, $c, $track_seq) = @_;
\&        $c\->stash\->{track} = $self\->stash\->{cd}\->find_track_by_seq($track_seq);
\&    }
\&
\&    package CD::Controller::ByTrackVolNo;
\&    use base qw/CD::Controller/;
\&
\&    sub volume : Chained(\*(Aqroot\*(Aq) PathPart(\*(Aqvolume\*(Aq) CaptureArgs(1) {
\&        my ($self, $c, $volume) = @_;
\&        $c\->stash\->{volume} = $volume;
\&    }
\&
\&    sub track : Chained(\*(Aqvolume\*(Aq) PathPart(\*(Aqtrack\*(Aq) CaptureArgs(1) {
\&        my ($self, $c, $track_no) = @_;
\&        $c\->stash\->{track} = $self\->stash\->{cd}\->find_track_by_vol_and_track_no(
\&            $c\->stash\->{volume}, $track_no
\&        );
\&    }
.Ve
.PP
Note that adding other actions (i.e. chain endpoints) which operate on a track
is simply a matter of adding a new sub to CD::Controller \- no code is duplicated,
even though there are two different methods of looking up a track.
.PP
This technique can be expanded as needed to fulfil your requirements \- for example,
if you inherit the first action of a chain from a base class, then mixing in a
different base class can be used to duplicate an entire \s-1URL\s0 hierarchy at a different
point within your application.
.SS "Component-based Subrequests"
.IX Subsection "Component-based Subrequests"
See Catalyst::Plugin::SubRequest.
.SS "File uploads"
.IX Subsection "File uploads"
\fISingle file upload with Catalyst\fR
.IX Subsection "Single file upload with Catalyst"
.PP
To implement uploads in Catalyst, you need to have a \s-1HTML\s0 form similar to
this:
.PP
.Vb 5
\&    <form action="/upload" method="post" enctype="multipart/form\-data">
\&      <input type="hidden" name="form_submit" value="yes">
\&      <input type="file" name="my_file">
\&      <input type="submit" value="Send">
\&    </form>
.Ve
.PP
It's very important not to forget \f(CW\*(C`enctype="multipart/form\-data"\*(C'\fR in
the form.
.PP
Catalyst Controller module 'upload' action:
.PP
.Vb 2
\&    sub upload : Global {
\&        my ($self, $c) = @_;
\&
\&        if ( $c\->request\->parameters\->{form_submit} eq \*(Aqyes\*(Aq ) {
\&
\&            if ( my $upload = $c\->request\->upload(\*(Aqmy_file\*(Aq) ) {
\&
\&                my $filename = $upload\->filename;
\&                my $target   = "/tmp/upload/$filename";
\&
\&                unless ( $upload\->link_to($target) || $upload\->copy_to($target) ) {
\&                    die( "Failed to copy \*(Aq$filename\*(Aq to \*(Aq$target\*(Aq: $!" );
\&                }
\&            }
\&        }
\&
\&        $c\->stash\->{template} = \*(Aqfile_upload.html\*(Aq;
\&    }
.Ve
.PP
\fIMultiple file upload with Catalyst\fR
.IX Subsection "Multiple file upload with Catalyst"
.PP
Code for uploading multiple files from one form needs a few changes:
.PP
The form should have this basic structure:
.PP
.Vb 7
\&    <form action="/upload" method="post" enctype="multipart/form\-data">
\&      <input type="hidden" name="form_submit" value="yes">
\&      <input type="file" name="file1" size="50"><br>
\&      <input type="file" name="file2" size="50"><br>
\&      <input type="file" name="file3" size="50"><br>
\&      <input type="submit" value="Send">
\&    </form>
.Ve
.PP
And in the controller:
.PP
.Vb 2
\&    sub upload : Local {
\&        my ($self, $c) = @_;
\&
\&        if ( $c\->request\->parameters\->{form_submit} eq \*(Aqyes\*(Aq ) {
\&
\&            for my $field ( $c\->req\->upload ) {
\&
\&                my $upload   = $c\->req\->upload($field);
\&                my $filename = $upload\->filename;
\&                my $target   = "/tmp/upload/$filename";
\&
\&                unless ( $upload\->link_to($target) || $upload\->copy_to($target) ) {
\&                    die( "Failed to copy \*(Aq$filename\*(Aq to \*(Aq$target\*(Aq: $!" );
\&                }
\&            }
\&        }
\&
\&        $c\->stash\->{template} = \*(Aqfile_upload.html\*(Aq;
\&    }
.Ve
.PP
\&\f(CW\*(C`for my $field ($c\->req\-\*(C'\fRupload)> loops automatically over all file
input fields and gets input names. After that is basic file saving code,
just like in single file upload.
.PP
Notice: \f(CW\*(C`die\*(C'\fRing might not be what you want to do, when an error
occurs, but it works as an example. A better idea would be to store
error \f(CW$!\fR in \f(CW$c\fR\->stash\->{error} and show a custom error template
displaying this message.
.PP
For more information about uploads and usable methods look at
Catalyst::Request::Upload and Catalyst::Request.
.SS "Forwarding with arguments"
.IX Subsection "Forwarding with arguments"
Sometimes you want to pass along arguments when forwarding to another
action. As of version 5.30, arguments can be passed in the call to
\&\f(CW\*(C`forward\*(C'\fR; in earlier versions, you can manually set the arguments in
the Catalyst Request object:
.PP
.Vb 2
\&  # version 5.30 and later:
\&  $c\->forward(\*(Aq/wherever\*(Aq, [qw/arg1 arg2 arg3/]);
\&
\&  # pre\-5.30
\&  $c\->req\->args([qw/arg1 arg2 arg3/]);
\&  $c\->forward(\*(Aq/wherever\*(Aq);
.Ve
.PP
(See the Catalyst::Manual::Intro Flow_Control section for more
information on passing arguments via \f(CW\*(C`forward\*(C'\fR.)
.SS "Chained dispatch using base classes, and inner packages."
.IX Subsection "Chained dispatch using base classes, and inner packages."
.Vb 2
\&  package MyApp::Controller::Base;
\&  use base qw/Catalyst::Controller/;
\&
\&  sub key1 : Chained(\*(Aq/\*(Aq)
.Ve
.SS "Extending RenderView (formerly DefaultEnd)"
.IX Subsection "Extending RenderView (formerly DefaultEnd)"
The recommended approach for an \f(CW\*(C`end\*(C'\fR action is to use
Catalyst::Action::RenderView (taking the place of
Catalyst::Plugin::DefaultEnd), which does what you usually need.
However there are times when you need to add a bit to it, but don't want
to write your own \f(CW\*(C`end\*(C'\fR action.
.PP
You can extend it like this:
.PP
To add something to an \f(CW\*(C`end\*(C'\fR action that is called before rendering
(this is likely to be what you want), simply place it in the \f(CW\*(C`end\*(C'\fR
method:
.PP
.Vb 4
\&    sub end : ActionClass(\*(AqRenderView\*(Aq) {
\&      my ( $self, $c ) = @_;
\&      # do stuff here; the RenderView action is called afterwards
\&    }
.Ve
.PP
To add things to an \f(CW\*(C`end\*(C'\fR action that are called \fIafter\fR rendering,
you can set it up like this:
.PP
.Vb 1
\&    sub render : ActionClass(\*(AqRenderView\*(Aq) { }
\&
\&    sub end : Private {
\&      my ( $self, $c ) = @_;
\&      $c\->forward(\*(Aqrender\*(Aq);
\&      # do stuff here
\&    }
.Ve
.SS "Serving static content"
.IX Subsection "Serving static content"
Serving static content in Catalyst used to be somewhat tricky; the use
of Catalyst::Plugin::Static::Simple makes everything much easier.
This plugin will automatically serve your static content during development,
but allows you to easily switch to Apache (or other server) in a
production environment.
.PP
\fIIntroduction to Static::Simple\fR
.IX Subsection "Introduction to Static::Simple"
.PP
Static::Simple is a plugin that will help to serve static content for your
application. By default, it will serve most types of files, excluding some
standard Template Toolkit extensions, out of your \fBroot\fR file directory. All
files are served by path, so if \fBimages/me.jpg\fR is requested, then
\&\fBroot/images/me.jpg\fR is found and served.
.PP
\fIUsage\fR
.IX Subsection "Usage"
.PP
Using the plugin is as simple as setting your use line in MyApp.pm to include:
.PP
.Vb 1
\& use Catalyst qw/Static::Simple/;
.Ve
.PP
and already files will be served.
.PP
\fIConfiguring\fR
.IX Subsection "Configuring"
.PP
Static content is best served from a single directory within your root
directory. Having many different directories such as \f(CW\*(C`root/css\*(C'\fR and
\&\f(CW\*(C`root/images\*(C'\fR requires more code to manage, because you must separately
identify each static directory\*(--if you decide to add a \f(CW\*(C`root/js\*(C'\fR
directory, you'll need to change your code to account for it. In
contrast, keeping all static directories as subdirectories of a main
\&\f(CW\*(C`root/static\*(C'\fR directory makes things much easier to manage. Here's an
example of a typical root directory structure:
.PP
.Vb 8
\&    root/
\&    root/content.tt
\&    root/controller/stuff.tt
\&    root/header.tt
\&    root/static/
\&    root/static/css/main.css
\&    root/static/images/logo.jpg
\&    root/static/js/code.js
.Ve
.PP
All static content lives under \f(CW\*(C`root/static\*(C'\fR, with everything else being
Template Toolkit files.
.IP "Include Path" 4
.IX Item "Include Path"
You may of course want to change the default locations, and make
Static::Simple look somewhere else, this is as easy as:
.Sp
.Vb 8
\& MyApp\->config(
\&    static => {
\&        include_path => [
\&            MyApp\->path_to(\*(Aq/\*(Aq),
\&            \*(Aq/path/to/my/files\*(Aq,
\&        ],
\&    },
\&  );
.Ve
.Sp
When you override include_path, it will not automatically append the
normal root path, so you need to add it yourself if you still want
it. These will be searched in order given, and the first matching file
served.
.IP "Static directories" 4
.IX Item "Static directories"
If you want to force some directories to be only static, you can set
them using paths relative to the root dir, or regular expressions:
.Sp
.Vb 8
\& MyApp\->config(
\&    static => {
\&        dirs => [
\&            \*(Aqstatic\*(Aq,
\&            qr/^(images|css)/,
\&        ],
\&    },
\&  );
.Ve
.IP "File extensions" 4
.IX Item "File extensions"
By default, the following extensions are not served (that is, they will
be processed by Catalyst): \fBtmpl, tt, tt2, html, xhtml\fR. This list can
be replaced easily:
.Sp
.Vb 7
\& MyApp\->config(
\&        static => {
\&            ignore_extensions => [
\&                qw/tmpl tt tt2 html xhtml/
\&            ],
\&        },
\&  );
.Ve
.IP "Ignoring directories" 4
.IX Item "Ignoring directories"
Entire directories can be ignored. If used with include_path,
directories relative to the include_path dirs will also be ignored:
.Sp
.Vb 3
\&  MyApp\->config( static => {
\&        ignore_dirs => [ qw/tmpl css/ ],
\&  });
.Ve
.PP
\fIMore information\fR
.IX Subsection "More information"
.PP
http://search.cpan.org/dist/Catalyst\-Plugin\-Static\-Simple/ <http://search.cpan.org/dist/Catalyst-Plugin-Static-Simple/>
.PP
\fIServing manually with the Static plugin with HTTP::Daemon (myapp_server.pl)\fR
.IX Subsection "Serving manually with the Static plugin with HTTP::Daemon (myapp_server.pl)"
.PP
In some situations you might want to control things more directly,
using Catalyst::Plugin::Static.
.PP
In your main application class (MyApp.pm), load the plugin:
.PP
.Vb 1
\&    use Catalyst qw/\-Debug FormValidator Static OtherPlugin/;
.Ve
.PP
You will also need to make sure your end method does \fInot\fR forward
static content to the view, perhaps like this:
.PP
.Vb 2
\&    sub end : Private {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->forward( \*(AqMyApp::View::TT\*(Aq )
\&          unless ( $c\->res\->body || !$c\->stash\->{template} );
\&    }
.Ve
.PP
This code will only forward to the view if a template has been
previously defined by a controller and if there is not already data in
\&\f(CW\*(C`$c\->res\->body\*(C'\fR.
.PP
Next, create a controller to handle requests for the /static path. Use
the Helper to save time. This command will create a stub controller as
\&\f(CW\*(C`lib/MyApp/Controller/Static.pm\*(C'\fR.
.PP
.Vb 1
\&    $ script/myapp_create.pl controller Static
.Ve
.PP
Edit the file and add the following methods:
.PP
.Vb 3
\&    # serve all files under /static as static files
\&    sub default : Path(\*(Aq/static\*(Aq) {
\&        my ( $self, $c ) = @_;
\&
\&        # Optional, allow the browser to cache the content
\&        $c\->res\->headers\->header( \*(AqCache\-Control\*(Aq => \*(Aqmax\-age=86400\*(Aq );
\&
\&        $c\->serve_static; # from Catalyst::Plugin::Static
\&    }
\&
\&    # also handle requests for /favicon.ico
\&    sub favicon : Path(\*(Aq/favicon.ico\*(Aq) {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->serve_static;
\&    }
.Ve
.PP
You can also define a different icon for the browser to use instead of
favicon.ico by using this in your \s-1HTML\s0 header:
.PP
.Vb 1
\&    <link rel="icon" href="/static/myapp.ico" type="image/x\-icon" />
.Ve
.PP
\fICommon problems with the Static plugin\fR
.IX Subsection "Common problems with the Static plugin"
.PP
The Static plugin makes use of the \f(CW\*(C`shared\-mime\-info\*(C'\fR package to
automatically determine \s-1MIME\s0 types. This package is notoriously
difficult to install, especially on win32 and \s-1OS\s0 X. For \s-1OS\s0 X the easiest
path might be to install Fink, then use \f(CW\*(C`apt\-get install
shared\-mime\-info\*(C'\fR. Restart the server, and everything should be fine.
.PP
Make sure you are using the latest version (>= 0.16) for best
results. If you are having errors serving \s-1CSS\s0 files, or if they get
served as text/plain instead of text/css, you may have an outdated
shared-mime-info version. You may also wish to simply use the following
code in your Static controller:
.PP
.Vb 5
\&    if ($c\->req\->path =~ /css$/i) {
\&        $c\->serve_static( "text/css" );
\&    } else {
\&        $c\->serve_static;
\&    }
.Ve
.PP
\fIServing Static Files with Apache\fR
.IX Subsection "Serving Static Files with Apache"
.PP
When using Apache, you can bypass Catalyst and any Static
plugins/controllers controller by intercepting requests for the
\&\f(CW\*(C`root/static\*(C'\fR path at the server level. All that is required is to
define a DocumentRoot and add a separate Location block for your static
content. Here is a complete config for this application under mod_perl
1.x:
.PP
.Vb 4
\&    <Perl>
\&        use lib qw(/var/www/MyApp/lib);
\&    </Perl>
\&    PerlModule MyApp
\&
\&    <VirtualHost *>
\&        ServerName myapp.example.com
\&        DocumentRoot /var/www/MyApp/root
\&        <Location />
\&            SetHandler perl\-script
\&            PerlHandler MyApp
\&        </Location>
\&        <LocationMatch "/(static|favicon.ico)">
\&            SetHandler default\-handler
\&        </LocationMatch>
\&    </VirtualHost>
.Ve
.PP
And here's a simpler example that'll get you started:
.PP
.Vb 4
\&    Alias /static/ "/my/static/files/"
\&    <Location "/static">
\&        SetHandler none
\&    </Location>
.Ve
.SS "Caching"
.IX Subsection "Caching"
Catalyst makes it easy to employ several different types of caching to
speed up your applications.
.PP
\fICache Plugins\fR
.IX Subsection "Cache Plugins"
.PP
There are three wrapper plugins around common \s-1CPAN\s0 cache modules:
Cache::FastMmap, Cache::FileCache, and Cache::Memcached.  These can be
used to cache the result of slow operations.
.PP
The Catalyst Advent Calendar uses the FileCache plugin to cache the
rendered \s-1XHTML\s0 version of the source \s-1POD\s0 document.  This is an ideal
application for a cache because the source document changes
infrequently but may be viewed many times.
.PP
.Vb 1
\&    use Catalyst qw/Cache::FileCache/;
\&
\&    ...
\&
\&    use File::stat;
\&    sub render_pod : Local {
\&        my ( self, $c ) = @_;
\&
\&        # the cache is keyed on the filename and the modification time
\&        # to check for updates to the file.
\&        my $file  = $c\->path_to( \*(Aqroot\*(Aq, \*(Aq2005\*(Aq, \*(Aq11.pod\*(Aq );
\&        my $mtime = ( stat $file )\->mtime;
\&
\&        my $cached_pod = $c\->cache\->get("$file $mtime");
\&        if ( !$cached_pod ) {
\&            $cached_pod = do_slow_pod_rendering();
\&            # cache the result for 12 hours
\&            $c\->cache\->set( "$file $mtime", $cached_pod, \*(Aq12h\*(Aq );
\&        }
\&        $c\->stash\->{pod} = $cached_pod;
\&    }
.Ve
.PP
We could actually cache the result forever, but using a value such as 12 hours
allows old entries to be automatically expired when they are no longer needed.
.PP
\fIPage Caching\fR
.IX Subsection "Page Caching"
.PP
Another method of caching is to cache the entire \s-1HTML\s0 page.  While this is
traditionally handled by a frontend proxy server like Squid, the Catalyst
PageCache plugin makes it trivial to cache the entire output from
frequently-used or slow actions.
.PP
Many sites have a busy content-filled front page that might look something
like this.  It probably takes a while to process, and will do the exact same
thing for every single user who views the page.
.PP
.Vb 2
\&    sub front_page : Path(\*(Aq/\*(Aq) {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->forward( \*(Aqget_news_articles\*(Aq );
\&        $c\->forward( \*(Aqbuild_lots_of_boxes\*(Aq );
\&        $c\->forward( \*(Aqmore_slow_stuff\*(Aq );
\&
\&        $c\->stash\->{template} = \*(Aqindex.tt\*(Aq;
\&    }
.Ve
.PP
We can add the PageCache plugin to speed things up.
.PP
.Vb 1
\&    use Catalyst qw/Cache::FileCache PageCache/;
\&
\&    sub front_page : Path (\*(Aq/\*(Aq) {
\&        my ( $self, $c ) = @_;
\&
\&        $c\->cache_page( 300 );
\&
\&        # same processing as above
\&    }
.Ve
.PP
Now the entire output of the front page, from <html> to </html>, will be
cached for 5 minutes.  After 5 minutes, the next request will rebuild the
page and it will be re-cached.
.PP
Note that the page cache is keyed on the page \s-1URI\s0 plus all parameters, so
requests for / and /?foo=bar will result in different cache items.  Also,
only \s-1GET\s0 requests will be cached by the plugin.
.PP
You can even get that frontend Squid proxy to help out by enabling \s-1HTTP\s0
headers for the cached page.
.PP
.Vb 5
\&    MyApp\->config(
\&        page_cache => {
\&            set_http_headers => 1,
\&        },
\&    );
.Ve
.PP
This would now set the following headers so proxies and browsers may cache
the content themselves.
.PP
.Vb 3
\&    Cache\-Control: max\-age=($expire_time \- time)
\&    Expires: $expire_time
\&    Last\-Modified: $cache_created_time
.Ve
.PP
\fITemplate Caching\fR
.IX Subsection "Template Caching"
.PP
Template Toolkit provides support for caching compiled versions of your
templates.  To enable this in Catalyst, use the following configuration.
\&\s-1TT\s0 will cache compiled templates keyed on the file mtime, so changes will
still be automatically detected.
.PP
.Vb 1
\&    package MyApp::View::TT;
\&
\&    use strict;
\&    use warnings;
\&    use base \*(AqCatalyst::View::TT\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config(
\&        COMPILE_DIR => \*(Aq/tmp/template_cache\*(Aq,
\&    );
\&
\&    1;
.Ve
.PP
\fIMore Info\fR
.IX Subsection "More Info"
.PP
See the documentation for each cache plugin for more details and other
available configuration options.
.PP
Catalyst::Plugin::Cache::FastMmap
Catalyst::Plugin::Cache::FileCache
Catalyst::Plugin::Cache::Memcached
Catalyst::Plugin::PageCache
http://search.cpan.org/dist/Template\-Toolkit/lib/Template/Manual/Config.pod#Caching_and_Compiling_Options <http://search.cpan.org/dist/Template-Toolkit/lib/Template/Manual/Config.pod#Caching_and_Compiling_Options>
.SH "Testing"
.IX Header "Testing"
Testing is an integral part of the web application development
process.  Tests make multi developer teams easier to coordinate, and
they help ensure that there are no nasty surprises after upgrades or
alterations.
.SS "Testing"
.IX Subsection "Testing"
Catalyst provides a convenient way of testing your application during
development and before deployment in a real environment.
.PP
\&\f(CW\*(C`Catalyst::Test\*(C'\fR makes it possible to run the same tests both locally
(without an external daemon) and against a remote server via \s-1HTTP\s0.
.PP
\fITests\fR
.IX Subsection "Tests"
.PP
Let's examine a skeleton application's \f(CW\*(C`t/\*(C'\fR directory:
.PP
.Vb 5
\&    mundus:~/MyApp chansen$ ls \-l t/
\&    total 24
\&    \-rw\-r\-\-r\-\-  1 chansen  chansen   95 18 Dec 20:50 01app.t
\&    \-rw\-r\-\-r\-\-  1 chansen  chansen  190 18 Dec 20:50 02pod.t
\&    \-rw\-r\-\-r\-\-  1 chansen  chansen  213 18 Dec 20:50 03podcoverage.t
.Ve
.ie n .IP """01app.t""" 4
.el .IP "\f(CW01app.t\fR" 4
.IX Item "01app.t"
Verifies that the application loads, compiles, and returns a successful
response.
.ie n .IP """02pod.t""" 4
.el .IP "\f(CW02pod.t\fR" 4
.IX Item "02pod.t"
Verifies that all \s-1POD\s0 is free from errors. Only executed if the \f(CW\*(C`TEST_POD\*(C'\fR
environment variable is true.
.ie n .IP """03podcoverage.t""" 4
.el .IP "\f(CW03podcoverage.t\fR" 4
.IX Item "03podcoverage.t"
Verifies that all methods/functions have \s-1POD\s0 coverage. Only executed if the
\&\f(CW\*(C`TEST_POD\*(C'\fR environment variable is true.
.PP
\fICreating tests\fR
.IX Subsection "Creating tests"
.PP
.Vb 5
\&    mundus:~/MyApp chansen$ cat t/01app.t | perl \-ne \*(Aqprintf( "%2d  %s", $., $_ )\*(Aq
\&    1  use Test::More tests => 2;
\&    2  BEGIN { use_ok( Catalyst::Test, \*(AqMyApp\*(Aq ) }
\&    3
\&    4  ok( request(\*(Aq/\*(Aq)\->is_success );
.Ve
.PP
The first line declares how many tests we are going to run, in this case
two. The second line tests and loads our application in test mode. The
fourth line verifies that our application returns a successful response.
.PP
\&\f(CW\*(C`Catalyst::Test\*(C'\fR exports two functions, \f(CW\*(C`request\*(C'\fR and \f(CW\*(C`get\*(C'\fR. Each can
take three different arguments:
.IP "A string which is a relative or absolute \s-1URI\s0." 4
.IX Item "A string which is a relative or absolute URI."
.Vb 2
\&    request(\*(Aq/my/path\*(Aq);
\&    request(\*(Aqhttp://www.host.com/my/path\*(Aq);
.Ve
.ie n .IP "An instance of ""URI""." 4
.el .IP "An instance of \f(CWURI\fR." 4
.IX Item "An instance of URI."
.Vb 1
\&    request( URI\->new(\*(Aqhttp://www.host.com/my/path\*(Aq) );
.Ve
.ie n .IP "An instance of ""HTTP::Request""." 4
.el .IP "An instance of \f(CWHTTP::Request\fR." 4
.IX Item "An instance of HTTP::Request."
.Vb 1
\&    request( HTTP::Request\->new( GET => \*(Aqhttp://www.host.com/my/path\*(Aq) );
.Ve
.PP
\&\f(CW\*(C`request\*(C'\fR returns an instance of \f(CW\*(C`HTTP::Response\*(C'\fR and \f(CW\*(C`get\*(C'\fR returns the
content (body) of the response.
.PP
\fIRunning tests locally\fR
.IX Subsection "Running tests locally"
.PP
.Vb 6
\&    mundus:~/MyApp chansen$ CATALYST_DEBUG=0 TEST_POD=1 prove \-\-lib lib/ t/
\&    t/01app............ok
\&    t/02pod............ok
\&    t/03podcoverage....ok
\&    All tests successful.
\&    Files=3, Tests=4,  2 wallclock secs ( 1.60 cusr +  0.36 csys =  1.96 CPU)
.Ve
.PP
\&\f(CW\*(C`CATALYST_DEBUG=0\*(C'\fR ensures that debugging is off; if it's enabled you
will see debug logs between tests.
.PP
\&\f(CW\*(C`TEST_POD=1\*(C'\fR enables \s-1POD\s0 checking and coverage.
.PP
\&\f(CW\*(C`prove\*(C'\fR A command-line tool that makes it easy to run tests. You can
find out more about it from the links below.
.PP
\fIRunning tests remotely\fR
.IX Subsection "Running tests remotely"
.PP
.Vb 4
\&    mundus:~/MyApp chansen$ CATALYST_SERVER=http://localhost:3000/ prove \-\-lib lib/ t/01app.t
\&    t/01app....ok
\&    All tests successful.
\&    Files=1, Tests=2,  0 wallclock secs ( 0.40 cusr +  0.01 csys =  0.41 CPU)
.Ve
.PP
\&\f(CW\*(C`CATALYST_SERVER=http://localhost:3000/\*(C'\fR is the absolute deployment \s-1URI\s0 of
your application. In \f(CW\*(C`CGI\*(C'\fR or \f(CW\*(C`FastCGI\*(C'\fR it should be the host and path
to the script.
.PP
\fI\f(CI\*(C`Test::WWW::Mechanize\*(C'\fI and Catalyst\fR
.IX Subsection "Test::WWW::Mechanize and Catalyst"
.PP
Be sure to check out \f(CW\*(C`Test::WWW::Mechanize::Catalyst\*(C'\fR. It makes it easy to
test \s-1HTML\s0, forms and links. A short example of usage:
.PP
.Vb 2
\&    use Test::More tests => 6;
\&    BEGIN { use_ok( Test::WWW::Mechanize::Catalyst, \*(AqMyApp\*(Aq ) }
\&
\&    my $mech = Test::WWW::Mechanize::Catalyst\->new;
\&    $mech\->get_ok("http://localhost/", \*(AqGot index page\*(Aq);
\&    $mech\->title_like( qr/^MyApp on Catalyst/, \*(AqGot right index title\*(Aq );
\&    ok( $mech\->find_link( text_regex => qr/^Wiki/i ), \*(AqFound link to Wiki\*(Aq );
\&    ok( $mech\->find_link( text_regex => qr/^Mailing\-List/i ), \*(AqFound link to Mailing\-List\*(Aq );
\&    ok( $mech\->find_link( text_regex => qr/^IRC channel/i ), \*(AqFound link to IRC channel\*(Aq );
.Ve
.PP
\fIFurther Reading\fR
.IX Subsection "Further Reading"
.IP "Catalyst::Test" 4
.IX Item "Catalyst::Test"
Catalyst::Test
.IP "Test::WWW::Mechanize::Catalyst" 4
.IX Item "Test::WWW::Mechanize::Catalyst"
http://search.cpan.org/dist/Test\-WWW\-Mechanize\-Catalyst/lib/Test/WWW/Mechanize/Catalyst.pm <http://search.cpan.org/dist/Test-WWW-Mechanize-Catalyst/lib/Test/WWW/Mechanize/Catalyst.pm>
.IP "Test::WWW::Mechanize" 4
.IX Item "Test::WWW::Mechanize"
http://search.cpan.org/dist/Test\-WWW\-Mechanize/Mechanize.pm <http://search.cpan.org/dist/Test-WWW-Mechanize/Mechanize.pm>
.IP "WWW::Mechanize" 4
.IX Item "WWW::Mechanize"
http://search.cpan.org/dist/WWW\-Mechanize/lib/WWW/Mechanize.pm <http://search.cpan.org/dist/WWW-Mechanize/lib/WWW/Mechanize.pm>
.IP "LWP::UserAgent" 4
.IX Item "LWP::UserAgent"
http://search.cpan.org/dist/libwww\-perl/lib/LWP/UserAgent.pm <http://search.cpan.org/dist/libwww-perl/lib/LWP/UserAgent.pm>
.IP "HTML::Form" 4
.IX Item "HTML::Form"
http://search.cpan.org/dist/libwww\-perl/lib/HTML/Form.pm <http://search.cpan.org/dist/libwww-perl/lib/HTML/Form.pm>
.IP "HTTP::Message" 4
.IX Item "HTTP::Message"
http://search.cpan.org/dist/libwww\-perl/lib/HTTP/Message.pm <http://search.cpan.org/dist/libwww-perl/lib/HTTP/Message.pm>
.IP "HTTP::Request" 4
.IX Item "HTTP::Request"
http://search.cpan.org/dist/libwww\-perl/lib/HTTP/Request.pm <http://search.cpan.org/dist/libwww-perl/lib/HTTP/Request.pm>
.IP "HTTP::Request::Common" 4
.IX Item "HTTP::Request::Common"
http://search.cpan.org/dist/libwww\-perl/lib/HTTP/Request/Common.pm <http://search.cpan.org/dist/libwww-perl/lib/HTTP/Request/Common.pm>
.IP "HTTP::Response" 4
.IX Item "HTTP::Response"
http://search.cpan.org/dist/libwww\-perl/lib/HTTP/Response.pm <http://search.cpan.org/dist/libwww-perl/lib/HTTP/Response.pm>
.IP "HTTP::Status" 4
.IX Item "HTTP::Status"
http://search.cpan.org/dist/libwww\-perl/lib/HTTP/Status.pm <http://search.cpan.org/dist/libwww-perl/lib/HTTP/Status.pm>
.IP "\s-1URI\s0" 4
.IX Item "URI"
<http://search.cpan.org/dist/URI/URI.pm>
.IP "Test::More" 4
.IX Item "Test::More"
http://search.cpan.org/dist/Test\-Simple/lib/Test/More.pm <http://search.cpan.org/dist/Test-Simple/lib/Test/More.pm>
.IP "Test::Pod" 4
.IX Item "Test::Pod"
http://search.cpan.org/dist/Test\-Pod/Pod.pm <http://search.cpan.org/dist/Test-Pod/Pod.pm>
.IP "Test::Pod::Coverage" 4
.IX Item "Test::Pod::Coverage"
http://search.cpan.org/dist/Test\-Pod\-Coverage/Coverage.pm <http://search.cpan.org/dist/Test-Pod-Coverage/Coverage.pm>
.IP "prove (Test::Harness)" 4
.IX Item "prove (Test::Harness)"
http://search.cpan.org/dist/Test\-Harness/bin/prove <http://search.cpan.org/dist/Test-Harness/bin/prove>
.PP
\fIMore Information\fR
.IX Subsection "More Information"
.PP
<http://search.cpan.org/perldoc?Catalyst::Plugin::Authorization::Roles>
<http://search.cpan.org/perldoc?Catalyst::Plugin::Authorization::ACL>
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
