.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Simple 3"
.TH CGI::Simple 3 "2012-02-01" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Simple \- A Simple totally OO CGI interface that is CGI.pm compliant
.SH "VERSION"
.IX Header "VERSION"
This document describes CGI::Simple version 1.113.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use CGI::Simple;
\&    $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB
\&    $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads
\&
\&    $q = new CGI::Simple;
\&    $q = new CGI::Simple( { \*(Aqfoo\*(Aq=>\*(Aq1\*(Aq, \*(Aqbar\*(Aq=>[2,3,4] } );
\&    $q = new CGI::Simple( \*(Aqfoo=1&bar=2&bar=3&bar=4\*(Aq );
\&    $q = new CGI::Simple( \e*FILEHANDLE );
\&
\&    $q\->save( \e*FILEHANDLE );   # save current object to a file as used by new
\&
\&    @params = $q\->param;        # return all param names as a list
\&    $value = $q\->param(\*(Aqfoo\*(Aq);  # return the first value supplied for \*(Aqfoo\*(Aq
\&    @values = $q\->param(\*(Aqfoo\*(Aq); # return all values supplied for foo
\&
\&    %fields   = $q\->Vars;      # returns untied key value pair hash
\&    $hash_ref = $q\->Vars;      # or as a hash ref
\&    %fields   = $q\->Vars("|"); # packs multiple values with "|" rather than "\e0";
\&
\&    @keywords = $q\->keywords;  # return all keywords as a list
\&
\&    $q\->param( \*(Aqfoo\*(Aq, \*(Aqsome\*(Aq, \*(Aqnew\*(Aq, \*(Aqvalues\*(Aq );      # set new \*(Aqfoo\*(Aq values
\&    $q\->param( \-name=>\*(Aqfoo\*(Aq, \-value=>\*(Aqbar\*(Aq );
\&    $q\->param( \-name=>\*(Aqfoo\*(Aq, \-value=>[\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq] );
\&
\&    $q\->param( \*(Aqfoo\*(Aq, \*(Aqsome\*(Aq, \*(Aqnew\*(Aq, \*(Aqvalues\*(Aq );      # append values to \*(Aqfoo\*(Aq
\&    $q\->append( \-name=>\*(Aqfoo\*(Aq, \-value=>\*(Aqbar\*(Aq );
\&    $q\->append( \-name=>\*(Aqfoo\*(Aq, \-value=>[\*(Aqsome\*(Aq, \*(Aqnew\*(Aq, \*(Aqvalues\*(Aq] );
\&
\&    $q\->delete(\*(Aqfoo\*(Aq); # delete param \*(Aqfoo\*(Aq and all its values
\&    $q\->delete_all;    # delete everything
\&
\&    <INPUT TYPE="file" NAME="upload_file" SIZE="42">
\&
\&    $files    = $q\->upload()                # number of files uploaded
\&    @files    = $q\->upload();               # names of all uploaded files
\&    $filename = $q\->param(\*(Aqupload_file\*(Aq)    # filename of uploaded file
\&    $mime     = $q\->upload_info($filename,\*(Aqmime\*(Aq); # MIME type of uploaded file
\&    $size     = $q\->upload_info($filename,\*(Aqsize\*(Aq); # size of uploaded file
\&
\&    my $fh = $q\->upload($filename);         # get filehandle to read from
\&    while ( read( $fh, $buffer, 1024 ) ) { ... }
\&
\&    # short and sweet upload
\&    $ok = $q\->upload( $q\->param(\*(Aqupload_file\*(Aq), \*(Aq/path/to/write/file.name\*(Aq );
\&    print "Uploaded ".$q\->param(\*(Aqupload_file\*(Aq)." and wrote it OK!" if $ok;
\&
\&    $decoded    = $q\->url_decode($encoded);
\&    $encoded    = $q\->url_encode($unencoded);
\&    $escaped    = $q\->escapeHTML(\*(Aq<>"&\*(Aq);
\&    $unescaped  = $q\->unescapeHTML(\*(Aq&lt;&gt;&quot;&amp;\*(Aq);
\&
\&    $qs = $q\->query_string; # get all data in $q as a query string OK for GET
\&
\&    $q\->no_cache(1);        # set Pragma: no\-cache + expires
\&    print $q\->header();     # print a simple header
\&    # get a complex header
\&    $header = $q\->header(   \-type       => \*(Aqimage/gif\*(Aq
\&                            \-nph        => 1,
\&                            \-status     => \*(Aq402 Payment required\*(Aq,
\&                            \-expires    =>\*(Aq+24h\*(Aq,
\&                            \-cookie     => $cookie,
\&                            \-charset    => \*(Aqutf\-7\*(Aq,
\&                            \-attachment => \*(Aqfoo.gif\*(Aq,
\&                            \-Cost       => \*(Aq$2.00\*(Aq
\&                        );
\&    # a p3p header (OK for redirect use as well)
\&    $header = $q\->header( \-p3p => \*(Aqpolicyref="http://somesite.com/P3P/PolicyReferences.xml\*(Aq );
\&
\&    @cookies = $q\->cookie();        # get names of all available cookies
\&    $value   = $q\->cookie(\*(Aqfoo\*(Aq)    # get first value of cookie \*(Aqfoo\*(Aq
\&    @value   = $q\->cookie(\*(Aqfoo\*(Aq)    # get all values of cookie \*(Aqfoo\*(Aq
\&    # get a cookie formatted for header() method
\&    $cookie  = $q\->cookie(  \-name    => \*(AqPassword\*(Aq,
\&                            \-values  => [\*(Aqsuperuser\*(Aq,\*(Aqgod\*(Aq,\*(Aqmy dog woofie\*(Aq],
\&                            \-expires => \*(Aq+3d\*(Aq,
\&                            \-domain  => \*(Aq.nowhere.com\*(Aq,
\&                            \-path    => \*(Aq/cgi\-bin/database\*(Aq,
\&                            \-secure  => 1
\&                         );
\&    print $q\->header( \-cookie=>$cookie );       # set cookie
\&
\&    print $q\->redirect(\*(Aqhttp://go.away.now\*(Aq);   # print a redirect header
\&
\&    dienice( $q\->cgi_error ) if $q\->cgi_error;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI::Simple provides a relatively lightweight drop in replacement for \s-1CGI\s0.pm.
It shares an identical \s-1OO\s0 interface to \s-1CGI\s0.pm for parameter parsing, file
upload, cookie handling and header generation. This module is entirely object
oriented, however a complete functional interface is available by using the
CGI::Simple::Standard module.
.PP
Essentially everything in \s-1CGI\s0.pm that relates to the \s-1CGI\s0 (not \s-1HTML\s0) side of
things is available. There are even a few new methods and additions to old
ones! If you are interested in what has gone on under the hood see the
Compatibility with \s-1CGI\s0.pm section at the end.
.PP
In practical testing this module loads and runs about twice as fast as \s-1CGI\s0.pm
depending on the precise task.
.SH "CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE"
.IX Header "CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE"
Here is a very brief rundown on how you use the interface. Full details
follow.
.SS "First you need to initialize an object"
.IX Subsection "First you need to initialize an object"
Before you can call a CGI::Simple method you must create a CGI::Simple object.
You do that by using the module and then calling the \fInew()\fR constructor:
.PP
.Vb 2
\&    use CGI::Simple;
\&    my $q = new CGI::Simple;
.Ve
.PP
It is traditional to call your object \f(CW$q\fR for query or perhaps \f(CW$cgi\fR.
.SS "Next you call methods on that object"
.IX Subsection "Next you call methods on that object"
Once you have your object you can call methods on it using the \-> arrow
syntax For example to get the names of all the parameters passed to your
script you would just write:
.PP
.Vb 1
\&    @names = $q\->param();
.Ve
.PP
Many methods are sensitive to the context in which you call them. In the
example above the \fB\f(BIparam()\fB\fR method returns a list of all the parameter names
when called without any arguments.
.PP
When you call \fBparam('arg')\fR with a single argument it assumes you want
to get the value(s) associated with that argument (parameter). If you ask
for an array it gives you an array of all the values associated with it's
argument:
.PP
.Vb 1
\&    @values = $q\->param(\*(Aqfoo\*(Aq);  # get all the values for \*(Aqfoo\*(Aq
.Ve
.PP
whereas if you ask for a scalar like this:
.PP
.Vb 1
\&    $value = $q\->param(\*(Aqfoo\*(Aq);   # get only the first value for \*(Aqfoo\*(Aq
.Ve
.PP
then it returns only the first value (if more than one value for
\&'foo' exists).
.PP
Most CGI::Simple routines accept several arguments, sometimes as many as
10 optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:
.PP
.Vb 1
\&    print $q\->header( \-type=>\*(Aqimage/gif\*(Aq, \-expires=>\*(Aq+3d\*(Aq );
.Ve
.PP
Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  \-type, \-Type, and \-TYPE are all
acceptable.
.PP
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  \fB\f(BIheader()\fB\fR happens to be one of these routines.  In this
case, the single argument is the document type.
.PP
.Vb 1
\&   print $q\->header(\*(Aqtext/html\*(Aq);
.Ve
.PP
Sometimes methods expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the \fB\f(BIparam()\fB\fR method can be used to set a \s-1CGI\s0 parameter to a
single or a multi-valued value.  The two cases are shown below:
.PP
.Vb 2
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>\*(Aqtomato\*(Aq);
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>[\*(Aqtomato\*(Aq,\*(Aqtomahto\*(Aq,\*(Aqpotato\*(Aq,\*(Aqpotahto\*(Aq]);
.Ve
.SH "CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE"
.IX Header "CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE"
For convenience a functional interface is provided by the
CGI::Simple::Standard module. This hides the \s-1OO\s0 details from you and allows
you to simply call methods. You may either use \s-1AUTOLOADING\s0 of methods or
import specific method sets into you namespace. Here are the first few
examples again using the function interface.
.PP
.Vb 6
\&    use CGI::Simple::Standard qw(\-autoload);
\&    @names  = param();
\&    @values = param(\*(Aqfoo\*(Aq);
\&    $value  = param(\*(Aqfoo\*(Aq);
\&    print header(\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq);
\&    print header(\*(Aqtext/html\*(Aq);
.Ve
.PP
Yes that's it. Not a \f(CW$q\fR\-> in sight. You just use the module and select
how/which methods to load. You then just call the methods you want exactly
as before but without the \f(CW$q\fR\-> notation.
.PP
When (if) you read the following docs and are using the functional interface
just pretend the \f(CW$q\fR\-> is not there.
.SS "Selecting which methods to load"
.IX Subsection "Selecting which methods to load"
When you use the functional interface Perl needs to be able to find the
functions you call. The simplest way of doing this is to use autoloading as
shown above. When you use CGI::Simple::Standard with the '\-autoload' pragma
it exports a single \s-1AUTOLOAD\s0 sub into you namespace. Every time you call a
non existent function \s-1AUTOLOAD\s0 is called and will load the required
function and install it in your namespace. Thus only the \s-1AUTOLOAD\s0 sub and
those functions you specifically call will be imported.
.PP
Alternatively CGI::Simple::Standard provides a range of function sets you can
import or you can just select exactly what you want. You do this using the
familiar
.PP
.Vb 1
\&    use CGI::Simple::Standard qw( :func_set  some_func);
.Ve
.PP
notation. This will import the ':func_set' function set and the specific
function 'some_func'.
.SS "To Autoload or not to Autoload, that is the question."
.IX Subsection "To Autoload or not to Autoload, that is the question."
If you do not have a \s-1AUTOLOAD\s0 sub in you script it is generally best to use
the '\-autoload' option. Under autoload you can use any method you want but
only import and compile those functions you actually use.
.PP
If you do not use autoload you must specify what functions to import. You can
only use functions that you have imported. For comvenience functions are
grouped into related sets. If you choose to import one or more ':func_set'
you may have potential namespace collisions so check out the docs to see
what gets imported. Using the ':all' tag is pretty slack but it is there
if you want. Full details of the function sets are provided in the
CGI::Simple::Standard docs
.PP
If you just want say the param and header methods just load these two.
.PP
.Vb 1
\&    use CGI::Simple::Standard qw(param header);
.Ve
.SS "Setting globals using the functional interface"
.IX Subsection "Setting globals using the functional interface"
Where you see global variables being set using the syntax:
.PP
.Vb 1
\&    $CGI::Simple::DEBUG = 1;
.Ve
.PP
You use exactly the same syntax when using CGI::Simple::Standard.
.SH "THE CORE METHODS"
.IX Header "THE CORE METHODS"
.SS "\fInew()\fP Creating a new query object"
.IX Subsection "new() Creating a new query object"
The first step in using CGI::Simple is to create a new query object using
the \fB\f(BInew()\fB\fR constructor:
.PP
.Vb 1
\&     $q = new CGI::Simple;
.Ve
.PP
This will parse the input (from both \s-1POST\s0 and \s-1GET\s0 methods) and store
it into an object called \f(CW$q\fR.
.PP
If you provide a file handle to the \fB\f(BInew()\fB\fR method, it will read
parameters from the file (or \s-1STDIN\s0, or whatever).
.PP
.Vb 2
\&     open FH, "test.in" or die $!;
\&     $q = new CGI::Simple(\e*FH);
\&
\&     open $fh, "test.in" or die $!;
\&     $q = new CGI::Simple($fh);
.Ve
.PP
The file should be a series of newline delimited TAG=VALUE pairs.
Conveniently, this type of file is created by the \fB\f(BIsave()\fB\fR method
(see below). Multiple records can be saved and restored.
IO::File objects work fine.
.PP
If you are using the function-oriented interface provided by
CGI::Simple::Standard and want to initialize from a file handle,
the way to do this is with \fB\f(BIrestore_parameters()\fB\fR.  This will (re)initialize
the default CGI::Simple object from the indicated file handle.
.PP
.Vb 1
\&    restore_parameters(\e*FH);
.Ve
.PP
In fact for all intents and purposes \fB\f(BIrestore_parameters()\fB\fR is identical
to \fB\f(BInew()\fB\fR Note that \fB\f(BIrestore_parameters()\fB\fR does not exist in
CGI::Simple itself so you can't use it.
.PP
You can also initialize the query object from an associative array
reference:
.PP
.Vb 4
\&    $q = new CGI::Simple( { \*(Aqdinosaur\*(Aq => \*(Aqbarney\*(Aq,
\&                            \*(Aqsong\*(Aq     => \*(AqI love you\*(Aq,
\&                            \*(Aqfriends\*(Aq  => [qw/Jessica George Nancy/] }
\&                        );
.Ve
.PP
or from a properly formatted, URL-escaped query string:
.PP
.Vb 1
\&    $q = new CGI::Simple( \*(Aqdinosaur=barney&color=purple\*(Aq );
.Ve
.PP
or from a previously existing CGI::Simple object (this generates an identical clone
including all global variable settings, etc that are stored in the object):
.PP
.Vb 2
\&    $old_query = new CGI::Simple;
\&    $new_query = new CGI::Simple($old_query);
.Ve
.PP
To create an empty query, initialize it from an empty string or hash:
.PP
.Vb 1
\&    $empty_query = new CGI::Simple("");
\&
\&       \-or\-
\&
\&    $empty_query = new CGI::Simple({});
.Ve
.SS "\fIkeywords()\fP Fetching a list of keywords from a query"
.IX Subsection "keywords() Fetching a list of keywords from a query"
.Vb 1
\&    @keywords = $q\->keywords;
.Ve
.PP
If the script was invoked as the result of an <\s-1ISINDEX\s0> search, the
parsed keywords can be obtained as an array using the \fB\f(BIkeywords()\fB\fR method.
.SS "\fIparam()\fP Fetching the names of all parameters passed to your script"
.IX Subsection "param() Fetching the names of all parameters passed to your script"
.Vb 1
\&    @names = $q\->param;
.Ve
.PP
If the script was invoked with a parameter list
(e.g. \*(L"name1=value1&name2=value2&name3=value3\*(R"), the \fB\f(BIparam()\fB\fR method
will return the parameter names as a list.  If the script was invoked
as an <\s-1ISINDEX\s0> script and contains a string without ampersands
(e.g. \*(L"value1+value2+value3\*(R") , there will be a single parameter named
\&\*(L"keywords\*(R" containing the \*(L"+\*(R"\-delimited keywords.
.PP
\&\s-1NOTE:\s0 The array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).
.SS "\fIparam()\fP Fetching the value or values of a simple named parameter"
.IX Subsection "param() Fetching the value or values of a simple named parameter"
.Vb 1
\&    @values = $q\->param(\*(Aqfoo\*(Aq);
\&
\&          \-or\-
\&
\&    $value = $q\->param(\*(Aqfoo\*(Aq);
.Ve
.PP
Pass the \fB\f(BIparam()\fB\fR method a single argument to fetch the value of the
named parameter. If the parameter is multi-valued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.
.PP
If a value is not given in the query string, as in the queries
\&\*(L"name1=&name2=\*(R" or \*(L"name1&name2\*(R", it will be returned by default
as an empty string. If you set the global variable:
.PP
.Vb 1
\&    $CGI::Simple::NO_UNDEF_PARAMS = 1;
.Ve
.PP
Then value-less parameters will be ignored, and will not exist in the
query object. If you try to access them via param you will get an undef
return value.
.SS "\fIparam()\fP Setting the values of a named parameter"
.IX Subsection "param() Setting the values of a named parameter"
.Vb 1
\&    $q\->param(\*(Aqfoo\*(Aq,\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq);
.Ve
.PP
This sets the value for the named parameter 'foo' to an array of
values.  This is one way to change the value of a field.
.PP
\&\fB\f(BIparam()\fB\fR also recognizes a named parameter style of calling described
in more detail later:
.PP
.Vb 1
\&    $q\->param(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq]);
\&
\&                  \-or\-
\&
\&    $q\->param(\-name=>\*(Aqfoo\*(Aq,\-value=>\*(Aqthe value\*(Aq);
.Ve
.SS "\fIparam()\fP Retrieving non\-application/x\-www\-form\-urlencoded data"
.IX Subsection "param() Retrieving non-application/x-www-form-urlencoded data"
If POSTed or PUTed data is not of type application/x\-www\-form\-urlencoded or multipart/form\-data, 
then the data will not be processed, but instead be returned as-is in a parameter named \s-1POSTDATA\s0
or \s-1PUTDATA\s0.  To retrieve it, use code like this:
.PP
.Vb 1
\&    my $data = $q\->param( \*(AqPOSTDATA\*(Aq );
\&
\&                  \-or\-
\&
\&    my $data = $q\->param( \*(AqPUTDATA\*(Aq );
.Ve
.PP
(If you don't know what the preceding means, don't worry about it.  It only affects people trying
to use CGI::Simple for \s-1REST\s0 webservices)
.SS "\fIadd_param()\fP Setting the values of a named parameter"
.IX Subsection "add_param() Setting the values of a named parameter"
You nay also use the new method \fBadd_param\fR to add parameters. This is an
alias to the \fI_add_param()\fR internal method that actually does all the work.
You can call it like this:
.PP
.Vb 3
\&    $q\->add_param(\*(Aqfoo\*(Aq, \*(Aqnew\*(Aq);
\&    $q\->add_param(\*(Aqfoo\*(Aq, [1,2,3,4,5]);
\&    $q\->add_param( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqoverwrite\*(Aq );
.Ve
.PP
The first argument is the parameter, the second the value or an array ref
of values and the optional third argument sets overwrite mode. If the third
argument is absent of false the values will be appended. If true the values
will overwrite any existing ones
.SS "\fIappend()\fP Appending values to a named parameter"
.IX Subsection "append() Appending values to a named parameter"
.Vb 1
\&   $q\->append(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqyet\*(Aq,\*(Aqmore\*(Aq,\*(Aqvalues\*(Aq]);
.Ve
.PP
This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.
.SS "\fIimport_names()\fP Importing all parameters into a namespace."
.IX Subsection "import_names() Importing all parameters into a namespace."
This method was silly, non \s-1OO\s0 and has been deleted. You can get all the params
as a hash using \fBVars\fR or via all the other accessors.
.SS "\fIdelete()\fP Deleting a parameter completely"
.IX Subsection "delete() Deleting a parameter completely"
.Vb 1
\&    $q\->delete(\*(Aqfoo\*(Aq);
.Ve
.PP
This completely clears a parameter. If you are using the function call
interface, use \fB\f(BIDelete()\fB\fR instead to avoid conflicts with Perl's
built-in delete operator.
.PP
If you are using the function call interface, use \fB\f(BIDelete()\fB\fR instead to
avoid conflicts with Perl's built-in delete operator.
.SS "\fIdelete_all()\fP Deleting all parameters"
.IX Subsection "delete_all() Deleting all parameters"
.Vb 1
\&    $q\->delete_all();
.Ve
.PP
This clears the CGI::Simple object completely. For \s-1CGI\s0.pm compatibility
\&\fB\f(BIDelete_all()\fB\fR is provided however there is no reason to use this in the
function call interface other than symmetry.
.PP
For \s-1CGI\s0.pm compatibility \fB\f(BIDelete_all()\fB\fR is provided as an alias for
\&\fBdelete_all\fR however there is no reason to use this, even in the
function call interface.
.SS "\fIparam_fetch()\fP Direct access to the parameter list"
.IX Subsection "param_fetch() Direct access to the parameter list"
This method is provided for \s-1CGI\s0.pm compatibility only. It returns an
array ref to the values associated with a named param. It is deprecated.
.SS "\fIVars()\fP Fetching the entire parameter list as a hash"
.IX Subsection "Vars() Fetching the entire parameter list as a hash"
.Vb 3
\&    $params = $q\->Vars;  # as a tied hash ref
\&    print $params\->{\*(Aqaddress\*(Aq};
\&    @foo = split "\e0", $params\->{\*(Aqfoo\*(Aq};
\&
\&    %params = $q\->Vars;  # as a plain hash
\&    print $params{\*(Aqaddress\*(Aq};
\&    @foo = split "\e0", $params{\*(Aqfoo\*(Aq};
\&
\&    %params = $q\->Vars(\*(Aq,\*(Aq); # specifying a different separator than "\e0"
\&    @foo = split \*(Aq,\*(Aq, $params{\*(Aqfoo\*(Aq};
.Ve
.PP
Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the \s-1CGI\s0 parameters, and the values are the
parameters' values.  The \fB\f(BIVars()\fB\fR method does this.
.PP
Called in a scalar context, it returns the parameter list as a tied
hash reference. Because this hash ref is tied changing a key/value
changes the underlying CGI::Simple object.
.PP
Called in a list context, it returns the parameter list as an ordinary hash.
Changing this hash will not change the underlying CGI::Simple object
.PP
When using \fB\f(BIVars()\fB\fR, the thing you must watch out for are multi-valued \s-1CGI\s0
parameters.  Because a hash cannot distinguish between scalar and
list context, multi-valued parameters will be returned as a packed
string, separated by the \*(L"\e0\*(R" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi\-lib.pl
module for Perl version 4.
.PP
You can change the character used to do the multiple value packing by passing
it to \fB\f(BIVars()\fB\fR as an argument as shown.
.SS "\fIurl_param()\fP Access the \s-1QUERY_STRING\s0 regardless of '\s-1GET\s0' or '\s-1POST\s0'"
.IX Subsection "url_param() Access the QUERY_STRING regardless of 'GET' or 'POST'"
The \fB\f(BIurl_param()\fB\fR method makes the \s-1QUERY_STRING\s0 data available regardless
of whether the \s-1REQUEST_METHOD\s0 was '\s-1GET\s0' or '\s-1POST\s0'. You can do anything
with \fBurl_param\fR that you can do with \fB\f(BIparam()\fB\fR, however the data set
is completely independent.
.PP
Technically what happens if you use this method is that the \s-1QUERY_STRING\s0 data
is parsed into a new CGI::Simple object which is stored within the current
object. \fBurl_param\fR then just calls \fB\f(BIparam()\fB\fR on this new object.
.SS "\fIparse_query_string()\fP Add \s-1QUERY_STRING\s0 data to '\s-1POST\s0' requests"
.IX Subsection "parse_query_string() Add QUERY_STRING data to 'POST' requests"
When the \s-1REQUEST_METHOD\s0 is '\s-1POST\s0' the default behavior is to ignore
name/value pairs or keywords in the \f(CW$ENV\fR{'\s-1QUERY_STRING\s0'}. You can override
this by calling \fB\f(BIparse_query_string()\fB\fR which will add the \s-1QUERY_STRING\s0 data to
the data already in our CGI::Simple object if the \s-1REQUEST_METHOD\s0 was '\s-1POST\s0'
.PP
.Vb 2
\&    $q = new CGI::Simple;
\&    $q\->parse_query_string;  # add $ENV{\*(AqQUERY_STRING\*(Aq} data to our $q object
.Ve
.PP
If the \s-1REQUEST_METHOD\s0 was '\s-1GET\s0' then the \s-1QUERY_STRING\s0 will already be
stored in our object so \fBparse_query_string\fR will be ignored.
.PP
This is a new method in CGI::Simple that is not available in \s-1CGI\s0.pm
.SS "\fIsave()\fP Saving the state of an object to file"
.IX Subsection "save() Saving the state of an object to file"
.Vb 1
\&    $q\->save(\e*FILEHANDLE)
.Ve
.PP
This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the \fB\f(BInew()\fB\fR method.
.PP
The format of the saved file is:
.PP
.Vb 5
\&    NAME1=VALUE1
\&    NAME1=VALUE1\*(Aq
\&    NAME2=VALUE2
\&    NAME3=VALUE3
\&    =
.Ve
.PP
Both name and value are \s-1URL\s0 escaped.  Multi-valued \s-1CGI\s0 parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to \fB\f(BInew()\fB\fR.
.PP
.Vb 3
\&    open FH, "test.in" or die $!;
\&    $q1 = new CGI::Simple(\e*FH);  # get the first record
\&    $q2 = new CGI::Simple(\e*FH);  # get the next record
.Ve
.PP
Note: If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is \fB\f(BIsave_parameters()\fB\fR.
Also if you want to initialize from a file handle, the way to do this is
with \fB\f(BIrestore_parameters()\fB\fR.  This will (re)initialize
the default CGI::Simple object from the indicated file handle.
.PP
.Vb 1
\&    restore_parameters(\e*FH);
.Ve
.SH "FILE UPLOADS"
.IX Header "FILE UPLOADS"
File uploads are easy with CGI::Simple. You use the \fB\f(BIupload()\fB\fR method.
Assuming you have the following in your \s-1HTML:\s0
.PP
.Vb 7
\&    <FORM
\&     METHOD="POST"
\&     ACTION="http://somewhere.com/cgi\-bin/script.cgi"
\&     ENCTYPE="multipart/form\-data">
\&        <INPUT TYPE="file" NAME="upload_file1" SIZE="42">
\&        <INPUT TYPE="file" NAME="upload_file2" SIZE="42">
\&    </FORM>
.Ve
.PP
Note that the \s-1ENCTYPE\s0 is \*(L"multipart/form\-data\*(R". You must specify this or the
browser will default to \*(L"application/x\-www\-form\-urlencoded\*(R" which will result
in no files being uploaded although on the surface things will appear \s-1OK\s0.
.PP
When the user submits this form any supplied files will be spooled onto disk
and saved in temporary files. These files will be deleted when your script.cgi
exits so if you want to keep them you will need to proceed as follows.
.SS "\fIupload()\fP The key file upload method"
.IX Subsection "upload() The key file upload method"
The \fB\f(BIupload()\fB\fR method is quite versatile. If you call \fB\f(BIupload()\fB\fR without
any arguments it will return a list of uploaded files in list context and
the number of uploaded files in scalar context.
.PP
.Vb 2
\&    $number_of_files = $q\->upload;
\&    @list_of_files   = $q\->upload;
.Ve
.PP
Having established that you have uploaded files available you can get the
browser supplied filename using \fB\f(BIparam()\fB\fR like this:
.PP
.Vb 1
\&    $filename1 = $q\->param(\*(Aqupload_file1\*(Aq);
.Ve
.PP
You can then get a filehandle to read from by calling \fB\f(BIupload()\fB\fR and
supplying this filename as an argument. Warning: do not modify the
value you get from \fB\f(BIparam()\fB\fR in any way \- you don't need to untaint it.
.PP
.Vb 1
\&    $fh = $q\->upload( $filename1 );
.Ve
.PP
Now to save the file you would just do something like:
.PP
.Vb 5
\&    $save_path = \*(Aq/path/to/write/file.name\*(Aq;
\&    open FH, ">$save_path" or die "Oops $!\en";
\&    binmode FH;
\&    print FH $buffer while read( $fh, $buffer, 4096 );
\&    close FH;
.Ve
.PP
By utilizing a new feature of the upload method this process can be
simplified to:
.PP
.Vb 6
\&    $ok = $q\->upload( $q\->param(\*(Aqupload_file1\*(Aq), \*(Aq/path/to/write/file.name\*(Aq );
\&    if ($ok) {
\&        print "Uploaded and wrote file OK!";
\&    } else {
\&        print $q\->cgi_error();
\&    }
.Ve
.PP
As you can see upload will accept an optional second argument and will write
the file to this file path. It will return 1 for success and undef if it
fails. If it fails you can get the error from \fBcgi_error\fR
.PP
You can also use just the fieldname as an argument to upload ie:
.PP
.Vb 1
\&    $fh = $q\->upload( \*(Aqupload_field_name\*(Aq );
\&
\&    or
\&
\&    $ok = $q\->upload( \*(Aqupload_field_name\*(Aq, \*(Aq/path/to/write/file.name\*(Aq );
.Ve
.PP
\&\s-1BUT\s0 there is a catch. If you have multiple upload fields, all called
\&'upload_field_name' then you will only get the last uploaded file from
these fields.
.SS "\fIupload_info()\fP Get the details about uploaded files"
.IX Subsection "upload_info() Get the details about uploaded files"
The \fB\f(BIupload_info()\fB\fR method is a new method. Called without arguments it
returns the number of uploaded files in scalar context and the names of
those files in list context.
.PP
.Vb 2
\&    $number_of_upload_files   = $q\->upload_info();
\&    @filenames_of_all_uploads = $q\->upload_info();
.Ve
.PP
You can get the \s-1MIME\s0 type of an uploaded file like this:
.PP
.Vb 1
\&    $mime = $q\->upload_info( $filename1, \*(Aqmime\*(Aq );
.Ve
.PP
If you want to know how big a file is before you copy it you can get that
information from \fBuploadInfo\fR which will return the file size in bytes.
.PP
.Vb 1
\&    $file_size = $q\->upload_info( $filename1, \*(Aqsize\*(Aq );
.Ve
.PP
The size attribute is optional as this is the default value returned.
.PP
Note: The old \s-1CGI\s0.pm \fB\f(BIuploadInfo()\fB\fR method has been deleted.
.ie n .SS "$POST_MAX and $DISABLE_UPLOADS"
.el .SS "\f(CW$POST_MAX\fP and \f(CW$DISABLE_UPLOADS\fP"
.IX Subsection "$POST_MAX and $DISABLE_UPLOADS"
\&\s-1CGI\s0.pm has a default setting that allows infinite size file uploads by
default. In contrast file uploads are disabled by default in CGI::Simple
to discourage Denial of Service attacks. You must enable them before you
expect file uploads to work.
.PP
When file uploads are disabled the file name and file size details will
still be available from \fB\f(BIparam()\fB\fR and \fBupload_info\fR respectively but
the upload filehandle returned by \fB\f(BIupload()\fB\fR will be undefined \- not
surprising as the underlying temp file will not exist either.
.PP
You can enable uploads using the '\-upload' pragma. You do this by specifying
this in you use statement:
.PP
.Vb 1
\&    use CGI::Simple qw(\-upload);
.Ve
.PP
Alternatively you can enable uploads via the \f(CW$DISABLE_UPLOADS\fR global like this:
.PP
.Vb 3
\&    use CGI::Simple;
\&    $CGI::Simple::DISABLE_UPLOADS = 0;
\&    $q = new CGI::Simple;
.Ve
.PP
If you wish to set \f(CW$DISABLE_UPLOADS\fR you must do this *after* the
use statement and *before* the new constructor call as shown above.
.PP
The maximum acceptable data via post is capped at 102_400kB rather than
infinity which is the \s-1CGI\s0.pm default. This should be ample for most tasks
but you can set this to whatever you want using the \f(CW$POST_MAX\fR global.
.PP
.Vb 4
\&    use CGI::Simple;
\&    $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads
\&    $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads
\&    $q = new CGI::Simple;
.Ve
.PP
If you set to \-1 infinite size uploads will be permitted, which is the \s-1CGI\s0.pm
default.
.PP
.Vb 1
\&    $CGI::Simple::POST_MAX = \-1;            # infinite size upload
.Ve
.PP
Alternatively you can specify all the \s-1CGI\s0.pm default values which allow file
uploads of infinite size in one easy step by specifying the '\-default' pragma
in your use statement.
.PP
.Vb 1
\&    use CGI::Simple qw( \-default ..... );
.Ve
.SS "\fIbinmode()\fP and Win32"
.IX Subsection "binmode() and Win32"
If you are using CGI::Simple be sure to call \fB\f(BIbinmode()\fB\fR on any handle that
you create to write the uploaded file to disk. Calling \fB\f(BIbinmode()\fB\fR will do
no harm on other systems anyway.
.SH "MISCELANEOUS METHODS"
.IX Header "MISCELANEOUS METHODS"
.SS "\fIescapeHTML()\fP Escaping \s-1HTML\s0 special characters"
.IX Subsection "escapeHTML() Escaping HTML special characters"
In \s-1HTML\s0 the < > " and & chars have special meaning and need to be
escaped to &lt; &gt; &quot; and &amp; respectively.
.PP
.Vb 1
\&    $escaped = $q\->escapeHTML( $string );
\&
\&    $escaped = $q\->escapeHTML( $string, \*(Aqnew_lines_too\*(Aq );
.Ve
.PP
If the optional second argument is supplied then newlines will be escaped to.
.SS "\fIunescapeHTML()\fP Unescape \s-1HTML\s0 special characters"
.IX Subsection "unescapeHTML() Unescape HTML special characters"
This performs the reverse of \fB\f(BIescapeHTML()\fB\fR.
.PP
.Vb 1
\&    $unescaped = $q\->unescapeHTML( $HTML_escaped_string );
.Ve
.SS "\fIurl_decode()\fP Decode a \s-1URL\s0 encoded string"
.IX Subsection "url_decode() Decode a URL encoded string"
This method will correctly decode a url encoded string.
.PP
.Vb 1
\&    $decoded = $q\->url_decode( $encoded );
.Ve
.SS "\fIurl_encode()\fP \s-1URL\s0 encode a string"
.IX Subsection "url_encode() URL encode a string"
This method will correctly \s-1URL\s0 encode a string.
.PP
.Vb 1
\&    $encoded = $q\->url_encode( $string );
.Ve
.SS "\fIparse_keywordlist()\fP Parse a supplied keyword list"
.IX Subsection "parse_keywordlist() Parse a supplied keyword list"
.Vb 1
\&    @keywords = $q\->parse_keywordlist( $keyword_list );
.Ve
.PP
This method returns a list of keywords, correctly \s-1URL\s0 escaped and split out
of the supplied string
.SS "\fIput()\fP Send output to browser"
.IX Subsection "put() Send output to browser"
\&\s-1CGI\s0.pm alias for print. \f(CW$q\fR\->put('Hello World!') will print the usual
.SS "\fIprint()\fP Send output to browser"
.IX Subsection "print() Send output to browser"
\&\s-1CGI\s0.pm alias for print. \f(CW$q\fR\->print('Hello World!') will print the usual
.SH "HTTP COOKIES"
.IX Header "HTTP COOKIES"
\&\s-1CGI\s0.pm has several methods that support cookies.
.PP
A cookie is a name=value pair much like the named parameters in a \s-1CGI\s0
query string.  \s-1CGI\s0 scripts create one or more cookies and send
them to the browser in the \s-1HTTP\s0 header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the \s-1CGI\s0 script during subsequent interactions.
.PP
In addition to the required name=value pair, each cookie has several
optional attributes:
.IP "1. an expiration time" 4
.IX Item "1. an expiration time"
This is a time/date string (in a special \s-1GMT\s0 format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.
.IP "2. a domain" 4
.IX Item "2. a domain"
This is a partial or complete domain name for which the cookie is
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of \*(L".capricorn.com\*(R", then the browser will return the cookie to
Web servers running on any of the machines \*(L"www.capricorn.com\*(R",
\&\*(L"www2.capricorn.com\*(R", \*(L"feckless.capricorn.com\*(R", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like \*(L".edu\*(R".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.
.IP "3. a path" 4
.IX Item "3. a path"
If you provide a cookie path attribute, the browser will check it
against your script's \s-1URL\s0 before returning the cookie.  For example,
if you specify the path \*(L"/cgi\-bin\*(R", then the cookie will be returned
to each of the scripts \*(L"/cgi\-bin/tally.pl\*(R", \*(L"/cgi\-bin/order.pl\*(R",
and \*(L"/cgi\-bin/customer_service/complain.pl\*(R", but not to the script
\&\*(L"/cgi\-private/site_admin.pl\*(R".  By default, path is set to \*(L"/\*(R", which
causes the cookie to be sent to any \s-1CGI\s0 script on your site.
.ie n .IP "4. a ""secure"" flag" 4
.el .IP "4. a ``secure'' flag" 4
.IX Item "4. a secure flag"
If the \*(L"secure\*(R" attribute is set, the cookie will only be sent to your
script if the \s-1CGI\s0 request is occurring on a secure channel, such as \s-1SSL\s0.
.SS "\fIcookie()\fP A simple access method to cookies"
.IX Subsection "cookie() A simple access method to cookies"
The interface to \s-1HTTP\s0 cookies is the \fB\f(BIcookie()\fB\fR method:
.PP
.Vb 8
\&    $cookie = $q\->cookie( \-name      => \*(AqsessionID\*(Aq,
\&                          \-value     => \*(Aqxyzzy\*(Aq,
\&                          \-expires   => \*(Aq+1h\*(Aq,
\&                          \-path      => \*(Aq/cgi\-bin/database\*(Aq,
\&                          \-domain    => \*(Aq.capricorn.org\*(Aq,
\&                          \-secure    => 1
\&                         );
\&    print $q\->header(\-cookie=>$cookie);
.Ve
.PP
\&\fB\f(BIcookie()\fB\fR creates a new cookie.  Its parameters include:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the cookie (required).  This can be any string at all.
Although browsers limit their cookie names to non-whitespace
alphanumeric characters, \s-1CGI\s0.pm removes this restriction by escaping
and unescaping cookies behind the scenes.
.IP "\fB\-value\fR" 4
.IX Item "-value"
The value of the cookie.  This can be any scalar value,
array reference, or even associative array reference.  For example,
you can store an entire associative array into a cookie this way:
.Sp
.Vb 2
\&    $cookie=$q\->cookie( \-name   => \*(Aqfamily information\*(Aq,
\&                        \-value  => \e%childrens_ages );
.Ve
.IP "\fB\-path\fR" 4
.IX Item "-path"
The optional partial path for which this cookie will be valid, as described
above.
.IP "\fB\-domain\fR" 4
.IX Item "-domain"
The optional partial domain for which this cookie will be valid, as described
above.
.IP "\fB\-expires\fR" 4
.IX Item "-expires"
The optional expiration date for this cookie.  The format is as described
in the section on the \fB\f(BIheader()\fB\fR method:
.Sp
.Vb 1
\&    "+1h"  one hour from now
.Ve
.IP "\fB\-secure\fR" 4
.IX Item "-secure"
If set to true, this cookie will only be used within a secure
\&\s-1SSL\s0 session.
.PP
The cookie created by \fB\f(BIcookie()\fB\fR must be incorporated into the \s-1HTTP\s0
header within the string returned by the \fB\f(BIheader()\fB\fR method:
.PP
.Vb 1
\&    print $q\->header(\-cookie=>$my_cookie);
.Ve
.PP
To create multiple cookies, give \fB\f(BIheader()\fB\fR an array reference:
.PP
.Vb 7
\&    $cookie1 = $q\->cookie( \-name  => \*(Aqriddle_name\*(Aq,
\&                           \-value => "The Sphynx\*(Aqs Question"
\&                         );
\&    $cookie2 = $q\->cookie( \-name  => \*(Aqanswers\*(Aq,
\&                           \-value => \e%answers
\&                         );
\&    print $q\->header( \-cookie => [ $cookie1, $cookie2 ] );
.Ve
.PP
To retrieve a cookie, request it by name by calling \fB\f(BIcookie()\fB\fR method
without the \fB\-value\fR parameter:
.PP
.Vb 4
\&    use CGI::Simple;
\&    $q = new CGI::Simple;
\&    $riddle  = $q\->cookie(\*(Aqriddle_name\*(Aq);
\&    %answers = $q\->cookie(\*(Aqanswers\*(Aq);
.Ve
.PP
Cookies created with a single scalar value, such as the \*(L"riddle_name\*(R"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.
.PP
The cookie and CGI::Simple  namespaces are separate.  If you have a parameter
named 'answers' and a cookie named 'answers', the values retrieved by
\&\fB\f(BIparam()\fB\fR and \fB\f(BIcookie()\fB\fR are independent of each other.  However, it's
simple to turn a \s-1CGI\s0 parameter into a cookie, and vice-versa:
.PP
.Vb 4
\&    # turn a CGI parameter into a cookie
\&    $c = $q\->cookie( \-name=>\*(Aqanswers\*(Aq, \-value=>[$q\->param(\*(Aqanswers\*(Aq)] );
\&    # vice\-versa
\&    $q\->param( \-name=>\*(Aqanswers\*(Aq, \-value=>[$q\->cookie(\*(Aqanswers\*(Aq)] );
.Ve
.SS "\fIraw_cookie()\fP"
.IX Subsection "raw_cookie()"
Returns the \s-1HTTP_COOKIE\s0 variable. Cookies have a special format, and
this method call just returns the raw form (?cookie dough). See
\&\fB\f(BIcookie()\fB\fR for ways of setting and retrieving cooked cookies.
.PP
Called with no parameters, \fB\f(BIraw_cookie()\fB\fR returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence \*(L"; \*(R".  Called with the name of a cookie,
retrieves the \fBunescaped\fR form of the cookie.  You can use the
regular \fB\f(BIcookie()\fB\fR method to get the names, or use the \fIraw_fetch()\fR
method from the CGI::Simmple::Cookie module.
.SH "CREATING HTTP HEADERS"
.IX Header "CREATING HTTP HEADERS"
Normally the first thing you will do in any \s-1CGI\s0 script is print out an
\&\s-1HTTP\s0 header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
.SS "\fIheader()\fP Create simple or complex \s-1HTTP\s0 headers"
.IX Subsection "header() Create simple or complex HTTP headers"
.Vb 1
\&    print $q\->header;
\&
\&         \-or\-
\&
\&    print $q\->header(\*(Aqimage/gif\*(Aq);
\&
\&         \-or\-
\&
\&    print $q\->header(\*(Aqtext/html\*(Aq,\*(Aq204 No response\*(Aq);
\&
\&         \-or\-
\&
\&    print $q\->header( \-type       => \*(Aqimage/gif\*(Aq,
\&                      \-nph        => 1,
\&                      \-status     => \*(Aq402 Payment required\*(Aq,
\&                      \-expires    => \*(Aq+3d\*(Aq,
\&                      \-cookie     => $cookie,
\&                      \-charset    => \*(Aqutf\-7\*(Aq,
\&                      \-attachment => \*(Aqfoo.gif\*(Aq,
\&                      \-Cost       => \*(Aq$2.00\*(Aq
\&                    );
.Ve
.PP
\&\fB\f(BIheader()\fB\fR returns the Content-type: header.  You can provide your own
\&\s-1MIME\s0 type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, \*(L"No response\*(R" to create a
script that tells the browser to do nothing at all.
.PP
The last example shows the named argument style for passing arguments
to the \s-1CGI\s0 methods using named parameters.  Recognized parameters are
\&\fB\-type\fR, \fB\-status\fR, \fB\-cookie\fR, \fB\-target\fR, \fB\-expires\fR, \fB\-nph\fR,
\&\fB\-charset\fR and \fB\-attachment\fR.  Any other named parameters will be
stripped of their initial hyphens and turned into header fields, allowing
you to specify any \s-1HTTP\s0 header you desire.
.PP
For example, you can produce non-standard \s-1HTTP\s0 header fields by providing
them as named arguments:
.PP
.Vb 6
\&  print $q\->header( \-type            => \*(Aqtext/html\*(Aq,
\&                    \-nph             => 1,
\&                    \-cost            => \*(AqThree smackers\*(Aq,
\&                    \-annoyance_level => \*(Aqhigh\*(Aq,
\&                    \-complaints_to   => \*(Aqbit bucket\*(Aq
\&                  );
.Ve
.PP
This will produce the following non-standard \s-1HTTP\s0 header:
.PP
.Vb 5
\&    HTTP/1.0 200 OK
\&    Cost: Three smackers
\&    Annoyance\-level: high
\&    Complaints\-to: bit bucket
\&    Content\-type: text/html
.Ve
.PP
Note that underscores are translated automatically into hyphens. This feature
allows you to keep up with the rapidly changing \s-1HTTP\s0 \*(L"standards\*(R".
.PP
The \fB\-type\fR is a key element that tell the browser how to display your
document. The default is 'text/html'. Common types are:
.PP
.Vb 6
\&    text/html
\&    text/plain
\&    image/gif
\&    image/jpg
\&    image/png
\&    application/octet\-stream
.Ve
.PP
The \fB\-status\fR code is the \s-1HTTP\s0 response code. The default is 200 \s-1OK\s0. Common
status codes are:
.PP
.Vb 10
\&    200 OK
\&    204 No Response
\&    301 Moved Permanently
\&    302 Found
\&    303 See Other
\&    307 Temporary Redirect
\&    400 Bad Request
\&    401 Unauthorized
\&    403 Forbidden
\&    404 Not Found
\&    405 Not Allowed
\&    408 Request Timed Out
\&    500 Internal Server Error
\&    503 Service Unavailable
\&    504 Gateway Timed Out
.Ve
.PP
The \fB\-expires\fR parameter lets you indicate to a browser and proxy server
how long to cache pages for. When you specify an absolute or relative
expiration interval with this parameter, some browsers and proxy servers
will cache the script's output until the indicated expiration date.
The following forms are all valid for the \-expires field:
.PP
.Vb 8
\&    +30s                                30 seconds from now
\&    +10m                                ten minutes from now
\&    +1h                                 one hour from now
\&    \-1d                                 yesterday (i.e. "ASAP!")
\&    now                                 immediately
\&    +3M                                 in three months
\&    +10y                                in ten years time
\&    Thursday, 25\-Apr\-1999 00:40:33 GMT  at the indicated time & date
.Ve
.PP
The \fB\-cookie\fR parameter generates a header that tells the browser to provide
a \*(L"magic cookie\*(R" during all subsequent transactions with your script.
Netscape cookies have a special format that includes interesting attributes
such as expiration time.  Use the \fB\f(BIcookie()\fB\fR method to create and retrieve
session cookies.
.PP
The \fB\-target\fR is for frames use
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers that expect all their scripts to be \s-1NPH\s0.
.PP
The \fB\-charset\fR parameter can be used to control the character set
sent to the browser.  If not provided, defaults to \s-1ISO\-8859\-1\s0.  As a
side effect, this sets the \fIcharset()\fR method as well.
.PP
The \fB\-attachment\fR parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the \fB\-type\fR to 'application/octet\-stream'.
.SS "\fIno_cache()\fP Preventing browser caching of scripts"
.IX Subsection "no_cache() Preventing browser caching of scripts"
Most browsers will not cache the output from \s-1CGI\s0 scripts. Every time
the browser reloads the page, the script is invoked anew. However some
browsers do cache pages. You can discourage this behavior using the
\&\fB\f(BIno_cache()\fB\fR function.
.PP
.Vb 2
\&    $q\->no_cache(1); # turn caching off by sending appropriate headers
\&    $q\->no_cache(1); # do not send cache related headers.
\&
\&    $q\->no_cache(1);
\&    print header (\-type=>\*(Aqimage/gif\*(Aq, \-nph=>1);
\&
\&    This will produce a header like the following:
\&
\&    HTTP/1.0 200 OK
\&    Server: Apache \- accept no substitutes
\&    Expires: Thu, 15 Nov 2001 03:37:50 GMT
\&    Date: Thu, 15 Nov 2001 03:37:50 GMT
\&    Pragma: no\-cache
\&    Content\-Type: image/gif
.Ve
.PP
Both the Pragma: no-cache header field and an Expires header that corresponds
to the current time (ie now) will be sent.
.SS "\fIcache()\fP Preventing browser caching of scripts"
.IX Subsection "cache() Preventing browser caching of scripts"
The somewhat ill named \fB\f(BIcache()\fB\fR method is a legacy from \s-1CGI\s0.pm. It operates
the same as the new \fB\f(BIno_cache()\fB\fR method. The difference is/was that when set
it results only in the Pragma: no-cache line being printed.
Expires time data is not sent.
.SS "\fIredirect()\fP Generating a redirection header"
.IX Subsection "redirect() Generating a redirection header"
.Vb 1
\&    print $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.PP
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a \s-1URL\s0 based on the
time of day or the identity of the user.
.PP
The \fB\f(BIredirect()\fB\fR function redirects the browser to a different \s-1URL\s0.  If
you use redirection like this, you should \fBnot\fR print out a header as
well.
.PP
One hint I can offer is that relative links may not work correctly
when you generate a redirection to another document on your site.
This is due to a well-intentioned optimization that some servers use.
The solution to this is to use the full \s-1URL\s0 (including the http: part)
of the document you are redirecting to.
.PP
You can also use named arguments:
.PP
.Vb 3
\&    print $q\->redirect( \-uri=>\*(Aqhttp://somewhere.else/in/movie/land\*(Aq,
\&                        \-nph=>1
\&                      );
.Ve
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft ones, which
expect all their scripts to be \s-1NPH\s0.
.SH "PRAGMAS"
.IX Header "PRAGMAS"
There are a number of pragmas that you can specify in your use CGI::Simple
statement. Pragmas, which are always preceded by a hyphen, change the way
that CGI::Simple functions in various ways. You can generally achieve
exactly the same results by setting the underlying \f(CW$GLOBAL_VARIABLES\fR.
.PP
For example the '\-upload' pargma will enable file uploads:
.PP
.Vb 1
\&    use CGI::Simple qw(\-upload);
.Ve
.PP
In CGI::Simple::Standard Pragmas, function sets , and individual functions
can all be imported in the same \fIuse()\fR line.  For example, the following
use statement imports the standard set of functions and enables debugging
mode (pragma \-debug):
.PP
.Vb 1
\&    use CGI::Simple::Standard qw(:standard \-debug);
.Ve
.PP
The current list of pragmas is as follows:
.IP "\-no_undef_params" 4
.IX Item "-no_undef_params"
If a value is not given in the query string, as in the queries
\&\*(L"name1=&name2=\*(R" or \*(L"name1&name2\*(R", by default it will be returned
as an empty string.
.Sp
If you specify the '\-no_undef_params' pragma then CGI::Simple ignores
parameters with no values and they will not appear in the query object.
.IP "\-nph" 4
.IX Item "-nph"
This makes \s-1CGI\s0.pm produce a header appropriate for an \s-1NPH\s0 (no
parsed header) script.  You may need to do other things as well
to tell the server that the script is \s-1NPH\s0.  See the discussion
of \s-1NPH\s0 scripts below.
.IP "\-newstyle_urls" 4
.IX Item "-newstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
semicolons rather than ampersands.  For example:
.Sp
.Vb 1
\&    ?name=fred;age=24;favorite_color=3
.Ve
.Sp
Semicolon-delimited query strings are always accepted, but will not be
emitted by \fIself_url()\fR and \fIquery_string()\fR unless the \-newstyle_urls
pragma is specified.
.IP "\-oldstyle_urls" 4
.IX Item "-oldstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
ampersands rather than semicolons.  This is the default.
.Sp
.Vb 1
\&    ?name=fred&age=24&favorite_color=3
.Ve
.IP "\-autoload" 4
.IX Item "-autoload"
This is only available for CGI::Simple::Standard and uses \s-1AUTOLOAD\s0 to
load functions on demand. See the CGI::Simple::Standard docs for details.
.IP "\-no_debug" 4
.IX Item "-no_debug"
This turns off the command-line processing features. This is the default.
.IP "\-debug1 and debug2" 4
.IX Item "-debug1 and debug2"
This turns on debugging.  At debug level 1 CGI::Simple will read arguments
from the command-line. At debug level 2 \s-1CGI\s0.pm will produce the prompt
\&\*(L"(offline mode: enter name=value pairs on standard input)\*(R" and wait for
input on \s-1STDIN\s0. If no number is specified then a debug level of 2 is used.
.Sp
See the section on debugging for more details.
.IP "\-default" 4
.IX Item "-default"
This sets the default global values for \s-1CGI\s0.pm which will enable infinite
size file uploads, and specify the '\-newstyle_urls' and '\-debug1' pragmas
.IP "\-no_upload" 4
.IX Item "-no_upload"
Disable uploads \- the default setting
.IP "\- upload" 4
.IX Item "- upload"
Enable uploads \- the \s-1CGI\s0.pm default
.IP "\-unique_header" 4
.IX Item "-unique_header"
Only allows headers to be generated once per script invocation
.IP "\-carp" 4
.IX Item "-carp"
Carp when \fB\f(BIcgi_error()\fB\fR called, default is to do nothing
.IP "\-croak" 4
.IX Item "-croak"
Croak when \fB\f(BIcgi_error()\fB\fR called, default is to do nothing
.SH "USING NPH SCRIPTS"
.IX Header "USING NPH SCRIPTS"
\&\s-1NPH\s0, or \*(L"no-parsed-header\*(R", scripts bypass the server completely by
sending the complete \s-1HTTP\s0 header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of \s-1HTTP\s0 extensions that are not directly supported by your server,
such as server push and \s-1PICS\s0 headers.
.PP
Servers use a variety of conventions for designating \s-1CGI\s0 scripts as
\&\s-1NPH\s0.  Many Unix servers look at the beginning of the script's name for
the prefix \*(L"nph\-\*(R".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an \s-1NPH\s0 script by examining the first line of script output.
.PP
\&\s-1CGI\s0.pm supports \s-1NPH\s0 scripts with a special \s-1NPH\s0 mode.  When in this
mode, \s-1CGI\s0.pm will output the necessary extra header information when
the \fB\f(BIheader()\fB\fR and \fB\f(BIredirect()\fB\fR methods are called. You can set \s-1NPH\s0 mode
in any of the following ways:
.IP "In the \fBuse\fR statement" 4
.IX Item "In the use statement"
Simply add the \*(L"\-nph\*(R" pragma to the use:
.Sp
.Vb 1
\&    use CGI::Simple qw(\-nph)
.Ve
.IP "By calling the \fB\f(BInph()\fB\fR method:" 4
.IX Item "By calling the nph() method:"
Call \fB\f(BInph()\fB\fR with a non-zero parameter at any point after using \s-1CGI\s0.pm in your program.
.Sp
.Vb 1
\&    $q\->nph(1)
.Ve
.IP "By using \fB\-nph\fR parameters" 4
.IX Item "By using -nph parameters"
in the \fB\f(BIheader()\fB\fR and \fB\f(BIredirect()\fB\fR  statements:
.Sp
.Vb 1
\&    print $q\->header(\-nph=>1);
.Ve
.PP
The Microsoft Internet Information Server requires \s-1NPH\s0 mode.
CGI::Simple will automatically detect when the script is
running under \s-1IIS\s0 and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of \s-1NPH\s0 scripts, including the ability to redirect while
setting a cookie, b<do not work at all> on \s-1IIS\s0 without a special patch
from Microsoft.  See
http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:
Non-Parsed Headers Stripped From \s-1CGI\s0 Applications That Have nph\-
Prefix in Name.
.SH "SERVER PUSH"
.IX Header "SERVER PUSH"
\&\s-1CGI\s0.pm provides four simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@fidalgo.net> with
additions from Andrew Benham <adsb@bigfoot.com>
.PP
You are also advised to put the script into \s-1NPH\s0 mode and to set $| to
1 to avoid buffering problems.
.PP
Browser support for server push is variable.
.PP
Here is a simple script that demonstrates server push:
.PP
.Vb 10
\&    #!/usr/local/bin/perl
\&    use CGI::Simple::Standard qw/:push \-nph/;
\&    $| = 1;
\&    print multipart_init(\-boundary=>\*(Aq\-\-\-\-here we go!\*(Aq);
\&    foreach (0 .. 4) {
\&        print multipart_start(\-type=>\*(Aqtext/plain\*(Aq),
\&        "The current time is ",scalar(localtime),"\en";
\&        if ($_ < 4) {
\&            print multipart_end;
\&        }
\&        else {
\&            print multipart_final;
\&        }
\&        sleep 1;
\&    }
.Ve
.PP
This script initializes server push by calling \fB\f(BImultipart_init()\fB\fR.
It then enters a loop in which it begins a new multipart section by
calling \fB\f(BImultipart_start()\fB\fR, prints the current local time,
and ends a multipart section with \fB\f(BImultipart_end()\fB\fR.  It then sleeps
a second, and begins again. On the final iteration, it ends the
multipart section with \fB\f(BImultipart_final()\fB\fR rather than with
\&\fB\f(BImultipart_end()\fB\fR.
.SS "\fImultipart_init()\fP Initialize the multipart system"
.IX Subsection "multipart_init() Initialize the multipart system"
.Vb 1
\&    multipart_init(\-boundary=>$boundary);
.Ve
.PP
Initialize the multipart system.  The \-boundary argument specifies
what \s-1MIME\s0 boundary string to use to separate parts of the document.
If not provided, \s-1CGI\s0.pm chooses a reasonable boundary for you.
.SS "\fImultipart_start()\fP Start a new part of the multipart document"
.IX Subsection "multipart_start() Start a new part of the multipart document"
.Vb 1
\&    multipart_start(\-type=>$type)
.Ve
.PP
Start a new part of the multipart document using the specified \s-1MIME\s0
type.  If not specified, text/html is assumed.
.SS "\fImultipart_end()\fP End a multipart part"
.IX Subsection "multipart_end() End a multipart part"
.Vb 1
\&    multipart_end()
.Ve
.PP
End a part.  You must remember to call \fB\f(BImultipart_end()\fB\fR once for each
\&\fB\f(BImultipart_start()\fB\fR, except at the end of the last part of the multipart
document when \fB\f(BImultipart_final()\fB\fR should be called instead of
\&\fB\f(BImultipart_end()\fB\fR.
.SS "\fImultipart_final()\fP"
.IX Subsection "multipart_final()"
.Vb 1
\&    multipart_final()
.Ve
.PP
End all parts.  You should call \fB\f(BImultipart_final()\fB\fR rather than
\&\fB\f(BImultipart_end()\fB\fR at the end of the last part of the multipart document.
.SS "CGI::Push"
.IX Subsection "CGI::Push"
Users interested in server push applications should also have a look
at the \fBCGI::Push\fR module.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  Before you do this you will need to change the
debug level from the default level of 0 (no debug) to either 1 if you
want to debug from \f(CW@ARGV\fR (the command line) of 2 if you want to debug from
\&\s-1STDIN\s0. You can do this using the debug pragma like this:
.PP
.Vb 1
\&    use CGI::Simple qw(\-debug2);  # set debug to level 2 => from STDIN
\&
\&        or this:
\&
\&    $CGI::Simple::DEBUG = 1;      # set debug to level 1 => from @ARGV
.Ve
.PP
At debug level 1 you can pass keywords and name=value pairs like this:
.PP
.Vb 1
\&    your_script.pl keyword1 keyword2 keyword3
\&
\&        or this:
\&
\&    your_script.pl keyword1+keyword2+keyword3
\&
\&        or this:
\&
\&    your_script.pl name1=value1 name2=value2
\&
\&        or this:
\&
\&    your_script.pl name1=value1&name2=value2
.Ve
.PP
At debug level 2 you can feed newline-delimited name=value
pairs to the script on standard input. You will be presented
with the following prompt:
.PP
.Vb 1
\&    (offline mode: enter name=value pairs on standard input)
.Ve
.PP
You end the input with your system dependent end of file character.
You should try ^Z ^X ^D and ^C if all else fails. The ^ means hold down
the [Ctrl] button while you press the other key.
.PP
When debugging, you can use quotes and backslashes to escape
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:
.PP
.Vb 1
\&    your_script.pl "name1=\*(AqI am a long value\*(Aq" "name2=two\e words"
.Ve
.SS "\fIDump()\fP Dumping the current object details"
.IX Subsection "Dump() Dumping the current object details"
The \fB\f(BIDump()\fB\fR method produces a string consisting of all the
query's object attributes formatted nicely as a nested list.  This dump
includes the name/value pairs and a number of other details. This is useful
for debugging purposes:
.PP
.Vb 1
\&    print $q\->Dump
.Ve
.PP
The actual result of this is \s-1HTML\s0 escaped formatted text wrapped in <pre> tags
so if you send it straight to the browser it produces something that looks
like:
.PP
.Vb 10
\&    $VAR1 = bless( {
\&         \*(Aq.parameters\*(Aq => [
\&                            \*(Aqname\*(Aq,
\&                            \*(Aqcolor\*(Aq
\&                          ],
\&         \*(Aq.globals\*(Aq => {
\&                         \*(AqFATAL\*(Aq => \-1,
\&                         \*(AqDEBUG\*(Aq => 0,
\&                         \*(AqNO_NULL\*(Aq => 1,
\&                         \*(AqPOST_MAX\*(Aq => 102400,
\&                         \*(AqUSE_CGI_PM_DEFAULTS\*(Aq => 0,
\&                         \*(AqHEADERS_ONCE\*(Aq => 0,
\&                         \*(AqNPH\*(Aq => 0,
\&                         \*(AqDISABLE_UPLOADS\*(Aq => 1,
\&                         \*(AqNO_UNDEF_PARAMS\*(Aq => 0,
\&                         \*(AqUSE_PARAM_SEMICOLONS\*(Aq => 0
\&                       },
\&         \*(Aq.fieldnames\*(Aq => {
\&                            \*(Aqcolor\*(Aq => \*(Aq1\*(Aq,
\&                            \*(Aqname\*(Aq => \*(Aq1\*(Aq
\&                          },
\&         \*(Aq.mod_perl\*(Aq => \*(Aq\*(Aq,
\&         \*(Aqcolor\*(Aq => [
\&                      \*(Aqred\*(Aq,
\&                      \*(Aqgreen\*(Aq,
\&                      \*(Aqblue\*(Aq
\&                    ],
\&         \*(Aqname\*(Aq => [
\&                     \*(AqJaPh,\*(Aq
\&                   ]
\&        }, \*(AqCGI::Simple\*(Aq );
.Ve
.PP
You may recognize this as valid Perl syntax (which it is) and/or the output
from Data::Dumper (also true). This is the actual guts of how the information
is stored in the query object. All the internal params start with a . char
.PP
Alternatively you can dump your object and the current environment using:
.PP
.Vb 1
\&    print $q\->Dump(\e%ENV);
.Ve
.SS "\fIPrintEnv()\fP Dumping the environment"
.IX Subsection "PrintEnv() Dumping the environment"
You can get a similar browser friendly dump of the current \f(CW%ENV\fR hash using:
.PP
.Vb 1
\&    print $q\->PrintEnv;
.Ve
.PP
This will produce something like (in the browser):
.PP
.Vb 10
\&    $VAR1 = {
\&          \*(AqQUERY_STRING\*(Aq => \*(Aqname=JaPh%2C&color=red&color=green&color=blue\*(Aq,
\&          \*(AqCONTENT_TYPE\*(Aq => \*(Aqapplication/x\-www\-form\-urlencoded\*(Aq,
\&          \*(AqREGRESSION_TEST\*(Aq => \*(Aqsimple.t.pl\*(Aq,
\&          \*(AqVIM\*(Aq => \*(AqC:\e\eWINDOWS\e\eDesktop\e\evim\*(Aq,
\&          \*(AqHTTP_REFERER\*(Aq => \*(Aqxxx.sex.com\*(Aq,
\&          \*(AqHTTP_USER_AGENT\*(Aq => \*(AqLWP\*(Aq,
\&          \*(AqHTTP_ACCEPT\*(Aq => \*(Aqtext/html;q=1, image/gif;q=0.42, */*;q=0.001\*(Aq,
\&          \*(AqREMOTE_HOST\*(Aq => \*(Aqlocalhost\*(Aq,
\&          \*(AqHTTP_HOST\*(Aq => \*(Aqthe.restaurant.at.the.end.of.the.universe\*(Aq,
\&          \*(AqGATEWAY_INTERFACE\*(Aq => \*(Aqbleeding edge\*(Aq,
\&          \*(AqREMOTE_IDENT\*(Aq => \*(AqNone of your damn business\*(Aq,
\&          \*(AqSCRIPT_NAME\*(Aq => \*(Aq/cgi\-bin/foo.cgi\*(Aq,
\&          \*(AqSERVER_NAME\*(Aq => \*(Aqnowhere.com\*(Aq,
\&          \*(AqHTTP_COOKIE\*(Aq => \*(Aq\*(Aq,
\&          \*(AqCONTENT_LENGTH\*(Aq => \*(Aq42\*(Aq,
\&          \*(AqHTTPS_A\*(Aq => \*(AqA\*(Aq,
\&          \*(AqHTTP_FROM\*(Aq => \*(Aqspammer@nowhere.com\*(Aq,
\&          \*(AqHTTPS_B\*(Aq => \*(AqB\*(Aq,
\&          \*(AqSERVER_PROTOCOL\*(Aq => \*(AqHTTP/1.0\*(Aq,
\&          \*(AqPATH_TRANSLATED\*(Aq => \*(Aq/usr/local/somewhere/else\*(Aq,
\&          \*(AqSERVER_SOFTWARE\*(Aq => \*(AqApache \- accept no substitutes\*(Aq,
\&          \*(AqPATH_INFO\*(Aq => \*(Aq/somewhere/else\*(Aq,
\&          \*(AqREMOTE_USER\*(Aq => \*(AqJust another Perl hacker,\*(Aq,
\&          \*(AqREMOTE_ADDR\*(Aq => \*(Aq127.0.0.1\*(Aq,
\&          \*(AqHTTPS\*(Aq => \*(AqON\*(Aq,
\&          \*(AqDOCUMENT_ROOT\*(Aq => \*(Aq/vs/www/foo\*(Aq,
\&          \*(AqREQUEST_METHOD\*(Aq => \*(AqGET\*(Aq,
\&          \*(AqREDIRECT_QUERY_STRING\*(Aq => \*(Aq\*(Aq,
\&          \*(AqAUTH_TYPE\*(Aq => \*(AqPGP MD5 DES rot13\*(Aq,
\&          \*(AqCOOKIE\*(Aq => \*(Aqfoo=a%20phrase; bar=yes%2C%20a%20phrase&;I%20say;\*(Aq,
\&          \*(AqSERVER_PORT\*(Aq => \*(Aq8080\*(Aq
\&        };
.Ve
.SS "\fIcgi_error()\fP Retrieving CGI::Simple error messages"
.IX Subsection "cgi_error() Retrieving CGI::Simple error messages"
Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, CGI::Simple will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the \fB\f(BIcgi_error()\fB\fR function.
The error messages are formatted as \s-1HTTP\s0 status codes. You can either
incorporate the error text into an \s-1HTML\s0 page, or use it as the value
of the \s-1HTTP\s0 status:
.PP
.Vb 6
\&    my $error = $q\->cgi_error;
\&    if ($error) {
\&        print $q\->header(\-status=>$error);
\&        print "<H2>$error</H2>;
\&      exit;
\&    }
.Ve
.SH "ACCESSOR METHODS"
.IX Header "ACCESSOR METHODS"
.SS "\fIversion()\fP Get the CGI::Simple version info"
.IX Subsection "version() Get the CGI::Simple version info"
.Vb 1
\&    $version = $q\->version();
.Ve
.PP
The \fB\f(BIversion()\fB\fR method returns the value of \f(CW$VERSION\fR
.SS "\fInph()\fP Enable/disable \s-1NPH\s0 (Non Parsed Header) mode"
.IX Subsection "nph() Enable/disable NPH (Non Parsed Header) mode"
.Vb 2
\&    $q\->nph(1);  # enable NPH mode
\&    $q\->nph(0);  # disable NPH mode
.Ve
.PP
The \fB\f(BInph()\fB\fR method enables and disables \s-1NPH\s0 headers. See the \s-1NPH\s0 section.
.SS "\fIall_parameters()\fP Get the names/values of all parameters"
.IX Subsection "all_parameters() Get the names/values of all parameters"
.Vb 1
\&    @all_parameters = $q\->all_parameters();
.Ve
.PP
The \fB\f(BIall_parameters()\fB\fR method is an alias for \fB\f(BIparam()\fB\fR
.SS "\fIcharset()\fP Get/set the current character set."
.IX Subsection "charset() Get/set the current character set."
.Vb 2
\&    $charset = $q\->charset(); # get current charset
\&    $q\->charset(\*(Aqutf\-42\*(Aq);    # set the charset
.Ve
.PP
The \fB\f(BIcharset()\fB\fR method gets the current charset value if no argument is
supplied or sets it if an argument is supplied.
.SS "\fIcrlf()\fP Get the system specific line ending sequence"
.IX Subsection "crlf() Get the system specific line ending sequence"
.Vb 1
\&    $crlf = $q\->crlf();
.Ve
.PP
The \fB\f(BIcrlf()\fB\fR method returns the system specific line ending sequence.
.SS "\fIglobals()\fP Get/set the value of the remaining global variables"
.IX Subsection "globals() Get/set the value of the remaining global variables"
.Vb 2
\&    $globals = $q\->globals(\*(AqFATAL\*(Aq);     # get the current value of $FATAL
\&    $globals = $q\->globals(\*(AqFATAL\*(Aq, 1 ); # set croak mode on cgi_error()
.Ve
.PP
The \fB\f(BIglobals()\fB\fR method gets/sets the values of the global variables after the
script has been invoked. For globals like \f(CW$POST_MAX\fR and \f(CW$DISABLE_UPLOADS\fR this
makes no difference as they must be set prior to calling the new constructor
but there might be reason the change the value of others.
.SS "\fIauth_type()\fP Get the current authorization/verification method"
.IX Subsection "auth_type() Get the current authorization/verification method"
.Vb 1
\&    $auth_type = $q\->auth_type();
.Ve
.PP
The \fB\f(BIauth_type()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1AUTH_TYPE\s0'} which should
contain the authorization/verification method in use for this script, if any.
.SS "\fIcontent_length()\fP Get the content length submitted in a \s-1POST\s0"
.IX Subsection "content_length() Get the content length submitted in a POST"
.Vb 1
\&    $content_length = $q\->content_length();
.Ve
.PP
The \fB\f(BIcontent_length()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1AUTH_TYPE\s0'}
.SS "\fIcontent_type()\fP Get the content_type of data submitted in a \s-1POST\s0"
.IX Subsection "content_type() Get the content_type of data submitted in a POST"
.Vb 1
\&    $content_type = $q\->content_type();
.Ve
.PP
The \fB\f(BIcontent_type()\fB\fR method returns the content_type of data submitted in
a \s-1POST\s0, generally 'multipart/form\-data' or
\&'application/x\-www\-form\-urlencoded' as supplied in \f(CW$ENV\fR{'\s-1CONTENT_TYPE\s0'}
.SS "\fIdocument_root()\fP Get the document root"
.IX Subsection "document_root() Get the document root"
.Vb 1
\&    $document_root = $q\->document_root();
.Ve
.PP
The \fB\f(BIdocument_root()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1DOCUMENT_ROOT\s0'}
.SS "\fIgateway_interface()\fP Get the gateway interface"
.IX Subsection "gateway_interface() Get the gateway interface"
.Vb 1
\&    $gateway_interface = $q\->gateway_interface();
.Ve
.PP
The \fB\f(BIgateway_interface()\fB\fR method returns the value of
\&\f(CW$ENV\fR{'\s-1GATEWAY_INTERFACE\s0'}
.SS "\fIpath_translated()\fP Get the value of path translated"
.IX Subsection "path_translated() Get the value of path translated"
.Vb 1
\&    $path_translated = $q\->path_translated();
.Ve
.PP
The \fB\f(BIpath_translated()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1PATH_TRANSLATED\s0'}
.SS "\fIreferer()\fP Spy on your users"
.IX Subsection "referer() Spy on your users"
.Vb 1
\&    $referer = $q\->referer();
.Ve
.PP
The \fB\f(BIreferer()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1REFERER\s0'} This will return
the \s-1URL\s0 of the page the browser was viewing prior to fetching your script.
Not available for all browsers.
.SS "\fIremote_addr()\fP Get the remote address"
.IX Subsection "remote_addr() Get the remote address"
.Vb 1
\&    $remote_addr = $q\->remote_addr();
.Ve
.PP
The \fB\f(BIremote_addr()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1REMOTE_ADDR\s0'} or
127.0.0.1 (localhost) if this is not defined.
.SS "\fIremote_host()\fP Get a value for remote host"
.IX Subsection "remote_host() Get a value for remote host"
.Vb 1
\&    $remote_host = $q\->remote_host();
.Ve
.PP
The \fB\f(BIremote_host()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1REMOTE_HOST\s0'} if it is
defined. If this is not defined it returns \f(CW$ENV\fR{'\s-1REMOTE_ADDR\s0'} If this is not
defined it returns 'localhost'
.SS "\fIremote_ident()\fP Get the remote identity"
.IX Subsection "remote_ident() Get the remote identity"
.Vb 1
\&    $remote_ident = $q\->remote_ident();
.Ve
.PP
The \fB\f(BIremote_ident()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1REMOTE_IDENT\s0'}
.SS "\fIremote_user()\fP Get the remote user"
.IX Subsection "remote_user() Get the remote user"
.Vb 1
\&    $remote_user = $q\->remote_user();
.Ve
.PP
The \fB\f(BIremote_user()\fB\fR method returns the authorization/verification name used
for user verification, if this script is protected. The value comes from
\&\f(CW$ENV\fR{'\s-1REMOTE_USER\s0'}
.SS "\fIrequest_method()\fP Get the request method"
.IX Subsection "request_method() Get the request method"
.Vb 1
\&    $request_method = $q\->request_method();
.Ve
.PP
The \fB\f(BIrequest_method()\fB\fR method returns the method used to access your
script, usually one of '\s-1POST\s0', '\s-1GET\s0' or '\s-1HEAD\s0' as supplied by
\&\f(CW$ENV\fR{'\s-1REQUEST_METHOD\s0'}
.SS "\fIscript_name()\fP Get the script name"
.IX Subsection "script_name() Get the script name"
.Vb 1
\&    $script_name = $q\->script_name();
.Ve
.PP
The \fB\f(BIscript_name()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1SCRIPT_NAME\s0'} if it is
defined. Otherwise it returns Perl's script name from \f(CW$0\fR. Failing this it
returns a null string ''
.SS "\fIserver_name()\fP Get the server name"
.IX Subsection "server_name() Get the server name"
.Vb 1
\&    $server_name = $q\->server_name();
.Ve
.PP
The \fB\f(BIserver_name()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1SERVER_NAME\s0'} if defined
or 'localhost' otherwise
.SS "\fIserver_port()\fP Get the port the server is listening on"
.IX Subsection "server_port() Get the port the server is listening on"
.Vb 1
\&    $server_port = $q\->server_port();
.Ve
.PP
The \fB\f(BIserver_port()\fB\fR method returns the value \f(CW$ENV\fR{'\s-1SERVER_PORT\s0'} if defined or
80 if not.
.SS "\fIserver_protocol()\fP Get the current server protocol"
.IX Subsection "server_protocol() Get the current server protocol"
.Vb 1
\&    $server_protocol = $q\->server_protocol();
.Ve
.PP
The \fB\f(BIserver_protocol()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1SERVER_PROTOCOL\s0'} if
defined or '\s-1HTTP/1\s0.0' otherwise
.SS "\fIserver_software()\fP Get the server software"
.IX Subsection "server_software() Get the server software"
.Vb 1
\&    $server_software = $q\->server_software();
.Ve
.PP
The \fB\f(BIserver_software()\fB\fR method returns the value \f(CW$ENV\fR{'\s-1SERVER_SOFTWARE\s0'} or
\&'cmdline' If the server software is \s-1IIS\s0 it formats your hard drive, installs
Linux, FTPs to www.apache.org, installs Apache, and then restores your system
from tape. Well maybe not, but it's a nice thought.
.SS "\fIuser_name()\fP Get a value for the user name."
.IX Subsection "user_name() Get a value for the user name."
.Vb 1
\&    $user_name = $q\->user_name();
.Ve
.PP
Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!
.PP
Technically the \fB\f(BIuser_name()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1HTTP_FROM\s0'}
or failing that \f(CW$ENV\fR{'\s-1REMOTE_IDENT\s0'} or as a last choice \f(CW$ENV\fR{'\s-1REMOTE_USER\s0'}
.SS "\fIuser_agent()\fP Get the users browser type"
.IX Subsection "user_agent() Get the users browser type"
.Vb 2
\&    $ua = $q\->user_agent();          # return the user agent
\&    $ok = $q\->user_agent(\*(Aqmozilla\*(Aq); # return true if user agent \*(Aqmozilla\*(Aq
.Ve
.PP
The \fB\f(BIuser_agent()\fB\fR method returns the value of \f(CW$ENV\fR{'\s-1HTTP_USER_AGENT\s0'}  when
called without an argument or true or false if the \f(CW$ENV\fR{'\s-1HTTP_USER_AGENT\s0'}
matches the passed argument. The matching is case insensitive and partial.
.SS "\fIvirtual_host()\fP Get the virtual host"
.IX Subsection "virtual_host() Get the virtual host"
.Vb 1
\&    $virtual_host = $q\->virtual_host();
.Ve
.PP
The \fB\f(BIvirtual_host()\fB\fR method returns the value of  \f(CW$ENV\fR{'\s-1HTTP_HOST\s0'} if defined
or \f(CW$ENV\fR{'\s-1SERVER_NAME\s0'} as a default. Port numbers are removed.
.SS "\fIpath_info()\fP Get any extra path info set to the script"
.IX Subsection "path_info() Get any extra path info set to the script"
.Vb 1
\&    $path_info = $q\->path_info();
.Ve
.PP
The \fB\f(BIpath_info()\fB\fR method returns additional path information from the script
\&\s-1URL\s0. E.G. fetching /cgi\-bin/your_script/additional/stuff will result in
\&\f(CW$q\fR\->\fIpath_info()\fR returning \*(L"/additional/stuff\*(R".
.PP
\&\s-1NOTE:\s0 The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl \s-1DLL\s0 library, the \s-1IIS\s0 server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment,
but incorrect.  The best thing to do is to avoid using additional
path information in \s-1CGI\s0 scripts destined for use with \s-1IIS\s0.
.SS "\fIAccept()\fP Get the browser \s-1MIME\s0 types"
.IX Subsection "Accept() Get the browser MIME types"
.Vb 1
\&    $Accept = $q\->Accept();
.Ve
.PP
The \fB\f(BIAccept()\fB\fR method returns a list of \s-1MIME\s0 types that the remote browser
accepts. If you give this method a single argument corresponding to a
\&\s-1MIME\s0 type, as in \f(CW$q\fR\->Accept('text/html'), it will return a floating point
value corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.
.SS "\fIaccept()\fP Alias for \fIAccept()\fP"
.IX Subsection "accept() Alias for Accept()"
.Vb 1
\&    $accept = $q\->accept();
.Ve
.PP
The \fB\f(BIaccept()\fB\fR Method is an alias for \fIAccept()\fR
.SS "\fIhttp()\fP Get a range of \s-1HTTP\s0 related information"
.IX Subsection "http() Get a range of HTTP related information"
.Vb 1
\&    $http = $q\->http();
.Ve
.PP
Called with no arguments the \fB\f(BIhttp()\fB\fR method returns the list of \s-1HTTP\s0 or \s-1HTTPS\s0
environment variables, including such things as \s-1HTTP_USER_AGENT\s0,
\&\s-1HTTP_ACCEPT_LANGUAGE\s0, and \s-1HTTP_ACCEPT_CHARSET\s0, corresponding to the
like-named \s-1HTTP\s0 header fields in the request. Called with the name of
an \s-1HTTP\s0 header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.
.PP
For example, all three of these examples are equivalent:
.PP
.Vb 3
\&   $requested_language = $q\->http(\*(AqAccept\-language\*(Aq);
\&   $requested_language = $q\->http(\*(AqAccept_language\*(Aq);
\&   $requested_language = $q\->http(\*(AqHTTP_ACCEPT_LANGUAGE\*(Aq);
.Ve
.SS "\fIhttps()\fP Get a range of \s-1HTTPS\s0 related information"
.IX Subsection "https() Get a range of HTTPS related information"
.Vb 1
\&    $https = $q\->https();
.Ve
.PP
The \fB\f(BIhttps()\fB\fR method is similar to the \fIhttp()\fR method except that when called
without an argument it returns the value of \f(CW$ENV\fR{'\s-1HTTPS\s0'} which will be
true if a \s-1HTTPS\s0 connection is in use and false otherwise.
.SS "\fIprotocol()\fP Get the current protocol"
.IX Subsection "protocol() Get the current protocol"
.Vb 1
\&    $protocol = $q\->protocol();
.Ve
.PP
The \fB\f(BIprotocol()\fB\fR method returns 'https' if a \s-1HTTPS\s0 connection is in use or the
\&\fB\f(BIserver_protocol()\fB\fR minus version numbers ('http') otherwise.
.SS "\fIurl()\fP Return the script's \s-1URL\s0 in several formats"
.IX Subsection "url() Return the script's URL in several formats"
.Vb 7
\&    $full_url      = $q\->url();
\&    $full_url      = $q\->url(\-full=>1);
\&    $relative_url  = $q\->url(\-relative=>1);
\&    $absolute_url  = $q\->url(\-absolute=>1);
\&    $url_with_path = $q\->url(\-path_info=>1);
\&    $url_with_path_and_query = $q\->url(\-path_info=>1,\-query=>1);
\&    $netloc        = $q\->url(\-base => 1);
.Ve
.PP
\&\fB\f(BIurl()\fB\fR returns the script's \s-1URL\s0 in a variety of formats.  Called
without any arguments, it returns the full form of the \s-1URL\s0, including
host name and port number
.PP
.Vb 1
\&    http://your.host.com/path/to/script.cgi
.Ve
.PP
You can modify this format with the following named arguments:
.IP "\fB\-absolute\fR" 4
.IX Item "-absolute"
If true, produce an absolute \s-1URL\s0, e.g.
.Sp
.Vb 1
\&    /path/to/script.cgi
.Ve
.IP "\fB\-relative\fR" 4
.IX Item "-relative"
Produce a relative \s-1URL\s0.  This is useful if you want to reinvoke your
script with different parameters. For example:
.Sp
.Vb 1
\&    script.cgi
.Ve
.IP "\fB\-full\fR" 4
.IX Item "-full"
Produce the full \s-1URL\s0, exactly as if called without any arguments.
This overrides the \-relative and \-absolute arguments.
.IP "\fB\-path\fR (\fB\-path_info\fR)" 4
.IX Item "-path (-path_info)"
Append the additional path information to the \s-1URL\s0.  This can be
combined with \fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-path_info\fR
is provided as a synonym.
.IP "\fB\-query\fR (\fB\-query_string\fR)" 4
.IX Item "-query (-query_string)"
Append the query string to the \s-1URL\s0.  This can be combined with
\&\fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-query_string\fR is provided
as a synonym.
.IP "\fB\-base\fR" 4
.IX Item "-base"
Generate just the protocol and net location, as in http://www.foo.com:8000
.SS "\fIself_url()\fP Get the scripts complete \s-1URL\s0"
.IX Subsection "self_url() Get the scripts complete URL"
.Vb 1
\&    $self_url = $q\->self_url();
.Ve
.PP
The \fB\f(BIself_url()\fB\fR method returns the value of:
.PP
.Vb 1
\&   $self\->url( \*(Aq\-path_info\*(Aq=>1, \*(Aq\-query\*(Aq=>1, \*(Aq\-full\*(Aq=>1 );
.Ve
.SS "\fIstate()\fP Alias for \fIself_url()\fP"
.IX Subsection "state() Alias for self_url()"
.Vb 1
\&    $state = $q\->state();
.Ve
.PP
The \fB\f(BIstate()\fB\fR method is an alias for \fIself_url()\fR
.SH "COMPATIBILITY WITH cgi\-lib.pl 2.18"
.IX Header "COMPATIBILITY WITH cgi-lib.pl 2.18"
To make it easier to port existing programs that use cgi\-lib.pl all
the subs within cgi\-lib.pl are available in CGI::Simple.  Using the
functional interface of CGI::Simple::Standard porting is
as easy as:
.PP
.Vb 4
\&    OLD VERSION
\&        require "cgi\-lib.pl";
\&        &ReadParse;
\&        print "The value of the antique is $in{\*(Aqantique\*(Aq}.\en";
\&
\&    NEW VERSION
\&        use CGI::Simple::Standard qw(:cgi\-lib);
\&        &ReadParse;
\&        print "The value of the antique is $in{\*(Aqantique\*(Aq}.\en";
.Ve
.PP
CGI:Simple's \fB\f(BIReadParse()\fB\fR routine creates a variable named \f(CW%in\fR,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable via a glob. Infrequently
used features of \fB\f(BIReadParse()\fB\fR, such as the creation of \f(CW@in\fR and \f(CW$in\fR
variables, are not supported.
.PP
You can also use the \s-1OO\s0 interface of CGI::Simple and call \fB\f(BIReadParse()\fB\fR and
other cgi\-lib.pl functions like this:
.PP
.Vb 1
\&    &CGI::Simple::ReadParse;       # get hash values in %in
\&
\&    my $q = new CGI::Simple;
\&    $q\->ReadParse();                # same thing
\&
\&    CGI::Simple::ReadParse(*field); # get hash values in %field function style
\&
\&    my $q = new CGI::Simple;
\&    $q\->ReadParse(*field);          # same thing
.Ve
.PP
Once you use \fB\f(BIReadParse()\fB\fR under the functional interface , you can retrieve
the query object itself this way if needed:
.PP
.Vb 1
\&    $q = $in{\*(AqCGI\*(Aq};
.Ve
.PP
Either way it allows you to start using the more interesting features
of \s-1CGI\s0.pm without rewriting your old scripts from scratch.
.PP
Unlike \s-1CGI\s0.pm all the cgi\-lib.pl functions from Version 2.18 are supported:
.PP
.Vb 10
\&    ReadParse()
\&    SplitParam()
\&    MethGet()
\&    MethPost()
\&    MyBaseUrl()
\&    MyURL()
\&    MyFullUrl()
\&    PrintHeader()
\&    HtmlTop()
\&    HtmlBot()
\&    PrintVariables()
\&    PrintEnv()
\&    CgiDie()
\&    CgiError()
.Ve
.SH "COMPATIBILITY WITH CGI.pm"
.IX Header "COMPATIBILITY WITH CGI.pm"
I has long been suggested that the \s-1CGI\s0 and \s-1HTML\s0 parts of \s-1CGI\s0.pm should be
split into separate modules (even the author suggests this!), CGI::Simple
represents the realization of this and contains the complete \s-1CGI\s0 side of
\&\s-1CGI\s0.pm. Code-wise it weighs in at a little under 30% of the size of \s-1CGI\s0.pm at
a little under 1000 lines.
.PP
A great deal of care has been taken to ensure that the interface remains
unchanged although a few tweaks have been made. The test suite is extensive
and includes all the \s-1CGI\s0.pm test scripts as well as a series of new test
scripts. You may like to have a look at /t/concur.t which makes 160 tests
of CGI::Simple and \s-1CGI\s0 in parallel and compares the results to ensure they
are identical. This is the case as of \s-1CGI\s0.pm 2.78.
.PP
You can't make an omelet without breaking eggs. A large number of methods
and global variables have been deleted as detailed below. Some pragmas are
also gone. In the tarball there is a script \fB/misc/check.pl\fR that will check if
a script seems to be using any of these now non existent methods, globals or
pragmas. You call it like this:
.PP
.Vb 1
\&    perl check.pl <files>
.Ve
.PP
If it finds any likely candidates it will print a line with the line number,
problem method/global and the complete line. For example here is some output
from running the script on \s-1CGI\s0.pm:
.PP
.Vb 4
\&    ...
\&    3162: Problem:\*(Aq$CGI::OS\*(Aq   local($CRLF) = "\e015\e012" if $CGI::OS eq \*(AqVMS\*(Aq;
\&    3165: Problem:\*(AqfillBuffer\*(Aq $self\->fillBuffer($FILLUNIT);
\&    ....
.Ve
.SH "DIFFERENCES FROM CGI.pm"
.IX Header "DIFFERENCES FROM CGI.pm"
CGI::Simple is strict and warnings compliant.
.PP
There are 4 modules in this distribution:
.PP
.Vb 4
\&    CGI/Simple.pm           supplies all the core code.
\&    CGI/Simple/Cookie.pm    supplies the cookie handling functions.
\&    CGI/Simple/Util.pm      supplies a variety of utility functions
\&    CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm
.Ve
.PP
Simple.pm is the core module that provide all the essential functionality.
Cookie.pm is a shortened rehash of the \s-1CGI\s0.pm module of the same name
which supplies the required cookie functionality. Util.pm has been recoded to
use an internal object for data storage and supplies rarely needed non core
functions and/or functions needed for the \s-1HTML\s0 side of things. Standard.pm is
a wrapper module that supplies a complete functional interface to the \s-1OO\s0
back end supplied by CGI::Simple.
.PP
Although a serious attempt has been made to keep the interface identical,
some minor changes and tweaks have been made. They will likely be
insignificant to most users but here are the gory details.
.SS "Globals Variables"
.IX Subsection "Globals Variables"
The list of global variables has been pruned by 75%. Here is the complete
list of the global variables used:
.PP
.Vb 10
\&    $VERSION = "0.01";
\&    # set this to 1 to use CGI.pm default global settings
\&    $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;
\&    # see if user wants old  CGI.pm defaults
\&    do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;
\&    # no file uploads by default, set to 0 to enable uploads
\&    $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;
\&    # use a post max of 100K, set to \-1 for no limits
\&    $POST_MAX = 102_400 unless defined $POST_MAX;
\&    # do not include undefined params parsed from query string
\&    $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;
\&    # separate the name=value pairs with ; rather than &
\&    $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;
\&    # only print headers once
\&    $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;
\&    # Set this to 1 to enable NPH scripts
\&    $NPH = 0 unless defined $NPH;
\&    # 0 => no debug, 1 => from @ARGV,  2 => from STDIN
\&    $DEBUG = 0 unless defined $DEBUG;
\&    # filter out null bytes in param \- value pairs
\&    $NO_NULL  = 1 unless defined $NO_NULL;
\&    # set behavior when cgi_err() called \-1 => silent, 0 => carp, 1 => croak
\&    $FATAL = \-1 unless defined $FATAL;
.Ve
.PP
Four of the default values of the old \s-1CGI\s0.pm variables have been changed.
Unlike \s-1CGI\s0.pm which by default allows unlimited \s-1POST\s0 data and file uploads
by default CGI::Simple limits \s-1POST\s0 data size to 100kB and denies file uploads
by default. \f(CW$USE_PARAM_SEMICOLONS\fR is set to 0 by default so we use (old style)
& rather than ; as the pair separator for query strings. Debugging is
disabled by default.
.PP
There are three new global variables. If \f(CW$NO_NULL\fR is true (the default) then
CGI::Simple will strip null bytes out of names, values and keywords. Null
bytes can do interesting things to C based code like Perl. Uploaded files
are not touched. \f(CW$FATAL\fR controls the behavior when \fB\f(BIcgi_error()\fB\fR is called.
The default value of \-1 makes errors silent. \f(CW$USE_CGI_PM_DEFAULTS\fR reverts the
defaults to the \s-1CGI\s0.pm standard values ie unlimited file uploads via \s-1POST\s0
for \s-1DNS\s0 attacks. You can also get the defaults back by using the '\-default'
pragma in the use:
.PP
.Vb 2
\&    use CGI::Simple qw(\-default);
\&    use CGI::Simple::Standard qw(\-default);
.Ve
.PP
The values of the global variables are stored in the CGI::Simple object and
can be referenced and changed using the \fB\f(BIglobals()\fB\fR method like this:
.PP
.Vb 2
\&    my $value = $q\->globals( \*(AqVARNAME\*(Aq );      # get
\&    $q\->globals( \*(AqVARNAME\*(Aq, \*(Aqsome value\*(Aq );    # set
.Ve
.PP
As with many \s-1CGI\s0.pm methods if you pass the optional value that will
be set.
.PP
The \f(CW$CGI::Simple::VARNAME\fR = 'N' syntax is only useful prior to calling the
\&\fB\f(BInew()\fB\fR constructor. After that all reference is to the values stored in the
CGI::Simple object so you must change these using the \fB\f(BIglobals()\fB\fR method.
.PP
\&\f(CW$DISABLE_UPLOADS\fR and \f(CW$POST_MAX\fR *must* be set prior to calling the constructor
if you want the changes to have any effect as they control behavior during
initialization. This is the same a \s-1CGI\s0.pm although some people seem to miss
this rather important point and set these after calling the constructor which
does nothing.
.PP
The following globals are no longer relevant and have all been deleted:
.PP
.Vb 10
\&    $AUTOLOADED_ROUTINES
\&    $AUTOLOAD_DEBUG
\&    $BEEN_THERE
\&    $CRLF
\&    $DEFAULT_DTD
\&    $EBCDIC
\&    $FH
\&    $FILLUNIT
\&    $IIS
\&    $IN
\&    $INITIAL_FILLUNIT
\&    $JSCRIPT
\&    $MAC
\&    $MAXTRIES
\&    $MOD_PERL
\&    $NOSTICKY
\&    $OS
\&    $PERLEX
\&    $PRIVATE_TEMPFILES
\&    $Q
\&    $QUERY_CHARSET
\&    $QUERY_PARAM
\&    $SCRATCH
\&    $SL
\&    $SPIN_LOOP_MAX
\&    $TIMEOUT
\&    $TMPDIRECTORY
\&    $XHTML
\&    %EXPORT
\&    %EXPORT_OK
\&    %EXPORT_TAGS
\&    %OVERLOAD
\&    %QUERY_FIELDNAMES
\&    %SUBS
\&    @QUERY_PARAM
\&    @TEMP
.Ve
.PP
Notes: CGI::Simple uses IO::File\->new_tmpfile to get tempfile filehandles.
These are private by default so \f(CW$PRIVATE_TEMPFILES\fR is no longer required nor
is \f(CW$TMPDIRECTORY\fR. The value that were stored in \f(CW$OS\fR, \f(CW$CRLF\fR, \f(CW$QUERY_CHARSET\fR
and \f(CW$EBCDIC\fR are now stored in the CGI::Simple::Util object where they find
most of their use. The \f(CW$MOD_PERL\fR and \f(CW$PERLEX\fR values are now stored in our
CGI::Simple object. \f(CW$IIS\fR was only used once in \fIpath_info()\fR.  \f(CW$SL\fR the system
specific / \e : path delimiter is not required as we let IO::File handle our
tempfile requirements. The rest of the globals are \s-1HTML\s0 related, export
related, hand rolled autoload related or serve obscure purposes in \s-1CGI\s0.pm
.SS "Changes to pragmas"
.IX Subsection "Changes to pragmas"
There are some new pragmas available. See the pragmas section for details.
The following \s-1CGI\s0.pm pragmas are not available:
.PP
.Vb 5
\&    \-any
\&    \-compile
\&    \-nosticky
\&    \-no_xhtml
\&    \-private_tempfiles
.Ve
.SS "Filehandles"
.IX Subsection "Filehandles"
Unlike \s-1CGI\s0.pm which tries to accept all filehandle like objects only \e*FH
and \f(CW$fh\fR are accepted by CGI::Simple as file accessors for \fB\f(BInew()\fB\fR and \fB\f(BIsave()\fB\fR.
IO::File objects work fine.
.SS "Hash interface"
.IX Subsection "Hash interface"
.Vb 2
\&    %hash = $q\->Vars();     # pack values with "\e0";
\&    %hash = $q\->Vars(",");  # comma separate values
.Ve
.PP
You may optionally pass \fB\f(BIVars()\fB\fR a string that will be used to separate multiple
values when they are packed into the single hash value. If no value is
supplied the default \*(L"\e0\*(R" (null byte) will be used. Null bytes are dangerous
things for C based code (ie Perl).
.SS "cgi\-lib.pl"
.IX Subsection "cgi-lib.pl"
All the cgi\-lib.pl 2.18 routines are supported. Unlike \s-1CGI\s0.pm all the
subroutines from cgi\-lib.pl are included. They have been \s-1GOLFED\s0 down to
25 lines but they all work pretty much the same as the originals.
.SH "CGI::Simple COMPLETE METHOD LIST"
.IX Header "CGI::Simple COMPLETE METHOD LIST"
Here is a complete list of all the CGI::Simple methods.
.SS "Guts (hands off, except of course for new)"
.IX Subsection "Guts (hands off, except of course for new)"
.Vb 10
\&    _initialize_globals
\&    _use_cgi_pm_global_settings
\&    _store_globals
\&    import
\&    _reset_globals
\&    new
\&    _initialize
\&    _read_parse
\&    _parse_params
\&    _add_param
\&    _parse_keywordlist
\&    _parse_multipart
\&    _save_tmpfile
\&    _read_data
.Ve
.SS "Core Methods"
.IX Subsection "Core Methods"
.Vb 10
\&    param
\&    add_param
\&    param_fetch
\&    url_param
\&    keywords
\&    Vars
\&    append
\&    delete
\&    Delete
\&    delete_all
\&    Delete_all
\&    upload
\&    upload_info
\&    query_string
\&    parse_query_string
\&    parse_keywordlist
.Ve
.SS "Save and Restore from File Methods"
.IX Subsection "Save and Restore from File Methods"
.Vb 3
\&    _init_from_file
\&    save
\&    save_parameters
.Ve
.SS "Miscellaneous Methods"
.IX Subsection "Miscellaneous Methods"
.Vb 6
\&    url_decode
\&    url_encode
\&    escapeHTML
\&    unescapeHTML
\&    put
\&    print
.Ve
.SS "Cookie Methods"
.IX Subsection "Cookie Methods"
.Vb 2
\&    cookie
\&    raw_cookie
.Ve
.SS "Header Methods"
.IX Subsection "Header Methods"
.Vb 4
\&    header
\&    cache
\&    no_cache
\&    redirect
.Ve
.SS "Server Push Methods"
.IX Subsection "Server Push Methods"
.Vb 4
\&    multipart_init
\&    multipart_start
\&    multipart_end
\&    multipart_final
.Ve
.SS "Debugging Methods"
.IX Subsection "Debugging Methods"
.Vb 4
\&    read_from_cmdline
\&    Dump
\&    as_string
\&    cgi_error
.Ve
.SS "cgi\-lib.pl Compatibility Routines \- all 2.18 functions available"
.IX Subsection "cgi-lib.pl Compatibility Routines - all 2.18 functions available"
.Vb 10
\&    _shift_if_ref
\&    ReadParse
\&    SplitParam
\&    MethGet
\&    MethPost
\&    MyBaseUrl
\&    MyURL
\&    MyFullUrl
\&    PrintHeader
\&    HtmlTop
\&    HtmlBot
\&    PrintVariables
\&    PrintEnv
\&    CgiDie
\&    CgiError
.Ve
.SS "Accessor Methods"
.IX Subsection "Accessor Methods"
.Vb 10
\&    version
\&    nph
\&    all_parameters
\&    charset
\&    crlf                # new, returns OS specific CRLF sequence
\&    globals             # get/set global variables
\&    auth_type
\&    content_length
\&    content_type
\&    document_root
\&    gateway_interface
\&    path_translated
\&    referer
\&    remote_addr
\&    remote_host
\&    remote_ident
\&    remote_user
\&    request_method
\&    script_name
\&    server_name
\&    server_port
\&    server_protocol
\&    server_software
\&    user_name
\&    user_agent
\&    virtual_host
\&    path_info
\&    Accept
\&    accept
\&    http
\&    https
\&    protocol
\&    url
\&    self_url
\&    state
.Ve
.SH "NEW METHODS IN CGI::Simple"
.IX Header "NEW METHODS IN CGI::Simple"
There are a few new methods in CGI::Simple as listed below. The highlights are
the \fB\f(BIparse_query_string()\fB\fR method to add the \s-1QUERY_STRING\s0 data to your object if
the method was \s-1POST\s0. The \fB\f(BIno_cache()\fB\fR method adds an expires now directive and
the Pragma: no-cache directive to the header to encourage some browsers to
do the right thing. \fB\f(BIPrintEnv()\fB\fR from the cgi\-lib.pl routines will dump an
\&\s-1HTML\s0 friendly list of the \f(CW%ENV\fR and makes a handy addition to \fB\f(BIDump()\fB\fR for use
in debugging. The upload method now accepts a filepath as an optional second
argument as shown in the synopsis. If this is supplied the uploaded file will
be written to there automagically.
.SS "Internal Routines"
.IX Subsection "Internal Routines"
.Vb 12
\&    _initialize_globals()
\&    _use_cgi_pm_global_settings()
\&    _store_globals()
\&    _initialize()
\&    _init_from_file()
\&    _read_parse()
\&    _parse_params()
\&    _add_param()
\&    _parse_keywordlist()
\&    _parse_multipart()
\&    _save_tmpfile()
\&    _read_data()
.Ve
.SS "New Public Methods"
.IX Subsection "New Public Methods"
.Vb 7
\&    add_param()             # adds a param/value(s) pair +/\- overwrite
\&    upload_info()           # uploaded files MIME type and size
\&    url_decode()            # decode s url encoded string
\&    url_encode()            # url encode a string
\&    parse_query_string()    # add QUERY_STRING data to $q object if \*(AqPOST\*(Aq
\&    no_cache()              # add both the Pragma: no\-cache
\&                            # and Expires/Date => \*(Aqnow\*(Aq to header
.Ve
.SS "cgi\-lib.pl methods added for completeness"
.IX Subsection "cgi-lib.pl methods added for completeness"
.Vb 8
\&    _shift_if_ref()         # internal hack reminiscent of self_or_default :\-)
\&    MyBaseUrl()
\&    MyURL()
\&    MyFullUrl()
\&    PrintVariables()
\&    PrintEnv()
\&    CgiDie()
\&    CgiError()
.Ve
.SS "New Accessors"
.IX Subsection "New Accessors"
.Vb 5
\&    crlf()                  # returns CRLF sequence
\&    globals()               # global vars now stored in $q object \- get/set
\&    content_length()        # returns $ENV{\*(AqCONTENT_LENGTH\*(Aq}
\&    document_root()         # returns $ENV{\*(AqDOCUMENT_ROOT\*(Aq}
\&    gateway_interface()     # returns $ENV{\*(AqGATEWAY_INTERFACE\*(Aq}
.Ve
.SH "METHODS IN CGI.pm NOT IN CGI::Simple"
.IX Header "METHODS IN CGI.pm NOT IN CGI::Simple"
Here is a complete list of what is not included in CGI::Simple. Basically all
the \s-1HTML\s0 related stuff plus large redundant chunks of the guts. The check.pl
script in the /misc dir will check to see if a script is using any of these.
.SS "Guts \- rearranged, recoded, renamed and hacked out of existence"
.IX Subsection "Guts - rearranged, recoded, renamed and hacked out of existence"
.Vb 10
\&    initialize_globals()
\&    compile()
\&    expand_tags()
\&    self_or_default()
\&    self_or_CGI()
\&    init()
\&    to_filehandle()
\&    save_request()
\&    parse_params()
\&    add_parameter()
\&    binmode()
\&    _make_tag_func()
\&    AUTOLOAD()
\&    _compile()
\&    _setup_symbols()
\&    new_MultipartBuffer()
\&    read_from_client()
\&    import_names()     # I dislike this and left it out, so shoot me.
.Ve
.SS "\s-1HTML\s0 Related"
.IX Subsection "HTML Related"
.Vb 10
\&    autoEscape()
\&    URL_ENCODED()
\&    MULTIPART()
\&    SERVER_PUSH()
\&    start_html()
\&    _style()
\&    _script()
\&    end_html()
\&    isindex()
\&    startform()
\&    start_form()
\&    end_multipart_form()
\&    start_multipart_form()
\&    endform()
\&    end_form()
\&    _textfield()
\&    textfield()
\&    filefield()
\&    password_field()
\&    textarea()
\&    button()
\&    submit()
\&    reset()
\&    defaults()
\&    comment()
\&    checkbox()
\&    checkbox_group()
\&    _tableize()
\&    radio_group()
\&    popup_menu()
\&    scrolling_list()
\&    hidden()
\&    image_button()
\&    nosticky()
\&    default_dtd()
.Ve
.SS "Upload Related"
.IX Subsection "Upload Related"
CGI::Simple uses anonymous tempfiles supplied by IO::File to spool uploaded
files to.
.PP
.Vb 3
\&    private_tempfiles() # automatic in CGI::Simple
\&    tmpFileName()       # all upload files are anonymous
\&    uploadInfo()        # relied on FH access, replaced with upload_info()
.Ve
.SS "Really Private Subs (marked as so)"
.IX Subsection "Really Private Subs (marked as so)"
.Vb 7
\&    previous_or_default()
\&    register_parameter()
\&    get_fields()
\&    _set_values_and_labels()
\&    _compile_all()
\&    asString()
\&    compare()
.Ve
.SS "Internal Multipart Parsing Routines"
.IX Subsection "Internal Multipart Parsing Routines"
.Vb 6
\&    read_multipart()
\&    readHeader()
\&    readBody()
\&    read()
\&    fillBuffer()
\&    eof()
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
Nothing.
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
Originally copyright 2001 Dr James Freeman <jfreeman@tassie.net.au>
This release by Andy Armstrong <andy@hexten.net>
.PP
This package is free software and is provided \*(L"as is\*(R" without express or
implied warranty. It may be used, redistributed and/or modified under the terms
of the Perl Artistic License (see http://www.perl.com/perl/misc/Artistic.html)
.PP
Address bug reports and comments to: andy@hexten.net.  When sending
bug reports, please provide the version of CGI::Simple, the version of
Perl, the name and version of your Web server, and the name and
version of the operating system you are using.  If the problem is even
remotely browser dependent, please provide information about the
affected browsers as well.
.PP
Address bug reports and comments to: andy@hexten.net
.SH "CREDITS"
.IX Header "CREDITS"
Lincoln D. Stein (lstein@cshl.org) and everyone else who worked on the
original \s-1CGI\s0.pm upon which this module is heavily based
.PP
Brandon Black for some heavy duty testing and bug fixes
.PP
John D Robinson and Jeroen Latour for helping solve some interesting test
failures as well as Perlmonks:
tommyw, grinder, Jaap, vek, erasei, jlongino and strider_corinth
.PP
Thanks for patches to:
.PP
Ewan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris
Williams, Mark Stosberg, Krasimir Berov, Yamada Masahiro
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2007, Andy Armstrong \f(CW\*(C`<andy@hexten.net>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\s-1CGI\s0\fR, CGI::Simple::Standard, CGI::Simple::Cookie,
CGI::Simple::Util, CGI::Minimal
