.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::IO 3"
.TH Imager::IO 3 "2011-11-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::IO \- Imager's io_layer object.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Imager supplies Imager::IO objects to various callbacks
\&  my $IO = ...;
\&
\&  my $count = $IO\->write($data);
\&  my $count = $IO\->read($buffer, $max_count);
\&  my $position = $IO\->seek($offset, $whence);
\&  my $status = $IO\->close;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imager uses an abstraction when dealing with image files to allow the
same code to work with disk files, in memory data and callbacks.
.PP
If you're writing an Imager file handler your code will be passed an
Imager::IO object to write to or read from.
.PP
Note that Imager::IO can only work with collections of bytes \-
if you need to read \s-1UTF\-8\s0 data you will need to read the bytes and
decode them.  If you want to write \s-1UTF\-8\s0 data you will need to encode
your characters to bytes and write the bytes.
.IX Xref "UTF-8 Unicode"
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "new_fd($fd)" 4
.IX Item "new_fd($fd)"
Create a new I/O layer based on a file descriptor.
.Sp
.Vb 1
\&  my $io = Imager::IO\->new(fileno($fh));
.Ve
.IP "new_buffer($data)" 4
.IX Item "new_buffer($data)"
Create a new I/O layer based on a memory buffer.
.Sp
The supplied variable must not be changed on the the life of the I/O
object.
.Sp
Buffer I/O layers are read only.
.ie n .IP "new_cb($writecb, $readcb, $seekcb, $closecb)" 4
.el .IP "new_cb($writecb, \f(CW$readcb\fR, \f(CW$seekcb\fR, \f(CW$closecb\fR)" 4
.IX Item "new_cb($writecb, $readcb, $seekcb, $closecb)"
Create a new I/O layer based on callbacks.  See 
\&\*(L"I/O Callbacks\*(R" in Imager::Files for details on the behavior of 
the callbacks.
.IP "\fInew_bufchain()\fR" 4
.IX Item "new_bufchain()"
Create a new \f(CW\*(C`bufchain\*(C'\fR based I/O layer.  This accumulates the file
data as a chain of buffers starting from an empty stream.
.Sp
Use the \*(L"\fIslurp()\fR\*(R" method to retrieve the accumulated content into a
perl string.
.SH "BUFFERED I/O METHODS"
.IX Header "BUFFERED I/O METHODS"
These methods use buffered I/O to improve performance unless you call
\&\fIset_buffered()\fR to disable buffering.
.PP
Prior to Imager 0.86 the write and read methods performed raw I/O.
.IP "write($data)" 4
.IX Item "write($data)"
Call to write to the file.  Returns the number of bytes written.  The
data provided may contain only characters \ex00 to \exFF \- characters
outside this range will cause this method to \fIcroak()\fR.
.Sp
If you supply a \s-1UTF\-8\s0 flagged string it will be converted to a byte
string, which may have a performance impact.
.Sp
Returns \-1 on error, though in most cases if the result of the write
isn't the number of bytes supplied you'll want to treat it as an error
anyway.
.ie n .IP "read($buffer, $size)" 4
.el .IP "read($buffer, \f(CW$size\fR)" 4
.IX Item "read($buffer, $size)"
.Vb 2
\&  my $buffer;
\&  my $count = $io\->read($buffer, $max_bytes);
.Ve
.Sp
Reads up to \fI\f(CI$max_bytes\fI\fR bytes from the current position in the file
and stores them in \fI\f(CI$buffer\fI\fR.  Returns the number of bytes read on
success or an empty list on failure.  Note that a read of zero bytes
is \fBnot\fR a failure, this indicates end of file.
.IP "read2($size)" 4
.IX Item "read2($size)"
.Vb 1
\&  my $buffer = $io\->read2($max_bytes);
.Ve
.Sp
An alternative interface to read, that might be simpler to use in some
cases.
.Sp
Returns the data read or an empty list.  At end of file the data read
will be an empty string.
.ie n .IP "seek($offset, $whence)" 4
.el .IP "seek($offset, \f(CW$whence\fR)" 4
.IX Item "seek($offset, $whence)"
.Vb 1
\&  my $new_position = $io\->seek($offset, $whence);
.Ve
.Sp
Seek to a new position in the file.  Possible values for \fI\f(CI$whence\fI\fR are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_SET\*(C'\fR \- \fI\f(CI$offset\fI\fR is the new position in the file.
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_CUR\*(C'\fR \- \fI\f(CI$offset\fI\fR is the offset from the current position in
the file.
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_END\*(C'\fR \- \fI\f(CI$offset\fI\fR is the offset relative to the end of the
file.
.RE
.RS 4
.Sp
Note that seeking past the end of the file may or may not result in an
error.
.Sp
Any buffered output will be flushed, if flushing fails, \fIseek()\fR will
return \-1.
.Sp
Returns the new position in the file, or \-1 on error.
.RE
.IP "\fIgetc()\fR" 4
.IX Item "getc()"
Return the next byte from the stream.
.Sp
Returns the ordinal of the byte or \-1 on error or end of file.
.Sp
.Vb 3
\&  while ((my $c = $io\->getc) != \-1) {
\&    print chr($c);
\&  }
.Ve
.IP "\fIgets()\fR" 4
.IX Item "gets()"
.PD 0
.IP "gets($max_size)" 4
.IX Item "gets($max_size)"
.ie n .IP "gets($max_size, $end_of_line)" 4
.el .IP "gets($max_size, \f(CW$end_of_line\fR)" 4
.IX Item "gets($max_size, $end_of_line)"
.PD
Returns the next line of input from the stream, as terminated by
\&\f(CW\*(C`end_of_line\*(C'\fR.
.Sp
The default \f(CW\*(C`max_size\*(C'\fR is 8192.
.Sp
The default \f(CW\*(C`end_of_line\*(C'\fR is \f(CW\*(C`ord "\en"\*(C'\fR.
.Sp
Returns nothing if the stream is in error or at end of file.
.Sp
Returns the line as a string, including the line terminator (if one
was found) on success.
.Sp
.Vb 3
\&  while (defined(my $line = $io\->gets)) {
\&    # do something with $line
\&  }
.Ve
.IP "\fIpeekc()\fR" 4
.IX Item "peekc()"
Return the buffered next character from the stream, loading the buffer
if necessary.
.Sp
For an unbuffered stream a buffer will be setup and loaded with a
single character.
.Sp
Returns the ordinal of the byte or \-1 on error or end of file.
.Sp
.Vb 1
\&  my $c = $io\->peekc;
.Ve
.IP "peekn($size)" 4
.IX Item "peekn($size)"
Returns up to the next \f(CW\*(C`size\*(C'\fR bytes from the file as a string.
.Sp
Only up to the stream buffer size bytes (currently 8192) can be peeked.
.Sp
This method ignores the buffering state of the stream.
.Sp
Returns nothing on \s-1EOF\s0.
.Sp
.Vb 4
\&  my $s = $io\->peekn(4);
\&  if ($s =~ /^(II|MM)\e*\e0/) {
\&    print "TIFF image";
\&  }
.Ve
.IP "putc($code)" 4
.IX Item "putc($code)"
Write a single character to the stream.
.Sp
Returns \f(CW\*(C`code\*(C'\fR on success, or \-1 on failure.
.IP "\fIclose()\fR" 4
.IX Item "close()"
.Vb 1
\&  my $result = $io\->close;
.Ve
.Sp
Call when you're done with the file.  If the \s-1IO\s0 object is connected to
a file this won't close the file handle, but buffers may be flushed
(if any).
.Sp
Returns 0 on success, \-1 on failure.
.IP "\fIeof()\fR" 4
.IX Item "eof()"
.Vb 1
\&  $io\->eof
.Ve
.Sp
Test if the stream is at end of file.  No further read requests will
be passed to your read callback until you \fIseek()\fR.
.IP "\fIerror()\fR" 4
.IX Item "error()"
Test if the stream has encountered a read or write error.
.Sp
.Vb 3
\&  my $data = $io\->read2(100);
\&  $io\->error
\&     and die "Failed";
.Ve
.Sp
When the stream has the error flag set no further read or write
requests will be passed to your callbacks until you seek.
.IP "\fIflush()\fR" 4
.IX Item "flush()"
.Vb 2
\&  $io\->flush
\&    or die "Flush error";
.Ve
.Sp
Flush any buffered output.  This will not call lower write layers when
the stream has it's error flag set.
.Sp
Returns a true value on success.
.IP "\fIis_buffered()\fR" 4
.IX Item "is_buffered()"
Test if buffering is enabled for this stream.
.Sp
Returns a true value if the stream is buffered.
.IP "set_buffered($enabled)" 4
.IX Item "set_buffered($enabled)"
If \f(CW$enabled\fR is a non-zero integer, enable buffering, other disable
it.
.Sp
Disabling buffering will flush any buffered output, but any buffered
input will be retained and consumed by input methods.
.Sp
Returns true if any buffered output was flushed successfully, false if
there was an error flushing output.
.SH "RAW I/O METHODS"
.IX Header "RAW I/O METHODS"
These call the underlying I/O abstraction directly.
.IP "\fIraw_write()\fR" 4
.IX Item "raw_write()"
Call to write to the file.  Returns the number of bytes written.  The
data provided may contain only characters \ex00 to \exFF \- characters
outside this range will cause this method to \fIcroak()\fR.
.Sp
If you supply a \s-1UTF\-8\s0 flagged string it will be converted to a byte
string, which may have a performance impact.
.Sp
Returns \-1 on error, though in most cases if the result of the write
isn't the number of bytes supplied you'll want to treat it as an error
anyway.
.IP "\fIraw_read()\fR" 4
.IX Item "raw_read()"
.Vb 2
\&  my $buffer;
\&  my $count = $io\->raw_read($buffer, $max_bytes);
.Ve
.Sp
Reads up to \fI\f(CI$max_bytes\fI\fR bytes from the current position in the file
and stores them in \fI\f(CI$buffer\fI\fR.  Returns the number of bytes read on
success or an empty list on failure.  Note that a read of zero bytes
is \fBnot\fR a failure, this indicates end of file.
.IP "\fIraw_read2()\fR" 4
.IX Item "raw_read2()"
.Vb 1
\&  my $buffer = $io\->raw_read2($max_bytes);
.Ve
.Sp
An alternative interface to raw_read, that might be simpler to use in some
cases.
.Sp
Returns the data read or an empty list.
.IP "\fIraw_seek()\fR" 4
.IX Item "raw_seek()"
.Vb 1
\&  my $new_position = $io\->raw_seek($offset, $whence);
.Ve
.Sp
Seek to a new position in the file.  Possible values for \fI\f(CI$whence\fI\fR are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_SET\*(C'\fR \- \fI\f(CI$offset\fI\fR is the new position in the file.
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_CUR\*(C'\fR \- \fI\f(CI$offset\fI\fR is the offset from the current position in
the file.
.IP "\(bu" 4
\&\f(CW\*(C`SEEK_END\*(C'\fR \- \fI\f(CI$offset\fI\fR is the offset relative to the end of the
file.
.RE
.RS 4
.Sp
Note that seeking past the end of the file may or may not result in an
error.
.Sp
Returns the new position in the file, or \-1 on error.
.RE
.IP "\fIraw_close()\fR" 4
.IX Item "raw_close()"
.Vb 1
\&  my $result = $io\->raw_close;
.Ve
.Sp
Call when you're done with the file.  If the \s-1IO\s0 object is connected to
a file this won't close the file handle.
.Sp
Returns 0 on success, \-1 on failure.
.SH "UTILITY METHODS"
.IX Header "UTILITY METHODS"
.IP "\fIslurp()\fR" 4
.IX Item "slurp()"
Retrieve the data accumulated from an I/O layer object created with
the \fInew_bufchain()\fR method.
.Sp
.Vb 1
\&  my $data = $io\->slurp;
.Ve
.IP "\fIdump()\fR" 4
.IX Item "dump()"
Dump the internal buffering state of the I/O object to \f(CW\*(C`stderr\*(C'\fR.
.Sp
.Vb 1
\&  $io\->dump();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager, Imager::Files
