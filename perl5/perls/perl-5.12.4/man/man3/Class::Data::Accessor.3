.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Data::Accessor 3"
.TH Class::Data::Accessor 3 "2008-08-13" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Data::Accessor \- Inheritable, overridable class and instance data accessor creation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Stuff;
\&  use base qw(Class::Data::Accessor);
\&
\&  # Set up DataFile as inheritable class data.
\&  Stuff\->mk_classaccessor(\*(AqDataFile\*(Aq);
\&
\&  # Declare the location of the data file for this class.
\&  Stuff\->DataFile(\*(Aq/etc/stuff/data\*(Aq);
\&
\&  # Or, all in one shot:
\&  Stuff\->mk_classaccessor(DataFile => \*(Aq/etc/stuff/data\*(Aq);
\&
\&
\&  Stuff\->DataFile; # returns /etc/stuff/data
\&
\&  my $stuff = Stuff\->new; # your new, not ours
\&
\&  $stuff\->DataFile; # returns /etc/stuff/data
\&
\&  $stuff\->DataFile(\*(Aq/etc/morestuff\*(Aq); # sets it on the object
\&
\&  Stuff\->DataFile; # still returns /etc/stuff/data
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBThis module is now deprecated!\fR
.PP
Please consider using Class::Accessor::Grouped or Moose
.PP
Class::Data::Accessor is the marriage of Class::Accessor and
Class::Data::Inheritable into a single module. It is used for creating
accessors to class data that overridable in subclasses as well as in
class instances.
.PP
For example:
.PP
.Vb 1
\&  Pere::Ubu\->mk_classaccessor(\*(AqSuitcase\*(Aq);
.Ve
.PP
will generate the method \fISuitcase()\fR in the class Pere::Ubu.
.PP
This new method can be used to get and set a piece of class data.
.PP
.Vb 2
\&  Pere::Ubu\->Suitcase(\*(AqRed\*(Aq);
\&  $suitcase = Pere::Ubu\->Suitcase;
.Ve
.PP
Taking this one step further, you can make a subclass that inherits from
Pere::Ubu:
.PP
.Vb 2
\&  package Raygun;
\&  use base qw(Pere::Ubu);
\&
\&  # Raygun\*(Aqs suitcase is Red.
\&  $suitcase = Raygun\->Suitcase;
.Ve
.PP
Raygun inherits its Suitcase class data from Pere::Ubu.
.PP
Inheritance of class data works analogous to method inheritance.  As
long as Raygun does not \*(L"override\*(R" its inherited class data (by using
\&\fISuitcase()\fR to set a new value) it will continue to use whatever is set
in Pere::Ubu and inherit further changes:
.PP
.Vb 2
\&  # Both Raygun\*(Aqs and Pere::Ubu\*(Aqs suitcases are now Blue
\&  Pere::Ubu\->Suitcase(\*(AqBlue\*(Aq);
.Ve
.PP
However, should Raygun decide to set its own \fISuitcase()\fR it has now
\&\*(L"overridden\*(R" Pere::Ubu and is on its own, just like if it had
overridden a method:
.PP
.Vb 2
\&  # Raygun has an orange suitcase, Pere::Ubu\*(Aqs is still Blue.
\&  Raygun\->Suitcase(\*(AqOrange\*(Aq);
.Ve
.PP
Now that Raygun has overridden Pere::Ubu, further changes by Pere::Ubu
no longer effect Raygun.
.PP
.Vb 2
\&  # Raygun still has an orange suitcase, but Pere::Ubu is using Samsonite.
\&  Pere::Ubu\->Suitcase(\*(AqSamsonite\*(Aq);
.Ve
.PP
You can also override this class data on a per-object basis.
If \f(CW$obj\fR isa Pere::Ubu then
.PP
.Vb 1
\&  $obj\->Suitcase; # will return Samsonite
\&
\&  $obj\->Suitcase(\*(AqPurple\*(Aq); # will set Suitcase *for this object only*
.Ve
.PP
And after you've done that,
.PP
.Vb 1
\&  $obj\->Suitcase; # will return Purple
.Ve
.PP
but
.PP
.Vb 1
\&  Pere::Ubu\->Suitcase; # will still return Samsonite
.Ve
.PP
If you don't want this behaviour use Class::Data::Inheritable instead.
.PP
\&\f(CW\*(C`mk_classaccessor\*(C'\fR will die if used as an object method instead of as a
class method.
.SH "METHODS"
.IX Header "METHODS"
.SS "mk_classaccessor"
.IX Subsection "mk_classaccessor"
.Vb 2
\&  Class\->mk_classaccessor($data_accessor_name);
\&  Class\->mk_classaccessor($data_accessor_name => $value);
.Ve
.PP
This is a class method used to declare new class data accessors.
A new accessor will be created in the Class using the name from
\&\f(CW$data_accessor_name\fR, and optionally initially setting it to the given
value.
.PP
To facilitate overriding, mk_classaccessor creates an alias to the
accessor, \fI_field_accessor()\fR.  So \fISuitcase()\fR would have an alias
\&\fI_Suitcase_accessor()\fR that does the exact same thing as \fISuitcase()\fR.
This is useful if you want to alter the behavior of a single accessor
yet still get the benefits of inheritable class data.  For example.
.PP
.Vb 3
\&  sub Suitcase {
\&      my($self) = shift;
\&      warn "Fashion tragedy" if @_ and $_[0] eq \*(AqPlaid\*(Aq;
\&
\&      $self\->_Suitcase_accessor(@_);
\&  }
.Ve
.PP
Overriding accessors does not work in the same class as you declare
the accessor in.  It only works in subclasses due to the fact that
subroutines are loaded at compile time and accessors are loaded at
runtime, thus overriding any subroutines with the same name in the
same class.
.SS "mk_classaccessors(@accessornames)"
.IX Subsection "mk_classaccessors(@accessornames)"
Takes a list of names and generates an accessor for each name in the list using
\&\f(CW\*(C`mk_classaccessor\*(C'\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Based on the creative stylings of Damian Conway, Michael G Schwern,
Tony Bowden (Class::Data::Inheritable) and Michael G Schwern, Marty Pauley
(Class::Accessor).
.PP
Coded by Matt S Trout
Tweaks by Christopher H. Laco.
.SH "BUGS and QUERIES"
.IX Header "BUGS and QUERIES"
If your object isn't hash-based, this will currently break. My modifications
aren't exactly sophisticated so far.
.PP
mstrout@cpan.org or bug me on irc.perl.org, nick mst
claco@cpan.org or irc.perl.org, nick claco
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself. (see
http://dev.perl.org/licenses/artistic.html and
http://www.opensource.org/licenses/gpl\-license.php)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perltootc has a very elaborate discussion of class data in Perl.
Class::Accessor, Class::Data::Inheritable
