.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Manual::Cookbook 3"
.TH HTML::FormHandler::Manual::Cookbook 3 "2012-02-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Manual::Cookbook \- FormHandler use recipes
.SH "VERSION"
.IX Header "VERSION"
version 0.36002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Collection of use recipes for HTML::FormHandler
.SS "No form file, no template file..."
.IX Subsection "No form file, no template file..."
I had to create a tiny little form this week for admins to enter a comment, and
it seemed silly to have to create a form file and a template file. I remembered
that you can set the \s-1TT\s0 'template' to a a string reference and not use a template
at all, which is nice when FormHandler will create the form \s-1HTML\s0 for you anyway.
.PP
.Vb 2
\&    sub comment : Chained(\*(Aqbase_sub\*(Aq) PathPart(\*(Aqcomment\*(Aq) Args(0) {
\&        my ( $self, $c ) = @_;
\&
\&        my $form = HTML::FormHandler\->new( field_list =>
\&            [ comment => { type => \*(AqText\*(Aq, size => 60 },
\&              submit => {type => \*(AqSubmit\*(Aq} ] );
\&        $form\->process($c\->req\->params);
\&        if ( $form\->validated ) {
\&            $self\->admin_log( $c, "Admin::Queue", "admin comment",
\&                  $form\->field(\*(Aqcomment\*(Aq)\->value );
\&            $c\->flash( message => \*(AqComment added\*(Aq );
\&            $c\->res\->redirect( $c\->stash\->{urilist}\->{view} );
\&        }
\&        my $rendered_form = $form\->render;
\&        $c\->stash( template => \e$rendered_form );
\&    }
.Ve
.PP
This creates the form on the fly with a comment field and a submit button,
renders it using the default \s-1TT\s0 wrappers, then logs the comment. No other files
at all....
.PP
FormHandler isn't really necessary for validation here, but it does make it
possible to have a simple, standalone method.
.SS "Dynamically change the active fields"
.IX Subsection "Dynamically change the active fields"
A common use case is for forms with some fields that should be displayed in
some circumstances and not in others. There are a number of ways to do this.
One way is to use the 'field_list' method:
.PP
.Vb 6
\&   sub field_list {
\&      my $self = shift;
\&      my @fields;
\&      <build list of fields>
\&      return \e@fields;
\&   }
.Ve
.PP
This only happens at form construction time, however. Another method that
works is to define all of the possible fields in your form, and mark some
of them 'inactive';
.PP
.Vb 3
\&   package MyApp::Variable::Form;
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler\*(Aq;
\&
\&   has_field \*(Aqfoo\*(Aq;
\&   has_field \*(Aqbar\*(Aq => ( inactive => 1 );
\&   1;
.Ve
.PP
Set to 'active' or 'inactive' on the 'process' call:
.PP
.Vb 3
\&   $form\->process( params => $params, active => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq] );
\&   ...
\&   $form\->process( params => $params, inactive => [\*(Aqbar\*(Aq] );
.Ve
.PP
If you need to check some other state to determine whether or not a field should
be active, you can do that using a Moose method modifier on 'set_active':
.PP
.Vb 4
\&   before \*(Aqset_active\*(Aq => sub {
\&      my $self = shift;
\&      $self\->active([\*(Aqfoo\*(Aq, bar\*(Aq]) if ( <some_condition> );
\&   };
.Ve
.PP
Fields set to active/inactive on the 'process' call be automatically set back
to inactive when the form is cleared, so there's no need to reset.
.PP
If you want the fields activated for the life of an object, set active on new:
.PP
.Vb 1
\&    my $form = MyApp::Form::User\->new( active => [\*(Aqopt_in\*(Aq, \*(Aqactive\*(Aq]);
.Ve
.SS "Add custom attributes to FormHandler fields"
.IX Subsection "Add custom attributes to FormHandler fields"
If you want to add custom attributes to the FormHandler fields but don't want
to subclass all the fields, you can apply a role containing the new
attributes to an HTML::FormHandler::Field in your form.
.PP
Use 'traits' on the individual fields to apply a role to field instances.
Use the form attribute 'field_traits' to apply a role to all field instances in
the form.
.PP
.Vb 3
\&    package MyApp::Form::Test;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has_field \*(Aqfoo\*(Aq => ( traits => [\*(AqMyApp::TraitFor::Test\*(Aq] );
\&    has \*(Aq+field_traits\*(Aq => ( default => sub { [\*(AqSome::Trait\*(Aq, \*(AqAnother::Trait\*(Aq] } );
.Ve
.PP
Or set the traits on new:
.PP
.Vb 3
\&    my $form = MyApp::Form::User\->new( field_traits => [\*(AqMyApp::TraitFor::Test\*(Aq] );
\&    my $form = MyApp::Form::User\->new(
\&             field_list => [ \*(Aq+foo\*(Aq => { traits => [...] } ]);
.Ve
.PP
To apply the role to a field base class, use 'apply_traits' on that class:
.PP
.Vb 2
\&    HTML::FormHandler::Field\->apply_traits( \*(AqSome::Test\*(Aq );
\&    HTML::FormHandler::Field::Text\->apply_traits( \*(AqAnother::Trait\*(Aq );
.Ve
.SS "Select lists"
.IX Subsection "Select lists"
If you want to set the default value of a select field to 0 (or some other
default):
.PP
.Vb 5
\&   sub default_license {
\&      my ( $self, $field, $item ) = @_;
\&      return 0 unless $item && $item\->license_id;
\&      return $item\->license_id;
\&   }
.Ve
.PP
If the table defining the choices for a select list doesn't include
a 'no choice' choice, in your template:
.PP
.Vb 9
\&   [% f = form.field(\*(Aqsubject_class\*(Aq) %]
\&   <select id="select_sc" name="[% f.name %]">
\&     <option value="">\-\-\- Choose Subject Class\-\-\-</option>
\&     [% FOR option IN f.options %]
\&       <option value="[% option.value %]"
\&          [% IF option.value == f.fif %]selected="selected"[% END %]>
\&          [% option.label | html %]</option>
\&     [% END %]
\&   </select>
.Ve
.PP
Or customize the select list in an 'options_' method:
.PP
.Vb 8
\&   sub options_country {
\&      my $self = shift;
\&      return unless $self\->schema;
\&      my @rows =
\&         $self\->schema\->resultset( \*(AqCountry\*(Aq )\->
\&            search( {}, { order_by => [\*(Aqrank\*(Aq, \*(Aqcountry_name\*(Aq] } )\->all;
\&      return [ map { $_\->digraph, $_\->country_name } @rows ];
\&   }
.Ve
.SS "The database and FormHandler forms"
.IX Subsection "The database and FormHandler forms"
If you have to process the input data before saving to the database, and
this is something that would be useful in other places besides your form,
you should do that processing in the DBIx::Class result class.
.PP
If the pre-processing is only relevant to \s-1HTML\s0 form input, you might want
to do it in the form by setting a flag to prevent database updates, performing
the pre-processing, and then updating the database yourself.
.PP
.Vb 1
\&   has_field \*(Aqmy_complex_field\*(Aq => ( type => \*(AqText\*(Aq, noupdate => 1 );
.Ve
.PP
The 'noupdate' flag is set in order to skip an attempt to update the database
for this field (it would not be necessary if the field doesn't actually exist
in the database...).  You can process the input for the non-updatable field
field in a number of different places, depending on what is most logical.
Some of the choices are:
.PP
.Vb 3
\&   1) validate (for the form or field)
\&   2) validate_model
\&   3) model_update
.Ve
.PP
When the field is flagged 'writeonly', the value from the database will not
be used to fill in the form (put in the \f(CW\*(C`$form\->fif\*(C'\fR hash, or the
field \f(CW\*(C`$field\->fif\*(C'\fR), but a value entered in the form \s-1WILL\s0 be used
to update the database.
.PP
If you want to enter fields from an additional table that is related to
this one in a 'single' relationship, you can use the DBIx::Class 'proxy'
feature to create accessors for those fields.
.SS "Set up form base classes or roles for your application"
.IX Subsection "Set up form base classes or roles for your application"
You can add whatever attributes you want to your form classes. Maybe you
want to save a title, or a particular navigation widget. You could even
save bits of text, or retrieve them from the database. Sometimes doing it
this way would be the wrong way. But it's your form, your choice. In the
right circumstances, it might provide a way to keep code out of your
templates and simplify your controllers.
.PP
.Vb 3
\&   package MyApp::Form::Base;
\&   use Moose;
\&   extends \*(AqHTML::FormHandler::Model::DBIC\*(Aq;
\&
\&   has \*(Aqtitle\*(Aq => ( isa => \*(AqStr\*(Aq, is => \*(Aqrw\*(Aq );
\&   has \*(Aqnav_bar\*(Aq => ( isa => \*(AqStr\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&   sub summary {
\&      my $self = shift;
\&      my $schema = $self\->schema;
\&      my $text = $schema\->resultset(\*(AqSummary\*(Aq)\->find( ... )\->text;
\&      return $text;
\&   }
\&   1;
.Ve
.PP
Then:
.PP
.Vb 3
\&   package MyApp::Form::Whatsup;
\&   use Moose;
\&   extends \*(AqMyApp::Form::Base\*(Aq;
\&
\&   has \*(Aq+title\*(Aq => ( default => \*(AqThis page is an example of what to expect...\*(Aq );
\&   has \*(Aq+nav_bar\*(Aq => ( default => ... );
\&   ...
\&   1;
.Ve
.PP
And in the template:
.PP
.Vb 3
\&   <h1>[% form.title %]</h1>
\&   [% form.nav_bar %]
\&   <p><b>Summary: </b>[% form.summary %]</p>
.Ve
.PP
Or you can make these customizations Moose roles.
.PP
.Vb 3
\&   package MyApp::Form::Role::Base;
\&   use Moose::Role;
\&   ...
\&
\&   package MyApp::Form::Whatsup;
\&   use Moose;
\&   with \*(AqMyApp::Form::Role::Base\*(Aq;
\&   ...
.Ve
.SS "Split up your forms into reusable pieces"
.IX Subsection "Split up your forms into reusable pieces"
A person form:
.PP
.Vb 3
\&   package Form::Person;
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler\*(Aq;
\&
\&   has_field \*(Aqname\*(Aq;
\&   has_field \*(Aqtelephone\*(Aq;
\&   has_field \*(Aqemail\*(Aq => ( type => \*(AqEmail\*(Aq );
\&
\&   sub validate_name {
\&    ....
\&   }
\&
\&   no HTML::FormHandler::Moose;
\&   1;
.Ve
.PP
An address form:
.PP
.Vb 3
\&   package Form::Address;
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler\*(Aq;
\&
\&   has_field \*(Aqstreet\*(Aq;
\&   has_field \*(Aqcity\*(Aq;
\&   has_field \*(Aqstate\*(Aq => ( type => \*(AqSelect\*(Aq );
\&   has_field \*(Aqzip\*(Aq => ( type => \*(Aq+Zip\*(Aq );
\&
\&   sub options_state {
\&     ...
\&   }
\&
\&   no HTML::FormHandler::Moose;
\&   1;
.Ve
.PP
A form that extends them both:
.PP
.Vb 3
\&   package Form::Member;
\&   use Moose;
\&   extends (\*(AqForm::Person\*(Aq, \*(AqForm::Address\*(Aq);
\&
\&   use namespace::autoclean;
\&   1;
.Ve
.PP
Or if you don't need to use the pieces of your forms as forms themself, you can
use roles;
.PP
.Vb 2
\&   package Form::Role::Address;
\&   use HTML::FormHandler::Moose::Role;
\&
\&   has_field \*(Aqstreet\*(Aq;
\&   has_field \*(Aqcity\*(Aq;
\&   has_field \*(Aqstate\*(Aq => ( type => \*(AqSelect\*(Aq );
\&   has_field \*(Aqzip\*(Aq => ( type => \*(Aq+Zip\*(Aq );
\&
\&   sub options_state {
\&     ...
\&   }
\&
\&   no HTML::FormHandler::Moose::Role;
\&   1;
.Ve
.PP
You could make roles that are collections of validations:
.PP
.Vb 2
\&   package Form::Role::Member;
\&   use Moose::Role;
\&
\&   sub check_zip {
\&      ...
\&   }
\&   sub check_email {
\&      ...
\&   }
\&
\&   1;
.Ve
.PP
And if the validations apply to fields with different names, specify the
\&'set_validate' on the fields:
.PP
.Vb 2
\&   with \*(AqForm::Role::Member\*(Aq;
\&   has_field \*(Aqzip\*(Aq => ( type => \*(AqInteger\*(Aq, set_validate => \*(Aqcheck_zip\*(Aq );
.Ve
.SS "Access a user record in the form"
.IX Subsection "Access a user record in the form"
You might need the user_id to create specialized select lists, or do other form processing. Add a user_id attribute to your form:
.PP
.Vb 1
\&  has \*(Aquser_id\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Then pass it in when you process the form:
.PP
.Vb 1
\&  $form\->process( item => $item, params => $c\->req\->parameters, user_id => $c\->user\->user_id );
.Ve
.SS "Handle extra database fields"
.IX Subsection "Handle extra database fields"
If there is another database field that needs to be updated when a row is
created, add an attribute to the form, and then process it with
\&\f(CW\*(C` before \*(Aqupdate_model\*(Aq \*(C'\fR.
.PP
In the form:
.PP
.Vb 1
\&    has \*(Aqhostname\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&    before \*(Aqupdate_model\*(Aq => sub {
\&       my $self = shift;
\&       $self\->item\->hostname( $self\->hostname );
\&    };
.Ve
.PP
Then just use an additional parameter when you create/process your form:
.PP
.Vb 1
\&    $form\->process( item => $item, params => $params, hostname => $c\->req\->host );
.Ve
.SS "Record the user update"
.IX Subsection "Record the user update"
Use the 'before' or 'after' method modifiers for 'update_model', to flag a record
as updated by the user, for example:
.PP
.Vb 4
\&   before \*(Aqupdate_model\*(Aq => sub {
\&      my $self = shift;
\&      $self\->item\->user_updated if $self\->item;
\&   };
.Ve
.SS "Additional changes to the database"
.IX Subsection "Additional changes to the database"
If you want to do additional database updates besides the ones that FormHandler
does for you, the best solution would generally be to add the functionality to
your result source or resultset classes, but if you want to do additional updates
in a form you should use an 'around' method modifier and a transaction:
.PP
.Vb 4
\&  around \*(Aqupdate_model\*(Aq => sub {
\&      my $orig = shift;
\&      my $self = shift;
\&      my $item = $self\->item;
\&
\&      $self\->schema\->txn_do( sub {
\&          $self\->$orig(@_);
\&
\&          <perform additional updates>
\&      });
\&  };
.Ve
.SS "Doing cross validation in roles"
.IX Subsection "Doing cross validation in roles"
In a role that handles a number of different fields, you may want to
perform cross validation after the individual fields are validated.
In the form you could use the 'validate' method, but that doesn't help
if you want to keep the functionality packaged in a role. Instead you
can use the 'after' method modifier on the 'validate' method:
.PP
.Vb 1
\&   package MyApp::Form::Roles::DateFromTo;
\&
\&   use HTML::FormHandler::Moose::Role;
\&   has_field \*(Aqdate_from\*(Aq => ( type => \*(AqDate\*(Aq );
\&   has_field \*(Aqdate_to\*(Aq   => ( type => \*(AqDate\*(Aq );
\&
\&   after \*(Aqvalidate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->field(\*(Aqdate_from\*(Aq)\->add_error(\*(AqFrom date must be before To date\*(Aq)
\&         if $self\->field(\*(Aqdate_from\*(Aq)\->value gt $self\->field(\*(Aqdate_to\*(Aq)\->value;
\&   };
.Ve
.SS "Changing required flag"
.IX Subsection "Changing required flag"
Sometimes a field is required in one situation and not required in another.
You can use a method modifier before 'validate_form':
.PP
.Vb 7
\&   before \*(Aqvalidate_form\*(Aq => sub {
\&      my $self = shift;
\&      my $required = 0;
\&      $required = 1
\&         if( $self\->params\->{field_name} eq \*(Aqsomething\*(Aq );
\&      $self\->field(\*(Aqsome_field\*(Aq)\->required($required);
\&   };
.Ve
.PP
This happens before the fields contain input or values, so you would need to
look at the param value. If you need the validated value, it might be better
to do these sort of checks in the form's 'validate' routine.
.PP
.Vb 6
\&   sub validate {
\&      my $self = shift;
\&      $self\->field(\*(Aqdependent_field\*(Aq)\->add_error("Field is required")
\&          if( $self\->field(\*(Aqsome_field\*(Aq)\->value eq \*(Aqsomething\*(Aq &&
\&              !$self\->field(\*(Aqdependent_field\*(Aq)\->has_value);
\&   }
.Ve
.PP
In a Moose role you would need to use a method modifier instead.
.PP
.Vb 1
\&   after \*(Aqvalidate\*(Aq => sub { ... };
.Ve
.PP
Don't forget the dependency list, which is used for cases where if any of one
of a group of fields has a value, all of the fields are required.
.SS "Supply an external coderef for validation"
.IX Subsection "Supply an external coderef for validation"
There are situations in which you need to use a subroutine for validation
which is not logically part of the form. It's possible to pass in a context
or other sort of pointer and call the routine in the form's validation
routine, but that makes the architecture muddy and is not a clear separation
of concerns.
.PP
This is an example of how to supply a coderef when constructing the form that
performs validation and can be used to set an appropriate error
using Moose::Meta::Attribute::Native::Trait::Code.
(Thanks to Florian Ragwitz for this excellent idea...)
.PP
Here's the form:
.PP
.Vb 3
\&    package SignupForm;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has check_name_availability => (
\&        traits   => [\*(AqCode\*(Aq],
\&        isa      => \*(AqCodeRef\*(Aq,
\&        required => 1,
\&        handles  => { name_available => \*(Aqexecute\*(Aq, },
\&    );
\&
\&    has_field \*(Aqname\*(Aq;
\&    has_field \*(Aqemail\*(Aq;
\&
\&    sub validate {
\&        my $self = shift;
\&        my $name = $self\->value\->{name};
\&        if ( defined $name && length $name && !$self\->name_available($name) ) {
\&            $self\->field(\*(Aqname\*(Aq)\->add_error(\*(AqThat name is taken already\*(Aq);
\&        }
\&    }
\&    1;
.Ve
.PP
And here's where the coderef is passed in to the form.
.PP
.Vb 2
\&    package MyApp::Signup;
\&    use Moose;
\&
\&    has \*(Aqform\*(Aq => ( is => \*(Aqro\*(Aq, builder => \*(Aqbuild_form\*(Aq );
\&    sub build_form {
\&        my $self = shift;
\&        return SignupForm\->new(
\&            {
\&                check_name_availability => sub {
\&                    my $name = shift;
\&                    return $self\->username_available($name);
\&                },
\&            }
\&        );
\&
\&    }
\&    sub username_available {
\&        my ( $self, $name ) = @_;
\&        # perform some sort of username availability checks
\&    }
\&    1;
.Ve
.SS "Example of a form with custom database interface"
.IX Subsection "Example of a form with custom database interface"
The default \s-1DBIC\s0 model requires that the form structure match the database
structure. If that doesn't work \- you need to present the form in a different
way \- you may need to fudge it by creating your own 'init_object' and doing
the database updates in the 'update_model' method.
.PP
Here is a working example for a 'family' object (equivalent to a 'user'
record') that has a relationship to permission type roles in a relationship
\&'user_roles'.
.PP
.Vb 3
\&    package My::Form::AdminRoles;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has \*(Aqschema\*(Aq => ( is => \*(Aqro\*(Aq, required => 1 );  # Note 1
\&    has \*(Aq+widget_wrapper\*(Aq => ( default => \*(AqNone\*(Aq ); # Note 2
\&
\&    has_field \*(Aqadmin_roles\*(Aq => ( type => \*(AqRepeatable\*(Aq ); # Note 3
\&    has_field \*(Aqadmin_roles.family\*(Aq    => ( type => \*(AqHidden\*(Aq ); # Note 4
\&    has_field \*(Aqadmin_roles.family_id\*(Aq => ( type => \*(AqPrimaryKey\*(Aq ); # Note 5
\&    has_field \*(Aqadmin_roles.admin_flag\*(Aq => ( type => \*(AqBoolean\*(Aq, label => \*(AqAdmin\*(Aq );
\&
\&    # Note 6
\&    sub init_object {
\&        my $self = shift;
\&
\&        my @is_admin;
\&        my @is_not_admin;
\&        my $active_families = $self\->schema\->resultset(\*(AqFamily\*(Aq)\->search( { active => 1 } );
\&        while ( my $fam = $active_families\->next ) {
\&            my $admin_flag =
\&                 $fam\->search_related(\*(Aquser_roles\*(Aq, { role_id => 2 } )\->count > 0 ? 1 : 0;
\&            my $family_name = $fam\->name1 . ", " . $fam\->name2;
\&            my $elem =  { family => $family_name, family_id => $fam\->family_id,
\&                 admin_flag => $admin_flag };
\&            if( $admin_flag ) {
\&                push @is_admin, $elem;
\&            }
\&            else {
\&                push @is_not_admin, $elem;
\&            }
\&        }
\&        # Note 7
\&        # sort into admin flag first, then family_name
\&        @is_admin = sort { $a\->{family} cmp $b\->{family} } @is_admin;
\&        @is_not_admin = sort { $a\->{family} cmp $b\->{family} } @is_not_admin;
\&        return { admin_roles => [@is_admin, @is_not_admin] };
\&    }
\&
\&    # Note 8
\&    sub update_model {
\&        my $self = shift;
\&
\&        my $families = $self\->schema\->resultset(\*(AqFamily\*(Aq);
\&        my $family_roles = $self\->value\->{admin_roles};
\&        foreach my $elem ( @{$family_roles} ) {
\&            my $fam = $families\->find( $elem\->{family_id} );
\&            my $has_admin_flag = $fam\->search_related(\*(Aquser_roles\*(Aq, { role_id => 2 } )\->count > 0;
\&            if( $elem\->{admin_flag} == 1 && !$has_admin_flag ) {
\&                $fam\->create_related(\*(Aquser_roles\*(Aq, { role_id => 2 } );
\&            }
\&            elsif( $elem\->{admin_flag} == 0 && $has_admin_flag ) {
\&                $fam\->delete_related(\*(Aquser_roles\*(Aq, { role_id => 2 } );
\&            }
\&        }
\&    }
.Ve
.PP
Note 1: This form creates its own 'schema' attribute. You could inherit from
HTML::FormHandler::Model::DBIC, but you won't be using its update code, so
it wouldn't add much.
.PP
Note 2: The form will be displayed with a template that uses 'bare' form input
fields, so 'widget_wrapper' is set to 'None' to skip wrapping the form inputs with
divs or table elements.
.PP
Note 3: This form consists of an array of elements, so there will be a single
Repeatable form field with subfields. If you wanted to use automatic rendering, you would
also need to create a 'submit' field, but in this case it will just be done
in the template.
.PP
Note 4: This field is actually going to be used for display purposes only, but it's
a hidden field because otherwise the information would be lost when displaying
the form from parameters. For this case there is no real 'validation' so it
might not be necessary, but it would be required if the form needed to be
re-displayed with error messages.
.PP
Note 5: The 'family_id' is the primary key field, necessary for updating the
correct records.
.PP
Note 6: 'init_object' method: This is where the initial object is created, which
takes the place of a database row for form creation.
.PP
Note 7: The entries with the admin flag turned on are sorted into the beginning
of the list. This is entirely a user interface choice.
.PP
Note 8: 'update_model' method: This is where the database updates are performed.
.PP
The Template Toolkit template for this form:
.PP
.Vb 10
\&    <h1>Update admin status for members</h1>
\&    <form name="adminroles" method="POST" action="[% c.uri_for(\*(Aqadmin_roles\*(Aq) %]">
\&      <input class="submit" name="submit" value="Save" type="submit">
\&    <table border="1">
\&      <th>Family</th><th>Admin</th>
\&      [% FOREACH f IN form.field(\*(Aqadmin_roles\*(Aq).sorted_fields %]
\&         <tr>
\&         <td><b>[% f.field(\*(Aqfamily\*(Aq).fif %]</b>[% f.field(\*(Aqfamily\*(Aq).render %]
\&         [% f.field(\*(Aqfamily_id\*(Aq).render %]</td><td> [% f.field(\*(Aqadmin_flag\*(Aq).render %]</td>
\&         </tr>
\&      [% END %]
\&    </table>
\&      <input class="submit" name="submit" value="Save" type="submit">
\&    </form
.Ve
.PP
The form is rendered in a simple table, with each field rendered using the
automatically installed rendering widgets with no wrapper (widget_wrapper => 'None').
There are two hidden fields here, so what is actually seen is two columns, one with
the user (family) name, the other with a checkbox showing whether the user has
admin status. Notice that the 'family' field information is rendered twice: once
as a hidden field that will allow it to be preserved in params, once as a label.
.PP
The Catalyst controller action to execute the form:
.PP
.Vb 2
\&    sub admin_roles : Local {
\&        my ( $self, $c ) = @_;
\&
\&        my $schema = $c\->model(\*(AqDB\*(Aq)\->schema;
\&        my $form = My::Form::AdminRoles\->new( schema => $schema );
\&        $form\->process( params => $c\->req\->params );
\&        # re\-process if form validated to reload from db and re\-sort
\&        $form\->process( params => {}) if $form\->validated;
\&        $c\->stash( form => $form, template => \*(Aqadmin/admin_roles.tt\*(Aq );
\&        return;
\&    }
.Ve
.PP
Rather than redirect to some other page after saving the form, the form is redisplayed.
If the form has been validated (i.e. the 'update_model' method has been run), the
\&'process' call is run again in order to re-sort the displayed list with admin users at
the top. That could have also been done in the 'update_model' method.
.SS "A form that takes a resultset, with custom update_model"
.IX Subsection "A form that takes a resultset, with custom update_model"
For updating a Repeatable field that is filled from a Resultset, and not a
relationship on a single row. Creates a 'resultset' attribute to pass in
a resultset. Massages the data into an array that's pointed to by an
\&'employers' hash key, and does the reverse in the 'update_model' method.
Yes, it's a kludge, but it could be worse. If you want to impement a more
general solution, patches welcome.
.PP
.Vb 3
\&    package Test::Resultset;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler::Model::DBIC\*(Aq;
\&
\&    has \*(Aq+item_class\*(Aq => ( default => \*(AqEmployer\*(Aq );
\&    has \*(Aqresultset\*(Aq => ( isa => \*(AqDBIx::Class::ResultSet\*(Aq, is => \*(Aqrw\*(Aq, 
\&            trigger => sub { shift\->set_resultset(@_) } );
\&    sub set_resultset {
\&        my ( $self, $resultset ) = @_;
\&        $self\->schema( $resultset\->result_source\->schema );
\&    }
\&    sub init_object {
\&        my $self = shift;
\&        my $rows = [$self\->resultset\->all];
\&        return { employers => $rows };
\&    }
\&    has_field \*(Aqemployers\*(Aq => ( type => \*(AqRepeatable\*(Aq );
\&    has_field \*(Aqemployers.employer_id\*(Aq => ( type => \*(AqPrimaryKey\*(Aq );
\&    has_field \*(Aqemployers.name\*(Aq;
\&    has_field \*(Aqemployers.category\*(Aq;
\&    has_field \*(Aqemployers.country\*(Aq;
\&
\&    sub update_model {
\&        my $self = shift;
\&        my $values = $self\->values\->{employers};
\&        foreach my $row (@$values) {
\&            delete $row\->{employer_id} unless defined $row\->{employer_id};
\&            $self\->resultset\->update_or_create( $row );
\&        }
\&    }
.Ve
.SS "Server-provided dynamic value for field"
.IX Subsection "Server-provided dynamic value for field"
There are many different ways to provide values for fields. Default values can be
statically provided in the form with the 'default' attribute on the field, with
a default_<field_name> method in the form, with an init_object/item, and with
\&'default_over_obj' if you have both an item/init_object and want to provide a
default.
.PP
.Vb 6
\&    has_field \*(Aqfoo\*(Aq => ( default => \*(Aqmy_default\*(Aq );
\&    has_field \*(Aqfoo\*(Aq => ( default_over_obj => \*(Aqmy_default\*(Aq );
\&    sub default_foo { \*(Aqmy_default\*(Aq }
\&    ..
\&    $form\->process( init_object => { foo => \*(Aqmy_default } );
\&    $form\->process( item => <object with $obj\->foo method to provide default> );
.Ve
.PP
If you want to change the default for the field at run time, there are a number
of options.
.PP
You can set the value in the init_object or item before doing process:
.PP
.Vb 2
\&    my $foo_value = \*(Aqsome calculated value\*(Aq;
\&    $form\->process( init_object => { foo => $foo_value } );
.Ve
.PP
You can use 'update_field_list' or 'defaults' on the 'process' call:
.PP
.Vb 3
\&    $form\->process( update_field_list => { foo => { default => $foo_value } } );
\&    \-\- or \-\-
\&    $form\->proces( defaults => { foo => $foo_value } );
.Ve
.PP
You can set a Moose attribute in the form class, and set the default in a
default_<field_name> method:
.PP
.Vb 3
\&    package My::Form;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::Formhandler\*(Aq;
\&
\&    has \*(Aqform_id\*(Aq => ( isa => \*(AqStr\*(Aq, is => \*(Aqrw\*(Aq );
\&    has_field \*(Aqfoo\*(Aq;
\&    sub default_foo {
\&        my $self = shift;
\&        return $self\->form_id;
\&    }
\&    ....
\&    $form\->process( form_id => \*(Aqmy_form\*(Aq, params => $params );
.Ve
.PP
You can set a Moose attribute in the form class and set it in an update_fields
method:
.PP
.Vb 4
\&    sub update_fields {
\&        my $self = shift;
\&        $self\->field(\*(Aqfoo\*(Aq)\->default(\*(Aqmy_form\*(Aq);
\&    }
.Ve
.SS "Static form, dynamic field IDs"
.IX Subsection "Static form, dynamic field IDs"
The problem: you have a form that will be used in multiple places on a page, but you don't
want to use a static form instead of doing 'new' for each. You can pass a form name in
on the process call and use 'html_prefix' in the form:
.PP
.Vb 1
\&   $form\->process( name => \*(Aq...\*(Aq, params => {} );
.Ve
.PP
But the field 'id' attribute has already been constructed and doesn't change.
.PP
Solution: apply a role to the base field class to replace the 'id' getter for the 'id'
attribute with a method which constructs the 'id' dynamically. Since the role is
being applied to the base field class, you can't just use 'sub id', because the 
\&'id' method defined by the 'id' attribute has precedence. So create an 'around'
method modifier that replaces it in the role.
.PP
.Vb 8
\&    package My::DynamicFieldId;
\&    use Moose::Role;
\&    around \*(Aqid\*(Aq => sub {
\&        my $orig = shift;
\&        my $self = shift;
\&        my $form_name = $self\->form\->name;
\&        return $form_name . "." . $self\->full_name;
\&    };
\&
\&    package My::CustomIdForm;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has \*(Aq+html_prefix\*(Aq => ( default => 1 );
\&    has \*(Aq+field_traits\*(Aq => ( default => sub { [\*(AqMy::DynamicFieldId\*(Aq] } );
\&
\&    has_field \*(Aqfoo\*(Aq;
\&    has_field \*(Aqbar\*(Aq;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
