.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2008-12-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Util \- Easy, versatile, portable file handling
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::Util provides a comprehensive toolbox of utilities to automate all
kinds of common tasks on file / directories.  Its purpose is to do so
in the most portable manner possible so that users of this module won't
have to worry about whether their programs will work on other OSes
and machines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&
\&   my($content) = $f\->load_file(\*(Aqfoo.txt\*(Aq);
\&
\&   $content =~ s/this/that/g;
\&
\&   $f\->write_file(
\&      \*(Aqfile\*(Aq => \*(Aqbar.txt\*(Aq,
\&      \*(Aqcontent\*(Aq => $content,
\&      \*(Aqbitmask\*(Aq => 0644
\&   );
\&
\&   $f\->write_file(
\&      \*(Aqfile\*(Aq => \*(Aqfile.bin\*(Aq, \*(Aqcontent\*(Aq => $binary_content, \*(Aq\-\-binmode\*(Aq
\&   );
\&
\&   my(@lines) = $f\->load_file(\*(Aqrandomquote.txt\*(Aq, \*(Aq\-\-as\-lines\*(Aq);
\&   my($line)  = int(rand(scalar @lines));
\&
\&   print $lines[$line];
\&
\&   my(@files) = $f\->list_dir(\*(Aq/var/tmp\*(Aq, qw/ \-\-files\-only \-\-recurse /);
\&   my(@textfiles) = $f\->list_dir(\*(Aq/var/tmp\*(Aq, \*(Aq\-\-pattern=\e.txt$\*(Aq);
\&
\&   if ($f\->can_write(\*(Aqwibble.log\*(Aq)) {
\&
\&      my($HANDLE) = $f\->open_handle(
\&         \*(Aqfile\*(Aq => \*(Aqwibble.log\*(Aq,
\&         \*(Aqmode\*(Aq => \*(Aqappend\*(Aq
\&      );
\&
\&      print $HANDLE "Hello World! It\*(Aqs ", scalar localtime;
\&
\&      close $HANDLE
\&   }
\&
\&   my($log_line_count) = $f\->line_count(\*(Aq/var/log/httpd/access_log\*(Aq);
\&
\&   print "My file has a bitmask of " . $f\->bitmask(\*(Aqmy.file\*(Aq);
\&
\&   print "My file is a " . join(\*(Aq, \*(Aq, $f\->file_type(\*(Aqmy.file\*(Aq)) . " file."
\&
\&   warn \*(AqThis file is binary!\*(Aq if $f\->isbin(\*(Aqmy.file\*(Aq);
\&
\&   print "My file was last modified on " .
\&      scalar localtime($f\->last_modified(\*(Aqmy.file\*(Aq));
\&
\&   # ...and _lots_ more
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module type the following at the command prompt:
.PP
.Vb 4
\&   perl Makefile.PL
\&   make
\&   make test
\&   make install
.Ve
.PP
On windows machines use nmake rather than make; those running cygwin don't have
to worry about this.  If you don't know what cygwin is, use nmake and check out
http://cygwin.com/ after you're done installing this module if you want to
find out.
.SH "ISA"
.IX Header "ISA"
.IP "Exporter" 4
.IX Item "Exporter"
.PD 0
.IP "Class::OOorNO" 4
.IX Item "Class::OOorNO"
.PD
.SH "EXPORTED SYMBOLS"
.IX Header "EXPORTED SYMBOLS"
Exports nothing by default.
.SS "\s-1EXPORT_OK\s0"
.IX Subsection "EXPORT_OK"
The following symbols comprise \f(CW@File::Util::EXPORT_OK\fR), and as such are
available for import to your namespace only upon request.
.PP
\&\f(CW\*(C`bitmask\*(C'\fR            \fI(see bitmask)\fR
.PP
\&\f(CW\*(C`can_flock\*(C'\fR          \fI(see can_flock)\fR
.PP
\&\f(CW\*(C`can_read\*(C'\fR           \fI(see can_read)\fR
.PP
\&\f(CW\*(C`can_write\*(C'\fR          \fI(see can_write)\fR
.PP
\&\f(CW\*(C`created\*(C'\fR            \fI(see created)\fR
.PP
\&\f(CW\*(C`ebcdic\*(C'\fR             \fI(see ebcdic)\fR
.PP
\&\f(CW\*(C`escape_filename\*(C'\fR    \fI(see escape_filename)\fR
.PP
\&\f(CW\*(C`existent\*(C'\fR           \fI(see existent)\fR
.PP
\&\f(CW\*(C`file_type\*(C'\fR          \fI(see file_type)\fR
.PP
\&\f(CW\*(C`isbin\*(C'\fR              \fI(see isbin)\fR
.PP
\&\f(CW\*(C`last_access\*(C'\fR        \fI(see last_access)\fR
.PP
\&\f(CW\*(C`last_changed\*(C'\fR       \fI(see last_changed)\fR
.PP
\&\f(CW\*(C`last_modified\*(C'\fR      \fI(see last_modified)\fR
.PP
\&\f(CW\*(C`NL\*(C'\fR                 \fI(see \s-1NL\s0)\fR
.PP
\&\f(CW\*(C`needs_binmode\*(C'\fR      \fI(see needs_binmode)\fR
.PP
\&\f(CW\*(C`return_path\*(C'\fR        \fI(see return_path)\fR
.PP
\&\f(CW\*(C`size\*(C'\fR               \fI(see size)\fR
.PP
\&\f(CW\*(C`SL\*(C'\fR                 \fI(see \s-1SL\s0)\fR
.PP
\&\f(CW\*(C`strip_path\*(C'\fR         \fI(see strip_path)\fR
.PP
\&\f(CW\*(C`valid_filename\*(C'\fR     \fI(see valid_filename)\fR
.PP
\&\fBNote:\fR Symbols in \f(CW@Class::OOorNO::EXPORT_OK\fR are also
available for import.
.SS "\s-1EXPORT_TAGS\s0"
.IX Subsection "EXPORT_TAGS"
.Vb 1
\&   :all (exports all of @File::Util::EXPORT_OK)
.Ve
.SH "METHODS"
.IX Header "METHODS"
\&\fBNote:\fR Some of the methods listed will state that they are autoloaded methods.
Autloaded methods are not compiled at runtime as part of your process and only
get created if called somewhere in your program.  \fI(see AutoLoader.)\fR
.PP
Methods listed in alphabetical order.
.ie n .SS """bitmask"""
.el .SS "\f(CWbitmask\fP"
.IX Subsection "bitmask"
.ie n .IP "\fISyntax:\fR ""bitmask( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWbitmask( [file name] )\fR" 4
.IX Item "Syntax: bitmask( [file name] )"
Gets the bitmask of the named file, provided the file exists. If the file
exists, the bitmask of the named file is returned in four digit octal
notation e.g.\- \f(CW0644\fR.  Otherwise, returns \f(CW\*(C`undef\*(C'\fR if the file does \fInot\fR
exist.  This is an autoloaded method.
.ie n .SS """can_flock"""
.el .SS "\f(CWcan_flock\fP"
.IX Subsection "can_flock"
.ie n .IP "\fISyntax:\fR ""can_flock""" 4
.el .IP "\fISyntax:\fR \f(CWcan_flock\fR" 4
.IX Item "Syntax: can_flock"
Returns 1 if the current system claims to support \f(CW\*(C`flock()\*(C'\fR \fIand\fR if the
Perl process can successfully call it.  \fI(see \*(L"flock\*(R" in perlfunc.)\fR  Unless
both of these conditions are true a zero value (0) is returned.  This is
an autoloaded method.  This is a constant subroutine.  It accepts no arguments
and will always return the same value for the system on which it is executed.
.Sp
\&\fBNote:\fR Perl will try to support or emulate flock whenever it can via
available system calls, namely \f(CW\*(C`flock\*(C'\fR; \f(CW\*(C`lockf\*(C'\fR; or with \f(CW\*(C`fcntl\*(C'\fR.
.ie n .SS """can_read"""
.el .SS "\f(CWcan_read\fP"
.IX Subsection "can_read"
.ie n .IP "\fISyntax:\fR ""can_read( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWcan_read( [file name] )\fR" 4
.IX Item "Syntax: can_read( [file name] )"
Returns 1 if the named file (or directory) is \fBreadable\fR by your program
according to the applied permissions of the file system on which the file
resides.  Otherwise a value of undef is returned.
.Sp
This works the same as Perl's built-in \f(CW\*(C`\-r\*(C'\fR file test operator,
\&\fI(see \*(L"\-X\*(R" in perlfunc)\fR, it's just easier for some people to remember.  This
is an autoloaded method.
.ie n .SS """can_write"""
.el .SS "\f(CWcan_write\fP"
.IX Subsection "can_write"
.ie n .IP "\fISyntax:\fR ""can_write( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWcan_write( [file name] )\fR" 4
.IX Item "Syntax: can_write( [file name] )"
Returns 1 if the named file (or directory) is \fBwritable\fR by your program
according to the applied permissions of the file system on which the file
resides.  Otherwise a value of undef is returned.
.Sp
This works the same as Perl's built-in \f(CW\*(C`\-w\*(C'\fR file test operator,
\&\fI(see \*(L"\-X\*(R" in perlfunc)\fR, it's just easier for some people to remember.  This
is an autoloaded method.
.ie n .SS """created"""
.el .SS "\f(CWcreated\fP"
.IX Subsection "created"
.ie n .IP "\fISyntax:\fR ""created( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWcreated( [file name] )\fR" 4
.IX Item "Syntax: created( [file name] )"
Returns the time of creation for the named file in non-leap seconds since
whatever your system considers to be the epoch.  Suitable for feeding to
Perl's built-in functions \*(L"gmtime\*(R" and \*(L"localtime\*(R".  \fI(see \*(L"time\*(R" in perlfunc.)\fR
This is an autoloaded method.
.ie n .SS """ebcdic"""
.el .SS "\f(CWebcdic\fP"
.IX Subsection "ebcdic"
.ie n .IP "\fISyntax:\fR ""ebcdic""" 4
.el .IP "\fISyntax:\fR \f(CWebcdic\fR" 4
.IX Item "Syntax: ebcdic"
Returns 1 if the machine on which the code is running uses \s-1EBCDIC\s0, or returns
0 if not.  \fI(see perlebcdic.)\fR  This is an autoloaded method.  This is a
constant subroutine.  It accepts no arguments and will always return the same
value for the system on which it is executed.
.ie n .SS """escape_filename"""
.el .SS "\f(CWescape_filename\fP"
.IX Subsection "escape_filename"
.ie n .IP "\fISyntax:\fR ""escape_filename( [string], [escape char] )""" 4
.el .IP "\fISyntax:\fR \f(CWescape_filename( [string], [escape char] )\fR" 4
.IX Item "Syntax: escape_filename( [string], [escape char] )"
Returns it's argument in an escaped form that is suitable for use as a filename.
Illegal characters (i.e.\- any type of newline character, tab, vtab, and the
following \f(CW\*(C`/ | * " ? < : > \e\*(C'\fR), are replaced with [escape char] or
"\fB_\fR" if no [escape char] is specified.  Returns an empty string if no
arguments are provided.  This is an autoloaded method.
.ie n .SS """existent"""
.el .SS "\f(CWexistent\fP"
.IX Subsection "existent"
.ie n .IP "\fISyntax:\fR ""existent( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWexistent( [file name] )\fR" 4
.IX Item "Syntax: existent( [file name] )"
Returns 1 if the named file (or directory) exists.  Otherwise a value of
undef is returned.
.Sp
This works the same as Perl's built-in \f(CW\*(C`\-e\*(C'\fR file test operator,
\&\fI(see \*(L"\-X\*(R" in perlfunc)\fR, it's just easier for some people to remember.  This
is an autoloaded method.
.ie n .SS """file_type"""
.el .SS "\f(CWfile_type\fP"
.IX Subsection "file_type"
.ie n .IP "\fISyntax:\fR ""file_type( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWfile_type( [file name] )\fR" 4
.IX Item "Syntax: file_type( [file name] )"
Returns a list of keywords corresponding to each of Perl's built in file tests
(those specific to file types) for which the named file returns true.
\&\fI(see \*(L"\-X\*(R" in perlfunc.)\fR  This is an autoloaded method.
.Sp
The keywords and their definitions appear below; the order of keywords returned
is the same as the order in which the are listed here:
.RS 4
.ie n .IP """PLAIN             File is a plain file.""" 4
.el .IP "\f(CWPLAIN             File is a plain file.\fR" 4
.IX Item "PLAIN             File is a plain file."
.PD 0
.ie n .IP """TEXT              File is a text file.""" 4
.el .IP "\f(CWTEXT              File is a text file.\fR" 4
.IX Item "TEXT              File is a text file."
.ie n .IP """BINARY            File is a binary file.""" 4
.el .IP "\f(CWBINARY            File is a binary file.\fR" 4
.IX Item "BINARY            File is a binary file."
.ie n .IP """DIRECTORY         File is a directory.""" 4
.el .IP "\f(CWDIRECTORY         File is a directory.\fR" 4
.IX Item "DIRECTORY         File is a directory."
.ie n .IP """SYMLINK           File is a symbolic link.""" 4
.el .IP "\f(CWSYMLINK           File is a symbolic link.\fR" 4
.IX Item "SYMLINK           File is a symbolic link."
.ie n .IP """PIPE              File is a named pipe (FIFO).""" 4
.el .IP "\f(CWPIPE              File is a named pipe (FIFO).\fR" 4
.IX Item "PIPE              File is a named pipe (FIFO)."
.ie n .IP """SOCKET            File is a socket.""" 4
.el .IP "\f(CWSOCKET            File is a socket.\fR" 4
.IX Item "SOCKET            File is a socket."
.ie n .IP """BLOCK             File is a block special file.""" 4
.el .IP "\f(CWBLOCK             File is a block special file.\fR" 4
.IX Item "BLOCK             File is a block special file."
.ie n .IP """CHARACTER         File is a character special file.""" 4
.el .IP "\f(CWCHARACTER         File is a character special file.\fR" 4
.IX Item "CHARACTER         File is a character special file."
.RE
.RS 4
.RE
.PD
.ie n .SS """flock_rules"""
.el .SS "\f(CWflock_rules\fP"
.IX Subsection "flock_rules"
.ie n .IP "\fISyntax:\fR ""flock_rules( [keyword list] )""" 4
.el .IP "\fISyntax:\fR \f(CWflock_rules( [keyword list] )\fR" 4
.IX Item "Syntax: flock_rules( [keyword list] )"
Sets I/O race condition policy, or tells File::Util how it should handle race
conditions created when a file can't be locked because it is already locked
somewhere else (usually by another process).
.Sp
An empty call to this method returns a list of keywords representing the rules
that are currently in effect for the object.
.Sp
Otherwise, a call should include a list with array containing your chosen
directive keywords in order of precedence.  The rules will be applied in
cascading order when a File::Util object attempts to lock a file, so if the
actions specified by the first rule don't result in success, the second rule
is applied, and so on.
.Sp
Recognized keywords:
.RS 4
.ie n .IP """NOBLOCKEX""" 4
.el .IP "\f(CWNOBLOCKEX\fR" 4
.IX Item "NOBLOCKEX"
tries to get an exclusive lock on the file without blocking (waiting)
.ie n .IP """NOBLOCKSH""" 4
.el .IP "\f(CWNOBLOCKSH\fR" 4
.IX Item "NOBLOCKSH"
tries to get a shared lock on the file without blocking
.ie n .IP """BLOCKEX""" 4
.el .IP "\f(CWBLOCKEX\fR" 4
.IX Item "BLOCKEX"
waits to try getting an exclusive lock
.ie n .IP """BLOCKSH""" 4
.el .IP "\f(CWBLOCKSH\fR" 4
.IX Item "BLOCKSH"
waits to try getting a shared lock
.ie n .IP """FAIL""" 4
.el .IP "\f(CWFAIL\fR" 4
.IX Item "FAIL"
dies with stack trace
.ie n .IP """WARN""" 4
.el .IP "\f(CWWARN\fR" 4
.IX Item "WARN"
\&\fIwarn()\fRs about the error with a stack trace and returns undef
.ie n .IP """IGNORE""" 4
.el .IP "\f(CWIGNORE\fR" 4
.IX Item "IGNORE"
ignores the failure to get an exclusive lock
.ie n .IP """UNDEF""" 4
.el .IP "\f(CWUNDEF\fR" 4
.IX Item "UNDEF"
returns undef
.ie n .IP """ZERO""" 4
.el .IP "\f(CWZERO\fR" 4
.IX Item "ZERO"
returns 0
.RE
.RS 4
.Sp
Examples:
.ie n .IP "ex\- ""flock_rules( qw/ NOBLOCKEX FAIL / );""" 4
.el .IP "ex\- \f(CWflock_rules( qw/ NOBLOCKEX FAIL / );\fR" 4
.IX Item "ex- flock_rules( qw/ NOBLOCKEX FAIL / );"
This is the default policy.  When in effect, the File::Util object will first
attempt to get a non-blocking exclusive lock on the file.  If that attempt
fails the File::Util object will call \fIdie()\fR with a detailed error message and
a stack trace.
.ie n .IP "ex\- ""flock_rules( qw/ NOBLOCKEX BLOCKEX FAIL / );""" 4
.el .IP "ex\- \f(CWflock_rules( qw/ NOBLOCKEX BLOCKEX FAIL / );\fR" 4
.IX Item "ex- flock_rules( qw/ NOBLOCKEX BLOCKEX FAIL / );"
The File::Util object will first attempt to get a non-blocking exclusive lock
on the file.  If that attempt fails it falls back to the second policy rule
\&\*(L"\s-1BLOCKEX\s0\*(R" and tries again to get an exclusive lock on the file, but this time
by blocking (waiting for its turn).  If that second attempt fails, the
File::Util object will fail with a detailed error message and a stack trace.
.ie n .IP "ex\- ""flock_rules( qw/ BLOCKEX IGNORE / );""" 4
.el .IP "ex\- \f(CWflock_rules( qw/ BLOCKEX IGNORE / );\fR" 4
.IX Item "ex- flock_rules( qw/ BLOCKEX IGNORE / );"
The File::Util object will first attempt to get a file non-blocking lock on
the file.  If that attempt fails it will ignore the error, and go on to open
the file anyway and no failures will occur or warings be issued.
.RE
.RS 4
.Sp
This is an autoloaded method.
.RE
.ie n .SS """isbin"""
.el .SS "\f(CWisbin\fP"
.IX Subsection "isbin"
.ie n .IP "\fISyntax:\fR ""isbin( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWisbin( [file name] )\fR" 4
.IX Item "Syntax: isbin( [file name] )"
Returns 1 if the named file (or directory) exists.  Otherwise a value of undef
is returned, indicating that the named file either does not exist or is of
another file type.
.Sp
This works the same as Perl's built-in \f(CW\*(C`\-B\*(C'\fR file test operator,
\&\fI(see \*(L"\-X\*(R" in perlfunc)\fR, it's just easier for some people to remember.  This
is an autoloaded method.
.ie n .SS """last_access"""
.el .SS "\f(CWlast_access\fP"
.IX Subsection "last_access"
.ie n .IP "\fISyntax:\fR ""last_access( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWlast_access( [file name] )\fR" 4
.IX Item "Syntax: last_access( [file name] )"
Returns the last accessed time for the named file in non-leap seconds since
whatever your system considers to be the epoch.  Suitable for feeding to
Perl's built-in functions \*(L"gmtime\*(R" and \*(L"localtime\*(R".  \fI(see \*(L"time\*(R" in perlfunc.)\fR
This is an autoloaded method.
.ie n .SS """last_changed"""
.el .SS "\f(CWlast_changed\fP"
.IX Subsection "last_changed"
.ie n .IP "\fISyntax:\fR ""last_changed( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWlast_changed( [file name] )\fR" 4
.IX Item "Syntax: last_changed( [file name] )"
Returns the inode change time for the named file in non-leap seconds since
whatever your system considers to be the epoch.  Suitable for feeding to
Perl's built-in functions \*(L"gmtime\*(R" and \*(L"localtime\*(R".  \fI(see \*(L"time\*(R" in perlfunc.)\fR
This is an autoloaded method.
.ie n .SS """last_modified"""
.el .SS "\f(CWlast_modified\fP"
.IX Subsection "last_modified"
.ie n .IP "\fISyntax:\fR ""last_modified( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWlast_modified( [file name] )\fR" 4
.IX Item "Syntax: last_modified( [file name] )"
Returns the last modified time for the named file in non-leap seconds since
whatever your system considers to be the epoch.  Suitable for feeding to
Perl's built-in functions \*(L"gmtime\*(R" and \*(L"localtime\*(R".  \fI(see \*(L"time\*(R" in perlfunc.)\fR
This is an autoloaded method.
.ie n .SS """line_count"""
.el .SS "\f(CWline_count\fP"
.IX Subsection "line_count"
.ie n .IP "\fISyntax:\fR ""line_count( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWline_count( [file name] )\fR" 4
.IX Item "Syntax: line_count( [file name] )"
Returns the number of lines in the named file.  Fails with an error if the
named file does not exist.
.ie n .SS """list_dir"""
.el .SS "\f(CWlist_dir\fP"
.IX Subsection "list_dir"
.ie n .IP "\fISyntax:\fR ""list_dir( [directory name] , [\-\-opts] )""" 4
.el .IP "\fISyntax:\fR \f(CWlist_dir( [directory name] , [\-\-opts] )\fR" 4
.IX Item "Syntax: list_dir( [directory name] , [--opts] )"
Returns alphabetically sorted all file names in the directory specified if it
exists.  Fails with an error message if no such directory is found.
.RS 4
.ie n .IP "\fBFlags accepted by \fB""list_dir()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBlist_dir()\fB\fR" 4
.IX Item "Flags accepted by list_dir()"
.RS 4
.PD 0
.ie n .IP """\-\-dirs\-only""" 4
.el .IP "\f(CW\-\-dirs\-only\fR" 4
.IX Item "--dirs-only"
.PD
return only directory contents which are directories
.ie n .IP """\-\-files\-only""" 4
.el .IP "\f(CW\-\-files\-only\fR" 4
.IX Item "--files-only"
return only directory contents which are files
.ie n .IP """\-\-no\-fsdots""" 4
.el .IP "\f(CW\-\-no\-fsdots\fR" 4
.IX Item "--no-fsdots"
do not include \*(L".\*(R" and \*(L"..\*(R" in the list of directory contents
.ie n .IP """\-\-pattern""" 4
.el .IP "\f(CW\-\-pattern\fR" 4
.IX Item "--pattern"
return only files/directories matching pattern provided. argument
should be plain text string.  It will be converted to a perl regex and passed
to CORE::grep as the method scans through directory listings for a match.
.Sp
(ex\- \f(CW\*(Aq\-\-pattern=\e.txt$\*(Aq\fR returns all file/directory names ending in \*(L".txt\*(R".
It will match \*(L"foo.txt\*(R", but not \*(L"foo.txt.gz\*(R" because of the \*(L"$\*(R" anchor in the
regular expression passed in.)
.Sp
or for the opposite effect, \f(CW\*(Aq\-\-pattern=.*(?<!\e.txt)$\*(Aq\fR returns all
file/directory names that don't end in \*(L".txt\*(R"
.ie n .IP """\-\-with\-paths""" 4
.el .IP "\f(CW\-\-with\-paths\fR" 4
.IX Item "--with-paths"
Include file paths with the contents of the directory list, relative
to the directory named in the call.
.ie n .IP """\-\-recurse""" 4
.el .IP "\f(CW\-\-recurse\fR" 4
.IX Item "--recurse"
Recurse subdirectories
.ie n .IP """\-\-follow""" 4
.el .IP "\f(CW\-\-follow\fR" 4
.IX Item "--follow"
Recurse subdirectories, same as \f(CW\*(C`\-\-recurse\*(C'\fR
.ie n .IP """\-\-dirs\-as\-ref""" 4
.el .IP "\f(CW\-\-dirs\-as\-ref\fR" 4
.IX Item "--dirs-as-ref"
When returning directory listing, include first a reference to the list
of subdirectories found, followed by anything else returned by the call.
.ie n .IP """\-\-files\-as\-ref""" 4
.el .IP "\f(CW\-\-files\-as\-ref\fR" 4
.IX Item "--files-as-ref"
When returning directory listing, include last a reference to the list
of files found, preceded by a list of subdirectories found (or preceeded
by a list reference to subdirectories found if \f(CW\*(C`\-\-dirs\-as\-ref\*(C'\fR was also used).
.ie n .IP """\-\-as\-ref""" 4
.el .IP "\f(CW\-\-as\-ref\fR" 4
.IX Item "--as-ref"
Return a pair list references: the first is a reference to any subdirectories
found by the call, the second is a reference to any files found by the call.
.ie n .IP """\-\-sl\-after\-dirs""" 4
.el .IP "\f(CW\-\-sl\-after\-dirs\fR" 4
.IX Item "--sl-after-dirs"
Append a directory seperator (\*(L"/, \*(R"\e\*(L", or \*(R":" depending on your system)
to all directories found by the call.  Useful in visual displays for quick
differentiation between subdirectories and files.
.ie n .IP """\-\-ignore\-case""" 4
.el .IP "\f(CW\-\-ignore\-case\fR" 4
.IX Item "--ignore-case"
Items returned by the call to this method are sorted alphabetically by
default, so \*(L"Zoo.txt\*(R" comes before \*(L"alligator.txt\*(R" because the alphabetical
sort is case-sensitive.  This is also the way directories are listed at the
system level on most operating systems.
.Sp
If you'd like the directory contents returned by this method to be
sorted without regard to case , use this flag.
.ie n .IP """\-\-count\-only""" 4
.el .IP "\f(CW\-\-count\-only\fR" 4
.IX Item "--count-only"
Returns a single value: an integer reflecting the number of items
found in the directory after applying the filter criteria specified by any
other flags (ie\- \*(L"\-\-dirs\-only\*(R", \*(L"\-\-recurse\*(R", etc.) that may have been passed
in as well.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .SS """load_dir"""
.el .SS "\f(CWload_dir\fP"
.IX Subsection "load_dir"
.ie n .IP "\fISyntax:\fR ""load_dir( [directory name] , [\-\-ds\-type] )""" 4
.el .IP "\fISyntax:\fR \f(CWload_dir( [directory name] , [\-\-ds\-type] )\fR" 4
.IX Item "Syntax: load_dir( [directory name] , [--ds-type] )"
Returns a data structure containing the contents of each file present in the
named directory.  This is an autoloaded method.
.Sp
The type of data structure returned is determined by the optional data-type
switch.  Only one option may be used for a given call to this method.
Recognized options are listed below.
.RS 4
.ie n .IP "\fBFlags accepted by \fB""load_dir()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBload_dir()\fB\fR" 4
.IX Item "Flags accepted by load_dir()"
.RS 4
.PD 0
.ie n .IP """\-\-as\-list""" 4
.el .IP "\f(CW\-\-as\-list\fR" 4
.IX Item "--as-list"
.PD
Causes the method to return a list comprised of the contents loaded from
each file (in case-sensitive order) located in the named directory.
.ie n .IP """\-\-as\-listref""" 4
.el .IP "\f(CW\-\-as\-listref\fR" 4
.IX Item "--as-listref"
Same as above, except an array reference to the list of items is returned
rather than the list itself.
.ie n .IP """\-\-as\-hashref"" *(default)" 4
.el .IP "\f(CW\-\-as\-hashref\fR *(default)" 4
.IX Item "--as-hashref *(default)"
Implicit.  If no option is passed in, the default behavior is to return a
reference to an anonymous hash whose keys are the names of each file in the
specified directory; the hash values for contain the contents of the file
represented by its corresponding key.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBNote:\fR This method does not distinguish between plain files and other file
types such as binaries, FIFOs, sockets, etc.
.Sp
Restrictions imposed by the current \*(L"read limit\*(R"
\&\fI(see the \fIreadlimit()\fI) entry below\fR will be applied to the
files opened by this method as well.  Adjust the readlimit as necessary.
.Sp
.Vb 1
\&   my($files) = $fu\->load_dir(\*(Aqdirectory/to/load/\*(Aq);
.Ve
.Sp
The above code creates an anonymous hash reference that is stored in the
variable named "\f(CW$files\fR\*(L".  The keys and values of the hash referenced by
\&\*(R"\f(CW$files\fR" would resemble those of the following code snippet (given that
the files in the named directory were the files 'a.txt', 'b.html', 'c.dat',
and 'd.conf')
.Sp
.Vb 7
\&   my($files) =
\&      {
\&         \*(Aqa.txt\*(Aq  => "the contents of file a.txt",
\&         \*(Aqb.html\*(Aq => "the contents of file b.html",
\&         \*(Aqc.dat\*(Aq  => "the contents of file c.dat",
\&         \*(Aqd.conf\*(Aq => "the contents of file d.conf",
\&      };
.Ve
.RE
.ie n .SS """load_file"""
.el .SS "\f(CWload_file\fP"
.IX Subsection "load_file"
.ie n .IP "\fISyntax:\fR ""load_file( [file name] , [\-\-opts] )""" 4
.el .IP "\fISyntax:\fR \f(CWload_file( [file name] , [\-\-opts] )\fR" 4
.IX Item "Syntax: load_file( [file name] , [--opts] )"
.PD 0
.ie n .IP "\fI\s-1OR:\s0\fR ""load_file( \*(AqFH\*(Aq => [file handle reference] , [\-\-opts] )""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWload_file( \*(AqFH\*(Aq => [file handle reference] , [\-\-opts] )\fR" 4
.IX Item "OR: load_file( FH => [file handle reference] , [--opts] )"
.PD
If [file name] is passed, returns the contents of [file name] in a string.
If a [file handle reference] is passed instead, the filehandle will be
\&\f(CW\*(C`CORE::read()\*(C'\fR and the data obtained by the read will be returned in a string.
.Sp
If you desire the contents of the file (or file handle data) in a list of
lines instead of a single string, this can be accomplished through the use
of the \f(CW\*(C`\-\-as\-lines\*(C'\fR flag (see below).
.RS 4
.ie n .IP "\fBFlags accepted by \fB""load_file()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBload_file()\fB\fR" 4
.IX Item "Flags accepted by load_file()"
.RS 4
.PD 0
.ie n .IP """\-\-as\-lines""" 4
.el .IP "\f(CW\-\-as\-lines\fR" 4
.IX Item "--as-lines"
.PD
If this flag is passed then your call to \f(CW\*(C`load_file\*(C'\fR will return an ordered
list of strings, each of which is a line from the file [file name].  The lines
are returned in the order they are read, from the beginning of the file to the
end.
.Sp
This is not the default behavior.  The default behavior is for \f(CW\*(C`load_file\*(C'\fR to
return a single string containing the entire contents of the file, including
line break characters.
.ie n .IP """\-\-no\-lock""" 4
.el .IP "\f(CW\-\-no\-lock\fR" 4
.IX Item "--no-lock"
By default this method will attempt to get a lock on the file while it is
being read, following whatever rules are in place for the flock policy
established either by default (implicitly) or changed by you in a call to
\&\fIFile::Util::flock_rules()\fR
\&\fI(see the \fIflock_rules()\fI) entry below\fR.
.Sp
This method will not try to get a lock on the file if the File::Util object was
created with the option \f(CW\*(C`\-\-no\-lock\*(C'\fR or if the method was called with the
option \f(CW\*(C`\-\-no\-lock\*(C'\fR.
.Sp
This method will automatically call \fIbinmode()\fR on binary files for you.  If you
pass in a filehandle instead of a file name you do not get this automatic
check performed for you.  In such a case, you'll have to call \fIbinmode()\fR on
the filehandle yourself.  Once you pass a filehandle to this method it has no
way of telling if the file opened to that filehandle is binary or not.
.Sp
\&\fBNotes:\fR This method does not distinguish between plain files and other file
types such as binaries, FIFOs, sockets, etc.
.Sp
Restrictions imposed by the current \*(L"read limit\*(R"
\&\fI(see the \fIreadlimit()\fI) entry below\fR will be applied to the
files opened by this method as well.  Adjust the readlimit as necessary.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .SS """make_dir"""
.el .SS "\f(CWmake_dir\fP"
.IX Subsection "make_dir"
.ie n .IP "\fISyntax:\fR ""make_dir( [new directory name] , [bitmask], [\-\-opts] )""" 4
.el .IP "\fISyntax:\fR \f(CWmake_dir( [new directory name] , [bitmask], [\-\-opts] )\fR" 4
.IX Item "Syntax: make_dir( [new directory name] , [bitmask], [--opts] )"
Attempts to create (recursively) a directory as [new directory name] with
the [bitmask] provided.  The bitmask is an optional argument and defaults to
0777.  If specified, the bitmask must be supplied in the form required by the
native perl umask function.  \fIsee \*(L"umask\*(R" in perlfunc\fR for more information
about the format of the bitmask argument.
.Sp
As mentioned above, the recursive creation of directories is transparently
handled for you.  This means that if the name of the directory you pass in
contains a parent directory that does not exist, the parent directory(ies) will
be created for you automatically and silently in order to create the final
directory in the [new directory name].
.Sp
Simply put, if [new directory] is \*(L"/path/to/directory\*(R" and the directory
\&\*(L"/path/to\*(R" does not exist, the directory \*(L"/path/to\*(R" will be created and the
\&\*(L"/path/to/directory\*(R" directory will be created thereafter.  All directories
created will be created with the [bitmask] you specify, or with the default
of 0777.
.Sp
Upon successful creation of the [new directory name], the [new directory name]
is returned to the caller.
.RS 4
.ie n .IP "\fBFlags accepted by \fB""make_dir()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBmake_dir()\fB\fR" 4
.IX Item "Flags accepted by make_dir()"
.RS 4
.PD 0
.ie n .IP """\-\-if\-not\-exists""" 4
.el .IP "\f(CW\-\-if\-not\-exists\fR" 4
.IX Item "--if-not-exists"
.PD
If this flag is passed in then make_dir will not attempt to create the directory
if it already exists.  Rather it will return the name of the directory as it
normally would if the directory did not exist previous to calling this method.
.Sp
If a call to this method is made without the \f(CW\*(C`\-\-if\-not\-exists\*(C'\fR flag and the
directory specified as [new directory name] does in fact exist, an error will
result as it is impossible to create a directory that already exists.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
This is an autoloaded method.
.RE
.ie n .SS """max_dives"""
.el .SS "\f(CWmax_dives\fP"
.IX Subsection "max_dives"
.ie n .IP "\fISyntax:\fR ""max_dives( [integer] )""" 4
.el .IP "\fISyntax:\fR \f(CWmax_dives( [integer] )\fR" 4
.IX Item "Syntax: max_dives( [integer] )"
When called without any arguments, this method returns an integer reflecting
the current number of times the File::Util object will dive into the
subdirectories it discovers when recursively listing directory contents from
a call to \f(CW\*(C`File::Util::list_dir()\*(C'\fR.  The default is 1000.  If the number is
exceeded, the File::Util object will fail with a diagnostic error message.
.Sp
When called with an argument, it sets the maximum number of times a File::Util
object will recurse into subdirectories before failing with an error message.
.Sp
This method can only be called with a numeric integer value.  Passing a bad
argument to this method will cause it to fail with an error message.
.Sp
\&\fI(see list_dir)\fR
.Sp
This is an autoloaded method.
.ie n .SS """needs_binmode"""
.el .SS "\f(CWneeds_binmode\fP"
.IX Subsection "needs_binmode"
.ie n .IP "\fISyntax:\fR ""needs_binmode""" 4
.el .IP "\fISyntax:\fR \f(CWneeds_binmode\fR" 4
.IX Item "Syntax: needs_binmode"
Returns 1 if the machine on which the code is running requires that \f(CW\*(C`binmode()\*(C'\fR
\&\fI(a built-in function)\fR be called on open file handles, or returns 0 if not.
\&\fI(see \*(L"binmode\*(R" in perlfunc.)\fR  This is an autoloaded method.  This is a constant
subroutine.  It accepts no arguments and will always return the same value for
the system on which it is executed.
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
.ie n .IP "\fISyntax:\fR ""new( [\*(Aqparameters\*(Aq => \*(Aqvalues\*(Aq, etc], [\-\-flags] )""" 4
.el .IP "\fISyntax:\fR \f(CWnew( [\*(Aqparameters\*(Aq => \*(Aqvalues\*(Aq, etc], [\-\-flags] )\fR" 4
.IX Item "Syntax: new( [parameters => values, etc], [--flags] )"
This is the File::Util constructor method.  eg\- It returns a new File::Util
object reference when you call it.  It recognizes various parameters and flags
that govern the behavior of the new File::Util object.
.RS 4
.ie n .IP "\fBParameters accepted by \fB""new()""\fB\fR" 4
.el .IP "\fBParameters accepted by \f(CBnew()\fB\fR" 4
.IX Item "Parameters accepted by new()"
.RS 4
.PD 0
.IP "use_flock   => true/false value" 4
.IX Item "use_flock   => true/false value"
.PD
Optionally specify this option to the \f(CW\*(C`File::Util::new\*(C'\fR method instruct the
new object that it should never attempt to use \f(CW\*(C`flock()\*(C'\fR in it's I/O
operations.  The default is to use \f(CW\*(C`flock()\*(C'\fR when available on your system.
Specify this option with a true or false value, true to use \f(CW\*(C`flock()\*(C'\fR, false
to not use it.
.IP "readlimit   => positive integer" 4
.IX Item "readlimit   => positive integer"
Optionally specify this option to the File::Util::new method to instruct the
new object that it should never attempt to open and read in a file greater
than the number of bytes you specify.  Obviously this argument can only be
a numeric integer value, otherwise it will be silently ignored.  The default
readlimit for File::Util objects is 52428800 bytes (50 megabytes).
.IP "max_dives   => positive integer" 4
.IX Item "max_dives   => positive integer"
Optionally specify this option to the File::Util::new method to instruct the
new object to set the maximum number of times it will recurse into
subdirectories while performing directory listing operations before failing
with an error message.  This argument can only be a numeric integer value,
otherwise it will be silently ignored.
.RE
.RS 4
.RE
.ie n .IP "\fBFlags accepted by \fB""new()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBnew()\fB\fR" 4
.IX Item "Flags accepted by new()"
.RS 4
.PD 0
.ie n .IP """\-\-fatals\-as\-warning""" 4
.el .IP "\f(CW\-\-fatals\-as\-warning\fR" 4
.IX Item "--fatals-as-warning"
.PD
Directive to instruct the new File::Util object that when any call to one of
its methods results in a fatal error that it should return \fB\f(CB\*(C`undef\*(C'\fB\fR
instead of the value(s) that would normally be returned by the call, and to
send an error message to \s-1STDERR\s0 as well.
.ie n .IP """\-\-fatals\-as\-status""" 4
.el .IP "\f(CW\-\-fatals\-as\-status\fR" 4
.IX Item "--fatals-as-status"
Directive to instruct the new File::Util object that when any call to one of
its methods results in a fatal error that it should return \fB\f(CB\*(C`undef\*(C'\fB\fR
instead of the value(s) that would normally be returned by the call.
.ie n .IP """\-\-fatals\-as\-errmsg""" 4
.el .IP "\f(CW\-\-fatals\-as\-errmsg\fR" 4
.IX Item "--fatals-as-errmsg"
Directive to instruct the new File::Util object that when any call to one of
its methods results in a fatal error that it should return \fBan error message\fR
instead of the value(s) that would normally be returned by the call.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .SS """open_handle"""
.el .SS "\f(CWopen_handle\fP"
.IX Subsection "open_handle"
.ie n .IP "\fISyntax:\fR ""open_handle(\*(Aqfile\*(Aq => [file name], [\-\-opts])""" 4
.el .IP "\fISyntax:\fR \f(CWopen_handle(\*(Aqfile\*(Aq => [file name], [\-\-opts])\fR" 4
.IX Item "Syntax: open_handle(file => [file name], [--opts])"
.PD 0
.ie n .IP "\fI\s-1OR:\s0\fR ""open_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWopen_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], [\-\-opts])\fR" 4
.IX Item "OR: open_handle(file => [file name], mode => [mode], [--opts])"
.ie n .IP "\fI\s-1OR:\s0\fR ""open_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWopen_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], [\-\-opts])\fR" 4
.IX Item "OR: open_handle(file => [file name], mode => [mode], bitmask => [bitmask], [--opts])"
.ie n .IP "\fI\s-1OR:\s0\fR ""open_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], \*(Aqdbitmask\*(Aq => [bitmask], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWopen_handle(\*(Aqfile\*(Aq => [file name], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], \*(Aqdbitmask\*(Aq => [bitmask], [\-\-opts])\fR" 4
.IX Item "OR: open_handle(file => [file name], mode => [mode], bitmask => [bitmask], dbitmask => [bitmask], [--opts])"
.PD
Attempts to get a unique open file handle on [file name] in [mode] mode.
Returns the file handle if successful or generates a fatal error with a
diagnostic message if the operation fails.
.Sp
You will need to remember to call \f(CW\*(C`close()\*(C'\fR on the filehandle yourself, at
your own discretion.  Leaving filehandles open is not a good practice, and
is not recommended.  \fIsee \*(L"close\*(R" in perlfunc\fR).
.Sp
Once you have the file handle you would use it as you would use any file handle.
Remember that unless you specifically turn file locking off when the
\&\f(CW\*(C`File::Util\*(C'\fR object is created (see \fI(see new)\fR or by using the
\&\f(CW\*(C`\-\-no\-lock\*(C'\fR flag when calling \f(CW\*(C`open_handle\*(C'\fR, that file locking is going to
automagically be handled for you behind the scenes, so long as your \s-1OS\s0 supports
file locking of any kind at all.  Great!  It's very convenient for you to not
have to worry about portably taking care of file locking between one
application and the next; by using \f(CW\*(C`File::Util\*(C'\fR in all of them, you know
that you're covered.
.Sp
A slight inconvenience for the price of a larger set of features (compare
write_file to this method)
\&\fI\f(BIyou will have to release the file lock on the open handle yourself.\fI\fR
\&\f(CW\*(C`File::Util\*(C'\fR can't manage it for you anymore once it hands the handle over
to you.  At that point, it's all yours.  In order to release the file lock
on your file handle, call \fIunlock_open_handle()\fR on it.
Otherwise the lock will remain for the life of your process.  If you don't
want to use the free portable file locking, remember the \f(CW\*(C`\-\-no\-lock\*(C'\fR flag,
which will turn off file locking for your open handle.  Seldom, however, should
you ever opt to not use file locking unless you really know what you are doing.
.Sp
If the file does not yet exist it will be created, and it will be created
with a bitmask of [bitmask] if you specify a file creation bitmask using
the \f(CW\*(Aqbitmask\*(Aq\fR option, otherwise the file will be created with the default
bitmask of 0777.
.Sp
If specified, the bitmask must be supplied in the form required by the
native perl umask function.  \fIsee \*(L"umask\*(R" in perlfunc\fR for more information
about the format of the bitmask argument.  If the file [file name] already
exists then the bitmask argument has no effect and is silently ignored.
.Sp
Any non-existent directories in the path preceeding the actual file name will
be automatically (and silently \- no warnings) created for you and any new
directories will be created with a bitmask of [dbitmask], provided you specify
a directory creation bitmask with the \f(CW\*(Aqdbitmask\*(Aq\fR option.
.Sp
If specified, the directory creation bitmask [dbitmask] must be supplied in
the form required by the native perl umask function.
.Sp
If there is an error while trying to create any preceeding directories, the
failure results in a fatal error with a diagnostic error message.  If all
directories preceeding the name of the file already exist, the dbitmask
argument has no effect and is silently ignored.
.IP "\fBNative Perl open modes\fR" 4
.IX Item "Native Perl open modes"
The default behavior of \f(CW\*(C`open_handle()\*(C'\fR is to open file handles using Perl's
native \f(CW\*(C`open()\*(C'\fR \fI(see \*(L"open\*(R" in perlfunc)\fR.  Unless you use the
\&\f(CW\*(C`\-\-use\-sysopen\*(C'\fR flag, the following modes and only these modes are valid.
.RS 4
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqread\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqread\*(Aq\fR" 4
.IX Item "mode => read"
[file name] is opened in read-only mode.  If the file does not yet exist then
a fatal error will occur with a diagnostic help message to help you troubleshoot
the problem.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqwrite\*(Aq (this is the default mode)" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqwrite\*(Aq\fR (this is the default mode)" 4
.IX Item "mode => write (this is the default mode)"
[file name] is created if it does not yet exist.  If [file name] already exists
then its contents are overwritten with the new content provided.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqappend\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqappend\*(Aq\fR" 4
.IX Item "mode => append"
[file name] is created if it does not yet exist.  If [file name] already exists
its contents will be preserved and the new content you provide will be appended
to the end of the file.
.RE
.RS 4
.RE
.ie n .IP "\fBSystem level open modes (""open a la C"")\fR" 4
.el .IP "\fBSystem level open modes (``open a la C'')\fR" 4
.IX Item "System level open modes (open a la C)"
Optionally you can ask \f(CW\*(C`File::Util\*(C'\fR to open your handle using \f(CW\*(C`CORE::sysopen\*(C'\fR
instead of using the native Perl \f(CW\*(C`CORE::open()\*(C'\fR.  This is accomplished by
passing in the \f(CW\*(C`\-\-use\-sysopen\*(C'\fR flag.  Using this feature opens up more
possibilities as far as the open modes you can choose from, but also carries
with it a few caveats so you have to be careful, just as you'd have to be a
little more careful when using \f(CW\*(C`sysopen()\*(C'\fR anyway.
.Sp
Specifically you need to remember that when using this feature you must \s-1NOT\s0
mix different types of I/O when working with the file handle.  You can't go
opening file handles with \f(CW\*(C`sysopen()\*(C'\fR and print to them as you normally
would print to a file handle.  You have to use \f(CW\*(C`syswrite()\*(C'\fR instead.  The
same applies here.  If you get a \f(CW\*(C`sysopen()\*(C'\fR'd filehandle from \f(CW\*(C`open_handle()\*(C'\fR
it is imperative that you use \f(CW\*(C`syswrite()\*(C'\fR on it.  You'll also need to use
\&\f(CW\*(C`sysseek()\*(C'\fR and other type of \f(CW\*(C`sys\*(C'\fR* commands on the filehandle instead of
their native Perl equivalents.
.Sp
(see \*(L"sysopen\*(R" in perlfunc, \*(L"syswrite\*(R" in perlfunc, \*(L"sysseek\*(R" in perlfunc,
\&\*(L"sysread\*(R" in perlfunc)
.Sp
That said, here are the different modes you can choose from to get a file handle
when using the \f(CW\*(C`\-\-use\-sysopen\*(C'\fR flag.  Remember that these won't work unless
you use the flag, and will generate an error if you try using them without it.
The standard \f(CW\*(Aqread\*(Aq\fR, \f(CW\*(Aqwrite\*(Aq\fR, and \f(CW\*(Aqappend\*(Aq\fR modes are already available
to you by default.  These are the extended modes:
.RS 4
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqrwcreate\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqrwcreate\*(Aq\fR" 4
.IX Item "mode => rwcreate"
[file name] is opened in read-write mode, and will be created for you if it
does not already exist.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqrwupdate\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqrwupdate\*(Aq\fR" 4
.IX Item "mode => rwupdate"
[file name] is opened for you in read-write mode, but must already exist.  If
it does not exist, a fatal error will result and a diagnostic help message will
be printed out to help you troubleshoot the problem.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqrwclobber\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqrwclobber\*(Aq\fR" 4
.IX Item "mode => rwclobber"
[file name] is opened for you in read-write mode.  If the file already exists
it's contents will be \*(L"clobbered\*(R" or wiped out.  The file will then be empty
and you will be working with the then-truncated file.  This can not be undone.
Once you call \f(CW\*(C`open_handle()\*(C'\fR using this option, your file \s-1WILL\s0 be wiped out.
If the file does not exist yet, it will be created for you.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqrwappend\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqrwappend\*(Aq\fR" 4
.IX Item "mode => rwappend"
[file name] will be opened for you in read-write mode ready for appending.  The
file's contents will not be wiped out; they will be preserved and you will be
working in append fashion.  You will only be able to write starting at the end
of the file.  If the file does not exist, it will be created for you.
.RE
.RS 4
.Sp
Remember to use \f(CW\*(C`sysread()\*(C'\fR and not plain \f(CW\*(C`read()\*(C'\fR when reading those
\&\f(CW\*(C`sysopen()\*(C'\fR'd filehandles!
.RE
.ie n .IP "\fBFlags accepted by \fB""open_handle()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBopen_handle()\fB\fR" 4
.IX Item "Flags accepted by open_handle()"
.RS 4
.PD 0
.ie n .IP """\-\-binmode""" 4
.el .IP "\f(CW\-\-binmode\fR" 4
.IX Item "--binmode"
.PD
Makes sure that \fICORE::binmode()\fR is called on the filehandle when your content
is written.  This is useful for times when the content you are writing to file
is a binary stream. \fI(see \*(L"binmode\*(R" in perlfunc)\fR.
.ie n .IP """\-\-no\-lock""" 4
.el .IP "\f(CW\-\-no\-lock\fR" 4
.IX Item "--no-lock"
By default this method will attempt to get a lock on the file while it is
being read, following whatever rules are in place for the flock policy
established either by default (implicitly) or changed by you in a call to
\&\fIFile::Util::flock_rules()\fR
\&\fI(see the \fIflock_rules()\fI) entry below\fR.
.Sp
This method will not try to get a lock on the file if the File::Util object was
created with the option \f(CW\*(C`\-\-no\-lock\*(C'\fR or if this method is called with the
option \f(CW\*(C`\-\-no\-lock\*(C'\fR.
.ie n .IP """\-\-use\-sysopen""" 4
.el .IP "\f(CW\-\-use\-sysopen\fR" 4
.IX Item "--use-sysopen"
Instead of opening the file using Perl's native \f(CW\*(C`open()\*(C'\fR command, \f(CW\*(C`File::Util\*(C'\fR
will open the file with the \f(CW\*(C`sysopen()\*(C'\fR command.  You will have to remember
that your filehandle is a \f(CW\*(C`sysopen()\*(C'\fR'd one, and that you will not be able to
use native Perl I/O functions on it.  You will have to use the \f(CW\*(C`sys\*(C'\fR*
equivalents.  See perlopentut for a more in-depth explanation of why you
can't mix native Perl I/O with system I/O.
.RE
.RS 4
.Sp
This is an autoloaded method.
.RE
.ie n .SS """readlimit"""
.el .SS "\f(CWreadlimit\fP"
.IX Subsection "readlimit"
.ie n .IP "\fISyntax:\fR ""readlimit( [integer] )""" 4
.el .IP "\fISyntax:\fR \f(CWreadlimit( [integer] )\fR" 4
.IX Item "Syntax: readlimit( [integer] )"
By default, the largest size file that File::Util will read into memory and
return via the load_file is 52428800 byptes (50 megabytes).
.Sp
This value can be modified by calling this method with an integer value
reflecting the new limit you want to impose, in bytes.  For example, if you want
to set the limit to 10 megabytes, call the method with an argument of 10485760.
.Sp
If this method is called without an argument, the read limit currently in force
for the File::Util object will be returned.
.Sp
This is an autoloaded method.
.ie n .SS """return_path"""
.el .SS "\f(CWreturn_path\fP"
.IX Subsection "return_path"
.ie n .IP "\fISyntax:\fR ""return_path( [string] )""" 4
.el .IP "\fISyntax:\fR \f(CWreturn_path( [string] )\fR" 4
.IX Item "Syntax: return_path( [string] )"
Takes the file path from the file name provided and returns it such that
\&\*(L"/foo/bar/baz.txt\*(R" is returned \*(L"/foo/bar\*(R".
.Sp
This is an autoloaded method.
.ie n .SS """size"""
.el .SS "\f(CWsize\fP"
.IX Subsection "size"
.ie n .IP "\fISyntax:\fR ""size( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWsize( [file name] )\fR" 4
.IX Item "Syntax: size( [file name] )"
Returns the file size of [file name] in bytes.  Returns \f(CW0\fR if the file is
empty, returns \f(CW\*(C`undef\*(C'\fR if the file does not exist.
.Sp
This is an autoloaded method.
.ie n .SS """strip_path"""
.el .SS "\f(CWstrip_path\fP"
.IX Subsection "strip_path"
.ie n .IP "\fISyntax:\fR ""strip_path( [string] )""" 4
.el .IP "\fISyntax:\fR \f(CWstrip_path( [string] )\fR" 4
.IX Item "Syntax: strip_path( [string] )"
Strips the file path from the file name provided and returns the file name only.
.ie n .SS """touch"""
.el .SS "\f(CWtouch\fP"
.IX Subsection "touch"
.ie n .IP "\fISyntax:\fR ""touch( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWtouch( [file name] )\fR" 4
.IX Item "Syntax: touch( [file name] )"
Behaves like the *nix \f(CW\*(C`touch\*(C'\fR command; Updates the access and modification
times of the specified file to the current time.  If the file does not exist,
\&\f(CW\*(C`File::Util\*(C'\fR tries to create it empty.  This method will fail with a fatal
error if system permissions deny alterations to or creation of the file.
.Sp
Returns \f(CW1\fR if successful.  If unsuccessful, fails with a descriptive error
message about what went wrong.
.Sp
This is an autoloaded method.
.ie n .SS """trunc"""
.el .SS "\f(CWtrunc\fP"
.IX Subsection "trunc"
.ie n .IP "\fISyntax:\fR ""trunc( [file name] )""" 4
.el .IP "\fISyntax:\fR \f(CWtrunc( [file name] )\fR" 4
.IX Item "Syntax: trunc( [file name] )"
Truncates [file name] (i.e.\- wipes out, or \*(L"clobbers\*(R" the contents of the
specified file.  Returns \f(CW1\fR if successful.  If unsuccessful, fails with a
descriptive error message about what went wrong.
.Sp
This is an autoloaded method.
.ie n .SS """unlock_open_handle"""
.el .SS "\f(CWunlock_open_handle\fP"
.IX Subsection "unlock_open_handle"
.ie n .IP "\fISyntax:\fR ""unlock_open_handle([file handle])""" 4
.el .IP "\fISyntax:\fR \f(CWunlock_open_handle([file handle])\fR" 4
.IX Item "Syntax: unlock_open_handle([file handle])"
Release the flock on a file handle you opened with open_handle.
.Sp
Returns true on success, false on failure.  Will not raise a fatal error if
the unlock operation fails.  You can capture the return value from your call
to this method and \f(CW\*(C`die()\*(C'\fR if you so desire.  Failure is not ever very likely,
or \f(CW\*(C`File::Util\*(C'\fR wouldn't have been able to get a portable lock on the file
in the first place.
.Sp
If \f(CW\*(C`File::Util\*(C'\fR wasn't able to ever lock the file due to limitations of your
operating system, a call to this method will return a true value.
.Sp
If file locking has been disabled on the file handle via the \f(CW\*(C`\-\-no\-lock\*(C'\fR flag
at the time open_handle was called, or if file locking was
disabled using the use_flock method, or if file locking was
disabled on the entire \f(CW\*(C`File::Util\*(C'\fR object at the time of its creation
\&\fI(see \fInew()\fI)\fR, calling this method will have no effect and a true value
will be returned.
.Sp
This is an autoloaded method, due to open_handle also being
autoloaded.
.ie n .SS """use_flock"""
.el .SS "\f(CWuse_flock\fP"
.IX Subsection "use_flock"
.ie n .IP "\fISyntax:\fR ""use_flock( [true / false value] )""" 4
.el .IP "\fISyntax:\fR \f(CWuse_flock( [true / false value] )\fR" 4
.IX Item "Syntax: use_flock( [true / false value] )"
When called without any arguments, this method returns a true or false value
to reflect the current use of \f(CW\*(C`flock()\*(C'\fR within the File::Util object.
.Sp
When called with a true or false value as its single argument, this method
will tell the File::Util object whether or not it should attempt to use
\&\f(CW\*(C`flock()\*(C'\fR in its I/O operations.  A true value indicates that the File::Util
object will use \f(CW\*(C`flock()\*(C'\fR if available, a false value indicates that it will
not.  The default is to use \f(CW\*(C`flock()\*(C'\fR when available on your system.
.Sp
This is an autoloaded method.
.ie n .SS """write_file"""
.el .SS "\f(CWwrite_file\fP"
.IX Subsection "write_file"
.ie n .IP "\fISyntax:\fR ""write_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], [\-\-opts])""" 4
.el .IP "\fISyntax:\fR \f(CWwrite_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], [\-\-opts])\fR" 4
.IX Item "Syntax: write_file(file => [file name], content => [string], [--opts])"
.PD 0
.ie n .IP "\fI\s-1OR:\s0\fR ""write_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWwrite_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], [\-\-opts])\fR" 4
.IX Item "OR: write_file(file => [file name], content => [string], mode => [mode], [--opts])"
.ie n .IP "\fI\s-1OR:\s0\fR ""write_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWwrite_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], [\-\-opts])\fR" 4
.IX Item "OR: write_file(file => [file name], content => [string], mode => [mode], bitmask => [bitmask], [--opts])"
.ie n .IP "\fI\s-1OR:\s0\fR ""write_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], \*(Aqdbitmask\*(Aq => [bitmask], [\-\-opts])""" 4
.el .IP "\fI\s-1OR:\s0\fR \f(CWwrite_file(\*(Aqfile\*(Aq => [file name], \*(Aqcontent\*(Aq => [string], \*(Aqmode\*(Aq => [mode], \*(Aqbitmask\*(Aq => [bitmask], \*(Aqdbitmask\*(Aq => [bitmask], [\-\-opts])\fR" 4
.IX Item "OR: write_file(file => [file name], content => [string], mode => [mode], bitmask => [bitmask], dbitmask => [bitmask], [--opts])"
.PD
Attempts to write [string] to [file name] in mode [mode].  If the file does
not yet exist it will be created, and it will be created with a bitmask of
[bitmask] if you specify a file creation bitmask using the \f(CW\*(Aqbitmask\*(Aq\fR option,
otherwise the file will be created with the default bitmask of 0777.
.Sp
[string] should be a string or a scalar variable containing a string.  The
string can be any type of data, such as a binary stream, or ascii text with
line breaks, etc.  Be sure to pass in the \f(CW\*(C`\-\-binmode\*(C'\fR flag for binary streams.
.Sp
If specified, the bitmask must be supplied in the form required by the
native perl umask function.  \fIsee \*(L"umask\*(R" in perlfunc\fR for more information
about the format of the bitmask argument.  If the file [file name] already
exists then the bitmask argument has no effect and is silently ignored.
.Sp
Returns 1 if successful or fails (fatal) with an error message if not
successful.
.Sp
Any non-existent directories in the path preceeding the actual file name will
be automatically (and silently \- no warnings) created for you and any new
directories will be created with a bitmask of [dbitmask], provided you specify
a directory creation bitmask with the \f(CW\*(Aqdbitmask\*(Aq\fR option.
.Sp
If specified, the directory creation bitmask [dbitmask] must be supplied in
the form required by the native perl umask function.
.Sp
If there is an error while trying to create any preceeding directories, the
failure results in a fatal error with a diagnostic error message.  If all
directories preceeding the name of the file already exist, the dbitmask
argument has no effect and is silently ignored.
.RS 4
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqwrite\*(Aq (this is the default mode)" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqwrite\*(Aq\fR (this is the default mode)" 4
.IX Item "mode => write (this is the default mode)"
[file name] is created if it does not yet exist.  If [file name] already exists
then its contents are overwritten with the new content provided.
.ie n .IP "\*(Aqmode\*(Aq => \*(Aqappend\*(Aq" 4
.el .IP "\f(CW\*(Aqmode\*(Aq => \*(Aqappend\*(Aq\fR" 4
.IX Item "mode => append"
[file name] is created if it does not yet exist.  If [file name] already exists
its contents will be preserved and the new content you provide will be appended
to the end of the file.
.RE
.RS 4
.ie n .IP "\fBFlags accepted by \fB""write_file()""\fB\fR" 4
.el .IP "\fBFlags accepted by \f(CBwrite_file()\fB\fR" 4
.IX Item "Flags accepted by write_file()"
.RS 4
.PD 0
.ie n .IP """\-\-binmode""" 4
.el .IP "\f(CW\-\-binmode\fR" 4
.IX Item "--binmode"
.PD
Makes sure that \fICORE::binmode()\fR is called on the filehandle when your content
is written.  This is useful for times when the content you are writing to file
is a binary stream.
.ie n .IP """\-\-empty\-writes\-OK""" 4
.el .IP "\f(CW\-\-empty\-writes\-OK\fR" 4
.IX Item "--empty-writes-OK"
Allows you to call this method without providing a content argument (it lets
you create an empty file without warning you or failing.  Be advised that
if you use this flag, it will have the same effect as truncating a file
that already has content in it (i.e.\- it will \*(L"clobber\*(R" non-empty files)
.ie n .IP """\-\-no\-lock""" 4
.el .IP "\f(CW\-\-no\-lock\fR" 4
.IX Item "--no-lock"
By default this method will attempt to get a lock on the file while it is
being read, following whatever rules are in place for the flock policy
established either by default (implicitly) or changed by you in a call to
\&\fIFile::Util::flock_rules()\fR
\&\fI(see the \fIflock_rules()\fI) entry below\fR.
.Sp
This method will not try to get a lock on the file if the File::Util object was
created with the option \f(CW\*(C`\-\-no\-lock\*(C'\fR or if this method is called with the
option \f(CW\*(C`\-\-no\-lock\*(C'\fR.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .SS """valid_filename"""
.el .SS "\f(CWvalid_filename\fP"
.IX Subsection "valid_filename"
.ie n .IP "\fISyntax:\fR ""valid_filename( [string] )""" 4
.el .IP "\fISyntax:\fR \f(CWvalid_filename( [string] )\fR" 4
.IX Item "Syntax: valid_filename( [string] )"
For the given string, returns 1 if the string is a legal file name for the
system on which the program is running, or returns undef if it is not.  This
method does not test for the validity of file paths!  It tests for the validity
of file names only.  (It is used internally to check beforehand if a file name
is useable when creating new files, but is also a public method available for
external use.)
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.ie n .SS """NL"""
.el .SS "\f(CWNL\fP"
.IX Subsection "NL"
.ie n .IP "\fISyntax:\fR ""NL""" 4
.el .IP "\fISyntax:\fR \f(CWNL\fR" 4
.IX Item "Syntax: NL"
Returns the correct new line character (or character sequence) for the system
on which your program runs.
.ie n .SS """SL"""
.el .SS "\f(CWSL\fP"
.IX Subsection "SL"
.ie n .IP "\fISyntax:\fR ""SL""" 4
.el .IP "\fISyntax:\fR \f(CWSL\fR" 4
.IX Item "Syntax: SL"
Returns the correct directory path seperator for the system on which your
program runs.
.ie n .SS """OS"""
.el .SS "\f(CWOS\fP"
.IX Subsection "OS"
.ie n .IP "\fISyntax:\fR ""OS""" 4
.el .IP "\fISyntax:\fR \f(CWOS\fR" 4
.IX Item "Syntax: OS"
Returns the File::Util keyword for the operating system \s-1FAMILY\s0 it detected.  The
keyword for the detected operating system will be one of the following, derived
from the conents of \f(CW$^O\fR, or if \f(CW$^O\fR can not be found, from the contents of
\&\f(CW$Config::Config{osname}\fR (see native Config library), or if that
doesn't contain a recognizable value, finally falls back to \f(CW\*(C`UNIX\*(C'\fR.
.Sp
Generally speaking, Linux operating systems are going to be detected as \f(CW\*(C`UNIX\*(C'\fR.
This isn't a bug.  The \s-1OS\s0 \s-1FAMILY\s0 to which it belongs uses \f(CW\*(C`UNIX\*(C'\fR style
filesystem conventions and line endings, which are the relevant things to
file handling operations.
.RS 4
.IP "\s-1UNIX\s0" 4
.IX Item "UNIX"
Specifics: \s-1OS\s0 name =~ /^(?:darwin|bsdos)/i
.IP "\s-1CYGWIN\s0" 4
.IX Item "CYGWIN"
Specifics: \s-1OS\s0 name =~ /^cygwin/i
.IP "\s-1WINDOWS\s0" 4
.IX Item "WINDOWS"
Specifics: \s-1OS\s0 name =~ /^MSWin/i
.IP "\s-1VMS\s0" 4
.IX Item "VMS"
Specifics: \s-1OS\s0 name =~ /^vms/i
.IP "\s-1DOS\s0" 4
.IX Item "DOS"
Specifics: \s-1OS\s0 name =~ /^dos/i
.IP "\s-1MACINTOSH\s0" 4
.IX Item "MACINTOSH"
Specifics: \s-1OS\s0 name =~ /^MacOS/i
.IP "\s-1EPOC\s0" 4
.IX Item "EPOC"
Specifics: \s-1OS\s0 name =~ /^epoc/i
.IP "\s-1OS2\s0" 4
.IX Item "OS2"
Specifics: \s-1OS\s0 name =~ /^os2/i
.RE
.RS 4
.RE
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.IP "Perl 5.006 or better" 4
.IX Item "Perl 5.006 or better"
.PD 0
.IP "Class::OOorNO        v0.01_1 or better" 4
.IX Item "Class::OOorNO        v0.01_1 or better"
.IP "Exception::Handler   v1.00_0 or better" 4
.IX Item "Exception::Handler   v1.00_0 or better"
.PD
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Get the names of all files and subdirectories in a directory"
.IX Subsection "Get the names of all files and subdirectories in a directory"
.Vb 4
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   # option \-\-no\-fsdots excludes "." and ".." from the list
\&   my(@dirs_and_files) = $f\->list_dir(\*(Aq/foo\*(Aq,\*(Aq\-\-no\-fsdots\*(Aq);
.Ve
.SS "Get the names of all files and subdirectories in a directory, recursively"
.IX Subsection "Get the names of all files and subdirectories in a directory, recursively"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my(@dirs_and_files) = $f\->list_dir(\*(Aq/foo\*(Aq,\*(Aq\-\-recurse\*(Aq);
.Ve
.SS "Get the names of all files (no subdirectories) in a directory"
.IX Subsection "Get the names of all files (no subdirectories) in a directory"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my(@dirs_and_files) = $f\->list_dir(\*(Aq/foo\*(Aq,\*(Aq\-\-files\-only\*(Aq);
.Ve
.SS "Get the names of all subdirectories (no files) in a directory"
.IX Subsection "Get the names of all subdirectories (no files) in a directory"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my(@dirs_and_files) = $f\->list_dir(\*(Aq/foo\*(Aq,\*(Aq\-\-dirs\-only\*(Aq);
.Ve
.SS "Get the number of files and subdirectories in a directory"
.IX Subsection "Get the number of files and subdirectories in a directory"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my(@dirs_and_files) = $f\->list_dir(\*(Aq/foo\*(Aq, qw/\-\-no\-fsdots \-\-count\-only/);
.Ve
.SS "Get the names of files and subdirs in a directory as seperate array refs"
.IX Subsection "Get the names of files and subdirs in a directory as seperate array refs"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($dirs,$files) = $f\->list_dir(\*(Aq/foo\*(Aq, \*(Aq\-\-as\-ref\*(Aq);
\&
\&      \-OR\-
\&   my($dirs,$files) = $f\->list_dir(\*(Aq.\*(Aq, qw/\-\-dirs\-as\-ref \-\-files\-as\-ref/);
.Ve
.SS "Get the contents of a file in a string"
.IX Subsection "Get the contents of a file in a string"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($contents) = $f\->load_file(\*(Aqfilename\*(Aq);
.Ve
.SS "Get the contents of a file in an array of lines in the file"
.IX Subsection "Get the contents of a file in an array of lines in the file"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my(@contents) = $f\->load_file(\*(Aqfilename\*(Aq,\*(Aq\-\-as\-lines\*(Aq);
.Ve
.SS "Get an open file handle for reading"
.IX Subsection "Get an open file handle for reading"
.Vb 6
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($FH_REF) = $f\->open_handle(
\&      \*(Aqfile\*(Aq => \*(Aqnew_filename\*(Aq,
\&      \*(Aqmode\*(Aq => \*(Aqread\*(Aq
\&   );
.Ve
.SS "Get an open file handle for writing"
.IX Subsection "Get an open file handle for writing"
.Vb 6
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($FH_REF) = $f\->open_handle(
\&      \*(Aqfile\*(Aq => \*(Aqnew_filename\*(Aq,
\&      \*(Aqmode\*(Aq => \*(Aqwrite\*(Aq
\&   );
.Ve
.SS "Write to a new or existing file"
.IX Subsection "Write to a new or existing file"
.Vb 4
\&   use File::Util;
\&   my($content) = \*(AqPathelogically Eclectic Rubbish Lister\*(Aq;
\&   my($f) = File::Util\->new();
\&   $f\->write_file(\*(Aqfile\*(Aq => \*(Aqa new file.txt\*(Aq, \*(Aqcontent\*(Aq => $content);
\&
\&   # optionally specify a creation bitmask when writing to a new file
\&   $f\->write_file(
\&      \*(Aqfile\*(Aq    => \*(Aqa new file.txt\*(Aq,
\&      \*(Aqbitmask\*(Aq => 0777,
\&      \*(Aqcontent\*(Aq => $content
\&   );
.Ve
.SS "Append to a new or existing file"
.IX Subsection "Append to a new or existing file"
.Vb 8
\&   use File::Util;
\&   my($content) = \*(AqPathelogically Eclectic Rubbish Lister\*(Aq;
\&   my($f) = File::Util\->new();
\&   $f\->write_file(
\&      \*(Aqfile\*(Aq => \*(Aqa new file.txt\*(Aq,
\&      \*(Aqmode\*(Aq => \*(Aqappend\*(Aq,
\&      \*(Aqcontent\*(Aq => $content
\&   );
.Ve
.SS "Determine if something is a valid file name"
.IX Subsection "Determine if something is a valid file name"
.Vb 1
\&   use File::Util qw( valid_filename );
\&
\&   if (valid_filename("foo?+/bar~@/#baz.txt")) {
\&      print "file name is valid"
\&   else {
\&      print "file name contains illegal characters"
\&   }
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->valid_filename("foo?+/bar~@/#baz.txt") ? \*(Aqok\*(Aq : \*(Aqbad\*(Aq;
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->valid_filename("foo?+/bar~@/#baz.txt") ? \*(Aqok\*(Aq : \*(Aqbad\*(Aq;
.Ve
.SS "Get the number of lines in a file"
.IX Subsection "Get the number of lines in a file"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($linecount) = $f\->line_count(\*(Aqfoo.txt\*(Aq);
.Ve
.SS "Strip the path from a file name"
.IX Subsection "Strip the path from a file name"
.Vb 2
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&
\&   # On Windows
\&   #  (prints "hosts")
\&   my($path) = $f\->strip_path(\*(AqC:\eWINDOWS\esystem32\edrivers\eetc\ehosts\*(Aq);
\&
\&   # On Linux/Unix
\&   #  (prints "perl")
\&   print $f\->strip_path(\*(Aq/usr/bin/perl\*(Aq);
\&
\&   # On a Mac
\&   #  (prints "baz")
\&   print $f\->strip_path(\*(Aqfoo:bar:baz\*(Aq);
.Ve
.SS "Get the path preceeding a file name"
.IX Subsection "Get the path preceeding a file name"
.Vb 2
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&
\&   # On Windows
\&   #  (prints "C:\eWINDOWS\esystem32\edrivers\eetc")
\&   my($path) = $f\->return_path(\*(AqC:\eWINDOWS\esystem32\edrivers\eetc\ehosts\*(Aq);
\&
\&   # On Linux/Unix
\&   #  (prints "/usr/bin")
\&   print $f\->return_path(\*(Aq/usr/bin/perl\*(Aq);
\&
\&   # On a Mac
\&   #  (prints "foo:bar")
\&   print $f\->return_path(\*(Aqfoo:bar:baz\*(Aq);
.Ve
.SS "Find out if the host system can use flock"
.IX Subsection "Find out if the host system can use flock"
.Vb 2
\&   use File::Util qw( can_flock );
\&   print can_flock;
\&
\&      \-OR\-
\&   print File::Util\->can_flock;
\&
\&      \-OR\-
\&   my($f) = File::Util\->new();
\&   print $f\->can_flock;
.Ve
.SS "Find out if the host system needs to call binmode on binary files"
.IX Subsection "Find out if the host system needs to call binmode on binary files"
.Vb 2
\&   use File::Util qw( needs_binmode );
\&   print needs_binmode;
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->needs_binmode;
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->needs_binmode;
.Ve
.SS "Find out if a file can be opened for read (based on file permissions)"
.IX Subsection "Find out if a file can be opened for read (based on file permissions)"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($is_readable) = $f\->can_read(\*(Aqfoo.txt\*(Aq);
.Ve
.SS "Find out if a file can be opened for write (based on file permissions)"
.IX Subsection "Find out if a file can be opened for write (based on file permissions)"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   my($is_writable) = $f\->can_write(\*(Aqfoo.txt\*(Aq);
.Ve
.SS "Escape illegal characters in a potential file name (and its path)"
.IX Subsection "Escape illegal characters in a potential file name (and its path)"
.Vb 2
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&
\&   # prints "C_\|_WINDOWS_system32_drivers_etc_hosts"
\&   print $f\->escape_filename(\*(AqC:\eWINDOWS\esystem32\edrivers\eetc\ehosts\*(Aq);
\&
\&   # prints "baz)_\|_@^"
\&   # (strips the file path from the file name, then escapes it
\&   print $f\->escape_filename(
\&      \*(Aq/foo/bar/baz)?*@^\*(Aq,
\&      \*(Aq\-\-strip\-path\*(Aq
\&   );
\&
\&   # prints "_foo_!_@so~me#illegal$_file&(name"
\&   # (yes, that is a legal filename)
\&   print $f\->escape_filename(q[\efoo*!_@so~me#illegal$*file&(name]);
.Ve
.SS "Find out if the host system uses \s-1EBCDIC\s0"
.IX Subsection "Find out if the host system uses EBCDIC"
.Vb 2
\&   use File::Util qw( ebcdic );
\&   print ebcdic;
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->ebcdic;
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->ebcdic;
.Ve
.SS "Get the type(s) of an existent file"
.IX Subsection "Get the type(s) of an existent file"
.Vb 2
\&   use File::Util qw( file_type );
\&   print file_type(\*(Aqfoo.exe\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->file_type(\*(Aqbar.txt\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->file_type(\*(Aq/dev/null\*(Aq);
.Ve
.SS "Get the bitmask of an existent file"
.IX Subsection "Get the bitmask of an existent file"
.Vb 2
\&   use File::Util qw( bitmask );
\&   print bitmask(\*(Aq/usr/sbin/sendmail\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->bitmask(\*(AqC:\eCOMMAND.COM\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->bitmask(\*(Aq/dev/null\*(Aq);
.Ve
.SS "Get time of creation for a file"
.IX Subsection "Get time of creation for a file"
.Vb 2
\&   use File::Util qw( created );
\&   print scalar localtime created(\*(Aq/usr/bin/exim\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print scalar localtime File::Util\->created(\*(AqC:\eCOMMAND.COM\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print scalar localtime $f\->created(\*(Aq/bin/less\*(Aq);
.Ve
.SS "Get the last access time for a file"
.IX Subsection "Get the last access time for a file"
.Vb 2
\&   use File::Util qw( last_access );
\&   print scalar localtime last_access(\*(Aq/usr/bin/exim\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print scalar localtime File::Util\->last_access(\*(AqC:\eCOMMAND.COM\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print scalar localtime $f\->last_access(\*(Aq/bin/less\*(Aq);
.Ve
.SS "Get the inode change time for a file"
.IX Subsection "Get the inode change time for a file"
.Vb 2
\&   use File::Util qw( last_changed );
\&   print scalar localtime last_changed(\*(Aq/usr/bin/vim\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print scalar localtime File::Util\->last_changed(\*(AqC:\eCOMMAND.COM\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print scalar localtime $f\->last_changed(\*(Aq/bin/cpio\*(Aq);
.Ve
.SS "Get the last modified time for a file"
.IX Subsection "Get the last modified time for a file"
.Vb 2
\&   use File::Util qw( last_modified );
\&   print scalar localtime last_modified(\*(Aq/usr/bin/exim\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   print scalar localtime File::Util\->last_modified(\*(AqC:\eCOMMAND.COM\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print scalar localtime $f\->last_modified(\*(Aq/bin/less\*(Aq);
.Ve
.SS "Make a new directory, recursively if neccessary"
.IX Subsection "Make a new directory, recursively if neccessary"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   $f\->make_dir(\*(Aq/var/tmp/tempfiles/foo/bar/\*(Aq);
\&
\&   # optionally specify a creation bitmask to be used in directory creations
\&   $f\->make_dir(\*(Aq/var/tmp/tempfiles/foo/bar/\*(Aq,0755);
.Ve
.SS "Touch a file"
.IX Subsection "Touch a file"
.Vb 2
\&   use File::Util qw( touch );
\&   touch(\*(Aqsomefile.txt\*(Aq);
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   $f\->touch(\*(Aq/foo/bar/baz.tmp\*(Aq);
.Ve
.SS "Truncate a file"
.IX Subsection "Truncate a file"
.Vb 3
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   $f\->trunc(\*(Aq/wibble/wombat/noot.tmp\*(Aq);
.Ve
.SS "Get the correct path seperator for the host system"
.IX Subsection "Get the correct path seperator for the host system"
.Vb 2
\&   use File::Util qw( SL );
\&   print SL;
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->SL;
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->SL;
.Ve
.SS "Get the correct newline character for the host system"
.IX Subsection "Get the correct newline character for the host system"
.Vb 2
\&   use File::Util qw( NL );
\&   print NL;
\&
\&      \-OR\-
\&   use File::Util;
\&   print File::Util\->NL;
\&
\&      \-OR\-
\&   use File::Util;
\&   my($f) = File::Util\->new();
\&   print $f\->NL;
.Ve
.SH "EXAMPLES (Full Programs)"
.IX Header "EXAMPLES (Full Programs)"
.SS "Batch File Rename"
.IX Subsection "Batch File Rename"
.Vb 2
\&   # Code changes the file suffix of all files in a directory ending in
\&   # *.foo so that they afterward end in *.bar
\&
\&   use strict;
\&   use vars qw( $dir );
\&   use File::Util qw( NL SL );
\&
\&   my($f)      = File::Util\->new();
\&   my($dir)    = \*(Aq../wibble\*(Aq;
\&   my($old)    = \*(Aqfoo\*(Aq;
\&   my($new)    = \*(Aqbar\*(Aq;
\&   my(@files)  = $f\->list_dir($dir, \*(Aq\-\-files\-only\*(Aq);
\&
\&   foreach (@files) {
\&
\&      # don\*(Aqt change the file suffix unless it is *.foo
\&      if ($_ =~ /\e.$old$/o) {
\&
\&         my($newname) = $_; $newname =~ s/\e.$old/\e.$new/;
\&
\&         if (rename($dir . SL . $_, $dir . SL . $newname)) {
\&
\&            print qq[$_ \-> $newname], NL
\&         }
\&         else { warn <<_\|_ERR_\|_ }
\&   Couldn\*(Aqt rename "$_" to "$newname"!
\&   _\|_ERR_\|_
\&      }
\&      else { print <<_\|_NOCHANGE_\|_ }
\&   File retained as "$_"
\&   _\|_NOCHANGE_\|_
\&   }
.Ve
.SS "Recursively remove a directory and all its contents"
.IX Subsection "Recursively remove a directory and all its contents"
.Vb 1
\&   # This code removes a directory and everything in it
\&
\&   use strict; # always
\&
\&   use File::Util qw( NL );
\&
\&   my($f) = File::Util\->new();
\&   my($removedir) = \*(Aq/path/to/directory/youwanttodelete\*(Aq;
\&
\&   my(@gonners) = $f\->list_dir($removedir, \*(Aq\-\-follow\*(Aq);
\&
\&   # remove directory and everything in it
\&   my($a, $b);
\&   foreach (reverse(sort({ length($a) <=> length($b) } @gonners)), $removedir) {
\&      print "Removing $_ ..." . NL;
\&      \-d $_ ? rmdir($_) || die $! : unlink($_) || die $!;
\&    }
\&
\&   print \*(AqDone.  w00T!\*(Aq, NL x 2;
.Ve
.SS "Wrap the lines in a file at 72 columns, then save it"
.IX Subsection "Wrap the lines in a file at 72 columns, then save it"
.Vb 2
\&   # This code opens a file, wraps its lines, and saves the file with
\&   # the newly formatted content
\&
\&   use strict; # always
\&
\&   use File::Util qw( NL );
\&   use Text::Wrap qw( wrap );
\&
\&   $Text::Wrap::columns = 72; # wrap text at this many columns
\&
\&   my($f) = File::Util\->new();
\&   my($textfile) = \*(Aqmyreport.txt\*(Aq; # file to wrap and save
\&
\&   $f\->write_file(
\&     \*(Aqfilename\*(Aq => $textfile,
\&     \*(Aqcontent\*(Aq => wrap(\*(Aq\*(Aq, \*(Aq\*(Aq, $f\->load_file($textfile))
\&   );
\&
\&   print \*(AqDone.\*(Aq, NL x 2;
.Ve
.SS "Read and increment a counter file, then save it"
.IX Subsection "Read and increment a counter file, then save it"
.Vb 2
\&   # This code opens a file, reads a number value, increments it,
\&   # then saves the newly incremented value back to the file
\&
\&   use strict; # always
\&
\&   use File::Util;
\&
\&   my($f) = File::Util\->new();
\&   my($counterfile) = \*(Aqcounter.txt\*(Aq;
\&
\&   # if the counter file doesn\*(Aqt exist, let\*(Aqs make one
\&   if (! $f\->existent($counterfile)) {
\&      $f\->touch($counterfile);
\&   }
\&
\&   my($count) = $f\->load_file($counterfile);
\&
\&   # convert textual number to in\-memory int type, \-this will default
\&   # to a zero if it encounters non\-numerical or empty content
\&   chomp($count); # strip off any trailing lines
\&   $count =~ s/[^[:digit:]]//g; # remove non\-numeric data
\&   $count = 0 if "$count" eq \*(Aq\*(Aq;   # set count to 0 if empty string
\&   $count = int($count); # numberify $count
\&
\&   print \*(AqCount value from file: \*(Aq . $f\->load_file($counterfile), $f\->NL;
\&
\&   $count++; # increment the counter value by 1
\&
\&   # save the incremented count back to the counter file
\&   $f\->write_file( \*(Aqfilename\*(Aq => $counterfile, \*(Aqcontent\*(Aq => $count);
\&
\&   # verify that "it worked"
\&   print \*(AqCount is now: \*(Aq . $f\->load_file($counterfile), $f\->NL;
\&   print \*(AqDone.\*(Aq, $f\->NL x 2;
.Ve
.SS "Batch Search & Replace"
.IX Subsection "Batch Search & Replace"
.Vb 3
\&   # Code does a batch find or search and replace for all files in a given
\&   # directory, recursively or non\-recursively based on choices set forth
\&   # in the code.
\&
\&   use strict;
\&   use File::Util qw( NL SL );
\&
\&   # will get search pattern from file named below
\&   use constant SFILE => \*(Aq./sr/searchfor\*(Aq;
\&
\&   # will get replace pattern from file named below
\&   use constant RFILE => \*(Aq./sr/replacewith\*(Aq;
\&
\&   # will perform batch operation in directory named below
\&   use constant INDIR => \*(Aq/foo/bar/baz\*(Aq;
\&
\&   # specify whether the operation will do a find or a search and replace
\&   use constant RMODE => [qw| read\-only  write |]\->[1];
\&
\&   # set the options for the search (will or will not recurse, etc)
\&   my(@opts) = [qw/ \-\-files\-only \-\-with\-paths \-\-recurse /]\->[0,1];
\&
\&   # create new File::Util object, set File::Util to send a warning for
\&   # fatal errors instead of dieing
\&   my($f)         = File::Util\->new(\*(Aq\-\-fatals\-as\-warning\*(Aq);
\&   my($rstr)      = $f\->load_file(RFILE);
\&   my($spat)      = quotemeta($f\->load_file(SFILE)); $spat = qr/$spat/;
\&   my($gsbt)      = 0;
\&   my($action)    = RMODE eq \*(Aqread\-only\*(Aq ? \*(Aqdetections\*(Aq : \*(Aqsubstitutions\*(Aq;
\&   my(@files)     = $f\->list_dir(INDIR, @opts);
\&
\&   for (my($i) = 0; $i < @files; ++$i) {
\&
\&      next if $f\->isbin($files[$i]);
\&
\&      my($sbt) = 0; my($file) = $f\->load_file($files[$i]);
\&
\&      $file =~ s/$spat/++$sbt;++$gsbt;$rstr/ge;
\&
\&      $f\->write_file(\*(Aqfile\*(Aq => $files[$i], \*(Aqcontent\*(Aq => $file)
\&         if RMODE eq \*(Aqwrite\*(Aq;
\&
\&      print $sbt ? (qq[$sbt $action in $files[$i]] . NL) : \*(Aq\*(Aq;
\&   }
\&
\&   print( NL . <<_\|_DONE_\|_ . NL x 2) and exit;
\&   $gsbt $action in ${\escalar(@files)} files.
\&   _\|_DONE_\|_
.Ve
.SS "Pretty-Print A Directory Recursively"
.IX Subsection "Pretty-Print A Directory Recursively"
.Vb 2
\&   use strict;
\&   use vars qw( $a $b );
\&
\&   use File::Util qw( NL );
\&   my($ind) = \*(Aq\*(Aq;
\&   my($f)   = File::Util\->new();
\&   my(@o)   = qw(
\&      \-\-with\-paths
\&      \-\-sl\-after\-dirs
\&      \-\-no\-fsdots
\&      \-\-files\-as\-ref
\&      \-\-dirs\-as\-ref
\&   );
\&
\&   my($filetree)  = {};
\&   my($treetrunk) = \*(Aq/var/\*(Aq;
\&   my($subdirs,$sfiles) = $f\->list_dir($treetrunk, @o);
\&
\&   $filetree = [{
\&      $treetrunk => [ sort({ uc $a cmp uc $b } @$subdirs, @$sfiles) ]
\&   }];
\&
\&   descend($filetree\->[0]{ $treetrunk },scalar(@$subdirs));
\&   walk(@$filetree);
\&
\&   sub descend {
\&      my($parent,$dirnum) = @_;
\&      for (my($i) = 0; $i < $dirnum; ++$i) {
\&         my($current) = $parent\->[$i]; next unless \-d $current;
\&         my($subdirs,$sfiles) = $f\->list_dir($current, @o);
\&         map { $_ = $f\->strip_path($_) } @$sfiles;
\&         splice(@$parent,$i,1,{
\&            $current => [ sort({ uc $a cmp uc $b } @$subdirs, @$sfiles) ]
\&         });
\&         descend($parent\->[$i]{ $current },scalar(@$subdirs));
\&      }
\&      $parent
\&   }
\&
\&   sub walk {
\&      my($dir) = shift(@_);
\&      foreach (@{ [ %$dir ]\->[1] }) {
\&         my($mem) = $_;
\&         if (ref($mem) eq \*(AqHASH\*(Aq) {
\&            print($ind . $f\->strip_path([ %$mem ]\->[0]) . \*(Aq/\*(Aq,NL);
\&            $ind .= \*(Aq \*(Aq x 3;
\&            walk($mem);
\&            $ind = substr($ind,3);
\&         } else { print($ind . $mem,NL) }
\&      }
\&   }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Send bug reports to the \s-1AUTHOR\s0.  There are no known bugs at this time.
.SH "TODO"
.IX Header "TODO"
Add full support for PerlIO layers in \f(CW\*(C`File::Util::open_handle()\*(C'\fR and possibly
\&\f(CW\*(C`File::Util::write_file()\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tommy Butler <cpan@atrixnet.com <mailto:cpan@atrixnet.com>>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright(C) 2001\-2007, Tommy Butler.  All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software, you may redistribute and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Slurp, Exception::Handler, Class::OOorNO
