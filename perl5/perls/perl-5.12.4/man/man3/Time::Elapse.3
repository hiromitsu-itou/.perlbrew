.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Elapse 3"
.TH Elapse 3 "2003-12-13" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Time::Elapse \- Perl extension for monitoring time conveniently during tasks
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Time::Elapse is a very simple class with one method: lapse.
.PP
Basically, the lapse method 'eats the brains' of the variable,
squirrels away whatever value it may have held internally,
(much like space aliens are known to do in the movies), and also stores 
the current time within it. Then, whenever you access the value of 
the variable, the 'alien' within formats the time differential 
between when you initialized the variable, and when you printed it, 
and returns that (along with any value the variable may hold, as well). :\-) 
Every time you print it, you get the updated differential, returned by 
the method hidden inside the variable itself. The output will be formatted 
as \s-1HH:MM:SS\s0.000000 [in Microseconds].
.PP
Frankly it doesn't do much more than \fItime()\fR, but then again the simplest 
things rarely do. :\-)
.PP
All it really does is hides the calculations that anyone else would have had 
to set up manually in a clever way and then produce a reasonably formatted 
output which lends itself equally well to single-line output or inlining with
other text.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Usage"
.IX Subsection "Usage"
To use Elapse is simplicity itself:
.PP
.Vb 1
\&    use Time::Elapse;
\&
\&    # somewhere in your program...
\&    Time::Elapse\->lapse(my $now); 
\&    # or you can do:
\&    # Time::Elapse\->lapse(my $now = "processing");
\&
\&    #...rest of program execution
\&
\&    print "Time Wasted: $now\en";
.Ve
.PP
To update the description and reset the time counter mid-stream, simply 
assign to the variable
.PP
.Vb 1
\&    $now = "parsing";
.Ve
.PP
somewhere in the middle of the program. The new value is stored, while 
the original time is replaced with the current time.
.SS "Sample Output"
.IX Subsection "Sample Output"
Output looks something like this, using above code:
.PP
.Vb 5
\&    Time Wasted: 00:00:05.565763
\&  or
\&    Time Wasted: 00:00:03.016700 [processing]
\&    (more output)
\&    Time Wasted: 00:00:02.003764 [parsing]
.Ve
.SS "Additional example code"
.IX Subsection "Additional example code"
You can also use this during a Net::FTP download loop of files to show 
elapsed time for each file's download.
.PP
.Vb 9
\&  foreach my $file (@files_to_download) 
\&  {
\&    # extract localfile name from $file
\&    # ...
\&    Time::Elapse\->lapse(my $now = "Downloading $localfile.");
\&    $ftp\->get($file, $localfile) or carp("### Could not download $file! $!") and next;
\&    print "Done. Elapsed : $now\en";
\&    # ...
\&  }
.Ve
.PP
This can also be a useful trick when you're processing a lot of data from multiple sources.
.SH "'BUGS'"
.IX Header "'BUGS'"
Elapse offers time granularity smaller than 1 second, but values are approximate since 
the accuracy is slightly hampered by the virtue of the process itself taking somewhere 
roughly around 0.00001 \- 0.0009 seconds. (depending on the system and how many 
processes are running at the time. :\-)
.PP
.Vb 9
\&    #!/usr/bin/perl
\&    use Time::Elapse;
\&    Time::Elapse\->lapse(my $now = "testing 0");
\&    for (1 .. 5)
\&    {
\&        print "$now\en";
\&        $now = "testing $_";
\&    }
\&    print "$now\en";
\&
\&   (results from a PowerMac G3/400 running MacPerl 5.004
\&    on MacOS 8.6)
\&    00:00:00.000937 [testing 0]
\&    00:00:00.000743 [testing 1]
\&    00:00:00.000344 [testing 2]
\&    00:00:00.000327 [testing 3]
\&    00:00:00.000358 [testing 4]
\&    00:00:00.000361 [testing 5]
\&
\&   (results from an AMD Duron 1.1Ghz running Perl 5.8.0
\&    on RedHat Linux 8.0)
\&    00:00:00.000079 [testing 0]
\&    00:00:00.000035 [testing 1]
\&    00:00:00.000018 [testing 2]
\&    00:00:00.000016 [testing 3]
\&    00:00:00.000016 [testing 4]
\&    00:00:00.000020 [testing 5]
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "AUTHOR"
.IX Header "AUTHOR"
.SS "Author"
.IX Subsection "Author"
Scott R. Godin, \f(CW\*(C`<mactech@webdragon.net>\*(C'\fR
.SS "Last Update"
.IX Subsection "Last Update"
Fri Aug  8 01:12:56 \s-1EDT\s0 2003
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001 Scott R. Godin. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Time::HiRes.
