.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Manual::Intro 3"
.TH HTML::FormHandler::Manual::Intro 3 "2012-02-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Manual::Intro \- introduction to using FormHandler
.SH "VERSION"
.IX Header "VERSION"
version 0.36002
.SH "SUMMARY"
.IX Header "SUMMARY"
HTML::FormHandler is a form handling class that validates \s-1HTML\s0 form data
and, for database forms, saves it to the database on validation.
It has field classes that can be used for creating a set of widgets
and highly automatic templates. There are two simple rendering roles,
HTML::FormHandler::Render::Simple and a subclass of it
HTML::FormHandler::Render::Table, plus a set of widget roles for
individual form and field classes. FormHandler is designed to
make it easy to produce alternative rendering modules.
.PP
The \s-1DBIC\s0 & \s-1CDBI\s0 models will save form fields automatically to the database, will
retrieve selection lists from the database (with type => 'Select' and a
fieldname containing a single relationship, or type => 'Multiple' and a
many_to_many relationship), and will save the selected values (one value for
\&'Select', multiple values in a mapping table for a 'Multiple' field).
.PP
The 'form' is a Perl subclass of HTML::FormHandler for non-database forms,
or a subclass of a model class for database forms, and in it you define
your fields and validation routines. Because it's a Perl class, you have a
lot of flexibility.
.PP
You can use transformations, Moose type constraints, and coercions, listed
in the field's 'apply' attribute, to validate or inflate the fields
(see \*(L"apply\*(R" in HTML::FormHandler::Field).  You can define your own
HTML::FormHandler::Field classes to create your own field types, and
perform specialized validation. You can create MooseX::Types libraries
and use them to perform field validation.
.PP
The HTML::FormHandler::Model::DBIC package includes a working
example using a SQLite database and a number of forms in the test directory.
You can execute the sample from a downloaded \s-1DBIC\s0 model distribution package with:
.PP
.Vb 1
\&   perl \-Ilib t/script/bookdb_server.pl
.Ve
.SH "Basics"
.IX Header "Basics"
You can either create a form dynamically with
\&\f(CW\*(C`my $form = HTML::FormHandler\->new( <arguments>);\*(C'\fR (or with
\&\f(CW\*(C`HTML::FormHandler::Model::DBIC\->new(...)\*(C'\fR for \s-1DBIC\s0 forms ) or by
creating a form subclass. There are some features
and usage patterns which do not fit well with the dynamic method \- it's harder
to create form methods or attributes, for example. But most forms could be
created in either way.
.PP
An example of a form class, subclassed from HTML::FormHandler::Model::DBIC. The fields
are declared here using the 'has_field' sugar, but they could also be
defined using the 'field_list', as in the following dynamic example.
.PP
.Vb 3
\&    package MyApp:Form::User;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler::Model::DBIC\*(Aq;
\&
\&    # Associate this form with a DBIx::Class result class
\&    # Or \*(Aqitem_class\*(Aq can be passed in on \*(Aqnew\*(Aq, or you
\&    # you can always pass in a row object
\&    has \*(Aq+item_class\*(Aq => ( default => \*(AqUser\*(Aq );
\&
\&    # Define the fields that this form will operate on
\&    # Field names are usually column, accessor, or relationship names in your
\&    # DBIx::Class result class. You can also have fields that don\*(Aqt exist
\&    # in your result class.
\&
\&    has_field \*(Aqname\*(Aq    => ( type => \*(AqText\*(Aq, label => \*(AqUsername\*(Aq, required => 1,
\&       unique => 1, messages => { required => \*(AqYou must enter a username\*(Aq,
\&       unique => \*(AqThat username is already taken\*(Aq } );
\&    # the css_class, title, and widget attributes are for use in templates
\&    has_field \*(Aqage\*(Aq     => ( type => \*(AqPosInteger\*(Aq, required => 1, css_class => \*(Aqbox\*(Aq,
\&       title => \*(AqUser age in years\*(Aq, widget => \*(Aqage_text\*(Aq, range_start => 18 );
\&    has_field \*(Aqsex\*(Aq     => ( type => \*(AqSelect\*(Aq, label => \*(AqGender\*(Aq, required => 1 );
\&    # a customized field class
\&    has_field \*(Aqbirthdate\*(Aq => ( type => \*(Aq+MyApp::Field::Date\*(Aq );
\&    has_field \*(Aqhobbies\*(Aq => ( type => \*(AqMultiple\*(Aq, size => 5 );
\&    has_field \*(Aqaddress\*(Aq => ( type => \*(AqText\*(Aq );
\&    has_field \*(Aqcity\*(Aq    => ( type => \*(AqText\*(Aq );
\&    has_field \*(Aqstate\*(Aq   => ( type => \*(AqSelect\*(Aq );
\&
\&    has \*(Aq+dependency\*(Aq => ( default => sub {
\&            [
\&                [\*(Aqaddress\*(Aq, \*(Aqcity\*(Aq, \*(Aqstate\*(Aq],
\&            ],
\&        }
\&    );
\&
\&    no HTML::FormHandler::Moose;
\&    1;
.Ve
.PP
An example of a dynamically created form instance:
.PP
.Vb 1
\&    use HTML::FormHandler;
\&
\&    my @select_options = ( {value => 1, label => \*(AqOne\*(Aq},
\&         {value => 2, label => \*(AqTwo\*(Aq}, {value => 3, label => \*(AqThree\*(Aq} );
\&    my $args =  {
\&        name       => \*(Aqtest_form\*(Aq,
\&        field_list => [
\&            \*(Aqusername\*(Aq => {
\&                type  => \*(AqText\*(Aq,
\&                apply => [ { check => qr/^[0\-9a\-z]*/,
\&                   message => \*(AqContains invalid characters\*(Aq } ],
\&            },
\&            \*(Aqpassword\*(Aq => {
\&                type => \*(AqPassword\*(Aq,
\&            },
\&            \*(Aqsome_number\*(Aq => {
\&                type      => \*(AqIntRange\*(Aq,
\&                range_min => 12,
\&                range_max => 291,
\&            },
\&            \*(Aqsome_option\*(Aq => {
\&                type           => \*(AqCheckbox\*(Aq,
\&                checkbox_value => \*(Aqyes\*(Aq,
\&                input_without_param => \*(Aqno\*(Aq
\&            },
\&            \*(Aqsome_text\*(Aq => {
\&                type => \*(AqTextArea\*(Aq,
\&            },
\&            \*(Aqhidden_field\*(Aq => {
\&                type    => \*(AqHidden\*(Aq,
\&                default => \*(Aqfoo\*(Aq,
\&            },
\&            \*(Aqupload_file\*(Aq => {
\&                type => \*(AqUpload\*(Aq,
\&                max_size => 262144,
\&            },
\&            \*(Aqselect_foo\*(Aq => {
\&                type    => \*(AqSelect\*(Aq,
\&                options => \e@select_options,
\&            },
\&            \*(Aqselect_bar\*(Aq => {
\&                type     => \*(AqSelect\*(Aq,
\&                options  => \e@select_options,
\&                multiple => 1,
\&                size     => 4,
\&            },
\&            \*(Aqselect_baz\*(Aq => {
\&                type    => \*(AqSelect\*(Aq,
\&                options => \e@select_options,
\&                widget  => \*(Aqradio_group\*(Aq,
\&            },
\&            \*(Aqselect_bax\*(Aq => {
\&                type     => \*(AqSelect\*(Aq,
\&                options  => \e@select_options,
\&                multiple => 1,
\&                widget   => \*(Aqcheckbox_group\*(Aq
\&            },
\&            \*(Aqsub\*(Aq => {
\&                type => \*(AqCompound\*(Aq,
\&            },
\&            \*(Aqsub.user\*(Aq => {
\&                type  => \*(AqText\*(Aq,
\&                apply => [ { check => qr/^[0\-9a\-z]*/,
\&                             message => \*(AqNot a valid user\*(Aq } ],
\&            },
\&            \*(Aqsub.name\*(Aq => {
\&                type  => \*(AqText\*(Aq,
\&                apply => [ { check => qr/^[0\-9a\-z]*/,
\&                             message => \*(AqNot a valid name\*(Aq } ],
\&            },
\&            \*(Aqreset\*(Aq => {
\&                type => \*(AqReset\*(Aq,
\&            },
\&            \*(Aqsubmit\*(Aq => {
\&                type => \*(AqSubmit\*(Aq,
\&            },
\&            \*(Aqsome_link\*(Aq => {
\&                type => \*(AqDisplay\*(Aq,
\&                html => \*(Aq<a href="http://google.com/">Go somewhere</>\*(Aq,
\&            },
\&        ]
\&    };
\&    my $form = HTML::FormHandler\->new( %$args );
\&    my $renderedform = $form\->render;
.Ve
.PP
You can create custom rendering roles or classes and easily change the
rendering methods. See HTML::FormHandler::Manual::Rendering for details.
.PP
By default the HTML::FormHandler::Widget roles will be applied, making it
possible to render a simple form for scaffolding:
.PP
.Vb 1
\&    [% form.render %]
.Ve
.PP
Individual fields can also be rendered:
.PP
.Vb 1
\&    [% form.field(\*(Aqtitle\*(Aq).render %]
.Ve
.PP
Note: If you don't want to use the field widgets, you can set the 'no_widgets' flag
in the form to skip having the widget roles applied to the fields.
.PP
You can render a field using a template. For an input field:
.PP
.Vb 5
\&   <p>
\&   [% f = form.field(\*(Aqaddress\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label %]:</label>
\&   <input type="text" name="[% f.name %]" id="[% f.name %]" value="[% f.fif %]">
\&   </p>
.Ve
.PP
The value can come from the hash returned by \f(CW\*(C`$form\->fif\*(C'\fR, from the 'fif'
attribute of the field, or can be supplied by FillInForm and the
Catalyst::View::FillInForm role on your view class.
Plain \s-1HTML\s0 works fine for a simple input field if you use FillInForm to
supply the value.
.PP
For a select list, provide a relationship name as the field name, or provide
an options_<field_name> subroutine in the form.  You need to access the field
\&'options' to create a select list.  You could,
of course, create the select lists by hand or some other way, but if you
don't use the same method that is used by your FormHandler Select field,
you risk getting out of sync.  \s-1TT\s0 example:
.PP
.Vb 11
\&   <p>
\&   [% f = form.field(\*(Aqsex\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label %]</label>
\&   <select name="[% f.name %]">
\&     [% FOR option IN f.options %]
\&       <option value="[% option.value %]"
\&       [% IF option.value == f.fif %]selected="selected"[% END %]>
\&       [% option.label | html %]</option>
\&     [% END %]
\&   </select>
\&   </p>
.Ve
.PP
A multiple select list where 'hobbies' is a 'many_to_many' pseudo-relationship.
(field attributes: sort_column, label_column, active_column).
.PP
.Vb 9
\&   <p>
\&   [% f = form.field(\*(Aqhobbies\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label || f.name %]</label>
\&   <select name="[% f.name %]" multiple="multiple" size="[% f.size %]">
\&     [% FOR option IN f.options %]
\&       <option value="[% option.value %]" [% FOREACH selval IN f.fif %][% IF selval == option.value %]selected="selected"[% END %][% END %]>[% option.label | html %]</option>
\&     [% END %]
\&   </select>
\&   </p>
.Ve
.PP
In a Catalyst controller:
.PP
.Vb 4
\&    package MyApp::Controller::User;
\&    use Moose;
\&    BEGIN { extends \*(AqCatalyst::Controller\*(Aq }
\&    use MyApp::Form::User
\&
\&    has \*(Aqform\*(Aq => ( isa => \*(AqMyApp::Form::User\*(Aq, is => \*(Aqrw\*(Aq,
\&        lazy => 1, default => sub { MyApp::Form::User\->new } );
\&
\&    # Create or edit
\&    sub edit : Local {
\&        my ( $self, $c, $user_id ) = @_;
\&
\&        $c\->stash(
\&          form => $self\->form,
\&          template => \*(Aquser/edit.tt\*(Aq );
\&
\&
\&        return unless $self\->form\->process( item_id => $user_id,
\&           schema => $c\->model(\*(AqDB\*(Aq)\->schema );
\&
\&        # Form validated.
\&        $c\->stash( user => $self\->form\->item );
\&        $c\->res\->redirect($c\->uri_for(\*(Aqprofile\*(Aq));
\&    }
\&
\&    1;
.Ve
.PP
With the \s-1DBIC\s0 model the schema is set from the 'item' (row object)
passed in, or from the primary key ('item_id') and schema.
You might also want to pass in the 'action' to which the form will
be submitted if you're using FormHandler's renderer and if it's important
to pass \s-1XHTML\s0 validation:
.PP
.Vb 2
\&   $form\->process( action => <valid url>, item => $row,
\&        params => $c\->req\->params );
.Ve
.PP
The example above uses persistent forms in a Moose attribute. The
\&'process' method will clear out non-persistent form values and
update the information from the database row (if given).
You can also create a new form on each request with new:
.PP
.Vb 2
\&   my $form = BookDB::Form::Book\->new( item => $book );
\&   return unless $form\->process( params => $c\->req\->parameters );
.Ve
.PP
There is also a 'validated' flag:
.PP
.Vb 2
\&   $form\->process( params => $c\->req\->parameters );
\&   return unless $form\->validated;
.Ve
.PP
Form processing is a two-pass operation. The first time through
the parameters will be an empty hashref, since the form has not been
submitted yet. FormHandler will load values from the database object
(item_id/schema or item) or from an 'init_object', and return false
because the form has not validated yet. At this point the 'return'
(in Catalyst) will cause the renderview processing to take place and
the form will be displayed with initialized values (from a template
using the 'fif' values or from HTML::FillInForm) to allow user input.
.PP
When the form is submitted, the action in the \s-1HTML\s0 form's 'action'
value will be called (the same one that just displayed the form
usually), and the second pass of calling the FormHandler
process method will occur.
.PP
This time there \s-1WILL\s0 be values in the parameters, and FormHandler
will call the validation routines. If the validation succeeds, FormHandler
will return a 'true' value, and execution will fall through to after
the \*(L"return unless ....\*(R" line. At this point you will either redirect
to some other page, or in some cases redisplay the form with a message
that saving succeeded. If the validation fails, the 'return' will cause
the form to be displayed again.
.PP
The values to be used to fill in your form are automatically created
by FormHandler, and are available in the field's 'fif' attribute:
.PP
.Vb 1
\&   $field\->fif
.Ve
.PP
or in the form's fif hash, which will contain the fill-in-form values
for all the form's fields:
.PP
.Vb 1
\&   $form\->fif
.Ve
.PP
If you want to use HTML::FillInForm to fill in values instead of the
doing it in directly in a template using either the field or the form 'fif'
methods, you can use Catalyst::View::FillInForm on your view class
and set the 'fif' hash in the 'fillinform' stash variable:
.PP
.Vb 3
\&    $self\->form\->process( ... );
\&    $c\->stash( fillinform => $self\->form\->fif );
\&    return unless $form\->validated;
.Ve
.PP
Note that FormHandler by default uses empty params as a signal that the
form has not actually been posted, and so will not attempt to validate
a form with empty params. Most of the time this works \s-1OK\s0, but if you
have a small form with only the controls that do not return a post
parameter if unselected (checkboxes and select lists), then the form
will not be validated if everything is unselected. For this case you
can either add a hidden field, or use the 'posted' flag:
.PP
.Vb 1
\&   $form\->process( posted => ($c\->req\->method eq \*(AqPOST\*(Aq, params => ... );
.Ve
.PP
The corollary is that you will confuse FormHandler if you add extra params.
It's often a better idea to add Moose attributes to the form rather than
\&'dummy' fields if the data is not coming from a form control.
.SH "Form generator"
.IX Header "Form generator"
A \s-1DBIC\s0 form generator is installed with the HTML::FormHandler::Model::DBIC
package. See HTML::FormHandler::Generator::DBIC.
.PP
There's also a role, HTML::FormHandler::TraitFor::DBICFields, that allows 
simple form fields to be auto-generated from a \s-1DBIC\s0 result class.
.PP
.Vb 5
\&    my $form = HTML::FormHandler::Model::DBIC\->new_with_traits(
\&        traits => [\*(AqHTML::FormHandler::TraitFor::DBICFields\*(Aq],
\&        include => [\*(Aqtitle\*(Aq, \*(Aqauthor\*(Aq ],
\&        field_list => [ \*(Aqsubmit\*(Aq => { type => \*(AqSubmit\*(Aq, value => \*(AqSave\*(Aq, order => 99 } ],
\&        item => $book );
.Ve
.SH "Non-database forms"
.IX Header "Non-database forms"
The base class for a  non-database form is HTML::FormHandler instead
of a model class.
You do not initialize a non-database form with an item or item_id,
although you can use an init_object for the initial values.
.PP
After validation, you can get a hashref of values back from
the 'value' method.
.PP
.Vb 2
\&   return unless $form\->validated;
\&   my $result = $form\->value;
.Ve
.PP
The 'value' structure is what FormHandler uses to update the database.
.SH "Form Models"
.IX Header "Form Models"
For a database form, use a model base class that interfaces with the
database, such as HTML::FormHandler::Model::DBIC, which needs to
be installed as a separate package.
.PP
When using a database model, form field values for the row are retrieved from
the database using the field 'accessor' attributes (defaults to field name)
as database class accessors.
.PP
FormHandler will use relationships to populate single and multiple
selection lists, and validate input. A 'single' relationship is processed
by HTML::FormHandler::Field::Compound. A 'has_many' relationship is
processed by HTML::FormHandler::Field::Repeatable.
.PP
You can pass in either the primary key and or a row object to the form. If a
primary key (item_id) is passed in, you must also provide the schema.
The model will use the item_class (\s-1DBIC\s0 source name) to fetch the row from the
database. If you pass in a row object (item), the schema, source_class, and
item_id will be set from the row.
.PP
The \f(CW\*(C`$form\->process\*(C'\fR will validate
the parameters and then update or create the database row object.
.SH "Field names"
.IX Header "Field names"
The standard way to use FormHandler is with field names that match your
database accessors. If you want to prepend the \s-1HTML\s0 field names with a
name plus dot, you can set the form 'name' and use the 'html_prefix'
flag. \*(L"$name.\*(R" will be stripped from the beginning of the \s-1HTML\s0 fields
before processing by \s-1HFH\s0, and will be added back in 'fif'. The field's
\&'html_name' convenience attribute will return this name for use in templates.
.PP
If you want the FormHandler field name to be different than the
database accessor, set 'accessor' on your fields. (It defaults to the field
name). You could then use any name that you want for your field.
.PP
There are a number of name related field attributes. The 'name' is
the name used to identify this particular field in this fields array.
The 'full_name' is includes the names of all parents of this field,
like 'address.street.streetname'. The 'html_name' is the same as the
\&'full_name' unless you have set the 'html_prefix' flag, in which case
it includes the form name: 'myform.address.street.streetname'.
.PP
To retrieve a field by name, you can use either the full_name or a
chain: \f(CW\*(C`$form\->field(\*(Aqaddress\*(Aq)\->field(\*(Aqstreet\*(Aq)\->field(\*(Aqstreetname\*(Aq)\*(C'\fR
or: \f(CW\*(C`$form\->field(\*(Aqaddress.street.streetname\*(Aq)\*(C'\fR.
.PP
You can process multiple FormHandler forms at the same time (using
the same \s-1HTML\s0 form) with multiple form objects and multiple process/update
calls. You would have to ensure that there are no duplicate field names,
possibly by using 'html_prefix'.
.SH "has_field"
.IX Header "has_field"
This is not actually a Moose attribute. It is sugar to allow the
declarative specification of fields. It will not create accessors for the
fields. The 'type' is not a Moose type, but an HTML::FormHandler::Field
class name. To use this sugar, you must do
.PP
.Vb 1
\&   use HTML::FormHandler::Moose;
.Ve
.PP
instead of \f(CW\*(C` use Moose; \*(C'\fR. (Moose best practice advises using
\&\f(CW\*(C` use namespace::autoclean; \*(C'\fR or putting \f(CW\*(C` no HTML::FormHandler::Moose; \*(C'\fR
at the end of the package to keep the namespace clean of imported methods.)
.PP
To declare fields use the syntax:
.PP
.Vb 2
\&   has_field \*(Aqtitle\*(Aq => ( type => \*(AqText\*(Aq, required => 1 );
\&   has_field \*(Aqauthors\*(Aq => ( type => \*(AqSelect\*(Aq );
.Ve
.PP
instead of:
.PP
.Vb 10
\&   has \*(Aqfield_list\*(Aq => ( default => sub {
\&         [
\&            title => {
\&               type => \*(AqText\*(Aq,
\&               required => 1,
\&            },
\&            authors => \*(AqSelect\*(Aq,
\&         ]
\&      }
\&   );
.Ve
.PP
Fields specified in a field_list are processed after fields specified with 'has_field'.
After processing, fields live in the 'fields' array, and can be accessed with the
field method: \f(CW\*(C`$form\->field(\*(Aqtitle\*(Aq)\*(C'\fR.
.PP
Forms with 'has_field' field declarations may be subclassed. Or use
HTML::FormHandler::Moose::Role to create roles with the 'has_field' syntax:
.PP
.Vb 1
\&   package Form::Role::Address;
\&
\&   use HTML::FormHandler::Moose::Role;
\&
\&   has_field \*(Aqstreet\*(Aq => ( type => \*(AqText\*(Aq, size => \*(Aq50\*(Aq );
\&   has_field \*(Aqcity\*(Aq => ( type = \*(AqText\*(Aq, size => 24 );
\&   has_field \*(Aqstate\*(Aq => ( type => \*(AqSelect );
\&   has_field \*(Aqzip\*(Aq => ( type => \*(Aq+Zip\*(Aq, required => 1 );
\&
\&   no HTML::FormHandler::Moose::Role;
\&   1;
.Ve
.PP
You can use roles to define fields and validations and include them in form
classes using 'with':
.PP
.Vb 5
\&   package Form::Member;
\&   use HTML::FormHandler::Moose;
\&   with \*(AqForm::Role::Person\*(Aq;
\&   with \*(AqForm::Role::Address\*(Aq;
\&   extends \*(AqHTML::FormHandler::Model::DBIC\*(Aq;
\&
\&   has_field \*(Aquser_name\*(Aq => ( type => \*(AqText\*(Aq, required => 1 );
\&
\&   no HTML::FormHandler::Moose;
\&   1;
.Ve
.PP
If you prefix the field name with a '+' the attributes in this definition
will modify existing attributes or be added to an existing field definition:
.PP
.Vb 3
\&    has_field \*(Aquser\*(Aq => ( type => \*(AqText\*(Aq, ...., required => 1 );
\&    ....
\&    has_field \*(Aq+user\*(Aq => ( required => 0 );
.Ve
.SH "The form field_list"
.IX Header "The form field_list"
An array of name, specification pairs to define fields.
.PP
The field_list is one way to define the fields in your form.
.PP
.Vb 10
\&   has \*(Aq+field_list\*(Aq => ( default => sub {
\&         [
\&            field_one => {
\&               type => \*(AqText\*(Aq,
\&               required => 1
\&            },
\&            field_two => \*(AqText,
\&         ]
\&      }
\&   );
.Ve
.PP
An example of a select field:
.PP
.Vb 9
\&    sub field_list {
\&       return [
\&            favorite_color => {
\&                type            => \*(AqSelect\*(Aq,
\&                label_column    => \*(Aqcolor_name\*(Aq,
\&                active_column   => \*(Aqis_active\*(Aq,
\&            },
\&        ];
\&    }
.Ve
.SH "Fields"
.IX Header "Fields"
A form's fields are created from the 'has_field' and 'field_list'
definitions.
FormHandler processes the field lists and creates an array of
HTML::FormHandler::Field objects. The \*(L"type\*(R" of a field
determines which field class to use. The field class determines which
attributes are valid for a particular field. A number of field classes are
provided by FormHandler. You can customize the validation in your form on a
per field basis, but validation that will be used for more than one field
might be more easily handled in a custom field class.
.PP
In the templates the fields are accessed with \f(CW\*(C` form.field(\*(Aqname\*(Aq) \*(C'\fR.
Field errors are in \f(CW\*(C`$field\->errors\*(C'\fR.
.PP
The fields are assumed to be in the HTML::FormHandler::Field name
space.  If you want to explicitly list the field's package, prefix it
with a plus sign. The field_name_space plus the default name spaces
\&'HTML::FormHandler::Field' and 'HTML::FormHandlerX::Field' will be
searched for fields.
.PP
.Vb 1
\&    has \*(Aq+field_name_space\*(Aq => ( default => \*(AqMyApp::Form::Field\*(Aq );
\&
\&    has_field \*(Aqname\*(Aq => ( type => \*(AqText\*(Aq ); # HTML::FormHandler::Field::Text
\&    has_field \*(Aqname\*(Aq => ( type => \*(Aq+My::FieldType\*(Aq ); # My::Fieldtype
\&    has_field \*(Aqfoo\*(Aq  => ( type => +Foo\*(Aq );  # MyApp::Form::Field::Foo
\&      or
\&    has_field \*(Aqfoo\*(Aq  => ( type => \*(AqFoo\*(Aq );  # MyApp::Form::Field::Foo
.Ve
.PP
The most basic type is \*(L"Text\*(R", which takes a single scalar value. (If the
type of a field is not specified, it will be set to 'Text'.)  A \*(L"Select\*(R"
class is similar, but its value must be a valid choice from a list of options.
A \*(L"Multiple\*(R" type is like \*(L"Select\*(R" but it allows selecting more than one value
at a time.
.PP
Each field has a \*(L"value\*(R" method, which is the field's internal value.  This is
the value your database object would have (e.g. scalar, boolean 0 or 1,
DateTime object).
.PP
When data is passed in to validate the form, the input is copied into the
\&'value' attribute of the field, and the actions specified by 'apply'
will be performed on the value. This includes the 'trim' transform which
will strip leading and trailing spaces. After the actions are applied,
the field's 'validate' method is called.
.SS "Compound fields"
.IX Subsection "Compound fields"
A compound field is a field that has sub-fields. Compound fields can be
created in two ways: 1) using a field class, 2) by declaration.
.PP
To create a compound field class, you must extend
HTML::FormHandler::Field::Compound and use HTML::FormHandler::Moose to
allow declaring fields:
.PP
.Vb 1
\&  package MyApp::Field::Duration;
\&
\&  use HTML::FormHandler::Moose;
\&  extends \*(AqHTML::FormHandler::Field::Compound\*(Aq;
\&
\&  has_field \*(Aqmonth\*(Aq => (type => \*(AqInteger\*(Aq);
\&  has_field \*(Aqday\*(Aq => ( type => \*(AqInteger\*(Aq );
\&  has_field \*(Aqminutes\*(Aq => ( type => \*(AqInteger\*(Aq );
.Ve
.PP
Then in the form:
.PP
.Vb 1
\&  has_field \*(Aqmy_duration\*(Aq => ( type => \*(Aq+Duration\*(Aq );
.Ve
.PP
To create a compound field by declaration, declare the containing
compound field and subfields, prefixing the subfield names
with the name of the containing compound field plus a dot:
.PP
.Vb 1
\&   package MyApp::Form;
\&
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler\*(Aq;
\&
\&   has_field \*(Aqduration\*(Aq => ( type => \*(AqCompound\*(Aq );
\&   has_field \*(Aqduration.month\*(Aq => ( type => \*(AqInteger\*(Aq );
\&   has_field \*(Aqduration.day\*(Aq => ( type => \*(AqInteger\*(Aq );
\&   has_field \*(Aqduration.year\*(Aq => ( type => \*(AqInteger\*(Aq );
.Ve
.PP
In an \s-1HTML\s0 form the name of the field must be the complete name
with dots. The 'html_name' field attribute can be used to get
this name:
.PP
.Vb 1
\&   [% field.html_name %]
.Ve
.PP
A compound field can be used for a database relation that will have only
one row (belongs_to or has_one).
.SS "Repeatable fields"
.IX Subsection "Repeatable fields"
Repeatable fields are used for arrays of compound fields.
.PP
.Vb 5
\&   has_field \*(Aqaddresses\*(Aq => ( type => \*(AqRepeatable\*(Aq );
\&   has_field \*(Aqaddresses.address_id\*(Aq => ( type => \*(AqPrimaryKey\*(Aq );
\&   has_field \*(Aqaddresses.street\*(Aq;
\&   has_field \*(Aqaddresses.city\*(Aq;
\&   has_field \*(Aqaddresses.country\*(Aq => ( type => \*(AqSelect\*(Aq );
.Ve
.PP
The arrays will be built from arrays passed in the params, or from
related ('has_many') rows in the database.
.PP
It is also used for arrays of single fields using the 'contains' keyword:
.PP
.Vb 2
\&  has_field \*(Aqtags\*(Aq => ( type => \*(AqRepeatable\*(Aq );
\&  has_field \*(Aqtags.contains\*(Aq => ( type => \*(Aq+Tag\*(Aq );
.Ve
.PP
See HTML::FormHandler::Field::Repeatable for more information.
.SS "Filters, transformations, and constraints"
.IX Subsection "Filters, transformations, and constraints"
HTML::FormHandler has a flexible system of of filters and constraints. You can
use Moose types to constrain the allowable values in a field and use coercions to
inflate the \s-1HTML\s0 field input, such as for a DateTime. You can also create
non-Moose transformations and constraints. See the 'apply' attribute
in HTML::FormHandler::Field.
.PP
.Vb 3
\&   has_field \*(Aqsome_field\*(Aq => ( apply => [ \*(AqMooseType\*(Aq,
\&       { transform => sub {...}, message => \*(Aqxxxx\*(Aq },
\&       { check => sub { ... }, message => \*(Aqxxxx\*(Aq } ] );
.Ve
.PP
The actions in the 'apply' array will be performed in the order they are
specified, allowing fine-grained control over inflation and validation.
.PP
You can also create a simple subroutine in your form class to perform validation.
The default name of this subroutine is 'validate_<fieldname>', but the name can
also be set in the field with the 'set_validate' attribute. (This method is
not called when the field is empty. Use 'required'/'required_message' for
that case.)
.PP
If you need to access form attributes such as the schema, the 'set_validate'
subroutine may be preferable, but most validations can be performed using
either method.
.SS "Inflation/deflation"
.IX Subsection "Inflation/deflation"
The most common object that needs inflation and deflation is a DateTime
field, such as would come from a \s-1DBIC\s0 result class if you are using
the InflateColumn plugin, but it could be any object, such as a Duration.
.PP
Inflation can be done in one of the 'actions' that are applied to the field
class or in any place that validation is done, though it is probably better
to do it in a field class. Usually the form's validate_<field_name> methods
should expect to get the already inflated value (unless inflation failed).
.PP
Deflation is done to convert the object that is retrieved from the model to
a format that can be displayed in an \s-1HTML\s0 form. Deflation is always performed
when retrieving from the initial object. If an input value exists for a field
that value is usually used to re-display the field, and deflation is \s-1NOT\s0
performed, unless the 'fif_from_value' flag is set for the field. (See
HTML::FormHandler::Field). This might be desirable if you want to
canonicalize the entered data into a standard form.
.SS "Creating custom fields"
.IX Subsection "Creating custom fields"
Subclass a custom field from HTML::FormHandler::Field, or one of the
existing subclasses. Almost everything that is done in a custom field
class can also be done in a form. The advantage of a field class
is that it can simplify declaration of often-repeated sets of attributes.
.PP
The simplest subclasses contain only a 'validate' routine or an 'apply' attribute,
which is called by the base Field class from 'process'. Look at
HTML::FormHandler::Field::Email, for example.
.PP
If the field's value will be an object instead of a simple scalar, such
as a DateTime and you want to use the transformed value to fill in the
form, then you will also need a deflation or field class 'deflate' method
to reformat the object into a form suitable for an \s-1HTML\s0 form field.
.PP
Some custom fields might only require setting certain attributes to
defaults, such as the HTML::FormHandler::Field::Hour field, which
set 'range_start' to 0 and 'range_end' to 23. A 'select' field might
override the 'build_options' builder for the 'options' array, like
HTML::FormHandler::Field::IntRange. A field may add additional
attributes, such as 'label_format' in HTML::FormHandler::Field::IntRange,
or set the 'required' message.
.PP
An alternative to new field classes for many field validations might
be roles with collections of validations.
.SH "Common form attributes"
.IX Header "Common form attributes"
The 'dependency' field_list key is an array of arrays of field names.
During validation, if any field in a given group
contains the pattern /\eS/ (non-blank), the 'required' flag
is set for all of the fields in the group.
.PP
.Vb 7
\&   has \*(Aq+dependency\*(Aq => ( default => sub {
\&            [
\&               [\*(Aqaddress\*(Aq, \*(Aqcity\*(Aq, \*(Aqstate\*(Aq, \*(Aqzip\*(Aq],
\&               [\*(Aqcc_no\*(Aq, \*(Aqcc_expires\*(Aq],
\&            ],
\&        },
\&    );
.Ve
.PP
The 'item_class':
.PP
.Vb 1
\&   has \*(Aq+item_class\*(Aq => ( default => \*(AqBook\*(Aq );
.Ve
.PP
The form name:
.PP
.Vb 1
\&   has \*(Aq+name\*(Aq => ( default => \*(Aqbook_form\*(Aq );
.Ve
.PP
The field name space for use with '+' prefixed fields:
.PP
.Vb 3
\&   has \*(Aq+field_name_space\*(Aq => ( default => \*(AqMyApp::Form::Field\*(Aq );
\&   ...
\&   has_field \*(Aqsubname\*(Aq => ( type => \*(Aq+SubName\*(Aq );
.Ve
.SH "Defaults"
.IX Header "Defaults"
Defaults for form fields come from a number of different places. The simplest
way to set a field's default is on the field definition:
.PP
.Vb 2
\&   has_field \*(Aqfoo\*(Aq => ( type => \*(AqText\*(Aq, default => \*(Aqmy_foo\*(Aq );
\&   has_field \*(Aqselect_many\*(Aq => ( type => \*(AqMultiple\*(Aq, default => [1, 2, 3] );
.Ve
.PP
You can also set the default for a field with a method in the form with the name
\&'default_<field_name>', where any periods in the field name are replaced
with underscores.
.PP
.Vb 2
\&   has_field \*(Aqfoo\*(Aq;
\&   sub default_foo { \*(Aqmy_default\*(Aq }
.Ve
.PP
Like other field attributes, the 'default' attribute can be modified on
new with the 'field_list' attribute, or on 'process' with the 'update_field_list'
parameter:
.PP
.Vb 2
\&   my $form => MyApp::Form\->new( field_list => { \*(Aq+foo\*(Aq => { default => \*(Aqmy_foo\*(Aq } } );
\&   $form\->process( update_field_list => { foo => { default => \*(Aqmy_foo\*(Aq } } );
.Ve
.PP
For forms where you pass in an 'item' (usually a database row object), the
values in that object will be used preferentially; if an accessor exists
in the 'item' object, then the defaults won't be used. (If an accessor
doesn't exist, the defaults *will* be used.)
.PP
.Vb 1
\&   $form\->process( item => $row, params => {} );
.Ve
.PP
For the above call the 'default' on the field will not be used, which is
usually what you want.
.PP
When creating a new database record with your form, if you don't pass in an
empty row, then the field defaults will be used, or you can provide defaults
in an 'init_object'.
.PP
.Vb 2
\&   note: the form class has \*(Aqitem_class\*(Aq set already.
\&   $form\->process( schema => $schema, init_object => $obj ... );
.Ve
.PP
If you provide an empty row object for 'create' type
actions, however, you might want some defaults filled in. This can
be done by filling the values into the row object or by turning on the form
flag 'use_defaults_over_obj'.
.PP
.Vb 1
\&   $form\->process( item => $empty_row, use_defaults_over_obj => 1 );
.Ve
.PP
You could also pass in another object or hashref in the 'init_object' attribute,
and set the 'use_init_obj_over_item' flag:
.PP
.Vb 2
\&   $form\->process( item => $empty_row, init_object => $example,
\&                   use_init_obj_over_item => 1 );
.Ve
.PP
Note that the 'use_init_obj_over_item' and 'use_defaults_over_obj' flags
are automatically cleared (if you're using persistent forms).
.PP
There is a convenience method for setting 'defaults' on a number of fields at
once, the form's 'defaults' attribute, which uses the same mechanism as
\&'update_field_list' but only sets defaults. Note that this hashref is
structured like the update_field_list with regard to field names,
while the 'init_object' uses \*(L"structured\*(R" data:
.PP
.Vb 9
\&   my $defaults = {
\&       model => \*(Aqstandard\*(Aq,
\&       opts.color => \*(AqRed\*(Aq,
\&       opts.size  => \*(AqBig\*(Aq,
\&   };
\&   my $init_object => {
\&       model => \*(Aqstandard\*(Aq,
\&       opts  => { color => \*(AqRed\*(Aq, size => \*(AqBig\*(Aq }
\&   };
\&
\&   $form\->process( defaults => $defaults, ... );
\&   $form\->process( init_object => $init_object ... );
.Ve
.PP
In addition, the 'defaults' actually changes the 'default' stored in
the field definitions, while the init_object does not.
.PP
There is also an alternative attribute in the fields, 'default_over_obj', but
the new 'use_defaults_over_obj' and 'use_init_obj_over_item' flags, make it less
necessary. Note that the 'default_over_obj' attribute only provides a default if
an item/init_object and accessor exists.
.SS "Query parameters for defaults"
.IX Subsection "Query parameters for defaults"
You can use either the 'defaults' hashref or the 'init_object' to provide query
parameter 'defaults'. They should not be provided in the 'params' hash, because
then FormHandler will assume that the form has been posted and attempt to validate,
when you probably don't want to do until the form has been submitted.
.SH "Other methods for your form"
.IX Header "Other methods for your form"
.IP "options_$fieldname" 4
.IX Item "options_$fieldname"
If you have a 'Select' or 'Multiple' field, there are three ways to provide the
\&'options', or the list of values and labels for the select list. 1) Get them
automatically from a database table (from the relationship that is the field
name/accessor), 2) provide them in the field's 'options' attribute, or 2)
provide them from an options_$fieldname method in the form.
.Sp
An 'options_$fieldname' method should return a list of ordered key (option
value) and value (label to be displayed in the select list) pairs.
.Sp
.Vb 7
\&   sub options_fruit {
\&       return (
\&           1   => \*(Aqapples\*(Aq,
\&           2   => \*(Aqoranges\*(Aq,
\&           3   => \*(Aqkiwi\*(Aq,
\&       );
\&   }
.Ve
.Sp
You can also write custom methods to retrieve the option info from the database:
.Sp
.Vb 8
\&   sub options_country {
\&      my $self = shift;
\&      return unless $self\->schema;
\&      my @rows =
\&         $self\->schema\->resultset( \*(AqCountry\*(Aq )\->
\&            search( {}, { order_by => [\*(Aqrank\*(Aq, \*(Aqcountry_name\*(Aq] } )\->all;
\&      return [ map { $_\->digraph, $_\->country_name } @rows ];
\&   }
.Ve
.IP "default_$fieldname" 4
.IX Item "default_$fieldname"
Allows you to provide (in the form) a different initial value for a particular
field than that in the database (formerly init_value_$fieldname ).
.Sp
.Vb 5
\&   sub default_license {
\&      my ( $self, $field, $item ) = @_;
\&      return 0 unless $item && $item\->license_id;
\&      return $item\->license_id;
\&   }
.Ve
.Sp
Defaults can also be provided by the field's 'default' attribute and the
init_object.
.IP "validate_$fieldname" 4
.IX Item "validate_$fieldname"
Instead of using field constraints, you can choose to
do per-field validation customization in a form method:
.Sp
.Vb 5
\&    sub validate_age {
\&        my ( $self, $field ) = @_;
\&        $field\->add_error(\*(AqSorry, you must be 18\*(Aq)
\&            if $field\->value < 18;
\&    }
.Ve
.Sp
A different form method name for this can be specified with the field's
\&'set_validate' attribute:
.Sp
.Vb 1
\&    has_field \*(Aqage\*(Aq => ( type => \*(AqText\*(Aq, set_validate => \*(Aqcheck_age\*(Aq );
\&
\&    sub check_age {
\&       ...
\&    }
.Ve
.Sp
This method is not called when the field is empty.
.IP "validate" 4
.IX Item "validate"
Handle cross-field validation, or any validation that needs to be done after
the entire form is validated.  This form method is executed whether or not the form
has validated so far.
.Sp
.Vb 8
\&   sub validate {
\&      my $self = shift;
\&      if ( $self\->field(\*(Aqcount\*(Aq)\->value && $self\->field(\*(Aqduration\*(Aq)\->value )
\&      {
\&          $self\->field(\*(Aqduration\*(Aq)\->add_error(
\&                    \*(AqDo not enter both a count and a duration\*(Aq );
\&      }
\&   }
.Ve
.IP "update_model" 4
.IX Item "update_model"
Override the model's 'update_model' method to do additional updates.
.Sp
.Vb 6
\&   sub update_model {
\&      my $self = shift;
\&      $self\->next::method;
\&      my $event = $self\->item;
\&      $event\->update( ... );
\&   }
.Ve
.Sp
You may want to use \s-1DBIC\s0's 'txn_do' to keep updates in the same transaction.
See HTML::FormHandler::Manual::Cookbook for an example.
.SH "Filling the HTML form with values"
.IX Header "Filling the HTML form with values"
There are three ways to get the database or parameter values into the actual
\&\s-1HTML\s0 form.
.PP
You can use the field method 'fif' (where \*(L"f\*(R" is \*(L"form.field('book')\*(R" ):
.PP
.Vb 1
\&   [% f.fif %]
.Ve
.PP
You can use the hash returned by the form method \*(L"fif\*(R":
.PP
.Vb 1
\&   [% form.fif.book %]
.Ve
.PP
Or you can use HTML::FillInForm (and Catalyst::View::FillInform if you
are using Catalyst) and the \f(CW\*(C`$form\->fif hash\*(C'\fR.
.PP
If you are already using FormHandler field attributes in your form elements,
then using the field 'fif' method is probably easiest. If you are not using
FormHandler field attributes, then your choice is between using form.fif and
FillInForm.
.PP
If you are not using FormHandler select lists and you use FillInForm, then
it is possible to have FormHandler process \s-1HTML\s0 forms that have no template
references to the form object at all, as long as the field names are correct.
If you think that FillInForm is evil, then you could manage with only
using FormHandler to fill in the form.
.SH "Using FormHandler with hand-built forms"
.IX Header "Using FormHandler with hand-built forms"
You can use FormHandler to validate your data (and load it into a database
if you choose) with nothing from FormHandler in the templates or \s-1HTML\s0 at all.
The 'name' for the \s-1HTML\s0 form fields must match the \s-1HFH\s0 field names. If you have
compound or repeatable fields, the field names must follow the \s-1HFH\s0 naming
convention. (See the documentation for Compound and Repeatable fields.)
.PP
In order to load the form with values, you should use HTML::FillInForm, and
Catalyst::View::FillInForm if you're using Catalyst. You must put the
FormHandler 'fif' hash into the Catalyst stash.
.PP
.Vb 3
\&   $form\->process($params);
\&   $c\->stash( fillinform => $form\->fif );
\&   return unless $form\->validated;
.Ve
.PP
(Or you could use one of the options described in the previous section for
minimal interaction with the FormHandler form.)
.PP
If you have select lists and use the FormHandler 'Select' field types, you need
to be careful that the select lists don't get out of sync.
.SH "Testing"
.IX Header "Testing"
It's much easier to write unit tests for FormHandler forms than for
Catalyst controllers. The 't' directory of the downloaded distribution
has lots of examples. Here is an example of a test script for a \s-1DBIC\s0 form:
.PP
.Vb 2
\&   use Test::More tests => 14;
\&   use lib \*(Aqt/lib\*(Aq;
\&
\&   use_ok( \*(AqBookDB::Form::Book\*(Aq);
\&   use_ok( \*(AqBookDB::Schema::DB\*(Aq);
\&
\&   my $schema = BookDB::Schema::DB\->connect(\*(Aqdbi:SQLite:t/db/book.db\*(Aq);
\&   ok($schema, \*(Aqget db schema\*(Aq);
\&
\&   my $form = BookDB::Form::Book\->new(schema => $schema);
\&
\&   # This is munging up the equivalent of param data from a form
\&   my $good = {
\&       \*(Aqtitle\*(Aq => \*(AqHow to Test Perl Form Processors\*(Aq,
\&       \*(Aqauthor\*(Aq => \*(AqI.M. Author\*(Aq,
\&       \*(Aqgenres\*(Aq => [2, 4],
\&       \*(Aqformat\*(Aq       => 2,
\&       \*(Aqisbn\*(Aq   => \*(Aq123\-02345\-0502\-2\*(Aq ,
\&       \*(Aqpublisher\*(Aq => \*(AqEreWhon Publishing\*(Aq,
\&   };
\&   ok( $form\->process( params => $good ), \*(AqGood data\*(Aq );
\&
\&   my $book = $form\->item;
\&   END { $book\->delete };
\&   ok ($book, \*(Aqget book object from form\*(Aq);
\&   my $num_genres = $book\->genres\->count;
\&   is( $num_genres, 2, \*(Aqmultiple select list updated ok\*(Aq);
\&   is( $form\->field(\*(Aqformat\*(Aq)\->value, 2, \*(Aqget value for format\*(Aq );
\&
\&   my $bad_1 = {
\&       notitle => \*(Aqnot req\*(Aq,
\&       silly_field   => 4,
\&   };
\&   ok( !$form\->process( $bad_1 ), \*(Aqbad 1\*(Aq );
\&
\&   my $bad_2 = {
\&       \*(Aqtitle\*(Aq => "Another Silly Test Book",
\&       \*(Aqauthor\*(Aq => "C. Foolish",
\&       \*(Aqyear\*(Aq => \*(Aq1590\*(Aq,
\&       \*(Aqpages\*(Aq => \*(Aqtoo few\*(Aq,
\&       \*(Aqformat\*(Aq => \*(Aq22\*(Aq,
\&   };
\&   ok( !$form\->process( $bad_2 ), \*(Aqbad 2\*(Aq);
\&   ok( $form\->field(\*(Aqyear\*(Aq)\->has_errors, \*(Aqyear has error\*(Aq );
\&   ok( $form\->field(\*(Aqpages\*(Aq)\->has_errors, \*(Aqpages has error\*(Aq );
\&   ok( !$form\->field(\*(Aqauthor\*(Aq)\->has_errors, \*(Aqauthor has no error\*(Aq );
\&   ok( $form\->field(\*(Aqformat\*(Aq)\->has_errors, \*(Aqformat has error\*(Aq );
\&
\&   my $good = {
\&      title => "Another Silly Test Book",
\&      author => "C. Foolish",
\&      year => 1999,
\&      pages => 101,
\&      format => 2
\&   };
\&   ok( $form\->process($good), \*(Aqnow form validates\*(Aq );
.Ve
.SH "Messages"
.IX Header "Messages"
The base field class and the field subclasses have some 'built\-in' error messages.
These can be modified by setting the 'messages' hashref in the form or the
individual fields.
.PP
When a message is retrieved in a field with \f(CW\*(C`$field\->get_message(\*(Aqupload_file_\*(Aq)\*(C'\fR
for example, the 'get_message' method will look first in user-set field specific messages,
then in user-supplied form messages, finally in messages provided by the field classes.
.PP
.Vb 3
\&   package MyApp::Form;
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler\*(Aq;
\&
\&   sub build_messages {
\&       return { required => \*(Aq....\*(Aq, my_message => \*(Aq....\*(Aq };
\&   }
\&   ...
\&   my $form = MyApp::Form\->new( messages => { required => \*(Aq...\*(Aq, ...} );  
\&   ...
\&   has_field \*(Aqmy_field\*(Aq => ( messages => { required => \*(AqPlease provide a my_field\*(Aq },
\&       required => 1 );
.Ve
.SH "Localization"
.IX Header "Localization"
FormHandler's built-in errors are added to the form fields with \f(CW\*(C`$field\->add_error\*(C'\fR,
and to the form with \f(CW\*(C`$form\->add_form_error\*(C'\fR.
These methods call a \f(CW\*(C`$self\->_localize method\*(C'\fR which is a coderef set from
the field's default_localize sub, the field's 'localize_meth' attribute with
\&\f(CW\*(C`localize_meth => sub {}\*(C'\fR, or a form's sub localize_meth. The default localize
uses Locale::Maketext.  You can also use duck_type classes for localization.
See the documentation in \*(L" HTML::FormHandler::TraitFor::I18N \*(R" and the tests in xt/locale.t.
.PP
If you wish to skip localization for a particular message (such as for system errors)
you can use \f(CW\*(C`$field\->push_errors\*(C'\fR or \f(CW\*(C`$form\->push_form_errors\*(C'\fR.
.SH "Performance"
.IX Header "Performance"
FormHandler makes heavy use of Moose, so almost all of FormHandler's profiled time
will actually be in Moose methods. Some people prefer to use a persistent form class
(in a Moose attribute) in order to skip the form building step on each call. Other
people don't like that solution because state will remain in the form until the
next process call. The 'clear' method is called at the beginning of each 'process',
but additional Moose attributes in the form, etc, will have to cleared by the
programmer (with a method modifier on 'clear').
.PP
If you are loading options from the database and you don't need to have them refreshed
each time, you can set the 'do_not_reload' flag in the Select/Multiple field.
If you're not using the field widget roles, you can set the 'no_widgets' flag.
If you always use 'process' on each call (recommended) then you can set the
\&'no_preload' flag in the form to skip building results in \s-1BUILD\s0 (new).
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
