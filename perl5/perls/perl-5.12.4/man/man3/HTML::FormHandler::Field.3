.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Field 3"
.TH HTML::FormHandler::Field 3 "2012-02-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Field \- base class for fields
.SH "VERSION"
.IX Header "VERSION"
version 0.36002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Instances of Field subclasses are generally built by HTML::FormHandler
from 'has_field' declarations or the field_list, but they can also be constructed
using new (usually for test purposes).
.PP
.Vb 2
\&    use HTML::FormHandler::Field::Text;
\&    my $field = HTML::FormHandler::Field::Text\->new( name => $name, ... );
.Ve
.PP
In your custom field class:
.PP
.Vb 3
\&    package MyApp::Field::MyText;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler::Field::Text\*(Aq;
\&
\&    has \*(Aqmy_attribute\*(Aq => ( isa => \*(AqStr\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&    apply [ { transform => sub { ... } },
\&            { check => [\*(Aqfighter\*(Aq, \*(Aqbard\*(Aq, \*(Aqmage\*(Aq ], message => \*(Aq....\*(Aq }
\&          ];
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for form fields. The 'type' of a field class
is used in the FormHandler field_list or has_field to identify which field class to
load. If the type is not specified, it defaults to Text.
.PP
There are two rough categories of Field classes: those that do extra processing
and those that are simple validators. The 'Compound', 'Repeatable', and
\&'Select' fields are fields that are functional.
.PP
A number of field classes are provided by the distribution. The basic
for-validation (as opposed to 'functional') field types are:
.PP
.Vb 3
\&   Text
\&   Integer
\&   Boolean
.Ve
.PP
These field types alone would be enough for most applications, since
the equivalent of the others could be defined using field attributes,
custom validation methods, and applied actions.  There is some benefit
to having descriptive names, of course, and if you have multiple fields
requiring the same validation, defining a custom field class may be a
good idea.
.PP
Inheritance hierarchy of the distribution's field classes:
.PP
.Vb 10
\&   Compound
\&      Repeatable
\&   Text
\&      Money
\&      Password
\&      Integer
\&         PosInteger
\&   TextArea
\&      HtmlArea
\&   Select
\&      Multiple
\&      IntRange
\&         Hour
\&         Minute
\&         MonthDay
\&         Month
\&         Second
\&         Year
\&      MonthName
\&      Weekday
\&   Boolean
\&      Checkbox
\&   DateMDY
\&   DateTime
\&   Email
\&   PrimaryKey
.Ve
.PP
See the documentation or source for the individual fields.
.PP
Many field classes contain only a list of constraints and transformations
to apply. Some use the 'validate' method, which is called after the actions
are applied. Some build a custom select list using 'build_options'.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "Names, types, accessor"
.IX Subsection "Names, types, accessor"
.IP "name" 4
.IX Item "name"
The name of the field. Used in the \s-1HTML\s0 form. Often a db accessor.
The only required attribute.
.IP "type" 4
.IX Item "type"
The class or type of the field. The 'type' of HTML::FormHandler::Field::Money
is 'Money'. Classes that you define yourself are prefixed with '+'.
.IP "accessor" 4
.IX Item "accessor"
If the name of your field is different than your database accessor, use
this attribute to provide the accessor.
.IP "full_name" 4
.IX Item "full_name"
The name of the field with all parents:
.Sp
.Vb 1
\&   \*(Aqevent.start_date.month\*(Aq
.Ve
.IP "full_accessor" 4
.IX Item "full_accessor"
The field accessor with all parents
.IP "html_name" 4
.IX Item "html_name"
The full_name plus the form name if 'html_prefix' is set.
.IP "input_param" 4
.IX Item "input_param"
By default we expect an input parameter based on the field name.  This allows
you to look for a different input parameter.
.SS "Field data"
.IX Subsection "Field data"
.IP "inactive, is_inactive, is_active" 4
.IX Item "inactive, is_inactive, is_active"
Set the 'inactive' attribute to 1 if this field is inactive. The 'inactive' attribute
that isn't set or is set to 0 will make a field 'active'.
This provides a way to define fields in the form and selectively set them to inactive.
There is also an '_active' attribute, for internal use to indicate that the field has
been activated/inactivated on 'process' by the form's 'active'/'inactive' attributes.
.Sp
You can use the is_inactive and is_active methods to check whether this particular
field is active.
.Sp
.Vb 1
\&   if( $form\->field(\*(Aqfoo\*(Aq)\->is_active ) { ... }
.Ve
.IP "input" 4
.IX Item "input"
The input string from the parameters passed in.
.IP "value" 4
.IX Item "value"
The value as it would come from or go into the database, after being
acted on by transforms. Used to construct the \f(CW\*(C`$form\->values\*(C'\fR
hash. Validation and constraints act on 'value'.
.IP "fif" 4
.IX Item "fif"
Values used to fill in the form. Read only. Use a deflation to get
from 'value' to 'fif' if an inflator was used. (Deflations can be
done in two different places. Set 'deflate_to' => 'fif' to deflate
in fillinform'.)
.Sp
.Vb 1
\&   [% form.field(\*(Aqtitle\*(Aq).fif %]
.Ve
.IP "init_value" 4
.IX Item "init_value"
Initial value populated by init_from_object. You can tell if a field
has changed by comparing 'init_value' and 'value'. Read only.
.IP "input_without_param" 4
.IX Item "input_without_param"
Input for this field if there is no param. Needed for checkbox,
since an unchecked checkbox does not return a parameter.
.SS "Form, parent"
.IX Subsection "Form, parent"
.IP "form" 4
.IX Item "form"
A reference to the containing form.
.IP "parent" 4
.IX Item "parent"
A reference to the parent of this field. Compound fields are the
parents for the fields they contain.
.SS "Errors"
.IX Subsection "Errors"
.IP "errors" 4
.IX Item "errors"
Returns the error list for the field. Also provides 'num_errors',
\&'has_errors', 'push_errors' and 'clear_errors' from Array
trait. Use 'add_error' to add an error to the array if you
want to use a MakeText language handle. Default is an empty list.
.IP "add_error" 4
.IX Item "add_error"
Add an error to the list of errors.  If \f(CW$field\fR\->form
is defined then process error message as Maketext input.
See \f(CW$form\fR\->language_handle for details. Returns undef.
.Sp
.Vb 1
\&    return $field\->add_error( \*(Aqbad data\*(Aq ) if $bad;
.Ve
.IP "error_fields" 4
.IX Item "error_fields"
Compound fields will have an array of errors from the subfields.
.SS "Attributes for creating \s-1HTML\s0"
.IX Subsection "Attributes for creating HTML"
There's a generic 'html_attr' hashref attribute that can be used to set
arbitrary \s-1HTML\s0 attributes on a field's input tag.
.PP
.Vb 1
\&   has_field \*(Aqfoo\*(Aq => ( html_attr => { readonly => 1, my_attr => \*(Aqabc\*(Aq } );
.Ve
.PP
The 'label_attr' hashref is for label attributes, and the 'wrapper_attr'
is for attributes on the wrapping element (a 'div' for the standard 'simple'
wrapper).
.PP
The javascript value of the javascript attribute is entered completely.
.PP
.Vb 1
\&   javascript  \- for a Javascript string
.Ve
.PP
The following are used in rendering \s-1HTML\s0, but are handled specially.
.PP
.Vb 5
\&   label       \- Text label for this field. Defaults to ucfirst field name.
\&   id          \- Useful for javascript (default is html_name. to prefix with
\&                 form name, use \*(Aqhtml_prefix\*(Aq in your form)
\&   render_filter \- Coderef for filtering fields before rendering. By default
\&                 changes >, <, &, " to the html entities
.Ve
.PP
The order attribute may be used to set the order in which fields are rendered.
.PP
.Vb 2
\&   order       \- Used for sorting errors and fields. Built automatically,
\&                 but may also be explicitly set
.Ve
.PP
The following are deprecated. Use 'html_attr', 'label_attr', and 'wrapper_attr'
instead.
.PP
.Vb 7
\&   css_class   \- instead use wrapper_attr => { class => \*(Aq...\*(Aq }
\&   input_class \- instead use html_attr => { class => \*(Aq...\*(Aq }
\&   title       \- instead use html_attr => { title => \*(Aq...\*(Aq }
\&   style       \- instead use html_attr => { style => \*(Aq...\*(Aq }
\&   disabled    \- instead use html_attr => { disabled => \*(Aqdisabled\*(Aq }
\&   tabindex    \- instead use html_attr => { tabindex => 1 }
\&   readonly    \- instead use html_attr => { readonly => \*(Aqreadonly\*(Aq }
.Ve
.PP
Rendering of the various \s-1HTML\s0 attributes is done by calling the 'process_attrs'
function (from HTML::FormHandler::Render::Util) and passing in a method that
adds in error classes, provides backward compatibility with the deprecated
attributes, etc.
.PP
.Vb 5
\&    attribute hashref            wrapping method
\&    =================            ================
\&    html_attr                    attributes
\&    label_attr                   label_attributes
\&    wrapper_attr                 wrapper_attributes
.Ve
.PP
In addition, these 'wrapping method' call a hook method in the form class,
\&'field_html_attributes' which you can use to customize and localize the various
attributes.
.PP
.Vb 4
\&   sub field_html_attributes {
\&       my ( $self, $field, $type, $attr ) = @_;
\&       $attr\->{class} = \*(Aqlabel\*(Aq if $type eq \*(Aqlabel\*(Aq;
\&   }
.Ve
.PP
The 'process_attrs' function will handle an array of strings, such as for the
\&'class' attribute.
.SS "html5_type_attr [string]"
.IX Subsection "html5_type_attr [string]"
This string is used when rendering the input tag as the value for the type attribute.
It is used when the form has the is_html5 flag on.
.SS "widget"
.IX Subsection "widget"
The 'widget' attribute is used in rendering, so if you are
not using FormHandler's rendering facility, you don't need this
attribute.
It is intended for use in generating \s-1HTML\s0, in templates and the
rendering roles, and is used in HTML::FormHandler::Render::Simple.
Fields of different type can use the same widget.
.PP
This attribute is set in the field classes, or in the fields
defined in the form. If you want a new widget type, use a new
name and provide a \f(CW\*(Aqwidget_<name>\*(Aq\fR method in your copy
of Render::Simple or in your form class.
.PP
If you are using a template based rendering system you will want
to create a widget template.
(see HTML::FormHandler::Manual::Templates)
.PP
If you are using the widget roles, you can specify the widget
with the short class name instead.
.PP
Widget types for the provided field classes:
.PP
.Vb 10
\&    Widget         : Field classes
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-:\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    text (Text)            : Text, Integer
\&    checkbox (Checkbox)    : Checkbox, Boolean
\&    radio_group
\&       (RadioGroup)        : Select, Multiple, IntRange (etc)
\&    select (Select)        : Select, Multiple, IntRange (etc)
\&    checkbox_group
\&       (CheckboxGroup)     : Multiple select
\&    textarea (Textarea)    : TextArea, HtmlArea
\&    compound (Compound)    : Compound, Repeatable, DateTime
\&    password (Password)    : Password
\&    hidden (Hidden)        : Hidden
\&    submit (Submit)        : Submit
\&    reset (Reset)          : Reset
\&    no_render (NoRender)   :
\&    upload (Upload)        : Upload
.Ve
.PP
Widget roles are automatically applied to field classes
unless they already have a 'render' method. Render::Simple
will fall back to doing \f(CW\*(C`$field\->render\*(C'\fR if the corresponding
widget method does not exist.
.PP
You can create your own widget roles and specify the namespace
in 'widget_name_space'. In the form:
.PP
.Vb 1
\&    has \*(Aq+widget_name_space\*(Aq => ( default => sub { [\*(AqMyApp::Widget\*(Aq] } );
.Ve
.PP
If you want to use a fully specified role name for a widget, you
can prefix it with a '+':
.PP
.Vb 1
\&   widget => \*(Aq+MyApp::Widget::SomeWidget\*(Aq
.Ve
.PP
For more about widgets, see HTML::FormHandler::Manual::Rendering.
.SS "Flags"
.IX Subsection "Flags"
.Vb 3
\&   password  \- prevents the entered value from being displayed in the form
\&   writeonly \- The initial value is not taken from the database
\&   noupdate  \- Do not update this field in the database (does not appear in $form\->value)
.Ve
.SS "Form methods for fields"
.IX Subsection "Form methods for fields"
These provide the name of a method in a form (not the field ) which will act
on a particular field.
.IP "set_validate" 4
.IX Item "set_validate"
Specify a form method to be used to validate this field.
The default is \f(CW\*(C`\*(Aqvalidate_\*(Aq . $field\->name\*(C'\fR. Periods in field names
will be replaced by underscores, so that the field 'addresses.city' will
use the 'validate_addresses_city' method for validation.
.Sp
.Vb 2
\&   has_field \*(Aqtitle\*(Aq => ( isa => \*(AqStr\*(Aq, set_validate => \*(Aqcheck_title\*(Aq );
\&   has_field \*(Aqsubtitle\*(Aq => ( isa => \*(AqStr\*(Aq, set_validate => \*(Aqcheck_title\*(Aq );
.Ve
.IP "set_default" 4
.IX Item "set_default"
The name of the method in the form that provides a field's default value.
Default is \f(CW\*(C`\*(Aqdefault_\*(Aq . $field\->name\*(C'\fR. Periods replaced by underscores.
.IP "default" 4
.IX Item "default"
Provide an initial value just like the 'set_default' method, except in the field
declaration:
.Sp
.Vb 1
\&  has_field \*(Aqbax\*(Aq => ( default => \*(AqDefault bax\*(Aq );
.Ve
.Sp
FormHandler has flipped back and forth a couple of times about whether a default
specified in the has_field definition should override values provided in an
initial item or init_object. Sometimes people want one behavior, and sometimes
the other. Now 'default' does *not* override.
.Sp
If you pass in a model object with \f(CW\*(C`item => $row\*(C'\fR or an initial object
with \f(CW\*(C`init_object => {....}\*(C'\fR the values in that object will be used instead
of values provided in the field definition with 'default' or 'default_fieldname'.
If you want defaults that override the item/init_object, you can use the form
flags 'use_defaults_over_obj' and 'use_init_obj_over_item'.
.Sp
You could also put your defaults into your row or init_object instead.
.Sp
See also HTML::FormHandler::Manual::Intro#Defaults.
.IP "default_over_obj" 4
.IX Item "default_over_obj"
This is deprecated; look into using 'use_defaults_over_obj' or 'use_init_obj_over_item'
flags instead. They allow using the standard 'default' attribute.
.Sp
Allows setting defaults which will override values provided with an item/init_object.
.Sp
.Vb 1
\&   has_field \*(Aqquux\*(Aq => ( default_over_obj => \*(Aqdefault quux\*(Aq );
.Ve
.Sp
At this time there is no equivalent of 'set_default', but the type of the attribute
is not defined so you can provide default values in a variety of other ways,
including providing a trait which does 'build_default_over_obj'. For examples,
see tests in the distribution.
.SH "Constraints and Validations"
.IX Header "Constraints and Validations"
.SS "Constraints set in attributes"
.IX Subsection "Constraints set in attributes"
.IP "required" 4
.IX Item "required"
Flag indicating whether this field must have a value
.IP "unique" 4
.IX Item "unique"
For \s-1DB\s0 field \- check for uniqueness. Action is performed by
the \s-1DB\s0 model.
.IP "messages" 4
.IX Item "messages"
.Vb 1
\&    messages => { required => \*(Aq...\*(Aq, unique => \*(Aq...\*(Aq }
.Ve
.Sp
Set messages created by FormHandler by setting in the 'messages'
hashref. Some field subclasses have additional settable messages.
.Sp
required:  Error message text added to errors if required field is not present
The default is \*(L"Field <field label> is required\*(R".
.Sp
unique: message for when 'unique' is set, but field is not unique
.IP "range_start" 4
.IX Item "range_start"
.PD 0
.IP "range_end" 4
.IX Item "range_end"
.PD
Field values are validated against the specified range if one
or both of range_start and range_end are set and the field
does not have 'options'.
.Sp
The IntRange field uses this range to create a select list
with a range of integers.
.Sp
In a FormHandler field_list
.Sp
.Vb 5
\&    age => {
\&        type            => \*(AqInteger\*(Aq,
\&        range_start     => 18,
\&        range_end       => 120,
\&    }
.Ve
.IP "not_nullable" 4
.IX Item "not_nullable"
Fields that contain 'empty' values such as '' are changed to undef in the validation process.
If this flag is set, the value is not changed to undef. If your database column requires
an empty string instead of a null value (such as a \s-1NOT\s0 \s-1NULL\s0 column), set this attribute.
.Sp
.Vb 4
\&    has_field \*(Aqdescription\*(Aq => (
\&        type => \*(AqTextArea\*(Aq,
\&        not_nullable => 1,
\&    );
.Ve
.Sp
This attribute is also used when you want an empty array to stay an empty array and not
be set to undef.
.SS "apply"
.IX Subsection "apply"
Use the 'apply' keyword to specify an ArrayRef of constraints and coercions to
be executed on the field at validate_field time.
.PP
.Vb 6
\&   has_field \*(Aqtest\*(Aq => (
\&      apply => [ \*(AqMooseType\*(Aq,
\&                 { check => sub {...}, message => { } },
\&                 { transform => sub { ... lc(shift) ... } }
\&               ],
\&   );
.Ve
.PP
In general the action can be of three types: a Moose type (which is
represented by its name), a transformation (which is a callback called on
the value of the field), or a constraint ('check') which performs a 'smart match'
on the value of the field.  Currently we implement the smart match
in our code \- but in the future when Perl 5.10 is more widely used we'll switch
to the core
http://search.cpan.org/~rgarcia/perl\-5.10.0/pod/perlsyn.pod#Smart_matching_in_detail <http://search.cpan.org/~rgarcia/perl-5.10.0/pod/perlsyn.pod#Smart_matching_in_detail>
smart match operator.
.PP
The Moose type action first tries to coerce the value \-
then it checks the result, so you can use it instead of both constraints and
tranformations \- \s-1TIMTOWTDI\s0.  For most constraints and transformations it is
your choice as to whether you use a Moose type or use a 'check' or 'transform'.
.PP
All three types define a message to be presented to the user in the case of
failure. Messages are passed to Locale::MakeText, and can either be simple
strings or an array suitable for MakeText, such as:
.PP
.Vb 2
\&     message => [\*(AqEmail should be of the format [_1]\*(Aq,
\&                 \*(Aqsomeuser@example.com\*(Aq ]
.Ve
.PP
Transformations and coercions are called in an eval
to catch the errors. Warnings are trapped in a sigwarn handler.
.PP
All the actions are called in the order that they are defined, so that you can
check constraints after transformations and vice versa. You can weave all three
types of actions in any order you need. The actions specified with 'apply' will
be stored in an 'actions' array.
.PP
To declare actions inside a field class use HTML::FormHandler::Moose and
\&'apply' sugar:
.PP
.Vb 3
\&   package MyApp::Field::Test;
\&   use HTML::FormHandler::Moose;
\&   extends \*(AqHTML::FormHandler::Field;
\&
\&   apply [ \*(AqSomeConstraint\*(Aq, { check => ..., message => .... } ];
\&
\&   1;
.Ve
.PP
Actions specified with apply are cumulative. Actions may be specified in
field classes and additional actions added in the 'has_field' declaration.
.PP
In addition to being a string, Messages may be arrayrefs, for localization,
or coderefs, which will be passed a reference to the field and the original value.
.PP
.Vb 5
\&   apply [ { check => [\*(Aqabc\*(Aq], message => \e&err_message } ];
\&   sub err_message {
\&      my ( $value, $field ) = @_;
\&      return $field\->name . ": must .... ";
\&   }
.Ve
.PP
You can see examples of field classes with 'apply' actions in the source for
HTML::FormHandler::Field::Money and HTML::FormHandler::Field::Email, and
in t/constraints.t.
.SS "Moose types for constraints and transformations"
.IX Subsection "Moose types for constraints and transformations"
Moose types can be used to do both constraints and transformations. If a coercion
exists it will be applied, resulting in a transformation. You can use type
constraints form MooseX::Types> libraries or defined using
Moose::Util::TypeConstraints.
.PP
A Moose type defined with Moose::Util::TypeConstraints:
  subtype 'MyStr'
      => as 'Str'
      => where { /^a/ };
.PP
This is a simple constraint checking if the value string starts with the letter 'a'.
.PP
Another Moose type:
  subtype 'MyInt'
      => as 'Int';
  coerce 'MyInt'
      => from 'MyStr'
      => via { return \f(CW$1\fR if /(\ed+)/ };
.PP
This type contains a coercion.
.PP
You can use them in a field like this (types defined with MooseX::Types
would not be quoted):
.PP
.Vb 3
\&   has_field \*(Aqsome_text_to_int\*(Aq => (
\&       apply => [ \*(AqMyStr\*(Aq, \*(AqMyInt\*(Aq ]
\&   );
.Ve
.PP
This will check if the field contains a string starting with 'a' \- and then
coerce it to an integer by extracting the first continuous string of digits.
.PP
If the error message returned by the Moose type is not suitable for displaying
in a form, you can define a different error message by using the 'type' and
\&'message' keys in a hashref:
.PP
.Vb 1
\&   apply => [ { type => \*(AqMyStr\*(Aq, message => \*(AqNot a valid value\*(Aq } ];
.Ve
.SS "Non-Moose checks and transforms"
.IX Subsection "Non-Moose checks and transforms"
A simple 'check' constraint uses the 'check' keyword pointing to a coderef,
a regular expression, or an array of valid values, plus a message.
.PP
A 'check' coderef will be passed the current value of the field. It should
return true or false:
.PP
.Vb 8
\&  has_field \*(Aqthis_num\*(Aq => (
\&      apply => [
\&         {
\&             check => sub { if ( $_[0] =~ /(\ed+)/ ) { return $1 > 10 } },
\&             message => \*(AqMust contain number greater than 10\*(Aq,
\&         }
\&      ]
\&  );
.Ve
.PP
A 'check' regular expression:
.PP
.Vb 3
\&  has_field \*(Aqsome_text\*(Aq => (
\&      apply => [ { check => qr/aaa/, message => \*(AqMust contain aaa\*(Aq } ],
\&  );
.Ve
.PP
A 'check' array of valid values:
.PP
.Vb 3
\&  has_field \*(Aqmore_text\*(Aq => (
\&      apply => [ { check => [\*(Aqaaa\*(Aq, \*(Aqbbb\*(Aq], message => \*(AqMust be aaa or bbb\*(Aq } ]
\&  );
.Ve
.PP
A simple transformation uses the 'transform' keyword and a coderef.
The coderef will be passed the current value of the field and should return
a transformed value.
.PP
.Vb 3
\&  has_field \*(Aqsprintf_filter\*(Aq => (
\&      apply => [ { transform => sub{ sprintf \*(Aq<%.1g>\*(Aq, $_[0] } } ]
\&  );
.Ve
.SS "trim"
.IX Subsection "trim"
An action to trim the field. By default
this contains a transform to strip beginning and trailing spaces.
Set this attribute to null to skip trimming, or supply a different
transform.
.PP
.Vb 7
\&  trim => { transform => sub {
\&      my $string = shift;
\&      $string =~ s/^\es+//;
\&      $string =~ s/\es+$//;
\&      return $string;
\&  } }
\&  trim => { type => MyTypeConstraint }
.Ve
.PP
Trimming is performed before any other defined actions.
.SS "deflation, deflate"
.IX Subsection "deflation, deflate"
A 'deflation' is a coderef that will convert from an inflated value back to a
flat data representation suitable for displaying in an \s-1HTML\s0 field.
If deflation is defined for a field it is automatically used for data that is
taken from the database.
.PP
.Vb 9
\&   has_field \*(Aqmy_date_time\*(Aq => (
\&      type => \*(AqCompound\*(Aq,
\&      apply => [ { transform => sub{ DateTime\->new( $_[0] ) } } ],
\&      deflation => sub { { year => $_[0]\->year, month => $_[0]\->month, day => $_[0]\->day } },
\&      fif_from_value => 1,
\&   );
\&   has_field \*(Aqmy_date_time.year\*(Aq;
\&   has_field \*(Aqmy_date_time.month\*(Aq;
\&   has_field \*(Aqmy_date_time.day\*(Aq;
.Ve
.PP
You can also use a 'deflate' method in a custom field class. See the Date field
for an example. If the deflation requires data that may vary (such as a format)
string and thus needs access to 'self', you would need to use the deflate method
since the deflation coderef is only passed the current value of the field
.PP
Normally if you have a deflation, you will need a matching inflation, which can be
supplied via a 'transform' action. When using a 'transform', the 'value' hash only
contains reliably inflated values after validation has been performed, since
inflation is performed at validation time.
.PP
Deflation can be done at two different places: transforming the value that's saved
from the initial_object/item, or when retrieving the 'fif' (fill-in-form) value that's
displayed in the \s-1HTML\s0 form. The default is \f(CW\*(C`deflate_to => \*(Aqvalue\*(Aq\*(C'\fR. To deflate
when getting the 'fif' value set 'deflate_to' to 'fif'. (See t/deflate.t for examples.)
.SH "Processing and validating the field"
.IX Header "Processing and validating the field"
.SS "validate_field"
.IX Subsection "validate_field"
This is the base class validation routine. Most users will not
do anything with this. It might be useful for method modifiers,
if you want code that executed before or after the validation
process.
.SS "validate"
.IX Subsection "validate"
This field method can be used in addition to or instead of 'apply' actions
in custom field classes.
It should validate the field data and set error messages on
errors with \f(CW\*(C`$field\->add_error\*(C'\fR.
.PP
.Vb 5
\&    sub validate {
\&        my $field = shift;
\&        my $value = $field\->value;
\&        return $field\->add_error( ... ) if ( ... );
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
