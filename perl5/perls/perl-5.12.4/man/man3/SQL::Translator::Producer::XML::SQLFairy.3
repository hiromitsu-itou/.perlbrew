.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Producer::XML::SQLFairy 3"
.TH SQL::Translator::Producer::XML::SQLFairy 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Producer::XML::SQLFairy \- SQLFairy's default XML format
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::Translator;
\&
\&  my $t              = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      to             => \*(AqXML\-SQLFairy\*(Aq,
\&      filename       => \*(Aqschema.sql\*(Aq,
\&      show_warnings  => 1,
\&  );
\&
\&  print $t\->translate;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates \s-1XML\s0 output of a schema, in the flavor of \s-1XML\s0 used natively by the
SQLFairy project (SQL::Translator). This format is detailed here.
.PP
The \s-1XML\s0 lives in the \f(CW\*(C`http://sqlfairy.sourceforge.net/sqlfairy.xml\*(C'\fR namespace.
With a root element of <schema>.
.PP
Objects in the schema are mapped to tags of the same name as the objects class
(all lowercase).
.PP
The attributes of the objects (e.g. \f(CW$field\fR\->name) are mapped to attributes of
the tag, except for sql, comments and action, which get mapped to child data
elements.
.PP
List valued attributes (such as the list of fields in an index)
get mapped to comma separated lists of values in the attribute.
.PP
Child objects, such as a tables fields, get mapped to child tags wrapped in a
set of container tags using the plural of their contained classes name.
.PP
An objects' extra attribute (a hash of arbitrary data) is
mapped to a tag called extra, with the hash of data as attributes, sorted into
alphabetical order.
.PP
e.g.
.PP
.Vb 2
\&    <schema name="" database=""
\&      xmlns="http://sqlfairy.sourceforge.net/sqlfairy.xml">
\&
\&      <tables>
\&        <table name="Story" order="1">
\&          <fields>
\&            <field name="id" data_type="BIGINT" size="20"
\&              is_nullable="0" is_auto_increment="1" is_primary_key="1"
\&              is_foreign_key="0" order="3">
\&              <extra ZEROFILL="1" />
\&              <comments></comments>
\&            </field>
\&            <field name="created" data_type="datetime" size="0"
\&              is_nullable="1" is_auto_increment="0" is_primary_key="0"
\&              is_foreign_key="0" order="1">
\&              <extra />
\&              <comments></comments>
\&            </field>
\&            ...
\&          </fields>
\&          <indices>
\&            <index name="foobar" type="NORMAL" fields="foo,bar" options="" />
\&          </indices>
\&        </table>
\&      </tables>
\&
\&      <views>
\&        <view name="email_list" fields="email" order="1">
\&          <sql>SELECT email FROM Basic WHERE email IS NOT NULL</sql>
\&        </view>
\&      </views>
\&
\&    </schema>
.Ve
.PP
To see a complete example of the \s-1XML\s0 translate one of your schema :)
.PP
.Vb 1
\&  $ sqlt \-f MySQL \-t XML\-SQLFairy schema.sql
.Ve
.SH "ARGS"
.IX Header "ARGS"
.IP "add_prefix" 4
.IX Item "add_prefix"
Set to true to use the default namespace prefix of 'sqlf', instead of using
the default namespace for
\&\f(CW\*(C`http://sqlfairy.sourceforge.net/sqlfairy.xml namespace\*(C'\fR
.Sp
e.g.
.Sp
.Vb 2
\& <!\-\- add_prefix=0 \-\->
\& <field name="foo" />
\&
\& <!\-\- add_prefix=1 \-\->
\& <sqlf:field name="foo" />
.Ve
.IP "prefix" 4
.IX Item "prefix"
Set to the namespace prefix you want to use for the
\&\f(CW\*(C`http://sqlfairy.sourceforge.net/sqlfairy.xml namespace\*(C'\fR
.Sp
e.g.
.Sp
.Vb 2
\& <!\-\- prefix=\*(Aqfoo\*(Aq \-\->
\& <foo:field name="foo" />
.Ve
.IP "newlines" 4
.IX Item "newlines"
If true (the default) inserts newlines around the \s-1XML\s0, otherwise the schema is
written on one line.
.IP "indent" 4
.IX Item "indent"
When using newlines the number of whitespace characters to use as the indent.
Default is 2, set to 0 to turn off indenting.
.SH "LEGACY FORMAT"
.IX Header "LEGACY FORMAT"
The previous version of the SQLFairy \s-1XML\s0 allowed the attributes of the the
schema objects to be written as either xml attributes or as data elements, in
any combination. The old producer could produce attribute only or data element
only versions. While this allowed for lots of flexibility in writing the \s-1XML\s0
the result is a great many possible \s-1XML\s0 formats, not so good for \s-1DTD\s0 writing,
XPathing etc! So we have moved to a fixed version described above.
.PP
This version of the producer will now only produce the new style \s-1XML\s0.
To convert your old format files simply pass them through the translator :)
.PP
.Vb 1
\& $ sqlt \-f XML\-SQLFairy \-t XML\-SQLFairy schema\-old.xml > schema\-new.xml
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Ken Youens-Clark <kclark@cpan.org>,
Darren Chamberlain <darren@cpan.org>,
Mark Addison <mark.addison@itn.co.uk>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), SQL::Translator, SQL::Translator::Parser::XML::SQLFairy,
SQL::Translator::Schema, XML::Writer.
