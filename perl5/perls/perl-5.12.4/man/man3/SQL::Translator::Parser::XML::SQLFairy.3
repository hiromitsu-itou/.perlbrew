.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Parser::XML::SQLFairy 3"
.TH SQL::Translator::Parser::XML::SQLFairy 3 "2011-05-05" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Parser::XML::SQLFairy \- parser for SQL::Translator's XML.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::Translator;
\&
\&  my $translator = SQL::Translator\->new( show_warnings  => 1 );
\&
\&  my $out = $obj\->translate(
\&      from     => \*(AqXML\-SQLFairy\*(Aq,
\&      to       => \*(AqMySQL\*(Aq,
\&      filename => \*(Aqschema.xml\*(Aq,
\&  ) or die $translator\->error;
\&
\&  print $out;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This parser handles the flavor of \s-1XML\s0 used natively by the SQLFairy
project (SQL::Translator).  The \s-1XML\s0 must be in the namespace
\&\*(L"http://sqlfairy.sourceforge.net/sqlfairy.xml.\*(R"
See SQL::Translator::Producer::XML::SQLFairy for details of this format.
.PP
You do not need to specify every attribute of the Schema objects as any missing
from the \s-1XML\s0 will be set to their default values. e.g. A field could be written
using only;
.PP
.Vb 1
\& <sqlf:field name="email" data_type="varchar" size="255" />
.Ve
.PP
Instead of the full;
.PP
.Vb 4
\& <sqlf:field name="email" data_type="varchar" size="255" is_nullable="1"
\&   is_auto_increment="0" is_primary_key="0" is_foreign_key="0" order="4">
\&   <sqlf:comments></sqlf:comments>
\& </sqlf:field>
.Ve
.PP
If you do not explicitly set the order of items using order attributes on the
tags then the order the tags appear in the \s-1XML\s0 will be used.
.SS "default_value"
.IX Subsection "default_value"
Leave the attribute out all together to use the default in Schema::Field.
Use empty quotes or '\s-1EMPTY_STRING\s0' for a zero lenth string. '\s-1NULL\s0' for an
explicit null (currently sets default_value to undef in the
Schema::Field obj).
.PP
.Vb 3
\&  <sqlf:field default_value="" />                <!\-\- Empty string \-\->
\&  <sqlf:field default_value="EMPTY_STRING" />    <!\-\- Empty string \-\->
\&  <sqlf:field default_value="NULL" />            <!\-\- NULL \-\->
.Ve
.SS "\s-1ARGS\s0"
.IX Subsection "ARGS"
Doesn't take any extra parser args at the moment.
.SH "LEGACY FORMAT"
.IX Header "LEGACY FORMAT"
The previous version of the SQLFairy \s-1XML\s0 allowed the attributes of the the
schema objects to be written as either xml attributes or as data elements, in
any combination. While this allows for lots of flexibility in writing the \s-1XML\s0
the result is a great many possible \s-1XML\s0 formats, not so good for \s-1DTD\s0 writing,
XPathing etc! So we have moved to a fixed version described in
SQL::Translator::Producer::XML::SQLFairy.
.PP
This version of the parser will still parse the old formats and emmit warnings
when it sees them being used but they should be considered \fBheavily
depreciated\fR.
.PP
To convert your old format files simply pass them through the translator :)
.PP
.Vb 1
\& $ sqlt \-f XML\-SQLFairy \-t XML\-SQLFairy schema\-old.xml > schema\-new.xml
.Ve
.SH "BUGS"
.IX Header "BUGS"
Ignores the order attribute for Constraints, Views, Indices, Views, Triggers
and Procedures, using the tag order instead. (This is the order output by the
SQLFairy \s-1XML\s0 producer).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, SQL::Translator, SQL::Translator::Producer::XML::SQLFairy,
SQL::Translator::Schema.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Support options attribute.
.IP "\(bu" 4
Test foreign keys are parsed ok.
.IP "\(bu" 4
Control over defaulting.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark D. Addison <mark.addison@itn.co.uk>,
Jonathan Yu <frequency@cpan.org>
