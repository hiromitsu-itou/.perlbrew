.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mechanize 3"
.TH Mechanize 3 "2011-10-29" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::WWW::Mechanize \- Testing\-specific WWW::Mechanize subclass
.SH "VERSION"
.IX Header "VERSION"
Version 1.38
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates
features for web application testing.  For example:
.PP
.Vb 2
\&    use Test::More tests => 5;
\&    use Test::WWW::Mechanize;
\&
\&    my $mech = Test::WWW::Mechanize\->new;
\&    $mech\->get_ok( $page );
\&    $mech\->base_is( \*(Aqhttp://petdance.com/\*(Aq, \*(AqProper <BASE HREF>\*(Aq );
\&    $mech\->title_is( \*(AqInvoice Status\*(Aq, "Make sure we\*(Aqre on the invoice page" );
\&    $mech\->text_contains( \*(AqAndy Lester\*(Aq, \*(AqMy name somewhere\*(Aq );
\&    $mech\->content_like( qr/(cpan|perl)\e.org/, \*(AqLink to perl.org or CPAN\*(Aq );
.Ve
.PP
This is equivalent to:
.PP
.Vb 2
\&    use Test::More tests => 5;
\&    use WWW::Mechanize;
\&
\&    my $mech = WWW::Mechanize\->new;
\&    $mech\->get( $page );
\&    ok( $mech\->success );
\&    is( $mech\->base, \*(Aqhttp://petdance.com\*(Aq, \*(AqProper <BASE HREF>\*(Aq );
\&    is( $mech\->title, \*(AqInvoice Status\*(Aq, "Make sure we\*(Aqre on the invoice page" );
\&    ok( index( $mech\->content( format => \*(Aqtext\*(Aq ), \*(AqAndy Lester\*(Aq ) >= 0, \*(AqMy name somewhere\*(Aq );
\&    like( $mech\->content, qr/(cpan|perl)\e.org/, \*(AqLink to perl.org or CPAN\*(Aq );
.Ve
.PP
but has nicer diagnostics if they fail.
.PP
Default descriptions will be supplied for most methods if you omit them. e.g.
.PP
.Vb 6
\&    my $mech = Test::WWW::Mechanize\->new;
\&    $mech\->get_ok( \*(Aqhttp://petdance.com/\*(Aq );
\&    $mech\->base_is( \*(Aqhttp://petdance.com/\*(Aq );
\&    $mech\->title_is( \*(AqInvoice Status\*(Aq );
\&    $mech\->content_contains( \*(AqAndy Lester\*(Aq );
\&    $mech\->content_like( qr/(cpan|perl)\e.org/ );
.Ve
.PP
results in
.PP
.Vb 5
\&    ok \- Got \*(Aqhttp://petdance.com/\*(Aq ok
\&    ok \- Base is \*(Aqhttp://petdance.com/\*(Aq
\&    ok \- Title is \*(AqInvoice Status\*(Aq
\&    ok \- Text contains \*(AqAndy Lester\*(Aq
\&    ok \- Content is like \*(Aq(?\-xism:(cpan|perl)\e.org)\*(Aq
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .SS "new( %args )"
.el .SS "new( \f(CW%args\fP )"
.IX Subsection "new( %args )"
Behaves like, and calls, WWW::Mechanize's \f(CW\*(C`new\*(C'\fR method.  Any parms
passed in get passed to WWW::Mechanize's constructor.
.PP
You can pass in \f(CW\*(C`autolint => 1\*(C'\fR to make Test::WWW::Mechanize
automatically run HTML::Lint after any of the following methods are
called. You can also pass in an HTML::Lint object like this:
.PP
.Vb 2
\&    my $lint = HTML::Lint\->new( only_types => HTML::Lint::Error::STRUCTURE );
\&    my $mech = Test::WWW::Mechanize\->new( autolint => $lint );
.Ve
.IP "\(bu" 4
\&\fIget_ok()\fR
.IP "\(bu" 4
\&\fIpost_ok()\fR
.IP "\(bu" 4
\&\fIsubmit_form_ok()\fR
.IP "\(bu" 4
\&\fIfollow_link_ok()\fR
.IP "\(bu" 4
\&\fIclick_ok()\fR
.PP
This means you no longer have to do the following:
.PP
.Vb 3
\&    my $mech = Test::WWW::Mechanize\->new();
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
\&    $mech\->html_lint_ok( \*(AqIntro page looks OK\*(Aq );
.Ve
.PP
and can simply do
.PP
.Vb 2
\&    my $mech = Test::WWW::Mechanize\->new( autolint => 1 );
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
.Ve
.PP
The \f(CW\*(C`$mech\->get_ok()\*(C'\fR only counts as one test in the test count.  Both the
main \s-1IO\s0 operation and the linting must pass for the entire test to pass.
.SH "METHODS: HTTP VERBS"
.IX Header "METHODS: HTTP VERBS"
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIget()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1GET\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->head_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->head_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->head_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIhead()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1HEAD\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->post_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->post_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->post_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIpost()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1POST\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->put_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->put_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->put_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIput()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1PUT\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->submit_form_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->submit_form_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->submit_form_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`submit_form()\*(C'\fR call and executes tests on the results.
The form must be found, and then submitted successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`submit_form()\*(C'\fR.
Note that the parms to \f(CW\*(C`submit_form()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 7
\&    $mech\->submit_form_ok( {
\&            form_number => 3,
\&            fields      => {
\&                answer => 42
\&            },
\&        }, \*(Aqnow we just need the question\*(Aq
\&    );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIsubmit_form()\fR
is not available.
.ie n .SS "$mech\->follow_link_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->follow_link_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->follow_link_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`follow_link()\*(C'\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`follow_link()\*(C'\fR.
Note that the parms to \f(CW\*(C`follow_link()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $mech\->follow_link_ok( {n=>3}, \*(Aqlooking for 3rd link\*(Aq );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns a true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIfollow_link()\fR
is not available.
.ie n .SS "click_ok( $button[, $desc] )"
.el .SS "click_ok( \f(CW$button\fP[, \f(CW$desc\fP] )"
.IX Subsection "click_ok( $button[, $desc] )"
Clicks the button named by \f(CW$button\fR.  An optional \f(CW$desc\fR can
be given for the test.
.SH "METHODS: CONTENT CHECKING"
.IX Header "METHODS: CONTENT CHECKING"
.ie n .SS "$mech\->html_lint_ok( [$desc] )"
.el .SS "\f(CW$mech\fP\->html_lint_ok( [$desc] )"
.IX Subsection "$mech->html_lint_ok( [$desc] )"
Checks the validity of the \s-1HTML\s0 on the current page.  If the page is not
\&\s-1HTML\s0, then it fails.  The \s-1URI\s0 is automatically appended to the \fI\f(CI$desc\fI\fR.
.PP
Note that HTML::Lint must be installed for this to work.  Otherwise,
it will blow up.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( \*(AqInvoice Summary\*(Aq );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->base_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_is( $str [, $desc ] )"
Tells if the base of the page is the given string.
.PP
.Vb 1
\&    $mech\->base_is( \*(Aqhttp://example.com/\*(Aq );
.Ve
.ie n .SS "$mech\->base_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_like( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_like( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->base_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_unlike( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_unlike( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->text_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_contains( $str [, $desc ] )"
Tells if the text form of the page's content contains \fI\f(CI$str\fI\fR.
.PP
When your page contains \s-1HTML\s0 which is difficult, unimportant, or
unlikely to match over time as designers alter markup, use
\&\f(CW\*(C`text_contains\*(C'\fR instead of \*(L"content_contains\*(R".
.PP
.Vb 3
\& # <b>Hi, <i><a href="some/path">User</a></i>!</b>
\& $mech\->content_contains(\*(AqHi, User\*(Aq); # Fails.
\& $mech\->text_contains(\*(AqHi, User\*(Aq); # Passes.
.Ve
.PP
Text is determined by calling \f(CW\*(C`$mech\->text()\*(C'\fR.
See \*(L"content\*(R" in WWW::Mechanize.
.ie n .SS "$mech\->text_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_lacks( $str [, $desc ] )"
Tells if the text of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->text_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_like( $regex [, $desc ] )"
Tells if the text form of the page's content matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->text_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_unlike( $regex [, $desc ] )"
Tells if the text format of the page's content does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->has_tag( $tag, $text [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag( \f(CW$tag\fP, \f(CW$text\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag( $tag, $text [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->has_tag_like( $tag, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag_like( \f(CW$tag\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag_like( $tag, $regex [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->\fIfollowable_links()\fP"
.el .SS "\f(CW$mech\fP\->\fIfollowable_links()\fP"
.IX Subsection "$mech->followable_links()"
Returns a list of links that Mech can follow.  This is only http and
https links.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for \s-1HTTP\s0 status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex [, $desc ] )"
Follow all links on the current page and test their contents for \fI\f(CI$regex\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->page_links_content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_unlike( $regex [, $desc ] )"
Follow all links on the current page and test their contents do not
contain the specified regex.
.PP
.Vb 2
\&    $mech\->page_links_content_unlike(qr/Restricted/,
\&      \*(AqCheck all links do not contain Restricted\*(Aq);
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar \s-1URL\s0
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Follow specified links on the current page and test the resulting
content of each against \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an
array of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Follow specified links on the current page and test that the resulting
content of each does not match \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an array
of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_unlike( \e@links, qr/Restricted/,
\&      \*(AqNo restricted links\*(Aq );
.Ve
.ie n .SS "$mech\->stuff_inputs( [\e%options] )"
.el .SS "\f(CW$mech\fP\->stuff_inputs( [\e%options] )"
.IX Subsection "$mech->stuff_inputs( [%options] )"
Finds all free-text input fields (text, textarea, and password) in the
current form and fills them to their maximum length in hopes of finding
application code that can't handle it.  Fields with no maximum length
and all textarea fields are set to 66000 bytes, which will often be
enough to overflow the data's eventual recepticle.
.PP
There is no return value.
.PP
If there is no current form then nothing is done.
.PP
The hashref \f(CW$options\fR can contain the following keys:
.IP "\(bu" 4
ignore
.Sp
hash value is arrayref of field names to not touch, e.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        ignore => [qw( specialfield1 specialfield2 )],
\&    } );
.Ve
.IP "\(bu" 4
fill
.Sp
hash value is default string to use when stuffing fields.  Copies
of the string are repeated up to the max length of each field.  E.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        fill => \*(Aq@\*(Aq  # stuff all fields with something easy to recognize
\&    } );
.Ve
.IP "\(bu" 4
specs
.Sp
hash value is arrayref of hashrefs with which you can pass detailed
instructions about how to stuff a given field.  E.g.:
.Sp
.Vb 8
\&    $mech\->stuff_inputs( {
\&        specs=>{
\&            # Some fields are datatype\-constrained.  It\*(Aqs most common to
\&            # want the field stuffed with valid data.
\&            widget_quantity => { fill=>\*(Aq9\*(Aq },
\&            notes => { maxlength=>2000 },
\&        }
\&    } );
.Ve
.Sp
The specs allowed are \fIfill\fR (use this fill for the field rather than
the default) and \fImaxlength\fR (use this as the field's maxlength instead
of any maxlength specified in the \s-1HTML\s0).
.ie n .SS "$mech\->lacks_uncapped_inputs( [$comment] )"
.el .SS "\f(CW$mech\fP\->lacks_uncapped_inputs( [$comment] )"
.IX Subsection "$mech->lacks_uncapped_inputs( [$comment] )"
Executes a test to make sure that the current form content has no
text input fields that lack the \f(CW\*(C`maxlength\*(C'\fR attribute, and that each
\&\f(CW\*(C`maxlength\*(C'\fR value is a positive integer.  The test fails if the current
form has such a field, and succeeds otherwise.
.PP
Returns an array containing all text input fields in the current
form that do not specify a maximum input length.  Fields for which
the concept of input length is irrelevant, and controls that \s-1HTML\s0
does not allow to be capped (e.g. textarea) are ignored.
.PP
The inputs in the returned array are descended from HTML::Form::Input.
.PP
The return is true if the test succeeded, false otherwise.
.ie n .SS "$mech\->grep_inputs( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_inputs( \e%properties )"
.IX Subsection "$mech->grep_inputs( %properties )"
\&\fIgrep_inputs()\fR returns an array of all the input controls in the
current form whose properties match all of the regexes in \f(CW$properties\fR.
The controls returned are all descended from HTML::Form::Input.
.PP
If \f(CW$properties\fR is undef or empty then all inputs will be
returned.
.PP
If there is no current page, there is no form on the current
page, or there are no submit controls in the current form
then the return will be an empty array.
.PP
.Vb 7
\&    # get all text controls whose names begin with "customer"
\&    my @customer_text_inputs =
\&        $mech\->grep_inputs( {
\&            type => qr/^(text|textarea)$/,
\&            name => qr/^customer/
\&        }
\&    );
.Ve
.ie n .SS "$mech\->grep_submits( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_submits( \e%properties )"
.IX Subsection "$mech->grep_submits( %properties )"
\&\fIgrep_submits()\fR does the same thing as \fIgrep_inputs()\fR except that
it only returns controls that are submit controls, ignoring
other types of input controls like text and checkboxes.
.SH "TODO"
.IX Header "TODO"
Add HTML::Tidy capabilities.
.PP
Add a broken image check.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy at petdance.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
<http://code.google.com/p/www\-mechanize/issues/list>.  I will be
notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::WWW::Mechanize
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
Bug tracker
.Sp
http://code.google.com/p/www\-mechanize/issues/list <http://code.google.com/p/www-mechanize/issues/list>
.Sp
Please \fBdo not use\fR the old queues for WWW::Mechanize and
Test::WWW::Mechanize at
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test\-WWW\-Mechanize <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test-WWW-Mechanize>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Test\-WWW\-Mechanize <http://annocpan.org/dist/Test-WWW-Mechanize>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Test\-WWW\-Mechanize <http://cpanratings.perl.org/d/Test-WWW-Mechanize>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Test\-WWW\-Mechanize <http://search.cpan.org/dist/Test-WWW-Mechanize>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to
Jonathan \*(L"Duke\*(R" Leto,
Philip G. Potter,
Niko Tyni,
Greg Sheard,
Michael Schwern,
Mark Blackman,
Mike O'Regan,
Shawn Sorichetti,
Chris Dolan,
Matt Trout,
\&\s-1MATSUNO\s0 Tokuhiro,
and Pete Krawczyk for patches.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2004\-2011 Andy Lester.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the Artistic License version 2.0.
