.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler 3"
.TH HTML::FormHandler 3 "2012-02-04" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler \- HTML forms using Moose
.SH "VERSION"
.IX Header "VERSION"
version 0.36002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See the manual at \*(L" HTML::FormHandler::Manual \*(R".
.PP
.Vb 10
\&    use HTML::FormHandler; # or a custom form: use MyApp::Form::User;
\&    my $form = HTML::FormHandler\->new( .... );
\&    $form\->process( params => $params );
\&    my $rendered_form = $form\->render;
\&    if( $form\->validated ) {
\&        # perform validated form actions
\&    }
\&    else {
\&        # perform non\-validated actions
\&    }
.Ve
.PP
Or, if you want to use a form 'result' (which contains only the form
values and error messages) instead:
.PP
.Vb 10
\&    use MyApp::Form; # or a generic form: use HTML::FormHandler;
\&    my $form = MyApp::Form\->new( .... );
\&    my $result = $form\->run( params => $params );
\&    if( $result\->validated ) {
\&        # perform validated form actions
\&    }
\&    else {
\&        # perform non\-validated actions
\&        $result\->render;
\&    }
.Ve
.PP
An example of a custom form class (you could also use a 'field_list'
like the dynamic form example if you don't want to use the 'has_field'
field declaration sugar):
.PP
.Vb 1
\&    package MyApp::Form::User;
\&
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&    use Moose::Util::TypeConstraints;
\&
\&    has \*(Aq+item_class\*(Aq => ( default => \*(AqUser\*(Aq );
\&
\&    has_field \*(Aqname\*(Aq => ( type => \*(AqText\*(Aq );
\&    has_field \*(Aqage\*(Aq => ( type => \*(AqPosInteger\*(Aq, apply => [ \*(AqMinimumAge\*(Aq ] );
\&    has_field \*(Aqbirthdate\*(Aq => ( type => \*(AqDateTime\*(Aq );
\&    has_field \*(Aqbirthdate.month\*(Aq => ( type => \*(AqMonth\*(Aq ); # Explicitly split
\&    has_field \*(Aqbirthdate.day\*(Aq => ( type => \*(AqMonthDay\*(Aq ); # fields for renderer
\&    has_field \*(Aqbirthdate.year\*(Aq => ( type => \*(AqYear\*(Aq );
\&    has_field \*(Aqhobbies\*(Aq => ( type => \*(AqMultiple\*(Aq );
\&    has_field \*(Aqaddress\*(Aq => ( type => \*(AqText\*(Aq );
\&    has_field \*(Aqcity\*(Aq => ( type => \*(AqText\*(Aq );
\&    has_field \*(Aqstate\*(Aq => ( type => \*(AqSelect\*(Aq );
\&    has_field \*(Aqemail\*(Aq => ( type => \*(AqEmail\*(Aq );
\&
\&    has \*(Aq+dependency\*(Aq => ( default => sub {
\&          [ [\*(Aqaddress\*(Aq, \*(Aqcity\*(Aq, \*(Aqstate\*(Aq], ]
\&       }
\&    );
\&
\&    subtype \*(AqMinimumAge\*(Aq
\&       => as \*(AqInt\*(Aq
\&       => where { $_ > 13 }
\&       => message { "You are not old enough to register" };
\&
\&    no HTML::FormHandler::Moose;
\&    1;
.Ve
.PP
A dynamic form \- one that does not use a custom form class \- may be
created using the 'field_list' attribute to set fields:
.PP
.Vb 10
\&    my $form = HTML::FormHandler\->new(
\&        name => \*(Aquser_form\*(Aq,
\&        item => $user,
\&        field_list => [
\&            \*(Aqusername\*(Aq => {
\&                type  => \*(AqText\*(Aq,
\&                apply => [ { check => qr/^[0\-9a\-z]*/,
\&                   message => \*(AqContains invalid characters\*(Aq } ],
\&            },
\&            \*(Aqselect_bar\*(Aq => {
\&                type     => \*(AqSelect\*(Aq,
\&                options  => \e@select_options,
\&                multiple => 1,
\&                size     => 4,
\&            },
\&        ],
\&    );
.Ve
.PP
FormHandler does not provide a custom controller for Catalyst because
it isn't necessary. Interfacing to FormHandler is only a couple of
lines of code. See HTML::FormHandler::Manual::Catalyst for more
details, or Catalyst::Manual::Tutorial::09_AdvancedCRUD::09_FormHandler.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
*** Although documentation in this file provides some overview, it is mainly
intended for \s-1API\s0 documentation. See HTML::FormHandler::Manual::Intro
for a more detailed introduction.
.PP
HTML::FormHandler maintains a clean separation between form construction
and form rendering. It allows you to define your forms and fields in a
number of flexible ways. Although it provides renderers for \s-1HTML\s0, you
can define custom renderers for any kind of presentation.
.PP
HTML::FormHandler allows you to define form fields and validators. It can
be used for both database and non-database forms, and will
automatically update or create rows in a database. It can be used
to process structured data that doesn't come from an \s-1HTML\s0 form.
.PP
One of its goals is to keep the controller/application program interface as
simple as possible, and to minimize the duplication of code. In most cases,
interfacing your controller to your form is only a few lines of code.
.PP
With FormHandler you'll never spend hours trying to figure out how to make a
simple \s-1HTML\s0 change that would take one minute by hand. Because you \s-1CAN\s0 do it
by hand. Or you can automate \s-1HTML\s0 generation as much as you want, with
template widgets or pure Perl rendering classes, and stay completely in
control of what, where, and how much is done automatically. You can define
custom renderers and display your rendered forms however you want.
.PP
You can split the pieces of your forms up into logical parts and compose
complete forms from FormHandler classes, roles, fields, collections of
validations, transformations and Moose type constraints.
You can write custom methods to process forms, add any attribute you like,
use Moose method modifiers.  FormHandler forms are Perl classes, so there's
a lot of flexibility in what you can do.
.PP
HTML::FormHandler provides rendering through roles which are applied to
form and field classes (although there's no reason you couldn't write
a renderer as an external object either).  There are currently two flavors:
all-in-one solutions like HTML::FormHandler::Render::Simple and
HTML::FormHandler::Render::Table that contain methods for rendering
field widget classes, and the HTML::FormHandler::Widget roles, which are
more atomic roles which are automatically applied to fields and form if a
\&'render' method does not already exist. See
HTML::FormHandler::Manual::Rendering for more details.
(And you can easily use hand-build forms \- FormHandler doesn't care.)
.PP
The typical application for FormHandler would be in a Catalyst, DBIx::Class,
Template Toolkit web application, but use is not limited to that. FormHandler
can be used in any Perl application.
.PP
More Formhandler documentation and a tutorial can be found in the manual
at HTML::FormHandler::Manual.
.SH "ATTRIBUTES and METHODS"
.IX Header "ATTRIBUTES and METHODS"
.SS "Creating a form with 'new'"
.IX Subsection "Creating a form with 'new'"
The new constructor takes name/value pairs:
.PP
.Vb 3
\&    MyForm\->new(
\&        item    => $item,
\&    );
.Ve
.PP
No attributes are required on new. The form's fields will be built from
the form definitions. If no initial data object has been provided, the form
will be empty. Most attributes can be set on either 'new' or 'process'.
The common attributes to be passed in to the constructor for a database form
are either item_id and schema or item:
.PP
.Vb 3
\&   item_id  \- database row primary key
\&   item     \- database row object
\&   schema   \- (for DBIC) the DBIx::Class schema
.Ve
.PP
The following are occasionally passed in, but are more often set
in the form class:
.PP
.Vb 4
\&   item_class  \- source name of row
\&   dependency  \- (see dependency)
\&   field_list  \- an array of field definitions
\&   init_object \- a hashref or object to provide initial values
.Ve
.PP
Examples of creating a form object with new:
.PP
.Vb 1
\&    my $form = MyApp::Form::User\->new;
\&
\&    # database form using a row object
\&    my $form = MyApp::Form::Member\->new( item => $row );
\&
\&    # a dynamic form (no form class has been defined)
\&    my $form = HTML::FormHandler::Model::DBIC\->new(
\&        item_id         => $id,
\&        item_class    => \*(AqUser\*(Aq,
\&        schema          => $schema,
\&        field_list         => [
\&                name    => \*(AqText\*(Aq,
\&                active  => \*(AqBoolean\*(Aq,
\&        ],
\&    );
.Ve
.PP
See the model class for more information about the 'item', 'item_id',
\&'item_class', and schema (for the \s-1DBIC\s0 model).
HTML::FormHandler::Model::DBIC.
.PP
FormHandler forms are handled in two steps: 1) create with 'new',
2) handle with 'process'. FormHandler doesn't
care whether most parameters are set on new or process or update,
but a 'field_list' argument must be passed in on 'new' since the
fields are built at construction time.
.PP
If you want to update field attributes on the 'process' call, you can
use an 'update_field_list' or 'defaults' hashref attribute , or subclass
update_fields in your form. The 'defaults' attribute will update only
the 'default' attribute in the field. The 'update_field_list' hashref
can be used to set any field attribute:
.PP
.Vb 2
\&   $form\->process( defaults => { foo => \*(Aqfoo_def\*(Aq, bar => \*(Aqbar_def\*(Aq } );
\&   $form\->process( update_field_list => { foo => { label => \*(AqNew Label\*(Aq } });
.Ve
.PP
Field results are built on the 'new' call, but will then be re-built
on the process call. If you always use 'process' before rendering the form,
accessing fields, etc, you can set the 'no_preload' flag to skip this step.
.SS "Processing the form"
.IX Subsection "Processing the form"
\fIprocess\fR
.IX Subsection "process"
.PP
Call the 'process' method on your form to perform validation and
update. A database form must have either an item (row object) or
a schema, item_id (row primary key), and item_class (usually set in the form).
A non-database form requires only parameters.
.PP
.Vb 4
\&   $form\->process( item => $book, params => $c\->req\->parameters );
\&   $form\->process( item_id => $item_id,
\&       schema => $schema, params => $c\->req\->parameters );
\&   $form\->process( params => $c\->req\->parameters );
.Ve
.PP
This process method returns the 'validated' flag. (\f(CW\*(C`$form\->validated\*(C'\fR)
If it is a database form and the form validates, the database row
will be updated.
.PP
After the form has been processed, you can get a parameter hashref suitable
for using to fill in the form from \f(CW\*(C`$form\->fif\*(C'\fR.
A hash of inflated values (that would be used to update the database for
a database form) can be retrieved with \f(CW\*(C`$form\->value\*(C'\fR.
.PP
\fIparams\fR
.IX Subsection "params"
.PP
Parameters are passed in or already set when you call 'process'.
\&\s-1HFH\s0 gets data to validate and store in the database from the params hash.
If the params hash is empty, no validation is done, so it is not necessary
to check for \s-1POST\s0 before calling \f(CW\*(C`$form\->process\*(C'\fR. (Although see
the 'posted' option for complications.)
.PP
Params can either be in the form of \s-1CGI/HTTP\s0 style params:
.PP
.Vb 12
\&   {
\&      user_name => "Joe Smith",
\&      occupation => "Programmer",
\&      \*(Aqaddresses.0.street\*(Aq => "999 Main Street",
\&      \*(Aqaddresses.0.city\*(Aq => "Podunk",
\&      \*(Aqaddresses.0.country\*(Aq => "UT",
\&      \*(Aqaddresses.0.address_id\*(Aq => "1",
\&      \*(Aqaddresses.1.street\*(Aq => "333 Valencia Street",
\&      \*(Aqaddresses.1.city\*(Aq => "San Francisco",
\&      \*(Aqaddresses.1.country\*(Aq => "UT",
\&      \*(Aqaddresses.1.address_id\*(Aq => "2",
\&   }
.Ve
.PP
or as structured data in the form of hashes and lists:
.PP
.Vb 10
\&   {
\&      addresses => [
\&         {
\&            city => \*(AqMiddle City\*(Aq,
\&            country => \*(AqGK\*(Aq,
\&            address_id => 1,
\&            street => \*(Aq101 Main St\*(Aq,
\&         },
\&         {
\&            city => \*(AqDownTown\*(Aq,
\&            country => \*(AqUT\*(Aq,
\&            address_id => 2,
\&            street => \*(Aq99 Elm St\*(Aq,
\&         },
\&      ],
\&      \*(Aqoccupation\*(Aq => \*(Aqmanagement\*(Aq,
\&      \*(Aquser_name\*(Aq => \*(Aqjdoe\*(Aq,
\&   }
.Ve
.PP
\&\s-1CGI\s0 style parameters will be converted to hashes and lists for \s-1HFH\s0 to
operate on.
.PP
\fIposted\fR
.IX Subsection "posted"
.PP
Note that FormHandler by default uses empty params as a signal that the
form has not actually been posted, and so will not attempt to validate
a form with empty params. Most of the time this works \s-1OK\s0, but if you
have a small form with only the controls that do not return a post
parameter if unselected (checkboxes and select lists), then the form
will not be validated if everything is unselected. For this case you
can either add a hidden field, or use the 'posted' flag:
.PP
.Vb 1
\&   $form\->process( posted => ($c\->req\->method eq \*(AqPOST\*(Aq), params => ... );
.Ve
.PP
The corollary is that you will confuse FormHandler if you add extra params.
It's often a better idea to add Moose attributes to the form rather than
\&'dummy' fields if the data is not coming from a form control.
.SS "Getting data out"
.IX Subsection "Getting data out"
\fIfif  (fill in form)\fR
.IX Subsection "fif  (fill in form)"
.PP
If you don't use FormHandler rendering and want to fill your form values in
using some other method (such as with HTML::FillInForm or using a template)
this returns a hash of values that are equivalent to params which you may
use to fill in your form.
.PP
The fif value for a 'title' field in a \s-1TT\s0 form:
.PP
.Vb 1
\&   [% form.fif.title %]
.Ve
.PP
Or you can use the 'fif' method on individual fields:
.PP
.Vb 1
\&   [% form.field(\*(Aqtitle\*(Aq).fif %]
.Ve
.PP
If you use FormHandler to render your forms or field you probably won't use
these methods.
.PP
\fIvalue\fR
.IX Subsection "value"
.PP
Returns a hashref of all field values. Useful for non-database forms, or if
you want to update the database yourself. The 'fif' method returns
a hashref with the field names for the keys and the field's 'fif' for the
values; 'value' returns a hashref with the field accessors for the keys, and the
field's 'value' (possibly inflated) for the the values.
.PP
Forms containing arrays to be processed with HTML::FormHandler::Field::Repeatable
will have parameters with dots and numbers, like 'addresses.0.city', while the
values hash will transform the fields with numbers to arrays.
.SS "Accessing and setting up fields"
.IX Subsection "Accessing and setting up fields"
Fields are declared with a number of attributes which are defined in
HTML::FormHandler::Field. If you want additional attributes you can
define your own field classes (or apply a role to a field class \- see
HTML::FormHandler::Manual::Cookbook). The field 'type' (used in field
definitions) is the short class name of the field class.
.PP
\fIhas_field\fR
.IX Subsection "has_field"
.PP
The most common way of declaring fields is the 'has_field' syntax.
Using the 'has_field' syntax sugar requires \f(CW\*(C` use HTML::FormHandler::Moose; \*(C'\fR
or \f(CW\*(C` use HTML::FormHandler::Moose::Role; \*(C'\fR in a role.
See HTML::FormHandler::Manual::Intro
.PP
.Vb 2
\&   use HTML::FormHandler::Moose;
\&   has_field \*(Aqfield_name\*(Aq => ( type => \*(AqFieldClass\*(Aq, .... );
.Ve
.PP
\fIfield_list\fR
.IX Subsection "field_list"
.PP
A 'field_list' is an array of field definitions which can be used as an
alternative to 'has_field' in small, dynamic forms to create fields.
.PP
.Vb 7
\&    field_list => [
\&       field_one => {
\&          type => \*(AqText\*(Aq,
\&          required => 1
\&       },
\&       field_two => \*(AqText,
\&    ]
.Ve
.PP
Or the field list can be set inside a form class, when you want to
add fields to the form depending on some other state.
.PP
.Vb 11
\&   sub field_list {
\&      my $self = shift;
\&      my $fields = $self\->schema\->resultset(\*(AqSomeTable\*(Aq)\->
\&                          search({user_id => $self\->user_id, .... });
\&      my @field_list;
\&      while ( my $field = $fields\->next )
\&      {
\&         < create field list >
\&      }
\&      return \e@field_list;
\&   }
.Ve
.PP
\fIupdate_field_list\fR
.IX Subsection "update_field_list"
.PP
Used to dynamically set particular field attributes on the 'process' (or
\&'run') call. (Will not create fields.)
.PP
.Vb 3
\&    $form\->process( update_field_list => {
\&       foo_date => { format => \*(Aq%m/%e/%Y\*(Aq, date_start => \*(Aq10\-01\-01\*(Aq } },
\&       params => $params );
.Ve
.PP
The 'update_field_list' is processed by the 'update_fields' form method,
which can also be used in a form to do specific field updates:
.PP
.Vb 5
\&    sub update_fields {
\&        my $self = shift;
\&        $self\->field(\*(Aqfoo\*(Aq)\->temp( \*(Aqfoo_temp\*(Aq );
\&        $self\->field(\*(Aqbar\*(Aq)\->default( \*(Aqfoo_value\*(Aq );
\&    }
.Ve
.PP
(Note that you although you can set a field's 'default', you can't set a
field's 'value' directly here, since it will
be overwritten by the validation process. Set the value in a field
validation method.)
.PP
\fIdefaults\fR
.IX Subsection "defaults"
.PP
This is a more specialized version of the 'update_field_list'. It can be
used to provide 'default' settings for fields, in a shorthand way (you don't
have to say 'default' for every field).
.PP
.Vb 1
\&   $form\->process( defaults => { foo => \*(Aqthis_foo\*(Aq, bar => \*(Aqthis_bar\*(Aq }, ... );
.Ve
.PP
\fIactive/inactive\fR
.IX Subsection "active/inactive"
.PP
A field can be marked 'inactive' and set to active at new or process time;
Then the field name can be specified in the 'active' array, either on 'new',
or on 'process':
.PP
.Vb 5
\&   has_field \*(Aqfoo\*(Aq => ( type => \*(AqText\*(Aq, inactive => 1 );
\&   ...
\&   my $form = MyApp::Form\->new( active => [\*(Aqfoo\*(Aq] );
\&   ...
\&   $form\->process( active => [\*(Aqfoo\*(Aq] );
.Ve
.PP
Or a field can be a normal active field and set to inactive at new or process
time:
.PP
.Vb 5
\&   has_field \*(Aqbar\*(Aq;
\&   ...
\&   my $form = MyApp::Form\->new( inactive => [\*(Aqfoo\*(Aq] );
\&   ...
\&   $form\->process( inactive => [\*(Aqfoo\*(Aq] );
.Ve
.PP
Fields specified as active/inactive on new will have the form's inactive/active
arrayref cleared and the the field's inactive flag set appropriately, so the
that state will be effective for the life of the form object. Fields specified as
active/inactive on 'process' will have the field's '_active' flag set for the life
of the request (the _active flag will be cleared when the form is cleared).
.PP
The 'sorted_fields' method returns only active fields. The 'fields' method returns
all fields.
.PP
.Vb 1
\&   foreach my $field ( $self\->sorted_fields ) { ... }
.Ve
.PP
You can test whether a field is active by using the field 'is_active' and 'is_inactive'
methods.
.PP
\fIfield_name_space\fR
.IX Subsection "field_name_space"
.PP
Use to set the name space used to locate fields that
start with a \*(L"+\*(R", as: \*(L"+MetaText\*(R". Fields without a \*(L"+\*(R" are loaded
from the \*(L"HTML::FormHandler::Field\*(R" name space. If 'field_name_space'
is not set, then field types with a \*(L"+\*(R" must be the complete package
name.
.PP
\fIfields\fR
.IX Subsection "fields"
.PP
The array of fields, objects of HTML::FormHandler::Field or its subclasses.
A compound field will itself have an array of fields,
so this is a tree structure.
.PP
\fIsorted_fields\fR
.IX Subsection "sorted_fields"
.PP
Returns those fields from the fields array which are currently active. This
is the method that returns the fields that are looped through when rendering.
.PP
\fIfield($name)\fR
.IX Subsection "field($name)"
.PP
This is the method that is usually called to access a field:
.PP
.Vb 2
\&    my $title = $form\->field(\*(Aqtitle\*(Aq)\->value;
\&    [% f = form.field(\*(Aqtitle\*(Aq) %]
\&
\&    my $city = $form\->field(\*(Aqaddresses.0.city\*(Aq)\->value;
.Ve
.PP
Pass a second true value to die on errors.
.SS "Constraints and validation"
.IX Subsection "Constraints and validation"
Most validation is performed on a per-field basis, and there are a number
of different places in which validation can be performed.
.PP
\fIApply actions\fR
.IX Subsection "Apply actions"
.PP
The 'actions' array contains a sequence of transformations and constraints
(including Moose type constraints) which will be applied in order. The 'apply'
sugar is used to add to the actions array in field classes. In a field definition
elements of the 'apply' array will added to the 'actions' array.
.PP
The current value of the field is passed in to the subroutines, but it has
no access to other field information. If you need more information to
perform validation, you should use one of the other validation methods.
.PP
HTML::FormHandler::Field::Compound fields receive as value
a hash containing values of their child fields \- this may be used for
easy creation of objects (like DateTime).
See \*(L"apply\*(R" in HTML::FormHandler::Field for more documentation.
.PP
.Vb 6
\&   has_field \*(Aqtest\*(Aq => ( apply => [ \*(AqMyConstraint\*(Aq,
\&                         { check => sub {... },
\&                           message => \*(Aq....\*(Aq },
\&                         { transform => sub { ... },
\&                           message => \*(Aq....\*(Aq }
\&                         ] );
.Ve
.PP
\fIField class validate method\fR
.IX Subsection "Field class validate method"
.PP
The 'validate' method can be used in custom field classes to perform additional
validation.  It has access to the field ($self).  This method is called after the
actions are performed.
.PP
\fIForm class validation for individual fields\fR
.IX Subsection "Form class validation for individual fields"
.PP
You can define a method in your form class to perform validation on a field.
This method is the equivalent of the field class validate method except it is
in the form class, so you might use this
validation method if you don't want to create a field subclass.
.PP
It has access to the form ($self) and the field.
This method is called after the field class 'validate' method, and is not
called if the value for the field is empty ('', undef). (If you want an
error message when the field is empty, use the 'required' flag and message
or the form 'validate' method.)
The name of this method can be set with 'set_validate' on the field. The
default is 'validate_' plus the field name:
.PP
.Vb 1
\&   sub validate_testfield { my ( $self, $field ) = @_; ... }
.Ve
.PP
If the field name has dots they should be replaced with underscores.
.PP
\fIvalidate\fR
.IX Subsection "validate"
.PP
This is a form method that is useful for cross checking values after they have
been saved as their final validated value, and for performing more complex
dependency validation. It is called after all other field validation is done,
and whether or not validation has succeeded, so it has access to the
post-validation values of all the fields.
.PP
This is the best place to do validation checks that depend on the values of
more than one field.
.SS "Accessing errors"
.IX Subsection "Accessing errors"
Set an error in a field with \f(CW\*(C`$field\->add_error(\*(Aqsome error string\*(Aq);\*(C'\fR.
Set a form error not tied to a specific field with
\&\f(CW\*(C`$self\->add_form_error(\*(Aqanother error string\*(Aq);\*(C'\fR.
The 'add_error' and 'add_form_error' methods call localization. If you
want to skip localization for a particular error, you can use 'push_errors'
or 'push_form_errors' instead.
.PP
.Vb 4
\&  has_errors \- returns true or false
\&  error_fields \- returns list of fields with errors
\&  errors \- returns array of error messages for the entire form
\&  num_errors \- number of errors in form
.Ve
.PP
Each field has an array of error messages. (errors, has_errors, num_errors,
clear_errors)
.PP
.Vb 1
\&  $form\->field(\*(Aqtitle\*(Aq)\->errors;
.Ve
.PP
Compound fields also have an array of error_fields.
.SS "Clear form state"
.IX Subsection "Clear form state"
The clear method is called at the beginning of 'process' if the form
object is reused, such as when it is persistent in a Moose attribute,
or in tests.  If you add other attributes to your form that are set on
each request, you may need to clear those yourself.
.PP
If you do not call the form's 'process' method on a persistent form,
such as in a \s-1REST\s0 controller's non-POST method or if you only call
process when the form is posted, you will also need to call \f(CW\*(C`$form\->clear\*(C'\fR.
.PP
The 'run' method which returns a result object always performs 'clear', to
keep the form object clean.
.SS "Miscellaneous attributes"
.IX Subsection "Miscellaneous attributes"
\fIname\fR
.IX Subsection "name"
.PP
The form's name.  Useful for multiple forms.
It is used to construct the default 'id' for fields, and is used
for the \s-1HTML\s0 field name when 'html_prefix' is set.
The default is \*(L"form\*(R" + a one to three digit random number.
.PP
\fIinit_object\fR
.IX Subsection "init_object"
.PP
An 'init_object' may be used instead of the 'item' to pre-populate the values
in the form. This can be useful when populating a form from default values
stored in a similar but different object than the one the form is creating.
The 'init_object' should be either a hash or the same type of object that
the model uses (a DBIx::Class row for the \s-1DBIC\s0 model). It can be set in a
variety of ways:
.PP
.Vb 4
\&   my $form = MyApp::Form\->new( init_object => { .... } );
\&   $form\->process( init_object => {...}, ... );
\&   has \*(Aq+init_object\*(Aq => ( default => sub { { .... } } );
\&   sub init_object { my $self = shift; .... }
.Ve
.PP
The method version is useful if the organization of data in your form does
not map to an existing or database object in an automatic way, and you need
to create a different type of object for initialization. (You might also
want to do 'update_model' yourself.)
.PP
Also see the 'use_init_obj_over_item' flag, if you want to provide both an
item and an init_object, and use the values from the init_object.
.PP
\fIctx\fR
.IX Subsection "ctx"
.PP
Place to store application context for your use in your form's methods.
.PP
\fIlanguage_handle\fR
.IX Subsection "language_handle"
.PP
See 'language_handle' and '_build_language_handle' in
HTML::FormHandler::TraitFor::I18N.
.PP
\fIdependency\fR
.IX Subsection "dependency"
.PP
Arrayref of arrayrefs of fields. If one of a group of fields has a
value, then all of the group are set to 'required'.
.PP
.Vb 3
\&  has \*(Aq+dependency\*(Aq => ( default => sub { [
\&     [\*(Aqstreet\*(Aq, \*(Aqcity\*(Aq, \*(Aqstate\*(Aq, \*(Aqzip\*(Aq ],] }
\&  );
.Ve
.SS "Flags"
.IX Subsection "Flags"
\fIvalidated, is_valid\fR
.IX Subsection "validated, is_valid"
.PP
Flag that indicates if form has been validated. You might want to use
this flag if you're doing something in between process and returning,
such as setting a stash key. ('is_valid' is a synonym for this flag)
.PP
.Vb 3
\&   $form\->process( ... );
\&   $c\->stash\->{...} = ...;
\&   return unless $form\->validated;
.Ve
.PP
\fIran_validation\fR
.IX Subsection "ran_validation"
.PP
Flag to indicate that validation has been run. This flag will be
false when the form is initially loaded and displayed, since
validation is not run until FormHandler has params to validate.
.PP
\fIverbose, dump, peek\fR
.IX Subsection "verbose, dump, peek"
.PP
Flag to dump diagnostic information. See 'dump_fields' and
\&'dump_validated'. 'Peek' can be useful in diagnosing bugs.
It will dump a brief listing of the fields and results.
.PP
.Vb 2
\&   $form\->process( ... );
\&   $form\->peek;
.Ve
.PP
\fIhtml_prefix\fR
.IX Subsection "html_prefix"
.PP
Flag to indicate that the form name is used as a prefix for fields
in an \s-1HTML\s0 form. Useful for multiple forms
on the same \s-1HTML\s0 page. The prefix is stripped off of the fields
before creating the internal field name, and added back in when
returning a parameter hash from the 'fif' method. For example,
the field name in the \s-1HTML\s0 form could be \*(L"book.borrower\*(R", and
the field name in the FormHandler form (and the database column)
would be just \*(L"borrower\*(R".
.PP
.Vb 2
\&   has \*(Aq+name\*(Aq => ( default => \*(Aqbook\*(Aq );
\&   has \*(Aq+html_prefix\*(Aq => ( default => 1 );
.Ve
.PP
Also see the Field attribute \*(L"html_name\*(R", a convenience function which
will return the form name + \*(L".\*(R" + field full_name
.PP
\fIis_html5\fR
.IX Subsection "is_html5"
.PP
Flag to indicate the fields will render using specialized attributes for html5.
Set to 0 by default.
.PP
\fIuse_defaults_over_obj\fR
.IX Subsection "use_defaults_over_obj"
.PP
The 'normal' precedence is that if there is an accessor in the item/init_object
that value is used and not the 'default'. This flag makes the defaults of higher
precedence. Mainly useful if providing an empty row on create.
.PP
\fIuse_init_obj_over_item\fR
.IX Subsection "use_init_obj_over_item"
.PP
If you are providing both an item and an init_object, and want the init_object
to be used for defaults instead of the item.
.SS "For use in \s-1HTML\s0"
.IX Subsection "For use in HTML"
.Vb 6
\&   html_attr \- hashref for setting arbitrary HTML attributes
\&         has \*(Aq+html_attr\*(Aq =>
\&           ( default => sub { { class => \*(Aq...\*(Aq, method => \*(Aq...\*(Aq } } );
\&   http_method \- For storing \*(Aqpost\*(Aq or \*(Aqget\*(Aq
\&   action \- Store the form \*(Aqaction\*(Aq on submission. No default value.
\&   uuid \- generates a string containing an HTML field with UUID
.Ve
.PP
Deprecated (use html_attr instead):
.PP
.Vb 3
\&   css_class \- adds a \*(Aqclass\*(Aq attribute to the form tag
\&   style \- adds a \*(Aqstyle\*(Aq attribute to the form tag
\&   enctype \- Request enctype
.Ve
.PP
Note that the form tag contains an 'id' attribute which is set to the
form name. The standards have been flip-flopping over whether a 'name'
attribute is valid. It can be set with 'html_attr'.
.PP
The rendering of the \s-1HTML\s0 attributes is done using the 'process_attrs'
function and the 'attributes' method, which munges the 'html_attr' hash
for backward compatibility, etc.
.PP
For field \s-1HTML\s0 attributes, there is a form method hook, 'field_html_attributes',
which can be used to customize/modify/localize field \s-1HTML\s0 attributes.
.PP
.Vb 6
\&   sub field_html_attributes {
\&       my ( $self, $field, $type, $attr ) = @_;
\&       $attr\->{class} = \*(Aqlabel\*(Aq if $type eq \*(Aqlabel\*(Aq;
\&       $attr\->{placeholder} = $self\->_localize($attr\->{placeholder})
\&           if exists $attr\->{placeholder};
\&   }
.Ve
.PP
Also see the documentation in HTML::FormHandler::Field.
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\s-1IRC:\s0
.PP
.Vb 1
\&  Join #formhandler on irc.perl.org
.Ve
.PP
Mailing list:
.PP
.Vb 1
\&  http://groups.google.com/group/formhandler
.Ve
.PP
Code repository:
.PP
.Vb 1
\&  http://github.com/gshank/html\-formhandler/tree/master
.Ve
.PP
Bug tracker:
.PP
.Vb 1
\&  https://rt.cpan.org/Dist/Display.html?Name=HTML\-FormHandler
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::FormHandler::Manual
.PP
HTML::FormHandler::Manual::Tutorial
.PP
HTML::FormHandler::Manual::Intro
.PP
HTML::FormHandler::Manual::Templates
.PP
HTML::FormHandler::Manual::Cookbook
.PP
HTML::FormHandler::Manual::Rendering
.PP
HTML::FormHandler::Manual::Reference
.PP
HTML::FormHandler::Field
.PP
HTML::FormHandler::Model::DBIC
.PP
HTML::FormHandler::Render::Simple
.PP
HTML::FormHandler::Render::Table
.PP
HTML::FormHandler::Moose
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
gshank: Gerda Shank <gshank@cpan.org>
.PP
zby: Zbigniew Lukasiak <zby@cpan.org>
.PP
t0m: Tomas Doran <bobtfish@bobtfish.net>
.PP
augensalat: Bernhard Graf <augensalat@gmail.com>
.PP
cubuanic: Oleg Kostyuk <cub.uanic@gmail.com>
.PP
rafl: Florian Ragwitz <rafl@debian.org>
.PP
mazpe: Lester Ariel Mesa
.PP
dew: Dan Thomas
.PP
koki: Klaus Ita
.PP
jnapiorkowski: John Napiorkowski
.PP
lestrrat: Daisuke Maki
.PP
hobbs: Andrew Rodland
.PP
Andy Clayton
.PP
boghead: Bryan Beeley
.PP
Csaba Hetenyi
.PP
Eisuke Oishi
.PP
Lian Wan Situ
.PP
Murray
.PP
Nick Logan
.PP
Vladimir Timofeev
.PP
diegok: Diego Kuperman
.PP
ijw: Ian Wells
.PP
amiri: Amiri Barksdale
.PP
ozum: Ozum Eldogan
.PP
Initially based on the source code of Form::Processor by Bill Moseley
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
