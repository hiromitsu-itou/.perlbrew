.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::APIRef 3"
.TH Imager::APIRef 3 "2012-01-31" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::APIRef \- Imager's C API \- reference.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  i_color color;
\&  color.rgba.r = 255; color.rgba.g = 0; color.rgba.b = 255;
\&
\&
\&  # Blit tools
\&
\&  # Data Types
\&  i_img *img;
\&  i_color black;
\&  black.rgba.r = black.rgba.g = black.rgba.b = black.rgba.a = 0;
\&  i_fill_t *fill;
\&  i_img_dim x, y;
\&  printf("left %" i_DF "\en", i_DFc(x));
\&  printf("point (" i_DFp ")\en", i_DFcp(x, y));
\&
\&  # Drawing
\&  i_arc(im, 50, 50, 20, 45, 135, &color);
\&  i_arc_cfill(im, 50, 50, 35, 90, 135, fill);
\&  i_arc_aa(im, 50, 50, 35, 90, 135, &color);
\&  i_arc_aa_cfill(im, 50, 50, 35, 90, 135, fill);
\&  i_circle_aa(im, 50, 50, 45, &color);
\&  i_box(im, 0, 0, im\->xsize\-1, im\->ysize\-1, &color).
\&  i_box_filled(im, 0, 0, im\->xsize\-1, im\->ysize\-1, &color);
\&  i_box_cfill(im, 0, 0, im\->xsize\-1, im\->ysize\-1, fill);
\&  i_flood_fill(im, 50, 50, &color);
\&  i_flood_cfill(im, 50, 50, fill);
\&  i_flood_fill_border(im, 50, 50, &color, &border);
\&  i_flood_cfill_border(im, 50, 50, fill, border);
\&
\&  # Error handling
\&  i_clear_error();
\&  i_push_error(0, "Yep, it\*(Aqs broken");
\&  i_push_error(errno, "Error writing");
\&  i_push_errorf(errno, "Cannot open file %s: %d", filename, errno);
\&
\&  # Files
\&  i_set_image_file_limits(500, 500, 1000000);
\&  i_get_image_file_limits(&width, &height, &bytes)
\&  i_i_int_check_image_file_limits(width, height, channels, sizeof(i_sample_t))
\&
\&  # Fills
\&  i_fill_t *fill = i_new_fill_solidf(&fcolor, combine);
\&  i_fill_t *fill = i_new_fill_solid(&color, combine);
\&  i_fill_t *fill = i_new_fill_hatch(&fg_color, &bg_color, combine, hatch, custom_hatch, dx, dy);
\&  i_fill_t *fill = i_new_fill_hatchf(&fg_fcolor, &bg_fcolor, combine, hatch, custom_hatch, dx, dy);
\&  i_fill_t *fill = i_new_fill_image(src_img, matrix, x_offset, y_offset, combine);
\&  fill = i_new_fill_fount(0, 0, 100, 100, i_ft_linear, i_ft_linear, 
\&                          i_fr_triangle, 0, i_fts_grid, 9, 1, segs);
\&  i_fill_destroy(fill);
\&
\&  # I/O Layers
\&  ssize_t count = i_io_peekn(ig, buffer, sizeof(buffer));
\&  ssize_t result = i_io_write(io, buffer, size)
\&  char buffer[BUFSIZ]
\&  ssize_t len = i_io_gets(buffer, sizeof(buffer), \*(Aq\en\*(Aq);
\&  io_glue_destroy(ig);
\&
\&  # Image
\&
\&  # Image creation/destruction
\&  i_img *img = i_sametype(src, width, height);
\&  i_img *img = i_sametype_chans(src, width, height, channels);
\&  i_img *img = i_img_16_new(width, height, channels);
\&  i_img *img = i_img_8_new(width, height, channels);
\&  i_img *img = i_img_double_new(width, height, channels);
\&  i_img *img = i_img_pal_new(width, height, channels, max_palette_size)
\&  i_img_destroy(img)
\&
\&  # Image Implementation
\&
\&  # Image Information
\&  // only channel 0 writable 
\&  i_img_setmask(img, 0x01);
\&  int mask = i_img_getmask(img);
\&  int channels = i_img_getchannels(img);
\&  i_img_dim width = i_img_get_width(im);
\&  i_img_dim height = i_img_get_height(im);
\&
\&  # Image quantization
\&
\&  # Logging
\&
\&  # Paletted images
\&
\&  # Tags
\&  i_tags_set(&img\->tags, "i_comment", \-1);
\&  i_tags_setn(&img\->tags, "i_xres", 204);
\&  i_tags_setn(&img\->tags, "i_yres", 196);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Blit tools"
.IX Subsection "Blit tools"
.IP "i_render_color(r, x, y, width, source, color)" 4
.IX Item "i_render_color(r, x, y, width, source, color)"
Render the given color with the coverage specified by \f(CW\*(C`source[0]\*(C'\fR to
\&\f(CW\*(C`source[width\-1]\*(C'\fR.
.Sp
Renders in normal combine mode.
.IP "i_render_delete(r)" 4
.IX Item "i_render_delete(r)"
Release an \f(CW\*(C`i_render\*(C'\fR object.
.IP "i_render_fill(r, x, y, width, source, fill)" 4
.IX Item "i_render_fill(r, x, y, width, source, fill)"
Render the given fill with the coverage in \f(CW\*(C`source[0]\*(C'\fR through
\&\f(CW\*(C`source[width\-1]\*(C'\fR.
.IP "i_render_line(r, x, y, width, source, fill)" 4
.IX Item "i_render_line(r, x, y, width, source, fill)"
Render the given fill with the coverage in \f(CW\*(C`source[0]\*(C'\fR through
\&\f(CW\*(C`source[width\-1]\*(C'\fR.
.IP "i_render_linef(r, x, y, width, source, fill)" 4
.IX Item "i_render_linef(r, x, y, width, source, fill)"
Render the given fill with the coverage in \f(CW\*(C`source[0]\*(C'\fR through
\&\f(CW\*(C`source[width\-1]\*(C'\fR.
.IP "i_render_new(im, width)" 4
.IX Item "i_render_new(im, width)"
Allocate a new \f(CW\*(C`i_render\*(C'\fR object and initialize it.
.SS "Data Types"
.IX Subsection "Data Types"
.IP "i_img" 4
.IX Item "i_img"
.Vb 1
\&  i_img *img;
.Ve
.Sp
This is Imager's image type.
.Sp
It contains the following members:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- the number of channels in the image
.IP "\(bu" 4
\&\f(CW\*(C`xsize\*(C'\fR, \f(CW\*(C`ysize\*(C'\fR \- the width and height of the image in pixels
.IP "\(bu" 4
\&\f(CW\*(C`bytes\*(C'\fR \- the number of bytes used to store the image data.  Undefined
where virtual is non-zero.
.IP "\(bu" 4
\&\f(CW\*(C`ch_mask\*(C'\fR \- a mask of writable channels.  eg. if this is 6 then only
channels 1 and 2 are writable.  There may be bits set for which there
are no channels in the image.
.IP "\(bu" 4
\&\f(CW\*(C`bits\*(C'\fR \- the number of bits stored per sample.  Should be one of
i_8_bits, i_16_bits, i_double_bits.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- either i_direct_type for direct color images, or i_palette_type
for paletted images.
.IP "\(bu" 4
\&\f(CW\*(C`virtual\*(C'\fR \- if zero then this image is-self contained.  If non-zero
then this image could be an interface to some other implementation.
.IP "\(bu" 4
\&\f(CW\*(C`idata\*(C'\fR \- the image data.  This should not be directly accessed.  A new
image implementation can use this to store its image data.
\&\fIi_img_destroy()\fR will \fImyfree()\fR this pointer if it's non-null.
.IP "\(bu" 4
\&\f(CW\*(C`tags\*(C'\fR \- a structure storing the image's tags.  This should only be
accessed via the i_tags_*() functions.
.IP "\(bu" 4
\&\f(CW\*(C`ext_data\*(C'\fR \- a pointer for use internal to an image implementation.
This should be freed by the image's destroy handler.
.IP "\(bu" 4
\&\f(CW\*(C`im_data\*(C'\fR \- data internal to Imager.  This is initialized by
\&\fIi_img_init()\fR.
.IP "\(bu" 4
i_f_ppix, i_f_ppixf, i_f_plin, i_f_plinf, i_f_gpix, i_f_gpixf,
i_f_glin, i_f_glinf, i_f_gsamp, i_f_gampf \- implementations for each
of the required image functions.  An image implementation should
initialize these between calling \fIi_img_alloc()\fR and \fIi_img_init()\fR.
.IP "\(bu" 4
i_f_gpal, i_f_ppal, i_f_addcolors, i_f_getcolors, i_f_colorcount,
i_f_maxcolors, i_f_findcolor, i_f_setcolors \- implementations for each
paletted image function.
.IP "\(bu" 4
i_f_destroy \- custom image destruction function.  This should be used
to release memory if necessary.
.IP "\(bu" 4
i_f_gsamp_bits \- implements \fIi_gsamp_bits()\fR for this image.
.IP "\(bu" 4
i_f_psamp_bits \- implements \fIi_psamp_bits()\fR for this image.
.RE
.RS 4
.RE
.IP "i_color" 4
.IX Item "i_color"
.Vb 2
\&  i_color black;
\&  black.rgba.r = black.rgba.g = black.rgba.b = black.rgba.a = 0;
.Ve
.Sp
Type for 8\-bit/sample color.
.Sp
Samples as per;
.Sp
.Vb 1
\&  i_color c;
.Ve
.Sp
i_color is a union of:
.RS 4
.IP "\(bu" 4
gray \- contains a single element gray_color, eg. \f(CW\*(C`c.gray.gray_color\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rgb\*(C'\fR \- contains three elements \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR, eg. \f(CW\*(C`c.rgb.r\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rgba\*(C'\fR \- contains four elements \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR, \f(CW\*(C`a\*(C'\fR, eg. \f(CW\*(C`c.rgba.a\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`cmyk\*(C'\fR \- contains four elements \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`m\*(C'\fR, \f(CW\*(C`y\*(C'\fR, \f(CW\*(C`k\*(C'\fR,
eg. \f(CW\*(C`c.cmyk.y\*(C'\fR.  Note that Imager never uses \s-1CMYK\s0 colors except when
reading/writing files.
.IP "\(bu" 4
channels \- an array of four channels, eg \f(CW\*(C`c.channels[2]\*(C'\fR.
.RE
.RS 4
.RE
.IP "i_fcolor" 4
.IX Item "i_fcolor"
This is the double/sample color type.
.Sp
Its layout exactly corresponds to i_color.
.IP "i_fill_t" 4
.IX Item "i_fill_t"
.Vb 1
\&  i_fill_t *fill;
.Ve
.Sp
This is the \*(L"abstract\*(R" base type for Imager's fill types.
.Sp
Unless you're implementing a new fill type you'll typically treat this
as an opaque type.
.IP "i_img_dim" 4
.IX Item "i_img_dim"
.Vb 1
\&  i_img_dim x, y;
.Ve
.Sp
A signed integer type that represents an image dimension or ordinate.
.Sp
May be larger than int on some platforms.
.IP "i_DF" 4
.IX Item "i_DF"
.Vb 1
\&  printf("left %" i_DF "\en", i_DFc(x));
.Ve
.Sp
This is a constant string that can be used with functions like
\&\fIprintf()\fR to format i_img_dim values after they're been cast with \fIi_DFc()\fR.
.Sp
Does not include the leading \f(CW\*(C`%\*(C'\fR.
.IP "i_DFc" 4
.IX Item "i_DFc"
Cast an \f(CW\*(C`i_img_dim\*(C'\fR value to a type for use with the i_DF format
string.
.IP "i_DFcp" 4
.IX Item "i_DFcp"
Casts two \f(CW\*(C`i_img_dim\*(C'\fR values for use with the i_DF (or i_DFp) format.
.IP "i_DFp" 4
.IX Item "i_DFp"
.Vb 1
\&  printf("point (" i_DFp ")\en", i_DFcp(x, y));
.Ve
.Sp
Format a pair of \f(CW\*(C`i_img_dim\*(C'\fR values.  This format string \fIdoes\fR
include the leading \f(CW\*(C`%\*(C'\fR.
.SS "Drawing"
.IX Subsection "Drawing"
.IP "i_arc(im, x, y, rad, d1, d2, color)" 4
.IX Item "i_arc(im, x, y, rad, d1, d2, color)"
.Vb 1
\&  i_arc(im, 50, 50, 20, 45, 135, &color);
.Ve
.Sp
Fills an arc centered at (x,y) with radius \fIrad\fR covering the range
of angles in degrees from d1 to d2, with the color.
.IP "i_arc_aa(im, x, y, rad, d1, d2, color)" 4
.IX Item "i_arc_aa(im, x, y, rad, d1, d2, color)"
.Vb 1
\&  i_arc_aa(im, 50, 50, 35, 90, 135, &color);
.Ve
.Sp
Anti-alias fills an arc centered at (x,y) with radius \fIrad\fR covering
the range of angles in degrees from d1 to d2, with the color.
.IP "i_arc_aa_cfill(im, x, y, rad, d1, d2, fill)" 4
.IX Item "i_arc_aa_cfill(im, x, y, rad, d1, d2, fill)"
.Vb 1
\&  i_arc_aa_cfill(im, 50, 50, 35, 90, 135, fill);
.Ve
.Sp
Anti-alias fills an arc centered at (x,y) with radius \fIrad\fR covering
the range of angles in degrees from d1 to d2, with the fill object.
.IP "i_arc_cfill(im, x, y, rad, d1, d2, fill)" 4
.IX Item "i_arc_cfill(im, x, y, rad, d1, d2, fill)"
.Vb 1
\&  i_arc_cfill(im, 50, 50, 35, 90, 135, fill);
.Ve
.Sp
Fills an arc centered at (x,y) with radius \fIrad\fR covering the range
of angles in degrees from d1 to d2, with the fill object.
.IP "i_box(im, x1, y1, x2, y2, color)" 4
.IX Item "i_box(im, x1, y1, x2, y2, color)"
.Vb 1
\&  i_box(im, 0, 0, im\->xsize\-1, im\->ysize\-1, &color).
.Ve
.Sp
Outlines the box from (x1,y1) to (x2,y2) inclusive with \fIcolor\fR.
.IP "i_box_cfill(im, x1, y1, x2, y2, fill)" 4
.IX Item "i_box_cfill(im, x1, y1, x2, y2, fill)"
.Vb 1
\&  i_box_cfill(im, 0, 0, im\->xsize\-1, im\->ysize\-1, fill);
.Ve
.Sp
Fills the box from (x1,y1) to (x2,y2) inclusive with fill.
.IP "i_box_filled(im, x1, y1, x2, y2, color)" 4
.IX Item "i_box_filled(im, x1, y1, x2, y2, color)"
.Vb 1
\&  i_box_filled(im, 0, 0, im\->xsize\-1, im\->ysize\-1, &color);
.Ve
.Sp
Fills the box from (x1,y1) to (x2,y2) inclusive with color.
.IP "i_circle_aa(im, x, y, rad, color)" 4
.IX Item "i_circle_aa(im, x, y, rad, color)"
.Vb 1
\&  i_circle_aa(im, 50, 50, 45, &color);
.Ve
.Sp
Anti-alias fills a circle centered at (x,y) for radius \fIrad\fR with
color.
.ie n .IP "i_flood_cfill(""im"", ""seedx"", ""seedy"", ""fill"")" 4
.el .IP "i_flood_cfill(\f(CWim\fR, \f(CWseedx\fR, \f(CWseedy\fR, \f(CWfill\fR)" 4
.IX Item "i_flood_cfill(im, seedx, seedy, fill)"
.Vb 1
\&  i_flood_cfill(im, 50, 50, fill);
.Ve
.Sp
Flood fills the 4\-connected region starting from the point (\f(CW\*(C`seedx\*(C'\fR,
\&\f(CW\*(C`seedy\*(C'\fR) with \f(CW\*(C`fill\*(C'\fR.
.Sp
Returns false if (\f(CW\*(C`seedx\*(C'\fR, \f(CW\*(C`seedy\*(C'\fR) are outside the image.
.ie n .IP "i_flood_cfill_border(""im"", ""seedx"", ""seedy"", ""fill"", ""border"")" 4
.el .IP "i_flood_cfill_border(\f(CWim\fR, \f(CWseedx\fR, \f(CWseedy\fR, \f(CWfill\fR, \f(CWborder\fR)" 4
.IX Item "i_flood_cfill_border(im, seedx, seedy, fill, border)"
.Vb 1
\&  i_flood_cfill_border(im, 50, 50, fill, border);
.Ve
.Sp
Flood fills the 4\-connected region starting from the point (\f(CW\*(C`seedx\*(C'\fR,
\&\f(CW\*(C`seedy\*(C'\fR) with \f(CW\*(C`fill\*(C'\fR, the fill stops when it reaches pixels of color
\&\f(CW\*(C`border\*(C'\fR.
.Sp
Returns false if (\f(CW\*(C`seedx\*(C'\fR, \f(CW\*(C`seedy\*(C'\fR) are outside the image.
.ie n .IP "i_flood_fill(""im"", ""seedx"", ""seedy"", ""color"")" 4
.el .IP "i_flood_fill(\f(CWim\fR, \f(CWseedx\fR, \f(CWseedy\fR, \f(CWcolor\fR)" 4
.IX Item "i_flood_fill(im, seedx, seedy, color)"
.Vb 1
\&  i_flood_fill(im, 50, 50, &color);
.Ve
.Sp
Flood fills the 4\-connected region starting from the point (\f(CW\*(C`seedx\*(C'\fR,
\&\f(CW\*(C`seedy\*(C'\fR) with \fIcolor\fR.
.Sp
Returns false if (\f(CW\*(C`seedx\*(C'\fR, \f(CW\*(C`seedy\*(C'\fR) are outside the image.
.ie n .IP "i_flood_fill_border(""im"", ""seedx"", ""seedy"", ""color"", ""border"")" 4
.el .IP "i_flood_fill_border(\f(CWim\fR, \f(CWseedx\fR, \f(CWseedy\fR, \f(CWcolor\fR, \f(CWborder\fR)" 4
.IX Item "i_flood_fill_border(im, seedx, seedy, color, border)"
.Vb 1
\&  i_flood_fill_border(im, 50, 50, &color, &border);
.Ve
.Sp
Flood fills the 4\-connected region starting from the point (\f(CW\*(C`seedx\*(C'\fR,
\&\f(CW\*(C`seedy\*(C'\fR) with \f(CW\*(C`color\*(C'\fR, fill stops when the fill reaches a pixels
with color \f(CW\*(C`border\*(C'\fR.
.Sp
Returns false if (\f(CW\*(C`seedx\*(C'\fR, \f(CW\*(C`seedy\*(C'\fR) are outside the image.
.IP "i_glin(im, l, r, y, colors)" 4
.IX Item "i_glin(im, l, r, y, colors)"
Retrieves (r\-l) pixels starting from (l,y) into \fIcolors\fR.
.Sp
Returns the number of pixels retrieved.
.IP "i_glinf(im, l, r, y, colors)" 4
.IX Item "i_glinf(im, l, r, y, colors)"
Retrieves (r\-l) pixels starting from (l,y) into \fIcolors\fR as floating
point colors.
.Sp
Returns the number of pixels retrieved.
.IP "i_gpal(im, left, right, y, indexes)" 4
.IX Item "i_gpal(im, left, right, y, indexes)"
Reads palette indexes for the horizontal line (left, y) to (right\-1,
y) into \f(CW\*(C`indexes\*(C'\fR.
.Sp
Returns the number of indexes read.
.Sp
Always returns 0 for direct color images.
.ie n .IP "i_gpix(im, ""x"", ""y"", ""color"")" 4
.el .IP "i_gpix(im, \f(CWx\fR, \f(CWy\fR, \f(CWcolor\fR)" 4
.IX Item "i_gpix(im, x, y, color)"
Retrieves the \f(CW\*(C`color\*(C'\fR of the pixel (x,y).
.Sp
Returns 0 if the pixel was retrieved, or \-1 if not.
.ie n .IP "i_gpixf(im, ""x"", ""y"", ""fcolor"")" 4
.el .IP "i_gpixf(im, \f(CWx\fR, \f(CWy\fR, \f(CWfcolor\fR)" 4
.IX Item "i_gpixf(im, x, y, fcolor)"
Retrieves the color of the pixel (x,y) as a floating point color into
\&\f(CW\*(C`fcolor\*(C'\fR.
.Sp
Returns 0 if the pixel was retrieved, or \-1 if not.
.IP "i_gsamp(im, left, right, y, samples, channels, channel_count)" 4
.IX Item "i_gsamp(im, left, right, y, samples, channels, channel_count)"
Reads sample values from \f(CW\*(C`im\*(C'\fR for the horizontal line (left, y) to
(right\-1,y) for the channels specified by \f(CW\*(C`channels\*(C'\fR, an array of int
with \f(CW\*(C`channel_count\*(C'\fR elements.
.Sp
If channels is \s-1NULL\s0 then the first channels_count channels are retrieved for
each pixel.
.Sp
Returns the number of samples read (which should be (right-left) *
channel_count)
.IP "i_gsamp_bg(im, l, r, y, samples, out_channels, background)" 4
.IX Item "i_gsamp_bg(im, l, r, y, samples, out_channels, background)"
Like \f(CW\*(C`i_gsampf()\*(C'\fR but applies the source image color over a supplied
background color.
.Sp
This is intended for output to image formats that don't support alpha
channels.
.IP "i_gsamp_bits(im, left, right, y, samples, channels, channel_count, bits)" 4
.IX Item "i_gsamp_bits(im, left, right, y, samples, channels, channel_count, bits)"
Reads integer samples scaled to \f(CW\*(C`bits\*(C'\fR bits of precision into the
\&\f(CW\*(C`unsigned int\*(C'\fR array \f(CW\*(C`samples\*(C'\fR.
.Sp
Expect this to be slow unless \f(CW\*(C`bits == im\->bits\*(C'\fR.
.Sp
Returns the number of samples copied, or \-1 on error.
.Sp
Not all image types implement this method.
.Sp
Pushes errors, but does not call \f(CW\*(C`i_clear_error()\*(C'\fR.
.IP "i_gsampf(im, left, right, y, samples, channels, channel_count)" 4
.IX Item "i_gsampf(im, left, right, y, samples, channels, channel_count)"
Reads floating point sample values from \f(CW\*(C`im\*(C'\fR for the horizontal line
(left, y) to (right\-1,y) for the channels specified by \f(CW\*(C`channels\*(C'\fR, an
array of int with channel_count elements.
.Sp
If \f(CW\*(C`channels\*(C'\fR is \s-1NULL\s0 then the first \f(CW\*(C`channel_count\*(C'\fR channels are
retrieved for each pixel.
.Sp
Returns the number of samples read (which should be (\f(CW\*(C`right\*(C'\fR\-\f(CW\*(C`left\*(C'\fR)
* \f(CW\*(C`channel_count\*(C'\fR)
.IP "i_gsampf_bg(im, l, r, y, samples, out_channels, background)" 4
.IX Item "i_gsampf_bg(im, l, r, y, samples, out_channels, background)"
Like \f(CW\*(C`i_gsampf()\*(C'\fR but applies the source image color over a supplied
background color.
.Sp
This is intended for output to image formats that don't support alpha
channels.
.ie n .IP "i_line(""im"", ""x1"", ""y1"", ""x2"", ""y2"", ""color"", ""endp"")" 4
.el .IP "i_line(\f(CWim\fR, \f(CWx1\fR, \f(CWy1\fR, \f(CWx2\fR, \f(CWy2\fR, \f(CWcolor\fR, \f(CWendp\fR)" 4
.IX Item "i_line(im, x1, y1, x2, y2, color, endp)"
Draw a line to image using Bresenham's line drawing algorithm
.Sp
.Vb 7
\&   im    \- image to draw to
\&   x1    \- starting x coordinate
\&   y1    \- starting x coordinate
\&   x2    \- starting x coordinate
\&   y2    \- starting x coordinate
\&   color \- color to write to image
\&   endp  \- endpoint flag (boolean)
.Ve
.ie n .IP "i_line_aa(""im"", ""x1"", ""x2"", ""y1"", ""y2"", ""color"", ""endp"")" 4
.el .IP "i_line_aa(\f(CWim\fR, \f(CWx1\fR, \f(CWx2\fR, \f(CWy1\fR, \f(CWy2\fR, \f(CWcolor\fR, \f(CWendp\fR)" 4
.IX Item "i_line_aa(im, x1, x2, y1, y2, color, endp)"
Anti-alias draws a line from (x1,y1) to (x2, y2) in color.
.Sp
The point (x2, y2) is drawn only if \f(CW\*(C`endp\*(C'\fR is set.
.IP "i_plin(im, l, r, y, colors)" 4
.IX Item "i_plin(im, l, r, y, colors)"
Sets (r\-l) pixels starting from (l,y) using (r\-l) values from
\&\fIcolors\fR.
.Sp
Returns the number of pixels set.
.ie n .IP "i_plinf(im, ""left"", ""right"", ""fcolors"")" 4
.el .IP "i_plinf(im, \f(CWleft\fR, \f(CWright\fR, \f(CWfcolors\fR)" 4
.IX Item "i_plinf(im, left, right, fcolors)"
Sets (right-left) pixels starting from (left,y) using (right-left)
floating point colors from \f(CW\*(C`fcolors\*(C'\fR.
.Sp
Returns the number of pixels set.
.IP "i_ppal(im, left, right, y, indexes)" 4
.IX Item "i_ppal(im, left, right, y, indexes)"
Writes palette indexes for the horizontal line (left, y) to (right\-1,
y) from \f(CW\*(C`indexes\*(C'\fR.
.Sp
Returns the number of indexes written.
.Sp
Always returns 0 for direct color images.
.IP "i_ppix(im, x, y, color)" 4
.IX Item "i_ppix(im, x, y, color)"
Sets the pixel at (x,y) to \fIcolor\fR.
.Sp
Returns 0 if the pixel was drawn, or \-1 if not.
.Sp
Does no alpha blending, just copies the channels from the supplied
color to the image.
.ie n .IP "i_ppixf(im, ""x"", ""y"", ""fcolor"")" 4
.el .IP "i_ppixf(im, \f(CWx\fR, \f(CWy\fR, \f(CWfcolor\fR)" 4
.IX Item "i_ppixf(im, x, y, fcolor)"
Sets the pixel at (\f(CW\*(C`x\*(C'\fR,\f(CW\*(C`y\*(C'\fR) to the floating point color \f(CW\*(C`fcolor\*(C'\fR.
.Sp
Returns 0 if the pixel was drawn, or \-1 if not.
.Sp
Does no alpha blending, just copies the channels from the supplied
color to the image.
.IP "i_psamp_bits(im, left, right, y, samples, channels, channel_count, bits)" 4
.IX Item "i_psamp_bits(im, left, right, y, samples, channels, channel_count, bits)"
Writes integer samples scaled to \f(CW\*(C`bits\*(C'\fR bits of precision from the
\&\f(CW\*(C`unsigned int\*(C'\fR array \f(CW\*(C`samples\*(C'\fR.
.Sp
Expect this to be slow unless \f(CW\*(C`bits == im\->bits\*(C'\fR.
.Sp
Returns the number of samples copied, or \-1 on error.
.Sp
Not all image types implement this method.
.Sp
Pushes errors, but does not call \f(CW\*(C`i_clear_error()\*(C'\fR.
.SS "Error handling"
.IX Subsection "Error handling"
.IP "\fIi_clear_error()\fR" 4
.IX Item "i_clear_error()"
.Vb 1
\&  i_clear_error();
.Ve
.Sp
Clears the error stack.
.Sp
Called by any Imager function before doing any other processing.
.IP "i_push_error(int code, char const *msg)" 4
.IX Item "i_push_error(int code, char const *msg)"
.Vb 2
\&  i_push_error(0, "Yep, it\*(Aqs broken");
\&  i_push_error(errno, "Error writing");
.Ve
.Sp
Called by an Imager function to push an error message onto the stack.
.Sp
No message is pushed if the stack is full (since this means someone
forgot to call \fIi_clear_error()\fR, or that a function that doesn't do
error handling is calling function that does.).
.IP "i_push_errorf(int code, char const *fmt, ...)" 4
.IX Item "i_push_errorf(int code, char const *fmt, ...)"
.Vb 1
\&  i_push_errorf(errno, "Cannot open file %s: %d", filename, errno);
.Ve
.Sp
A version of \fIi_push_error()\fR that does \fIprintf()\fR like formatting.
.Sp
Does not support perl specific format codes.
.ie n .IP "i_push_errorvf(int ""code"", char const *""fmt"", va_list ""ap"")" 4
.el .IP "i_push_errorvf(int \f(CWcode\fR, char const *\f(CWfmt\fR, va_list \f(CWap\fR)" 4
.IX Item "i_push_errorvf(int code, char const *fmt, va_list ap)"
Intended for use by higher level functions, takes a varargs pointer
and a format to produce the finally pushed error message.
.Sp
Does not support perl specific format codes.
.SS "Files"
.IX Subsection "Files"
.IP "i_get_file_background(im, &bg)" 4
.IX Item "i_get_file_background(im, &bg)"
Retrieve the file write background color tag from the image.
.Sp
If not present, returns black.
.IP "i_get_file_backgroundf(im, &bg)" 4
.IX Item "i_get_file_backgroundf(im, &bg)"
Retrieve the file write background color tag from the image as a
floating point color.
.Sp
Implemented in terms of \fIi_get_file_background()\fR.
.Sp
If not present, returns black.
.IP "i_get_image_file_limits(&width, &height, &bytes)" 4
.IX Item "i_get_image_file_limits(&width, &height, &bytes)"
.Vb 1
\&  i_get_image_file_limits(&width, &height, &bytes)
.Ve
.Sp
Retrieves the file limits set by \fIi_set_image_file_limits()\fR.
.RS 4
.IP "\(bu" 4
i_img_dim *width, *height \- the maximum width and height of the image.
.IP "\(bu" 4
size_t *bytes \- size in memory of the image in bytes.
.RE
.RS 4
.RE
.IP "i_int_check_image_file_limits(width, height, channels, sample_size)" 4
.IX Item "i_int_check_image_file_limits(width, height, channels, sample_size)"
.Vb 1
\&  i_i_int_check_image_file_limits(width, height, channels, sizeof(i_sample_t))
.Ve
.Sp
Checks the size of a file in memory against the configured image file
limits.
.Sp
This also range checks the values to those permitted by Imager and
checks for overflows in calculating the size.
.Sp
Returns non-zero if the file is within limits.
.Sp
This function is intended to be called by image file read functions.
.IP "i_set_image_file_limits(width, height, bytes)" 4
.IX Item "i_set_image_file_limits(width, height, bytes)"
.Vb 1
\&  i_set_image_file_limits(500, 500, 1000000);
.Ve
.Sp
Set limits on the sizes of images read by Imager.
.Sp
Setting a limit to 0 means that limit is ignored.
.Sp
Negative limits result in failure.
.Sp
Parameters:
.RS 4
.IP "\(bu" 4
i_img_dim width, height \- maximum width and height.
.IP "\(bu" 4
size_t bytes \- maximum size in memory in bytes
.RE
.RS 4
.Sp
Returns non-zero on success.
.RE
.SS "Fills"
.IX Subsection "Fills"
.ie n .IP "i_new_fill_fount(""xa"", ""ya"", ""xb"", ""yb"", ""type"", ""repeat"", ""combine"", ""super_sample"", ""ssample_param"", ""count"", ""segs"")" 4
.el .IP "i_new_fill_fount(\f(CWxa\fR, \f(CWya\fR, \f(CWxb\fR, \f(CWyb\fR, \f(CWtype\fR, \f(CWrepeat\fR, \f(CWcombine\fR, \f(CWsuper_sample\fR, \f(CWssample_param\fR, \f(CWcount\fR, \f(CWsegs\fR)" 4
.IX Item "i_new_fill_fount(xa, ya, xb, yb, type, repeat, combine, super_sample, ssample_param, count, segs)"
.Vb 2
\&  fill = i_new_fill_fount(0, 0, 100, 100, i_ft_linear, i_ft_linear, 
\&                          i_fr_triangle, 0, i_fts_grid, 9, 1, segs);
.Ve
.Sp
Creates a new general fill which fills with a fountain fill.
.ie n .IP "i_new_fill_hatch(""fg"", ""bg"", ""combine"", ""hatch"", ""cust_hatch"", ""dx"", ""dy"")" 4
.el .IP "i_new_fill_hatch(\f(CWfg\fR, \f(CWbg\fR, \f(CWcombine\fR, \f(CWhatch\fR, \f(CWcust_hatch\fR, \f(CWdx\fR, \f(CWdy\fR)" 4
.IX Item "i_new_fill_hatch(fg, bg, combine, hatch, cust_hatch, dx, dy)"
.Vb 1
\&  i_fill_t *fill = i_new_fill_hatch(&fg_color, &bg_color, combine, hatch, custom_hatch, dx, dy);
.Ve
.Sp
Creates a new hatched fill with the \f(CW\*(C`fg\*(C'\fR color used for the 1 bits in
the hatch and \f(CW\*(C`bg\*(C'\fR for the 0 bits.  If \f(CW\*(C`combine\*(C'\fR is non-zero alpha
values will be combined.
.Sp
If \f(CW\*(C`cust_hatch\*(C'\fR is non-NULL it should be a pointer to 8 bytes of the
hash definition, with the high-bits to the left.
.Sp
If \f(CW\*(C`cust_hatch\*(C'\fR is \s-1NULL\s0 then one of the standard hatches is used.
.Sp
(\f(CW\*(C`dx\*(C'\fR, \f(CW\*(C`dy\*(C'\fR) are an offset into the hatch which can be used to hatch
adjoining areas out of alignment, or to align the origin of a hatch
with the the side of a filled area.
.ie n .IP "i_new_fill_hatchf(""fg"", ""bg"", ""combine"", ""hatch"", ""cust_hatch"", ""dx"", ""dy"")" 4
.el .IP "i_new_fill_hatchf(\f(CWfg\fR, \f(CWbg\fR, \f(CWcombine\fR, \f(CWhatch\fR, \f(CWcust_hatch\fR, \f(CWdx\fR, \f(CWdy\fR)" 4
.IX Item "i_new_fill_hatchf(fg, bg, combine, hatch, cust_hatch, dx, dy)"
.Vb 1
\&  i_fill_t *fill = i_new_fill_hatchf(&fg_fcolor, &bg_fcolor, combine, hatch, custom_hatch, dx, dy);
.Ve
.Sp
Creates a new hatched fill with the \f(CW\*(C`fg\*(C'\fR color used for the 1 bits in
the hatch and \f(CW\*(C`bg\*(C'\fR for the 0 bits.  If \f(CW\*(C`combine\*(C'\fR is non-zero alpha
values will be combined.
.Sp
If \f(CW\*(C`cust_hatch\*(C'\fR is non-NULL it should be a pointer to 8 bytes of the
hash definition, with the high-bits to the left.
.Sp
If \f(CW\*(C`cust_hatch\*(C'\fR is \s-1NULL\s0 then one of the standard hatches is used.
.Sp
(\f(CW\*(C`dx\*(C'\fR, \f(CW\*(C`dy\*(C'\fR) are an offset into the hatch which can be used to hatch
adjoining areas out of alignment, or to align the origin of a hatch
with the the side of a filled area.
.ie n .IP "i_new_fill_image(""im"", ""matrix"", ""xoff"", ""yoff"", ""combine"")" 4
.el .IP "i_new_fill_image(\f(CWim\fR, \f(CWmatrix\fR, \f(CWxoff\fR, \f(CWyoff\fR, \f(CWcombine\fR)" 4
.IX Item "i_new_fill_image(im, matrix, xoff, yoff, combine)"
.Vb 1
\&  i_fill_t *fill = i_new_fill_image(src_img, matrix, x_offset, y_offset, combine);
.Ve
.Sp
Create an image based fill.
.Sp
matrix is an array of 9 doubles representing a transformation matrix.
.Sp
\&\f(CW\*(C`xoff\*(C'\fR and \f(CW\*(C`yoff\*(C'\fR are the offset into the image to start filling from.
.IP "i_new_fill_solid(color, combine)" 4
.IX Item "i_new_fill_solid(color, combine)"
.Vb 1
\&  i_fill_t *fill = i_new_fill_solid(&color, combine);
.Ve
.Sp
Create a solid fill based on an 8\-bit color.
.Sp
If combine is non-zero then alpha values will be combined.
.IP "i_new_fill_solidf(color, combine)" 4
.IX Item "i_new_fill_solidf(color, combine)"
.Vb 1
\&  i_fill_t *fill = i_new_fill_solidf(&fcolor, combine);
.Ve
.Sp
Create a solid fill based on a float color.
.Sp
If combine is non-zero then alpha values will be combined.
.IP "i_fill_destroy(fill)" 4
.IX Item "i_fill_destroy(fill)"
.Vb 1
\&  i_fill_destroy(fill);
.Ve
.Sp
Call to destroy any fill object.
.SS "I/O Layers"
.IX Subsection "I/O Layers"
.IP "\fIio_new_bufchain()\fR" 4
.IX Item "io_new_bufchain()"
returns a new io_glue object that has the 'empty' source and but can
be written to and read from later (like a pseudo file).
.IP "io_new_buffer(data, length)" 4
.IX Item "io_new_buffer(data, length)"
Returns a new io_glue object that has the source defined as reading
from specified buffer.  Note that the buffer is not copied.
.Sp
.Vb 2
\&   data \- buffer to read from
\&   length \- length of buffer
.Ve
.IP "io_new_cb(p, read_cb, write_cb, seek_cb, close_cb, destroy_cb)" 4
.IX Item "io_new_cb(p, read_cb, write_cb, seek_cb, close_cb, destroy_cb)"
Create a new I/O layer object that calls your supplied callbacks.
.Sp
In general the callbacks should behave like the corresponding \s-1POSIX\s0
primitives.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`read_cb\*(C'\fR(p, buffer, length) should read up to \f(CW\*(C`length\*(C'\fR bytes into
\&\f(CW\*(C`buffer\*(C'\fR and return the number of bytes read.  At end of file, return
0.  On error, return \-1.
.IP "\(bu" 4
\&\f(CW\*(C`write_cb\*(C'\fR(p, buffer, length) should write up to \f(CW\*(C`length\*(C'\fR bytes from
\&\f(CW\*(C`buffer\*(C'\fR and return the number of bytes written.  A return value <= 0
will be treated as an error.
.IP "\(bu" 4
\&\f(CW\*(C`seekcb\*(C'\fR(p, offset, whence) should seek and return the new offset.
.IP "\(bu" 4
\&\f(CW\*(C`close_cb\*(C'\fR(p) should return 0 on success, \-1 on failure.
.IP "\(bu" 4
\&\f(CW\*(C`destroy_cb\*(C'\fR(p) should release any memory specific to your callback
handlers.
.RE
.RS 4
.RE
.IP "io_new_fd(fd)" 4
.IX Item "io_new_fd(fd)"
returns a new io_glue object that has the source defined as reading
from specified file descriptor.  Note that the the interface to receiving
data from the io_glue callbacks hasn't been done yet.
.Sp
.Vb 1
\&   fd \- file descriptor to read/write from
.Ve
.IP "i_io_close(io)" 4
.IX Item "i_io_close(io)"
Flush any pending output and perform the close action for the stream.
.Sp
Returns 0 on success.
.IP "i_io_flush(io)" 4
.IX Item "i_io_flush(io)"
Flush any buffered output.
.Sp
Returns true on success,
.IP "i_io_getc(ig)" 4
.IX Item "i_io_getc(ig)"
A macro to read a single byte from a buffered I/O glue object.
.Sp
Returns \s-1EOF\s0 on failure, or a byte.
.IP "i_io_gets(ig, buffer, size, end_of_line)" 4
.IX Item "i_io_gets(ig, buffer, size, end_of_line)"
.Vb 2
\&  char buffer[BUFSIZ]
\&  ssize_t len = i_io_gets(buffer, sizeof(buffer), \*(Aq\en\*(Aq);
.Ve
.Sp
Read up to \f(CW\*(C`size\*(C'\fR\-1 bytes from the stream \f(CW\*(C`ig\*(C'\fR into \f(CW\*(C`buffer\*(C'\fR.
.Sp
If the byte \f(CW\*(C`end_of_line\*(C'\fR is seen then no further bytes will be read.
.Sp
Returns the number of bytes read.
.Sp
Always \f(CW\*(C`NUL\*(C'\fR terminates the buffer.
.IP "i_io_peekc(ig)" 4
.IX Item "i_io_peekc(ig)"
Read the next character from the stream without advancing the stream.
.Sp
On error or end of file, return \s-1EOF\s0.
.Sp
For unbuffered streams a single character buffer will be setup.
.IP "i_io_peekn(ig, buffer, size)" 4
.IX Item "i_io_peekn(ig, buffer, size)"
.Vb 1
\&  ssize_t count = i_io_peekn(ig, buffer, sizeof(buffer));
.Ve
.Sp
Buffer at least \f(CW\*(C`size\*(C'\fR (at most \f(CW\*(C`ig\->buf_size\*(C'\fR bytes of data
from the stream and return \f(CW\*(C`size\*(C'\fR bytes of it to the caller in
\&\f(CW\*(C`buffer\*(C'\fR.
.Sp
This ignores the buffered state of the stream, and will always setup
buffering if needed.
.Sp
If no \f(CW\*(C`type\*(C'\fR parameter is provided to \fIImager::read()\fR or
\&\fIImager::read_multi()\fR, Imager will call \f(CW\*(C`i_io_peekn()\*(C'\fR when probing
for the file format.
.Sp
Returns \-1 on error, 0 if there is no data before \s-1EOF\s0, or the number
of bytes read into \f(CW\*(C`buffer\*(C'\fR.
.IP "i_io_putc(ig, c)" 4
.IX Item "i_io_putc(ig, c)"
Write a single character to the stream.
.Sp
On success return c, on error returns \s-1EOF\s0
.IP "i_io_read(io, buffer, size)" 4
.IX Item "i_io_read(io, buffer, size)"
Read up to \f(CW\*(C`size\*(C'\fR bytes from the stream \f(CW\*(C`io\*(C'\fR into \f(CW\*(C`buffer\*(C'\fR.
.Sp
Returns the number of bytes read.  Returns 0 on end of file.  Returns
\&\-1 on error.
.IP "i_io_seek(io, offset, whence)" 4
.IX Item "i_io_seek(io, offset, whence)"
Seek within the stream.
.Sp
Acts like perl's seek.
.IP "i_io_set_buffered(io, buffered)" 4
.IX Item "i_io_set_buffered(io, buffered)"
Set the buffering mode of the stream.
.Sp
If you switch buffering off on a stream with buffering on:
.RS 4
.IP "\(bu" 4
any buffered output will be flushed.
.IP "\(bu" 4
any existing buffered input will be consumed before reads become
unbuffered.
.RE
.RS 4
.Sp
Returns true on success.  This may fail if any buffered output cannot
be flushed.
.RE
.IP "i_io_write(io, buffer, size)" 4
.IX Item "i_io_write(io, buffer, size)"
.Vb 1
\&  ssize_t result = i_io_write(io, buffer, size)
.Ve
.Sp
Write to the given I/O stream.
.Sp
Returns the number of bytes written.
.IP "io_slurp(ig, c)" 4
.IX Item "io_slurp(ig, c)"
Takes the source that the io_glue is bound to and allocates space for
a return buffer and returns the entire content in a single buffer.
Note: This only works for io_glue objects created by
\&\fIio_new_bufchain()\fR.  It is useful for saving to scalars and such.
.Sp
.Vb 2
\&   ig \- io_glue object
\&   c  \- pointer to a pointer to where data should be copied to
\&
\&  char *data;
\&  size_t size = io_slurp(ig, &data);
\&  ... do something with the data ...
\&  myfree(data);
.Ve
.Sp
\&\fIio_slurp()\fR will abort the program if the supplied I/O layer is not
from \fIio_new_bufchain()\fR.
.IP "io_glue_destroy(ig)" 4
.IX Item "io_glue_destroy(ig)"
.Vb 1
\&  io_glue_destroy(ig);
.Ve
.Sp
Destroy an io_glue objects.  Should clean up all related buffers.
.Sp
.Vb 1
\&   ig \- io_glue object to destroy.
.Ve
.SS "Image"
.IX Subsection "Image"
.IP "i_copy(source)" 4
.IX Item "i_copy(source)"
Creates a new image that is a copy of the image \f(CW\*(C`source\*(C'\fR.
.Sp
Tags are not copied, only the image data.
.Sp
Returns: i_img *
.ie n .IP "i_copyto(""dest"", ""src"", ""x1"", ""y1"", ""x2"", ""y2"", ""tx"", ""ty"")" 4
.el .IP "i_copyto(\f(CWdest\fR, \f(CWsrc\fR, \f(CWx1\fR, \f(CWy1\fR, \f(CWx2\fR, \f(CWy2\fR, \f(CWtx\fR, \f(CWty\fR)" 4
.IX Item "i_copyto(dest, src, x1, y1, x2, y2, tx, ty)"
Copies image data from the area (\f(CW\*(C`x1\*(C'\fR,\f(CW\*(C`y1\*(C'\fR)\-[\f(CW\*(C`x2\*(C'\fR,\f(CW\*(C`y2\*(C'\fR] in the
source image to a rectangle the same size with it's top-left corner at
(\f(CW\*(C`tx\*(C'\fR,\f(CW\*(C`ty\*(C'\fR) in the destination image.
.Sp
If \f(CW\*(C`x1\*(C'\fR > \f(CW\*(C`x2\*(C'\fR or \f(CW\*(C`y1\*(C'\fR > \f(CW\*(C`y2\*(C'\fR then the corresponding co-ordinates
are swapped.
.ie n .IP "i_copyto_trans(""im"", ""src"", ""x1"", ""y1"", ""x2"", ""y2"", ""tx"", ""ty"", ""trans"")" 4
.el .IP "i_copyto_trans(\f(CWim\fR, \f(CWsrc\fR, \f(CWx1\fR, \f(CWy1\fR, \f(CWx2\fR, \f(CWy2\fR, \f(CWtx\fR, \f(CWty\fR, \f(CWtrans\fR)" 4
.IX Item "i_copyto_trans(im, src, x1, y1, x2, y2, tx, ty, trans)"
(\f(CW\*(C`x1\*(C'\fR,\f(CW\*(C`y1\*(C'\fR) (\f(CW\*(C`x2\*(C'\fR,\f(CW\*(C`y2\*(C'\fR) specifies the region to copy (in the
source coordinates) (\f(CW\*(C`tx\*(C'\fR,\f(CW\*(C`ty\*(C'\fR) specifies the upper left corner for
the target image.  pass \s-1NULL\s0 in \f(CW\*(C`trans\*(C'\fR for non transparent i_colors.
.IP "i_img_info(im, info)" 4
.IX Item "i_img_info(im, info)"
Return image information
.Sp
.Vb 2
\&   im \- Image pointer
\&   info \- pointer to array to return data
.Ve
.Sp
info is an array of 4 integers with the following values:
.Sp
.Vb 4
\& info[0] \- width
\& info[1] \- height
\& info[2] \- channels
\& info[3] \- channel mask
.Ve
.ie n .IP "i_rubthru(""im"", ""src"", ""tx"", ""ty"", ""src_minx"", ""src_miny"", ""src_maxx"", ""src_maxy"")" 4
.el .IP "i_rubthru(\f(CWim\fR, \f(CWsrc\fR, \f(CWtx\fR, \f(CWty\fR, \f(CWsrc_minx\fR, \f(CWsrc_miny\fR, \f(CWsrc_maxx\fR, \f(CWsrc_maxy\fR)" 4
.IX Item "i_rubthru(im, src, tx, ty, src_minx, src_miny, src_maxx, src_maxy)"
Takes the sub image \f(CW\*(C`src\*(C'\fR[\f(CW\*(C`src_minx\*(C'\fR, \f(CW\*(C`src_maxx\*(C'\fR)[\f(CW\*(C`src_miny\*(C'\fR, \f(CW\*(C`src_maxy\*(C'\fR)> and
overlays it at (\f(CW\*(C`tx\*(C'\fR,\f(CW\*(C`ty\*(C'\fR) on the image object.
.Sp
The alpha channel of each pixel in \f(CW\*(C`src\*(C'\fR is used to control how much
the existing color in \f(CW\*(C`im\*(C'\fR is replaced, if it is 255 then the color
is completely replaced, if it is 0 then the original color is left
unmodified.
.SS "Image creation/destruction"
.IX Subsection "Image creation/destruction"
.IP "i_img_16_new(x, y, ch)" 4
.IX Item "i_img_16_new(x, y, ch)"
.Vb 1
\&  i_img *img = i_img_16_new(width, height, channels);
.Ve
.Sp
Create a new 16\-bit/sample image.
.Sp
Returns the image on success, or \s-1NULL\s0 on failure.
.IP "i_img_8_new(x, y, ch)" 4
.IX Item "i_img_8_new(x, y, ch)"
.Vb 1
\&  i_img *img = i_img_8_new(width, height, channels);
.Ve
.Sp
Creates a new image object \fIx\fR pixels wide, and \fIy\fR pixels high with
\&\fIch\fR channels.
.IP "i_img_double_new(i_img_dim x, i_img_dim y, int ch)" 4
.IX Item "i_img_double_new(i_img_dim x, i_img_dim y, int ch)"
.Vb 1
\&  i_img *img = i_img_double_new(width, height, channels);
.Ve
.Sp
Creates a new double per sample image.
.ie n .IP "i_img_pal_new(""x"", ""y"", ""channels"", ""maxpal"")" 4
.el .IP "i_img_pal_new(\f(CWx\fR, \f(CWy\fR, \f(CWchannels\fR, \f(CWmaxpal\fR)" 4
.IX Item "i_img_pal_new(x, y, channels, maxpal)"
.Vb 1
\&  i_img *img = i_img_pal_new(width, height, channels, max_palette_size)
.Ve
.Sp
Creates a new paletted image of the supplied dimensions.
.Sp
\&\f(CW\*(C`maxpal\*(C'\fR is the maximum palette size and should normally be 256.
.Sp
Returns a new image or \s-1NULL\s0 on failure.
.ie n .IP "i_sametype(""im"", ""xsize"", ""ysize"")" 4
.el .IP "i_sametype(\f(CWim\fR, \f(CWxsize\fR, \f(CWysize\fR)" 4
.IX Item "i_sametype(im, xsize, ysize)"
.Vb 1
\&  i_img *img = i_sametype(src, width, height);
.Ve
.Sp
Returns an image of the same type (sample size, channels, paletted/direct).
.Sp
For paletted images the palette is copied from the source.
.ie n .IP "i_sametype_chans(""im"", ""xsize"", ""ysize"", ""channels"")" 4
.el .IP "i_sametype_chans(\f(CWim\fR, \f(CWxsize\fR, \f(CWysize\fR, \f(CWchannels\fR)" 4
.IX Item "i_sametype_chans(im, xsize, ysize, channels)"
.Vb 1
\&  i_img *img = i_sametype_chans(src, width, height, channels);
.Ve
.Sp
Returns an image of the same type (sample size).
.Sp
For paletted images the equivalent direct type is returned.
.ie n .IP "i_img_destroy(""img"")" 4
.el .IP "i_img_destroy(\f(CWimg\fR)" 4
.IX Item "i_img_destroy(img)"
.Vb 1
\&  i_img_destroy(img)
.Ve
.Sp
Destroy an image object
.SS "Image Implementation"
.IX Subsection "Image Implementation"
.IP "\fIi_img_alloc()\fR" 4
.IX Item "i_img_alloc()"
Allocates a new i_img structure.
.Sp
When implementing a new image type perform the following steps in your
image object creation function:
.RS 4
.IP "1." 4
allocate the image with \fIi_img_alloc()\fR.
.IP "2." 4
initialize any function pointers or other data as needed, you can
overwrite the whole block if you need to.
.IP "3." 4
initialize Imager's internal data by calling \fIi_img_init()\fR on the image
object.
.RE
.RS 4
.RE
.ie n .IP "i_img_init(""img"")" 4
.el .IP "i_img_init(\f(CWimg\fR)" 4
.IX Item "i_img_init(img)"
Imager internal initialization of images.
.Sp
Currently this does very little, in the future it may be used to
support threads, or color profiles.
.SS "Image Information"
.IX Subsection "Image Information"
.ie n .IP "i_img_color_channels(""im"")" 4
.el .IP "i_img_color_channels(\f(CWim\fR)" 4
.IX Item "i_img_color_channels(im)"
The number of channels holding color information.
.ie n .IP "i_img_get_height(""im"")" 4
.el .IP "i_img_get_height(\f(CWim\fR)" 4
.IX Item "i_img_get_height(im)"
.Vb 1
\&  i_img_dim height = i_img_get_height(im);
.Ve
.Sp
Returns the height in pixels of the image.
.ie n .IP "i_img_get_width(""im"")" 4
.el .IP "i_img_get_width(\f(CWim\fR)" 4
.IX Item "i_img_get_width(im)"
.Vb 1
\&  i_img_dim width = i_img_get_width(im);
.Ve
.Sp
Returns the width in pixels of the image.
.ie n .IP "i_img_getchannels(""im"")" 4
.el .IP "i_img_getchannels(\f(CWim\fR)" 4
.IX Item "i_img_getchannels(im)"
.Vb 1
\&  int channels = i_img_getchannels(img);
.Ve
.Sp
Get the number of channels in \f(CW\*(C`im\*(C'\fR.
.ie n .IP "i_img_getmask(""im"")" 4
.el .IP "i_img_getmask(\f(CWim\fR)" 4
.IX Item "i_img_getmask(im)"
.Vb 1
\&  int mask = i_img_getmask(img);
.Ve
.Sp
Get the image channel mask for \f(CW\*(C`im\*(C'\fR.
.ie n .IP "i_img_has_alpha(""im"")" 4
.el .IP "i_img_has_alpha(\f(CWim\fR)" 4
.IX Item "i_img_has_alpha(im)"
Return true if the image has an alpha channel.
.IP "i_img_is_monochrome(img, &zero_is_white)" 4
.IX Item "i_img_is_monochrome(img, &zero_is_white)"
Tests an image to check it meets our monochrome tests.
.Sp
The idea is that a file writer can use this to test where it should
write the image in whatever bi-level format it uses, eg. \f(CW\*(C`pbm\*(C'\fR for
\&\f(CW\*(C`pnm\*(C'\fR.
.Sp
For performance of encoders we require monochrome images:
.RS 4
.IP "\(bu" 4
be paletted
.IP "\(bu" 4
have a palette of two colors, containing only \f(CW\*(C`(0,0,0)\*(C'\fR and
\&\f(CW\*(C`(255,255,255)\*(C'\fR in either order.
.RE
.RS 4
.Sp
\&\f(CW\*(C`zero_is_white\*(C'\fR is set to non-zero if the first palette entry is white.
.RE
.ie n .IP "i_img_setmask(""im"", ""ch_mask"")" 4
.el .IP "i_img_setmask(\f(CWim\fR, \f(CWch_mask\fR)" 4
.IX Item "i_img_setmask(im, ch_mask)"
.Vb 2
\&  // only channel 0 writable 
\&  i_img_setmask(img, 0x01);
.Ve
.Sp
Set the image channel mask for \f(CW\*(C`im\*(C'\fR to \f(CW\*(C`ch_mask\*(C'\fR.
.Sp
The image channel mask gives some control over which channels can be
written to in the image.
.SS "Image quantization"
.IX Subsection "Image quantization"
.ie n .IP "i_quant_makemap(""quant"", ""imgs"", ""count"")" 4
.el .IP "i_quant_makemap(\f(CWquant\fR, \f(CWimgs\fR, \f(CWcount\fR)" 4
.IX Item "i_quant_makemap(quant, imgs, count)"
Analyzes the \f(CW\*(C`count\*(C'\fR images in \f(CW\*(C`imgs\*(C'\fR according to the rules in
\&\f(CW\*(C`quant\*(C'\fR to build a color map (optimal or not depending on
\&\f(CW\*(C`quant\->make_colors\*(C'\fR).
.ie n .IP "i_quant_translate(""quant"", ""img"")" 4
.el .IP "i_quant_translate(\f(CWquant\fR, \f(CWimg\fR)" 4
.IX Item "i_quant_translate(quant, img)"
Quantize the image given the palette in \f(CW\*(C`quant\*(C'\fR.
.Sp
On success returns a pointer to a memory block of \f(CW\*(C`img\->xsize *
img\->ysize\*(C'\fR \f(CW\*(C`i_palidx\*(C'\fR entries.
.Sp
On failure returns \s-1NULL\s0.
.Sp
You should call \fImyfree()\fR on the returned block when you're done with
it.
.Sp
This function will fail if the supplied palette contains no colors.
.ie n .IP "i_quant_transparent(""quant"", ""data"", ""img"", ""trans_index"")" 4
.el .IP "i_quant_transparent(\f(CWquant\fR, \f(CWdata\fR, \f(CWimg\fR, \f(CWtrans_index\fR)" 4
.IX Item "i_quant_transparent(quant, data, img, trans_index)"
Dither the alpha channel on \f(CW\*(C`img\*(C'\fR into the palette indexes in
\&\f(CW\*(C`data\*(C'\fR.  Pixels to be transparent are replaced with \f(CW\*(C`trans_pixel\*(C'\fR.
.Sp
The method used depends on the tr_* members of \f(CW\*(C`quant\*(C'\fR.
.SS "Logging"
.IX Subsection "Logging"
.IP "i_lhead(file, line)" 4
.IX Item "i_lhead(file, line)"
This is an internal function called by the \fImm_log()\fR macro.
.IP "i_loog(level, format, ...)" 4
.IX Item "i_loog(level, format, ...)"
This is an internal function called by the \fImm_log()\fR macro.
.IP "mm_log((level, format, ...))" 4
.IX Item "mm_log((level, format, ...))"
This is the main entry point to logging. Note that the extra set of
parentheses are required due to limitations in C89 macros.
.Sp
This will format a string with the current file and line number to the
log file if logging is enabled.
.SS "Paletted images"
.IX Subsection "Paletted images"
.IP "i_addcolors(im, colors, count)" 4
.IX Item "i_addcolors(im, colors, count)"
Adds colors to the image's palette.
.Sp
On success returns the index of the lowest color added.
.Sp
On failure returns \-1.
.Sp
Always fails for direct color images.
.IP "i_colorcount(im)" 4
.IX Item "i_colorcount(im)"
Returns the number of colors in the image's palette.
.Sp
Returns \-1 for direct images.
.IP "i_findcolor(im, color, &entry)" 4
.IX Item "i_findcolor(im, color, &entry)"
Searches the images palette for the given color.
.Sp
On success sets *\fIentry\fR to the index of the color, and returns true.
.Sp
On failure returns false.
.Sp
Always fails on direct color images.
.IP "i_getcolors(im, index, colors, count)" 4
.IX Item "i_getcolors(im, index, colors, count)"
Retrieves \fIcount\fR colors starting from \fIindex\fR in the image's
palette.
.Sp
On success stores the colors into \fIcolors\fR and returns true.
.Sp
On failure returns false.
.Sp
Always fails for direct color images.
.Sp
Fails if there are less than \fIindex\fR+\fIcount\fR colors in the image's
palette.
.IP "i_maxcolors(im)" 4
.IX Item "i_maxcolors(im)"
Returns the maximum number of colors the palette can hold for the
image.
.Sp
Returns \-1 for direct color images.
.IP "i_setcolors(im, index, colors, count)" 4
.IX Item "i_setcolors(im, index, colors, count)"
Sets \fIcount\fR colors starting from \fIindex\fR in the image's palette.
.Sp
On success returns true.
.Sp
On failure returns false.
.Sp
The image must have at least \fIindex\fR+\fIcount\fR colors in it's palette
for this to succeed.
.Sp
Always fails on direct color images.
.SS "Tags"
.IX Subsection "Tags"
.IP "i_tags_delbycode(tags, code)" 4
.IX Item "i_tags_delbycode(tags, code)"
Delete any tags with the given code.
.Sp
Returns the number of tags deleted.
.IP "i_tags_delbyname(tags, name)" 4
.IX Item "i_tags_delbyname(tags, name)"
Delete any tags with the given name.
.Sp
Returns the number of tags deleted.
.IP "i_tags_delete(tags, index)" 4
.IX Item "i_tags_delete(tags, index)"
Delete a tag by index.
.Sp
Returns true on success.
.IP "i_tags_destroy(tags)" 4
.IX Item "i_tags_destroy(tags)"
Destroys the given tags structure.  Called by \fIi_img_destroy()\fR.
.IP "i_tags_find(tags, name, start, &entry)" 4
.IX Item "i_tags_find(tags, name, start, &entry)"
Searches for a tag of the given \fIname\fR starting from index \fIstart\fR.
.Sp
On success returns true and sets *\fIentry\fR.
.Sp
On failure returns false.
.IP "i_tags_findn(tags, code, start, &entry)" 4
.IX Item "i_tags_findn(tags, code, start, &entry)"
Searches for a tag of the given \fIcode\fR starting from index \fIstart\fR.
.Sp
On success returns true and sets *\fIentry\fR.
.Sp
On failure returns false.
.IP "i_tags_get_color(tags, name, code, &value)" 4
.IX Item "i_tags_get_color(tags, name, code, &value)"
Retrieve a tag specified by name or code as color.
.Sp
On success sets the i_color *\fIvalue\fR to the color and returns true.
.Sp
On failure returns false.
.IP "i_tags_get_float(tags, name, code, value)" 4
.IX Item "i_tags_get_float(tags, name, code, value)"
Retrieves a tag as a floating point value.
.Sp
If the tag has a string value then that is parsed as a floating point
number, otherwise the integer value of the tag is used.
.Sp
On success sets *\fIvalue\fR and returns true.
.Sp
On failure returns false.
.IP "i_tags_get_int(tags, name, code, &value)" 4
.IX Item "i_tags_get_int(tags, name, code, &value)"
Retrieve a tag specified by name or code as an integer.
.Sp
On success sets the int *\fIvalue\fR to the integer and returns true.
.Sp
On failure returns false.
.IP "i_tags_get_string(tags, name, code, value, value_size)" 4
.IX Item "i_tags_get_string(tags, name, code, value, value_size)"
Retrieves a tag by name or code as a string.
.Sp
On success copies the string to value for a max of value_size and
returns true.
.Sp
On failure returns false.
.Sp
value_size must be at least large enough for a string representation
of an integer.
.Sp
The copied value is always \f(CW\*(C`NUL\*(C'\fR terminated.
.IP "i_tags_new(i_img_tags *tags)" 4
.IX Item "i_tags_new(i_img_tags *tags)"
Initialize a tags structure.  Should not be used if the tags structure
has been previously used.
.Sp
This should be called tags member of an i_img object on creation (in
i_img_*\fI_new()\fR functions).
.Sp
To destroy the contents use \fIi_tags_destroy()\fR
.IP "i_tags_set(tags, name, data, size)" 4
.IX Item "i_tags_set(tags, name, data, size)"
.Vb 1
\&  i_tags_set(&img\->tags, "i_comment", \-1);
.Ve
.Sp
Sets the given tag to the string \fIdata\fR
.Sp
If size is \-1 then the strlen(\fIdata\fR) bytes are stored.
.Sp
Even on failure, if an existing tag \fIname\fR exists, it will be
removed.
.IP "i_tags_set_color(tags, name, code, &value)" 4
.IX Item "i_tags_set_color(tags, name, code, &value)"
Stores the given color as a tag with the given name and code.
.IP "i_tags_set_float(tags, name, code, value)" 4
.IX Item "i_tags_set_float(tags, name, code, value)"
Equivalent to i_tags_set_float2(tags, name, code, value, 30).
.IP "i_tags_set_float2(tags, name, code, value, places)" 4
.IX Item "i_tags_set_float2(tags, name, code, value, places)"
Sets the tag with the given name and code to the given floating point
value.
.Sp
Since tags are strings or ints, we convert the value to a string before
storage at the precision specified by \f(CW\*(C`places\*(C'\fR.
.ie n .IP "i_tags_setn(""tags"", ""name"", ""idata"")" 4
.el .IP "i_tags_setn(\f(CWtags\fR, \f(CWname\fR, \f(CWidata\fR)" 4
.IX Item "i_tags_setn(tags, name, idata)"
.Vb 2
\&  i_tags_setn(&img\->tags, "i_xres", 204);
\&  i_tags_setn(&img\->tags, "i_yres", 196);
.Ve
.Sp
Sets the given tag to the integer \f(CW\*(C`idata\*(C'\fR
.Sp
Even on failure, if an existing tag \f(CW\*(C`name\*(C'\fR exists, it will be
removed.
.SS "Uncategorized functions"
.IX Subsection "Uncategorized functions"
.IP "i_utf8_advance(char **p, size_t *len)" 4
.IX Item "i_utf8_advance(char **p, size_t *len)"
Retrieve a \f(CW\*(C`UTF\-8\*(C'\fR character from the stream.
.Sp
Modifies *p and *len to indicate the consumed characters.
.Sp
This doesn't support the extended \f(CW\*(C`UTF\-8\*(C'\fR encoding used by later
versions of Perl.  Since this is typically used to implement text
output by font drivers, the strings supplied shouldn't have such out
of range characters.
.Sp
This doesn't check that the \f(CW\*(C`UTF\-8\*(C'\fR character is using the shortest
possible representation.
.Sp
Returns ~0UL on failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager, Imager::ExtUtils, Imager::Inline
