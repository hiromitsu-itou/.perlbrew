.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Realm::SimpleDB 3"
.TH Catalyst::Authentication::Realm::SimpleDB 3 "2011-08-24" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Authentication::Realm::SimpleDB \- A simplified Catalyst authentication configurator.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Catalyst qw/
\&        Authentication
\&    /;
\&
\&    _\|_PACKAGE_\|_\->config\->{\*(AqPlugin::Authentication\*(Aq} =
\&        {
\&            default => {
\&                class      => \*(AqSimpleDB\*(Aq,
\&                user_model => \*(AqMyApp::Schema::Users\*(Aq,
\&            }
\&        }
\&
\&    # later on ...
\&    $c\->authenticate({ username => \*(Aqmyusername\*(Aq,
\&                       password => \*(Aqmypassword\*(Aq });
\&
\&    my $age = $c\->user\->get(\*(Aqage\*(Aq);
\&
\&    $c\->logout;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Catalyst::Authentication::Realm::SimpleDB provides a simple way to configure Catalyst Authentication
when using the most common configuration of a password protected user retrieved from an \s-1SQL\s0 database.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The SimpleDB Realm class configures the Catalyst authentication system based on the following:
.IP "\(bu" 4
Your user data is stored in a table that is accessible via \f(CW$c\fR\->model($cfg\->{user_model});
.IP "\(bu" 4
Your passwords are stored in the 'password' field in your users table and are not encrypted.
.IP "\(bu" 4
Your roles for users are stored in a separate table and are directly
accessible via a DBIx::Class relationship called 'roles' and the text of the
role is stored in a field called 'role' within the role table.
.IP "\(bu" 4
Your user information is stored in the session once the user is authenticated.
.PP
For the above usage, only one configuration option is necessary, 'user_model'.
\&\fBuser_model\fR should contain the \fBclass name of your user class\fR. See the
\&\*(L"\s-1PREPARATION\s0\*(R" section for info on how to set up your database for use with
this module.
.PP
If your system differs from the above, some minor configuration may be
necessary. The options available are detailed below. These options match the
configuration options used by the underlying credential and store modules.
More information on these options can be found in
Catalyst::Authentication::Credential::Password and
Catalyst::Authentication::Store::DBIx::Class.
.IP "user_model" 4
.IX Item "user_model"
Contains the class name (as passed to \f(CW$c\fR\->\fImodel()\fR ) of the DBIx::Class schema
to use as the source for user information.  This config item is \fB\s-1REQUIRED\s0\fR.
.IP "password_field" 4
.IX Item "password_field"
If your password field is not 'password' set this option to the name of your password field.  Note that if you change this
to, say 'users_password' you will need to use that in the authenticate call:
.Sp
.Vb 1
\&    $c\->authenticate({ username => \*(Aqbob\*(Aq, users_password => \*(Aqfoo\*(Aq });
.Ve
.IP "password_type" 4
.IX Item "password_type"
If the password is not stored in plaintext you will need to define what format the password is in.  The common options are
\&\fBcrypted\fR and \fBhashed\fR.  Crypted uses the standard unix crypt to encrypt the password.  Hashed uses the Digest modules to
perform password hashing.
.IP "password_hash_type" 4
.IX Item "password_hash_type"
If you use a hashed password type \- this defines the type of hashing. See Catalyst::Authentication::Credential::Password
for more details on this setting.
.IP "role_column" 4
.IX Item "role_column"
If your users roles are stored directly in your user table, set this to the column name that contains your roles.  For
example, if your user table contains a field called 'permissions', the value of role_column would be 'permissions'.
\&\fB\s-1NOTE\s0\fR: If multiple values are stored in the role column, they should be space or pipe delimited.
.IP "role_relation and role_field" 4
.IX Item "role_relation and role_field"
These define an alternate role relationship name and the column that holds the role's name in plain text.  See
\&\*(L"\s-1CONFIGURATION\s0\*(R" in Catalyst::Authentication::Store::DBIx::Class for more details on these settings.
.IP "use_userdata_from_session" 4
.IX Item "use_userdata_from_session"
This is a simple 1 / 0 setting which determines how a user's data is saved / restored from the session.  If
it is set to 1, the user's complete information (at the time of authentication) is cached between requests.
If it is set to 0, the users information is loaded from the database on each request.
.SH "PREPARATION"
.IX Header "PREPARATION"
This module makes several assumptions about the structure of your database.
Below is an example of a table structure which will function with this module
in it's default configuration. You can use this table structure as-is or add
additional fields as necessary. \fB\s-1NOTE\s0\fR that this is the default SimpleDB
configuration only. Your table structure can differ significantly from this
when using the DBIx::Class
Store directly.
.PP
.Vb 8
\&    \-\-
\&    \-\- note that you can add any additional columns you require to the users table.
\&    \-\-
\&    CREATE TABLE users (
\&            id            INTEGER PRIMARY KEY,
\&            username      TEXT,
\&            password      TEXT,
\&    );
\&
\&    CREATE TABLE roles (
\&            id   INTEGER PRIMARY KEY,
\&            role TEXT
\&    );
\&    CREATE TABLE user_roles (
\&            user_id INTEGER,
\&            role_id INTEGER,
\&            PRIMARY KEY (user_id, role_id)
\&    );
.Ve
.PP
Also, after you have loaded this table structure into your DBIx::Class schema,
please be sure that you have a many_to_many DBIx::Class relationship defined
for the users to roles relation. Your schema files should contain something
along these lines:
.PP
\&\f(CW\*(C`lib/MyApp/Schema/Users.pm\*(C'\fR:
.PP
.Vb 2
\&    _\|_PACKAGE_\|_\->has_many(map_user_role => \*(AqMyApp::Schema::UserRoles\*(Aq, \*(Aquser_id\*(Aq);
\&    _\|_PACKAGE_\|_\->many_to_many(roles => \*(Aqmap_user_role\*(Aq, \*(Aqrole\*(Aq);
.Ve
.PP
\&\f(CW\*(C`lib/MyApp/Schema/UserRoles.pm\*(C'\fR:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->belongs_to(role => \*(AqMyApp::Schema::Roles\*(Aq, \*(Aqrole_id\*(Aq);
.Ve
.SH "MIGRATION"
.IX Header "MIGRATION"
If and when your application becomes complex enough that you need more features
than SimpleDB gives you access to, you can migrate to a standard Catalyst
Authentication configuration fairly easily.  SimpleDB simply creates a standard
Auth config based on the inputs you give it.  The config SimpleDB creates by default
looks like this:
.PP
.Vb 10
\&    MyApp\->config(\*(AqPlugin::Authentication\*(Aq) = {
\&        default => {
\&            credential => {
\&                class => \*(AqPassword\*(Aq,
\&                password_type => \*(Aqclear\*(Aq
\&            },
\&            store => {
\&                class => \*(AqDBIx::Class\*(Aq,
\&                role_relation => \*(Aqroles\*(Aq,
\&                role_field => \*(Aqrole\*(Aq,
\&                use_userdata_from_session => \*(Aq1\*(Aq,
\&                user_model => $user_model_from_simpledb_config
\&                }
\&            }
\&    };
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module relies on a number of other modules to do it's job.  For more information
you can refer to the following:
.IP "\(bu" 4
Catalyst::Manual::Tutorial::Authentication
.IP "\(bu" 4
Catalyst::Plugin::Authentication
.IP "\(bu" 4
Catalyst::Authentication::Credential::Password
.IP "\(bu" 4
Catalyst::Authentication::Store::DBIx::Class
.IP "\(bu" 4
Catalyst::Plugin::Authorization::Roles
