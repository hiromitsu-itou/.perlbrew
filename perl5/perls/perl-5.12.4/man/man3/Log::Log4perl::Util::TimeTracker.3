.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util::TimeTracker 3"
.TH Util::TimeTracker 3 "2010-07-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Log4perl::Util::TimeTracker \- Track time elapsed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Log4perl::Util::TimeTracker;
\&
\&  my $timer = Log::Log4perl::Util::TimeTracker\->new();
\&
\&    # equivalent to Time::HiRes::gettimeofday(), regardless
\&    # if Time::HiRes is present or not. 
\&  my($seconds, $microseconds) = $timer\->gettimeofday();
\&
\&    # reset internal timer
\&  $timer\->reset();
\&
\&    # return milliseconds since last reset
\&  $msecs = $timer\->milliseconds();
\&
\&    # return milliseconds since last call
\&  $msecs = $timer\->delta_milliseconds();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This utility module helps tracking time elapsed for PatternLayout's
date and time placeholders. Its accuracy depends on the availability
of the Time::HiRes module. If it's available, its granularity is
milliseconds, if not, seconds.
.PP
The most common use of this module is calling the \fIgettimeofday()\fR 
method:
.PP
.Vb 1
\&  my($seconds, $microseconds) = $timer\->gettimeofday();
.Ve
.PP
It returns seconds and microseconds of the current epoch time. If 
Time::HiRes is installed, it will simply defer to its \fIgettimeofday()\fR
function, if it's missing, \fItime()\fR will be called instead and \f(CW$microseconds\fR
will always be 0.
.PP
To measure time elapsed in milliseconds, use the \fIreset()\fR method to 
reset the timer to the current time, followed by one or more calls to
the \fImilliseconds()\fR method:
.PP
.Vb 2
\&    # reset internal timer
\&  $timer\->reset();
\&
\&    # return milliseconds since last reset
\&  $msecs = $timer\->milliseconds();
.Ve
.PP
On top of the time span between the last reset and the current time, 
the module keeps track of the time between calls to \fIdelta_milliseconds()\fR:
.PP
.Vb 1
\&  $msecs = $timer\->delta_milliseconds();
.Ve
.PP
On the first call, this will return the number of milliseconds since the
last \fIreset()\fR, on subsequent calls, it will return the time elapsed in
milliseconds since the last call to \fIdelta_milliseconds()\fR instead. Note
that \fIreset()\fR also resets the time of the last call.
.PP
The internal timer of this module gets its time input from the \s-1POSIX\s0 \fItime()\fR 
function, or, if the Time::HiRes module is available, from its 
\&\fIgettimeofday()\fR function. To figure out which one it is, use
.PP
.Vb 5
\&    if( $timer\->hires_available() ) {
\&        print "Hooray, we get real milliseconds!\en";
\&    } else {
\&        print "Milliseconds are just bogus\en";
\&    }
.Ve
.PP
For testing purposes, a different time source can be provided, so test
suites can simulate time passing by without actually having to wait:
.PP
.Vb 1
\&  my $start_time = time();
\&
\&  my $timer = Log::Log4perl::Util::TimeTracker\->new(
\&          time_function => sub {
\&              return $start_time++;
\&          },
\&  );
.Ve
.PP
Every call to \f(CW$timer\fR\->\fIepoch()\fR will then return a time value that is one
second ahead of the the value returned on the previous call. This also means
that every call to \fIdelta_milliseconds()\fR will return a value that exceeds
the value returned on the previous call by 1000.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2002\-2009 by Mike Schilli <m@perlmeister.com> 
and Kevin Goess <cpan@goess.org>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
