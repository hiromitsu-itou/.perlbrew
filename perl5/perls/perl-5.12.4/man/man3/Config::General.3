.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "General 3"
.TH General 3 "2010-12-01" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::General \- Generic Config Module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& #
\& # the OOP way
\& use Config::General;
\& $conf = new Config::General("rcfile");
\& my %config = $conf\->getall;
\&
\& #
\& # the procedural way
\& use Config::General qw(ParseConfig SaveConfig SaveConfigString);
\& my %config = ParseConfig("rcfile");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module opens a config file and parses its contents for you. The \fBnew\fR method
requires one parameter which needs to be a filename. The method \fBgetall\fR returns a hash
which contains all options and its associated values of your config file.
.PP
The format of config files supported by \fBConfig::General\fR is inspired by the well known Apache config
format, in fact, this module is 100% compatible to Apache configs, but you can also just use simple
 name/value pairs in your config files.
.PP
In addition to the capabilities of an Apache config file it supports some enhancements such as here-documents,
C\-style comments or multiline options.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Possible ways to call \fB\f(BInew()\fB\fR:
.Sp
.Vb 1
\& $conf = new Config::General("rcfile");
\&
\& $conf = new Config::General(\e%somehash);
\&
\& $conf = new Config::General( %options ); # see below for description of possible options
.Ve
.Sp
This method returns a \fBConfig::General\fR object (a hash blessed into \*(L"Config::General\*(R" namespace.
All further methods must be used from that returned object. see below.
.Sp
You can use the new style with hash parameters or the old style which is of course
still supported. Possible parameters to \fB\f(BInew()\fB\fR are:
.Sp
* a filename of a configfile, which will be opened and parsed by the parser
.Sp
or
.Sp
* a hash reference, which will be used as the config.
.Sp
An alternative way to call \fB\f(BInew()\fB\fR is supplying an option\- hash with one or more of
the following keys set:
.RS 4
.IP "\fB\-ConfigFile\fR" 4
.IX Item "-ConfigFile"
A filename or a filehandle, i.e.:
.Sp
.Vb 1
\& \-ConfigFile => "rcfile" or \-ConfigFile => \e$FileHandle
.Ve
.IP "\fB\-ConfigHash\fR" 4
.IX Item "-ConfigHash"
A hash reference, which will be used as the config, i.e.:
.Sp
.Vb 1
\& \-ConfigHash => \e%somehash
.Ve
.IP "\fB\-String\fR" 4
.IX Item "-String"
A string which contains a whole config, or an arrayref
containing the whole config line by line.
The parser will parse the contents of the string instead
of a file. i.e:
.Sp
.Vb 1
\& \-String => $complete_config
.Ve
.Sp
it is also possible to feed an array reference to \-String:
.Sp
.Vb 1
\& \-String => \e@config_lines
.Ve
.IP "\fB\-AllowMultiOptions\fR" 4
.IX Item "-AllowMultiOptions"
If the value is \*(L"no\*(R", then multiple identical options are disallowed.
The default is \*(L"yes\*(R".
i.e.:
.Sp
.Vb 1
\& \-AllowMultiOptions => "yes"
.Ve
.Sp
see \fB\s-1IDENTICAL\s0 \s-1OPTIONS\s0\fR for details.
.IP "\fB\-LowerCaseNames\fR" 4
.IX Item "-LowerCaseNames"
If set to a true value, then all options found in the config will be converted
to lowercase. This allows you to provide case-in-sensitive configs. The
values of the options will \fBnot\fR lowercased.
.IP "\fB\-UseApacheInclude\fR" 4
.IX Item "-UseApacheInclude"
If set to a true value, the parser will consider \*(L"include ...\*(R" as valid include
statement (just like the well known Apache include statement).
.IP "\fB\-IncludeRelative\fR" 4
.IX Item "-IncludeRelative"
If set to a true value, included files with a relative path (i.e. \*(L"cfg/blah.conf\*(R")
will be opened from within the location of the configfile instead from within the
location of the script($0). This works only if the configfile has a absolute pathname
(i.e. \*(L"/etc/main.conf\*(R").
.Sp
If the variable \fB\-ConfigPath\fR has been set and if the file to be included could
not be found in the location relative to the current config file, the module
will search within \fB\-ConfigPath\fR for the file. See the description of \fB\-ConfigPath\fR
for more details.
.IP "\fB\-IncludeDirectories\fR" 4
.IX Item "-IncludeDirectories"
If set to a true value, you may specify include a directory, in which case all
files inside the directory will be loaded in \s-1ASCII\s0 order.  Directory includes
will not recurse into subdirectories.  This is comparable to including a
directory in Apache-style config files.
.IP "\fB\-IncludeGlob\fR" 4
.IX Item "-IncludeGlob"
If set to a true value, you may specify a glob pattern for an include to
include all matching files (e.g. <<include conf.d/*.conf>>).  Also note that as
with standard file patterns, * will not match dot-files, so <<include dir/*>>
is often more desirable than including a directory with \fB\-IncludeDirectories\fR.
.IP "\fB\-IncludeAgain\fR" 4
.IX Item "-IncludeAgain"
If set to a true value, you will be able to include a sub-configfile
multiple times.  With the default, false, you will get a warning about
duplicate includes and only the first include will succeed.
.Sp
Reincluding a configfile can be useful if it contains data that you want to
be present in multiple places in the data tree.  See the example under
\&\*(L"\s-1INCLUDES\s0\*(R".
.Sp
Note, however, that there is currently no check for include recursion.
.IP "\fB\-ConfigPath\fR" 4
.IX Item "-ConfigPath"
As mentioned above, you can use this variable to specify a search path for relative
config files which have to be included. Config::General will search within this
path for the file if it cannot find the file at the location relative to the
current config file.
.Sp
To provide multiple search paths you can specify an array reference for the
path.  For example:
.Sp
.Vb 3
\& @path = qw(/usr/lib/perl /nfs/apps/lib /home/lib);
\& ..
\& \-ConfigPath => \e@path
.Ve
.IP "\fB\-MergeDuplicateBlocks\fR" 4
.IX Item "-MergeDuplicateBlocks"
If set to a true value, then duplicate blocks, that means blocks and named blocks,
will be merged into a single one (see below for more details on this).
The default behavior of Config::General is to create an array if some junk in a
config appears more than once.
.IP "\fB\-MergeDuplicateOptions\fR" 4
.IX Item "-MergeDuplicateOptions"
If set to a true value, then duplicate options will be merged. That means, if the
same option occurs more than once, the last one will be used in the resulting
config hash.
.Sp
Setting this option implies \fB\-AllowMultiOptions == false\fR unless you set
\&\fB\-AllowMultiOptions\fR explicit to 'true'. In this case duplicate blocks are
allowed and put into an array but duplicate options will be merged.
.IP "\fB\-AutoLaunder\fR" 4
.IX Item "-AutoLaunder"
If set to a true value, then all values in your config file will be laundered
to allow them to be used under a \-T taint flag.  This could be regarded as circumventing
the purpose of the \-T flag, however, if the bad guys can mess with your config file,
you have problems that \-T will not be able to stop.  AutoLaunder will only handle
a config file being read from \-ConfigFile.
.IP "\fB\-AutoTrue\fR" 4
.IX Item "-AutoTrue"
If set to a true value, then options in your config file, whose values are set to
true or false values, will be normalised to 1 or 0 respectively.
.Sp
The following values will be considered as \fBtrue\fR:
.Sp
.Vb 1
\& yes, on, 1, true
.Ve
.Sp
The following values will be considered as \fBfalse\fR:
.Sp
.Vb 1
\& no, off, 0, false
.Ve
.Sp
This effect is case-insensitive, i.e. both \*(L"Yes\*(R" or \*(L"oN\*(R" will result in 1.
.IP "\fB\-FlagBits\fR" 4
.IX Item "-FlagBits"
This option takes one required parameter, which must be a hash reference.
.Sp
The supplied hash reference needs to define variables for which you
want to preset values. Each variable you have defined in this hash-ref
and which occurs in your config file, will cause this variable being
set to the preset values to which the value in the config file refers to.
.Sp
Multiple flags can be used, separated by the pipe character |.
.Sp
Well, an example will clarify things:
.Sp
.Vb 9
\& my $conf = new Config::General(
\&         \-ConfigFile => "rcfile",
\&         \-FlagBits => {
\&              Mode => {
\&                 CLEAR    => 1,
\&                 STRONG   => 1,
\&                 UNSECURE => "32bit" }
\&         }
\& );
.Ve
.Sp
In this example we are defining a variable named \fI\*(L"Mode\*(R"\fR which
may contain one or more of \*(L"\s-1CLEAR\s0\*(R", \*(L"\s-1STRONG\s0\*(R" and \*(L"\s-1UNSECURE\s0\*(R" as value.
.Sp
The appropriate config entry may look like this:
.Sp
.Vb 2
\& # rcfile
\& Mode = CLEAR | UNSECURE
.Ve
.Sp
The parser will create a hash which will be the value of the key \*(L"Mode\*(R". This
hash will contain \fBall\fR flags which you have pre-defined, but only those
which were set in the config will contain the pre-defined value, the other
ones will be undefined.
.Sp
The resulting config structure would look like this after parsing:
.Sp
.Vb 7
\& %config = (
\&             Mode => {
\&                       CLEAR    => 1,
\&                       UNSECURE => "32bit",
\&                       STRONG   => undef,
\&                     }
\&           );
.Ve
.Sp
This method allows the user (or, the \*(L"maintainer\*(R" of the configfile for your
application) to set multiple pre-defined values for one option.
.Sp
Please beware, that all occurrences of those variables will be handled this
way, there is no way to distinguish between variables in different scopes.
That means, if \*(L"Mode\*(R" would also occur inside a named block, it would
also parsed this way.
.Sp
Values which are not defined in the hash-ref supplied to the parameter \fB\-FlagBits\fR
and used in the corresponding variable in the config will be ignored.
.Sp
Example:
.Sp
.Vb 2
\& # rcfile
\& Mode = BLAH | CLEAR
.Ve
.Sp
would result in this hash structure:
.Sp
.Vb 7
\&  %config = (
\&             Mode => {
\&                       CLEAR    => 1,
\&                       UNSECURE => undef,
\&                       STRONG   => undef,
\&                     }
\&           );
.Ve
.Sp
\&\*(L"\s-1BLAH\s0\*(R" will be ignored silently.
.IP "\fB\-DefaultConfig\fR" 4
.IX Item "-DefaultConfig"
This can be a hash reference or a simple scalar (string) of a config. This
causes the module to preset the resulting config hash with the given values,
which allows you to set default values for particular config options directly.
.IP "\fB\-Tie\fR" 4
.IX Item "-Tie"
\&\fB\-Tie\fR takes the name of a Tie class as argument that each new hash should be
based off of.
.Sp
This hash will be used as the 'backing hash' instead of a standard Perl hash,
which allows you to affect the way, variable storing will be done. You could, for
example supply a tied hash, say Tie::DxHash, which preserves ordering of the
keys in the config (which a standard Perl hash won't do). Or, you could supply
a hash tied to a \s-1DBM\s0 file to save the parsed variables to disk.
.Sp
There are many more things to do in tie-land, see tie to get some interesting
ideas.
.Sp
If you want to use the \fB\-Tie\fR feature together with \fB\-DefaultConfig\fR make sure
that the hash supplied to \fB\-DefaultConfig\fR must be tied to the same Tie class.
.Sp
Make sure that the hash which receives the generated hash structure (e.g. which
you are using in the assignment: \f(CW%hash\fR = \f(CW$config\fR\->\fIgetall()\fR) must be tied to
the same Tie class.
.Sp
Example:
.Sp
.Vb 7
\& use Config::General qw(ParseConfig);
\& use Tie::IxHash;
\& tie my %hash, "Tie::IxHash";
\& %hash = ParseConfig(
\&           \-ConfigFile => shift(),
\&           \-Tie => "Tie::IxHash"
\&         );
.Ve
.IP "\fB\-InterPolateVars\fR" 4
.IX Item "-InterPolateVars"
If set to a true value, variable interpolation will be done on your config
input. See Config::General::Interpolated for more information.
.IP "\fB\-InterPolateEnv\fR" 4
.IX Item "-InterPolateEnv"
If set to a true value, environment variables can be used in
configs.
.Sp
This implies \fB\-InterPolateVars\fR.
.IP "\fB\-AllowSingleQuoteInterpolation\fR" 4
.IX Item "-AllowSingleQuoteInterpolation"
By default variables inside single quotes will not be interpolated. If
you turn on this option, they will be interpolated as well.
.IP "\fB\-ExtendedAccess\fR" 4
.IX Item "-ExtendedAccess"
If set to a true value, you can use object oriented (extended) methods to
access the parsed config. See Config::General::Extended for more informations.
.IP "\fB\-StrictObjects\fR" 4
.IX Item "-StrictObjects"
By default this is turned on, which causes Config::General to croak with an
error if you try to access a non-existent key using the OOP-way (\fB\-ExtendedAcess\fR
enabled). If you turn \fB\-StrictObjects\fR off (by setting to 0 or \*(L"no\*(R") it will
just return an empty object/hash/scalar. This is valid for OOP-access 8via \s-1AUTOLOAD\s0
and for the methods \fIobj()\fR, \fIhash()\fR and \fIvalue()\fR.
.IP "\fB\-StrictVars\fR" 4
.IX Item "-StrictVars"
By default this is turned on, which causes Config::General to croak with an
error if an undefined variable with \fBInterPolateVars\fR turned on occurs
in a config. Set to \fIfalse\fR (i.e. 0) to avoid such error messages.
.IP "\fB\-SplitPolicy\fR" 4
.IX Item "-SplitPolicy"
You can influence the way how Config::General decides which part of a line
in a config file is the key and which one is the value. By default it tries
its best to guess. That means you can mix equalsign assignments and whitespace
assignments.
.Sp
However, somtime you may wish to make it more strictly for some reason. In
this case you can set \fB\-SplitPolicy\fR. The possible values are: 'guess' which
is the default, 'whitespace' which causes the module to split by whitespace,
\&'equalsign' which causes it to split strictly by equal sign, or 'custom'. In the
latter case you must also set \fB\-SplitDelimiter\fR to some regular expression
of your choice. For example:
.Sp
.Vb 1
\& \-SplitDelimiter => \*(Aq\es*:\es*\*(Aq
.Ve
.Sp
will cause the module to split by colon while whitespace which surrounds
the delimiter will be removed.
.Sp
Please note that the delimiter used when saving a config (\fIsave_file()\fR or \fIsave_string()\fR)
will be chosen according to the current \fB\-SplitPolicy\fR. If \-SplitPolicy is
set to 'guess' or 'whitespace', 3 spaces will be used to delimit saved
options. If 'custom' is set, then you need to set \fB\-StoreDelimiter\fR.
.IP "\fB\-SplitDelimiter\fR" 4
.IX Item "-SplitDelimiter"
Set this to any arbitrary regular expression which will be used for option/value
splitting. \fB\-SplitPolicy\fR must be set to 'custom' to make this work.
.IP "\fB\-StoreDelimiter\fR" 4
.IX Item "-StoreDelimiter"
You can use this parameter to specify a custom delimiter to use when saving
configs to a file or string. You only need to set it if you want to store
the config back to disk and if you have \fB\-SplitPolicy\fR set to 'custom'.
.Sp
Be very careful with this parameter.
.IP "\fB\-CComments\fR" 4
.IX Item "-CComments"
Config::General is able to notice c\-style comments (see section \s-1COMMENTS\s0).
But for some reason you might no need this. In this case you can turn
this feature off by setting \fB\-CComments\fR to a false value('no', 0, 'off').
.Sp
By default \fB\-CComments\fR is turned on.
.IP "\fB\-BackslashEscape\fR" 4
.IX Item "-BackslashEscape"
\&\fBDeprecated Option\fR.
.IP "\fB\-SlashIsDirectory\fR" 4
.IX Item "-SlashIsDirectory"
If you turn on this parameter, a single slash as the last character
of a named block will be considered as a directory name.
.Sp
By default this flag is turned off, which makes the module somewhat
incompatible to Apache configs, since such a setup will be normally
considered as an explicit empty block, just as \s-1XML\s0 defines it.
.Sp
For example, if you have the following config:
.Sp
.Vb 3
\& <Directory />
\&   Index index.awk
\& </Directory>
.Ve
.Sp
you will get such an error message from the parser:
.Sp
.Vb 1
\& EndBlock "</Directory>" has no StartBlock statement (level: 1, chunk 10)!
.Ve
.Sp
This is caused by the fact that the config chunk below will be
internally converted to:
.Sp
.Vb 3
\& <Directory></Directory>
\&   Index index.awk
\& </Directory>
.Ve
.Sp
Now there is one '</Directory>' too much. The proper solution is
to use quotation to circumvent this error:
.Sp
.Vb 3
\& <Directory "/">
\&   Index index.awk
\& </Directory>
.Ve
.Sp
However, a raw apache config comes without such quotes. In this
case you may consider to turn on \fB\-SlashIsDirectory\fR.
.Sp
Please note that this is a new option (incorporated in version 2.30),
it may lead to various unexpected side effects or other failures.
You've been warned.
.IP "\fB\-ApacheCompatible\fR" 4
.IX Item "-ApacheCompatible"
Over the past years a lot of options has been incorporated
into Config::General to be able to parse real Apache configs.
.Sp
The new \fB\-ApacheCompatible\fR option now makes it possible to
tweak all options in a way that Apache configs can be parsed.
.Sp
This is called \*(L"apache compatibility mode\*(R" \- if you will ever
have problems with parsing Apache configs without this option
being set, you'll get no help by me. Thanks :)
.Sp
The following options will be set:
.Sp
.Vb 7
\& UseApacheInclude   = 1
\& IncludeRelative    = 1
\& IncludeDirectories = 1
\& IncludeGlob        = 1
\& SlashIsDirectory   = 1
\& SplitPolicy        = \*(Aqequalsign\*(Aq
\& CComments          = 0
.Ve
.Sp
Take a look into the particular documentation sections what
those options are doing.
.Sp
Beside setting some options it also turns off support for
explicit empty blocks.
.IP "\fB\-UTF8\fR" 4
.IX Item "-UTF8"
If turned on, all files will be opened in utf8 mode. This may
not work properly with older versions of Perl.
.IP "\fB\-SaveSorted\fR" 4
.IX Item "-SaveSorted"
If you want to save configs in a sorted manner, turn this
parameter on. It is not enabled by default.
.RE
.RS 4
.RE
.IP "\fIgetall()\fR" 4
.IX Item "getall()"
Returns a hash structure which represents the whole config.
.IP "\fIfiles()\fR" 4
.IX Item "files()"
Returns a list of all files read in.
.IP "\fIsave_file()\fR" 4
.IX Item "save_file()"
Writes the config hash back to the hard disk. This method takes one or two
parameters. The first parameter must be the filename where the config
should be written to. The second parameter is optional, it must be a
reference to a hash structure, if you set it. If you do not supply this second parameter
then the internal config hash, which has already been parsed, will be
used.
.Sp
Please note that any occurence of comments will be ignored by \fIgetall()\fR
and thus be lost after you call this method.
.Sp
You need also to know that named blocks will be converted to nested blocks
(which is the same from the perl point of view). An example:
.Sp
.Vb 3
\& <user hans>
\&   id 13
\& </user>
.Ve
.Sp
will become the following after saving:
.Sp
.Vb 5
\& <user>
\&   <hans>
\&      id 13
\&   </hans>
\& </user>
.Ve
.Sp
Example:
.Sp
.Vb 1
\& $conf_obj\->save_file("newrcfile", \e%config);
.Ve
.Sp
or, if the config has already been parsed, or if it didn't change:
.Sp
.Vb 1
\& $conf_obj\->save_file("newrcfile");
.Ve
.IP "\fIsave_string()\fR" 4
.IX Item "save_string()"
This method is equivalent to the previous \fIsave_file()\fR, but it does not
store the generated config to a file. Instead it returns it as a string,
which you can save yourself afterwards.
.Sp
It takes one optional parameter, which must be a reference to a hash structure.
If you omit this parameter, the internal config hash, which has already been parsed,
will be used.
.Sp
Example:
.Sp
.Vb 1
\& my $content = $conf_obj\->save_string(\e%config);
.Ve
.Sp
or:
.Sp
.Vb 1
\& my $content = $conf_obj\->save_string();
.Ve
.SH "CONFIG FILE FORMAT"
.IX Header "CONFIG FILE FORMAT"
Lines beginning with \fB#\fR and empty lines will be ignored. (see section \s-1COMMENTS\s0!)
Spaces at the beginning and the end of a line will also be ignored as well as tabulators.
If you need spaces at the end or the beginning of a value you can surround it with
double quotes.
An option line starts with its name followed by a value. An equal sign is optional.
Some possible examples:
.PP
.Vb 3
\& user    max
\& user  = max
\& user            max
.Ve
.PP
If there are more than one statements with the same name, it will create an array
instead of a scalar. See the example below.
.PP
The method \fBgetall\fR returns a hash of all values.
.SH "BLOCKS"
.IX Header "BLOCKS"
You can define a \fBblock\fR of options. A \fBblock\fR looks much like a block
in the wellknown Apache config format. It starts with <\fBblockname\fR> and ends
with </\fBblockname\fR>. An example:
.PP
.Vb 6
\& <database>
\&    host   = muli
\&    user   = moare
\&    dbname = modb
\&    dbpass = D4r_9Iu
\& </database>
.Ve
.PP
Blocks can also be nested. Here is a more complicated example:
.PP
.Vb 10
\& user   = hans
\& server = mc200
\& db     = maxis
\& passwd = D3rf$
\& <jonas>
\&        user    = tom
\&        db      = unknown
\&        host    = mila
\&        <tablestructure>
\&                index   int(100000)
\&                name    char(100)
\&                prename char(100)
\&                city    char(100)
\&                status  int(10)
\&                allowed moses
\&                allowed ingram
\&                allowed joice
\&        </tablestructure>
\& </jonas>
.Ve
.PP
The hash which the method \fBgetall\fR returns look like that:
.PP
.Vb 10
\& print Data::Dumper(\e%hash);
\& $VAR1 = {
\&          \*(Aqpasswd\*(Aq => \*(AqD3rf$\*(Aq,
\&          \*(Aqjonas\*(Aq  => {
\&                       \*(Aqtablestructure\*(Aq => {
\&                                             \*(Aqprename\*(Aq => \*(Aqchar(100)\*(Aq,
\&                                             \*(Aqindex\*(Aq   => \*(Aqint(100000)\*(Aq,
\&                                             \*(Aqcity\*(Aq    => \*(Aqchar(100)\*(Aq,
\&                                             \*(Aqname\*(Aq    => \*(Aqchar(100)\*(Aq,
\&                                             \*(Aqstatus\*(Aq  => \*(Aqint(10)\*(Aq,
\&                                             \*(Aqallowed\*(Aq => [
\&                                                            \*(Aqmoses\*(Aq,
\&                                                            \*(Aqingram\*(Aq,
\&                                                            \*(Aqjoice\*(Aq,
\&                                                          ]
\&                                           },
\&                       \*(Aqhost\*(Aq           => \*(Aqmila\*(Aq,
\&                       \*(Aqdb\*(Aq             => \*(Aqunknown\*(Aq,
\&                       \*(Aquser\*(Aq           => \*(Aqtom\*(Aq
\&                     },
\&          \*(Aqdb\*(Aq     => \*(Aqmaxis\*(Aq,
\&          \*(Aqserver\*(Aq => \*(Aqmc200\*(Aq,
\&          \*(Aquser\*(Aq   => \*(Aqhans\*(Aq
\&        };
.Ve
.PP
If you have turned on \fB\-LowerCaseNames\fR (see \fInew()\fR) then blocks as in the
following example:
.PP
.Vb 5
\& <Dir>
\&   <AttriBUTES>
\&     Owner  root
\&   </attributes>
\& </dir>
.Ve
.PP
would produce the following hash structure:
.PP
.Vb 7
\& $VAR1 = {
\&          \*(Aqdir\*(Aq => {
\&                    \*(Aqattributes\*(Aq => {
\&                                     \*(Aqowner  => "root",
\&                                    }
\&                   }
\&         };
.Ve
.PP
As you can see, the keys inside the config hash are normalized.
.PP
Please note, that the above config block would result in a
valid hash structure, even if \fB\-LowerCaseNames\fR is not set!
This is because \fIConfig::General\fR does not
use the block names to check if a block ends, instead it uses an internal
state counter, which indicates a block end.
.PP
If the module cannot find an end-block statement, then this block will be ignored.
.SH "NAMED BLOCKS"
.IX Header "NAMED BLOCKS"
If you need multiple blocks of the same name, then you have to name every block.
This works much like Apache config. If the module finds a named block, it will
create a hashref with the left part of the named block as the key containing
one or more hashrefs with the right part of the block as key containing everything
inside the block(which may again be nested!). As examples says more than words:
.PP
.Vb 9
\& # given the following sample
\& <Directory /usr/frisco>
\&        Limit Deny
\&        Options ExecCgi Index
\& </Directory>
\& <Directory /usr/frik>
\&        Limit DenyAll
\&        Options None
\& </Directory>
\&
\& # you will get:
\& $VAR1 = {
\&          \*(AqDirectory\*(Aq => {
\&                           \*(Aq/usr/frik\*(Aq => {
\&                                            \*(AqOptions\*(Aq => \*(AqNone\*(Aq,
\&                                            \*(AqLimit\*(Aq => \*(AqDenyAll\*(Aq
\&                                          },
\&                           \*(Aq/usr/frisco\*(Aq => {
\&                                              \*(AqOptions\*(Aq => \*(AqExecCgi Index\*(Aq,
\&                                              \*(AqLimit\*(Aq => \*(AqDeny\*(Aq
\&                                            }
\&                         }
\&        };
.Ve
.PP
You cannot have more than one named block with the same name because it will
be stored in a hashref and therefore be overwritten if a block occurs once more.
.SH "WHITESPACE IN BLOCKS"
.IX Header "WHITESPACE IN BLOCKS"
The normal behavior of Config::General is to look for whitespace in
block names to decide if it's a named block or just a simple block.
.PP
Sometimes you may need blocknames which have whitespace in their names.
.PP
With named blocks this is no problem, as the module only looks for the
first whitespace:
.PP
.Vb 2
\& <person hugo gera>
\& </person>
.Ve
.PP
would be parsed to:
.PP
.Vb 6
\& $VAR1 = {
\&          \*(Aqperson\*(Aq => {
\&                       \*(Aqhugo gera\*(Aq => {
\&                                      },
\&                      }
\&         };
.Ve
.PP
The problem occurs, if you want to have a simple block containing whitespace:
.PP
.Vb 2
\& <hugo gera>
\& </hugo gera>
.Ve
.PP
This would be parsed as a named block, which is not what you wanted. In this
very case you may use quotation marks to indicate that it is not a named block:
.PP
.Vb 2
\& <"hugo gera">
\& </"hugo gera">
.Ve
.PP
The \fIsave()\fR method of the module inserts automatically quotation marks in such
cases.
.SH "EXPLICIT EMPTY BLOCKS"
.IX Header "EXPLICIT EMPTY BLOCKS"
Beside the notation of blocks mentioned above it is possible to use
explicit empty blocks.
.PP
Normally you would write this in your config to define an empty
block:
.PP
.Vb 2
\& <driver Apache>
\& </driver>
.Ve
.PP
To save writing you can also write:
.PP
.Vb 1
\& <driver Apache/>
.Ve
.PP
which is the very same as above. This works for normal blocks and
for named blocks.
.SH "IDENTICAL OPTIONS (ARRAYS)"
.IX Header "IDENTICAL OPTIONS (ARRAYS)"
You may have more than one line of the same option with different values.
.PP
Example:
 log  log1
 log  log2
 log  log2
.PP
You will get a scalar if the option occurred only once or an array if it occurred
more than once. If you expect multiple identical options, then you may need to
check if an option occurred more than once:
.PP
.Vb 6
\& $allowed = $hash{jonas}\->{tablestructure}\->{allowed};
\& if(ref($allowed) eq "ARRAY") {
\&     @ALLOWED = @{$allowed};
\& else {
\&     @ALLOWED = ($allowed);
\& }
.Ve
.PP
The same applies to blocks and named blocks too (they are described in more detail
below). For example, if you have the following config:
.PP
.Vb 6
\& <dir blah>
\&   user max
\& </dir>
\& <dir blah>
\&   user hannes
\& </dir>
.Ve
.PP
then you would end up with a data structure like this:
.PP
.Vb 12
\& $VAR1 = {
\&          \*(Aqdir\*(Aq => {
\&                    \*(Aqblah\*(Aq => [
\&                                {
\&                                  \*(Aquser\*(Aq => \*(Aqmax\*(Aq
\&                                },
\&                                {
\&                                  \*(Aquser\*(Aq => \*(Aqhannes\*(Aq
\&                                }
\&                              ]
\&                    }
\&          };
.Ve
.PP
As you can see, the two identical blocks are stored in a hash which contains
an array(\-reference) of hashes.
.PP
Under some rare conditions you might not want this behavior with blocks (and
named blocks too). If you want to get one single hash with the contents of
both identical blocks, then you need to turn the \fB\f(BInew()\fB\fR parameter \fB\-MergeDuplicateBlocks\fR
on (see above). The parsed structure of the example above would then look like
this:
.PP
.Vb 10
\& $VAR1 = {
\&          \*(Aqdir\*(Aq => {
\&                    \*(Aqblah\*(Aq => {
\&                               \*(Aquser\*(Aq => [
\&                                           \*(Aqmax\*(Aq,
\&                                           \*(Aqhannes\*(Aq
\&                                         ]
\&                              }
\&                    }
\&          };
.Ve
.PP
As you can see, there is only one hash \*(L"dir\->{blah}\*(R" containing multiple
\&\*(L"user\*(R" entries. As you can also see, turning on  \fB\-MergeDuplicateBlocks\fR
does not affect scalar options (i.e. \*(L"option = value\*(R"). In fact you can
tune merging of duplicate blocks and options independent from each other.
.PP
If you don't want to allow more than one identical options, you may turn it off
by setting the flag \fIAllowMultiOptions\fR in the \fB\f(BInew()\fB\fR method to \*(L"no\*(R".
If turned off, Config::General will complain about multiple occurring options
with identical names!
.SS "\s-1FORCE\s0 \s-1SINGLE\s0 \s-1VALUE\s0 \s-1ARRAYS\s0"
.IX Subsection "FORCE SINGLE VALUE ARRAYS"
You may also force a single config line to get parsed into an array by
turning on the option \fB\-ForceArray\fR and by surrounding the value of the
config entry by []. Example:
.PP
.Vb 1
\& hostlist = [ foo.bar ]
.Ve
.PP
Will be a singlevalue array entry if the option is turned on. If you want
it to remain to be an array you have to turn on \fB\-ForceArray\fR during save too.
.SH "LONG LINES"
.IX Header "LONG LINES"
If you have a config value, which is too long and would take more than one line,
you can break it into multiple lines by using the backslash character at the end
of the line. The Config::General module will concatenate those lines to one single-value.
.PP
Example:
.PP
command = cat /var/log/secure/tripwire | \e
           mail \f(CW\*(C`\-s\*(C'\fR \*(L"report from tripwire\*(R" \e
           honey@myotherhost.nl
.PP
command will become:
 "cat /var/log/secure/tripwire | mail \f(CW\*(C`\-s\*(C'\fR 'report from twire' honey@myotherhost.nl"
.SH "HERE DOCUMENTS"
.IX Header "HERE DOCUMENTS"
You can also define a config value as a so called \*(L"here-document\*(R". You must tell
the module an identifier which idicates the end of a here document. An
identifier must follow a \*(L"<<\*(R".
.PP
Example:
.PP
.Vb 6
\& message <<EOF
\&   we want to
\&   remove the
\&   homedir of
\&   root.
\& EOF
.Ve
.PP
Everything between the two \*(L"\s-1EOF\s0\*(R" strings will be in the option \fImessage\fR.
.PP
There is a special feature which allows you to use indentation with here documents.
You can have any amount of whitespace or tabulators in front of the end
identifier. If the module finds spaces or tabs then it will remove exactly those
amount of spaces from every line inside the here-document.
.PP
Example:
.PP
.Vb 6
\& message <<EOF
\&         we want to
\&         remove the
\&         homedir of
\&         root.
\&      EOF
.Ve
.PP
After parsing, message will become:
.PP
.Vb 4
\&   we want to
\&   remove the
\&   homedir of
\&   root.
.Ve
.PP
because there were the string \*(L"     \*(R" in front of \s-1EOF\s0, which were cut from every
line inside the here-document.
.SH "INCLUDES"
.IX Header "INCLUDES"
You can include an external file at any posision in your config file using the following statement
in your config file:
.PP
.Vb 1
\& <<include externalconfig.rc>>
.Ve
.PP
If you turned on \fB\-UseApacheInclude\fR (see \fB\f(BInew()\fB\fR), then you can also use the following
statement to include an external file:
.PP
.Vb 1
\& include externalconfig.rc
.Ve
.PP
This file will be inserted at the position where it was found as if the contents of this file
were directly at this position.
.PP
You can also recursively include files, so an included file may include another one and so on.
Beware that you do not recursively load the same file, you will end with an error message like
\&\*(L"too many open files in system!\*(R".
.PP
By default included files with a relative pathname will be opened from within the current
working directory. Under some circumstances it maybe possible to
open included files from the directory, where the configfile resides. You need to turn on
the option \fB\-IncludeRelative\fR (see \fB\f(BInew()\fB\fR) if you want that. An example:
.PP
.Vb 4
\& my $conf = Config::General(
\&                             \-ConfigFile => "/etc/crypt.d/server.cfg"
\&                             \-IncludeRelative => 1
\&                           );
\&
\& /etc/crypt.d/server.cfg:
\&  <<include acl.cfg>>
.Ve
.PP
In this example Config::General will try to include \fIacl.cfg\fR from \fI/etc/crypt.d\fR:
.PP
.Vb 1
\& /etc/crypt.d/acl.cfg
.Ve
.PP
The default behavior (if \fB\-IncludeRelative\fR is \fBnot\fR set!) will be to open just \fIacl.cfg\fR,
wherever it is, i.e. if you did a chdir(\*(L"/usr/local/etc\*(R"), then Config::General will include:
.PP
.Vb 1
\& /usr/local/etc/acl.cfg
.Ve
.PP
Include statements can be case insensitive (added in version 1.25).
.PP
Include statements will be ignored within C\-Comments and here-documents.
.PP
By default, a config file will only be included the first time it is
referenced.  If you wish to include a file in multiple places, set
\&\fB/\-IncludeAgain\fR to true. But be warned: this may lead to infinite loops,
so make sure, you're not including the same file from within itself!
.PP
Example:
.PP
.Vb 10
\&    # main.cfg
\&    <object billy>
\&        class=Some::Class
\&        <printers>
\&            include printers.cfg
\&        </printers>
\&        # ...
\&    </object>
\&    <object bob>
\&        class=Another::Class
\&        <printers>
\&            include printers.cfg
\&        </printers>
\&        # ...
\&    </object>
.Ve
.PP
Now \f(CW\*(C`printers.cfg\*(C'\fR will be include in both the \f(CW\*(C`billy\*(C'\fR and \f(CW\*(C`bob\*(C'\fR objects.
.PP
You will have to be careful to not recursively include a file.  Behaviour
in this case is undefined.
.SH "COMMENTS"
.IX Header "COMMENTS"
A comment starts with the number sign \fB#\fR, there can be any number of spaces and/or
tab stops in front of the #.
.PP
A comment can also occur after a config statement. Example:
.PP
.Vb 1
\& username = max  # this is the comment
.Ve
.PP
If you want to comment out a large block you can use C\-style comments. A \fB/*\fR signals
the begin of a comment block and the \fB*/\fR signals the end of the comment block.
Example:
.PP
.Vb 6
\& user  = max # valid option
\& db    = tothemax
\& /*
\& user  = andors
\& db    = toand
\& */
.Ve
.PP
In this example the second options of user and db will be ignored. Please beware of the fact,
if the Module finds a \fB/*\fR string which is the start of a comment block, but no matching
end block, it will ignore the whole rest of the config file!
.PP
\&\fB\s-1NOTE:\s0\fR If you require the \fB#\fR character (number sign) to remain in the option value, then
you can use a backslash in front of it, to escape it. Example:
.PP
.Vb 1
\& bgcolor = \e#ffffcc
.Ve
.PP
In this example the value of \f(CW$config\fR{bgcolor} will be \*(L"#ffffcc\*(R", Config::General will not treat
the number sign as the begin of a comment because of the leading backslash.
.PP
Inside here-documents escaping of number signs is \s-1NOT\s0 required!
.SH "OBJECT ORIENTED INTERFACE"
.IX Header "OBJECT ORIENTED INTERFACE"
There is a way to access a parsed config the OO-way.
Use the module \fBConfig::General::Extended\fR, which is
supplied with the Config::General distribution.
.SH "VARIABLE INTERPOLATION"
.IX Header "VARIABLE INTERPOLATION"
You can use variables inside your config files if you like. To do
that you have to use the module \fBConfig::General::Interpolated\fR,
which is supplied with the Config::General distribution.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Config::General exports some functions too, which makes it somewhat
easier to use it, if you like this.
.PP
How to import the functions:
.PP
.Vb 1
\& use Config::General qw(ParseConfig SaveConfig SaveConfigString);
.Ve
.IP "\fB\f(BIParseConfig()\fB\fR" 4
.IX Item "ParseConfig()"
This function takes exactly all those parameters, which are
allowed to the \fB\f(BInew()\fB\fR method of the standard interface.
.Sp
Example:
.Sp
.Vb 2
\& use Config::General qw(ParseConfig);
\& my %config = ParseConfig(\-ConfigFile => "rcfile", \-AutoTrue => 1);
.Ve
.IP "\fB\f(BISaveConfig()\fB\fR" 4
.IX Item "SaveConfig()"
This function requires two arguments, a filename and a reference
to a hash structure.
.Sp
Example:
.Sp
.Vb 3
\& use Config::General qw(SaveConfig);
\& ..
\& SaveConfig("rcfile", \e%some_hash);
.Ve
.IP "\fB\f(BISaveConfigString()\fB\fR" 4
.IX Item "SaveConfigString()"
This function requires a reference to a config hash as parameter.
It generates a configuration based on this hash as the object-interface
method \fB\f(BIsave_string()\fB\fR does.
.Sp
Example:
.Sp
.Vb 4
\& use Config::General qw(ParseConfig SaveConfigString);
\& my %config = ParseConfig(\-ConfigFile => "rcfile");
\& .. # change %config something
\& my $content = SaveConfigString(\e%config);
.Ve
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
No environment variables will be used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I recommend you to read the following documents, which are supplied with Perl:
.PP
.Vb 4
\& perlreftut                     Perl references short introduction
\& perlref                        Perl references, the rest of the story
\& perldsc                        Perl data structures intro
\& perllol                        Perl data structures: arrays of arrays
\&
\& Config::General::Extended      Object oriented interface to parsed configs
\& Config::General::Interpolated  Allows to use variables inside config files
.Ve
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2000\-2010 Thomas Linden
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
See rt.cpan.org for current bugs, if any.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None known.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
To debug Config::General use the Perl debugger, see perldebug.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Config::General depends on the modules FileHandle,
File::Spec::Functions, File::Glob, which all are
shipped with Perl.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas Linden <tlinden |AT| cpan.org>
.SH "VERSION"
.IX Header "VERSION"
2.50
